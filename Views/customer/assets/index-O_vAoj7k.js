var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var require_index_001 = __commonJS({
  "assets/index-O_vAoj7k.js"(exports, module) {
    function _mergeNamespaces(n2, m2) {
      for (var i = 0; i < m2.length; i++) {
        const e2 = m2[i];
        if (typeof e2 !== "string" && !Array.isArray(e2)) {
          for (const k2 in e2) {
            if (k2 !== "default" && !(k2 in n2)) {
              const d2 = Object.getOwnPropertyDescriptor(e2, k2);
              if (d2) {
                Object.defineProperty(n2, k2, d2.get ? d2 : {
                  enumerable: true,
                  get: () => e2[k2]
                });
              }
            }
          }
        }
      }
      return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
    }
    (function polyfill() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) {
        return;
      }
      for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link);
      }
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") {
            continue;
          }
          for (const node2 of mutation.addedNodes) {
            if (node2.tagName === "LINK" && node2.rel === "modulepreload")
              processPreload(node2);
          }
        }
      }).observe(document, { childList: true, subtree: true });
      function getFetchOpts(link) {
        const fetchOpts = {};
        if (link.integrity)
          fetchOpts.integrity = link.integrity;
        if (link.referrerPolicy)
          fetchOpts.referrerPolicy = link.referrerPolicy;
        if (link.crossOrigin === "use-credentials")
          fetchOpts.credentials = "include";
        else if (link.crossOrigin === "anonymous")
          fetchOpts.credentials = "omit";
        else
          fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link) {
        if (link.ep)
          return;
        link.ep = true;
        const fetchOpts = getFetchOpts(link);
        fetch(link.href, fetchOpts);
      }
    })();
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function getDefaultExportFromCjs(x2) {
      return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
    }
    function getAugmentedNamespace(n2) {
      if (n2.__esModule)
        return n2;
      var f2 = n2.default;
      if (typeof f2 == "function") {
        var a = function a2() {
          if (this instanceof a2) {
            return Reflect.construct(f2, arguments, this.constructor);
          }
          return f2.apply(this, arguments);
        };
        a.prototype = f2.prototype;
      } else
        a = {};
      Object.defineProperty(a, "__esModule", { value: true });
      Object.keys(n2).forEach(function(k2) {
        var d2 = Object.getOwnPropertyDescriptor(n2, k2);
        Object.defineProperty(a, k2, d2.get ? d2 : {
          enumerable: true,
          get: function() {
            return n2[k2];
          }
        });
      });
      return a;
    }
    var jsxRuntime = { exports: {} };
    var reactJsxRuntime_production_min = {};
    var react = { exports: {} };
    var react_production_min = {};
    /**
     * @license React
     * react.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var l$4 = Symbol.for("react.element"), n$5 = Symbol.for("react.portal"), p$6 = Symbol.for("react.fragment"), q$5 = Symbol.for("react.strict_mode"), r$4 = Symbol.for("react.profiler"), t$4 = Symbol.for("react.provider"), u$3 = Symbol.for("react.context"), v$4 = Symbol.for("react.forward_ref"), w$2 = Symbol.for("react.suspense"), x$1 = Symbol.for("react.memo"), y$1 = Symbol.for("react.lazy"), z$2 = Symbol.iterator;
    function A$2(a) {
      if (null === a || "object" !== typeof a)
        return null;
      a = z$2 && a[z$2] || a["@@iterator"];
      return "function" === typeof a ? a : null;
    }
    var B$1 = { isMounted: function() {
      return false;
    }, enqueueForceUpdate: function() {
    }, enqueueReplaceState: function() {
    }, enqueueSetState: function() {
    } }, C$1 = Object.assign, D$1 = {};
    function E$1(a, b2, e2) {
      this.props = a;
      this.context = b2;
      this.refs = D$1;
      this.updater = e2 || B$1;
    }
    E$1.prototype.isReactComponent = {};
    E$1.prototype.setState = function(a, b2) {
      if ("object" !== typeof a && "function" !== typeof a && null != a)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, a, b2, "setState");
    };
    E$1.prototype.forceUpdate = function(a) {
      this.updater.enqueueForceUpdate(this, a, "forceUpdate");
    };
    function F() {
    }
    F.prototype = E$1.prototype;
    function G$1(a, b2, e2) {
      this.props = a;
      this.context = b2;
      this.refs = D$1;
      this.updater = e2 || B$1;
    }
    var H$1 = G$1.prototype = new F();
    H$1.constructor = G$1;
    C$1(H$1, E$1.prototype);
    H$1.isPureReactComponent = true;
    var I$1 = Array.isArray, J = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$1 = { key: true, ref: true, __self: true, __source: true };
    function M$1(a, b2, e2) {
      var d2, c2 = {}, k2 = null, h2 = null;
      if (null != b2)
        for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
          J.call(b2, d2) && !L$1.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
      var g2 = arguments.length - 2;
      if (1 === g2)
        c2.children = e2;
      else if (1 < g2) {
        for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
          f2[m2] = arguments[m2 + 2];
        c2.children = f2;
      }
      if (a && a.defaultProps)
        for (d2 in g2 = a.defaultProps, g2)
          void 0 === c2[d2] && (c2[d2] = g2[d2]);
      return { $$typeof: l$4, type: a, key: k2, ref: h2, props: c2, _owner: K$1.current };
    }
    function N$1(a, b2) {
      return { $$typeof: l$4, type: a.type, key: b2, ref: a.ref, props: a.props, _owner: a._owner };
    }
    function O$1(a) {
      return "object" === typeof a && null !== a && a.$$typeof === l$4;
    }
    function escape(a) {
      var b2 = { "=": "=0", ":": "=2" };
      return "$" + a.replace(/[=:]/g, function(a2) {
        return b2[a2];
      });
    }
    var P$1 = /\/+/g;
    function Q$1(a, b2) {
      return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b2.toString(36);
    }
    function R$1(a, b2, e2, d2, c2) {
      var k2 = typeof a;
      if ("undefined" === k2 || "boolean" === k2)
        a = null;
      var h2 = false;
      if (null === a)
        h2 = true;
      else
        switch (k2) {
          case "string":
          case "number":
            h2 = true;
            break;
          case "object":
            switch (a.$$typeof) {
              case l$4:
              case n$5:
                h2 = true;
            }
        }
      if (h2)
        return h2 = a, c2 = c2(h2), a = "" === d2 ? "." + Q$1(h2, 0) : d2, I$1(c2) ? (e2 = "", null != a && (e2 = a.replace(P$1, "$&/") + "/"), R$1(c2, b2, e2, "", function(a2) {
          return a2;
        })) : null != c2 && (O$1(c2) && (c2 = N$1(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$1, "$&/") + "/") + a)), b2.push(c2)), 1;
      h2 = 0;
      d2 = "" === d2 ? "." : d2 + ":";
      if (I$1(a))
        for (var g2 = 0; g2 < a.length; g2++) {
          k2 = a[g2];
          var f2 = d2 + Q$1(k2, g2);
          h2 += R$1(k2, b2, e2, f2, c2);
        }
      else if (f2 = A$2(a), "function" === typeof f2)
        for (a = f2.call(a), g2 = 0; !(k2 = a.next()).done; )
          k2 = k2.value, f2 = d2 + Q$1(k2, g2++), h2 += R$1(k2, b2, e2, f2, c2);
      else if ("object" === k2)
        throw b2 = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
      return h2;
    }
    function S$1(a, b2, e2) {
      if (null == a)
        return a;
      var d2 = [], c2 = 0;
      R$1(a, d2, "", "", function(a2) {
        return b2.call(e2, a2, c2++);
      });
      return d2;
    }
    function T$1(a) {
      if (-1 === a._status) {
        var b2 = a._result;
        b2 = b2();
        b2.then(function(b3) {
          if (0 === a._status || -1 === a._status)
            a._status = 1, a._result = b3;
        }, function(b3) {
          if (0 === a._status || -1 === a._status)
            a._status = 2, a._result = b3;
        });
        -1 === a._status && (a._status = 0, a._result = b2);
      }
      if (1 === a._status)
        return a._result.default;
      throw a._result;
    }
    var U$1 = { current: null }, V$1 = { transition: null }, W$1 = { ReactCurrentDispatcher: U$1, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$1 };
    react_production_min.Children = { map: S$1, forEach: function(a, b2, e2) {
      S$1(a, function() {
        b2.apply(this, arguments);
      }, e2);
    }, count: function(a) {
      var b2 = 0;
      S$1(a, function() {
        b2++;
      });
      return b2;
    }, toArray: function(a) {
      return S$1(a, function(a2) {
        return a2;
      }) || [];
    }, only: function(a) {
      if (!O$1(a))
        throw Error("React.Children.only expected to receive a single React element child.");
      return a;
    } };
    react_production_min.Component = E$1;
    react_production_min.Fragment = p$6;
    react_production_min.Profiler = r$4;
    react_production_min.PureComponent = G$1;
    react_production_min.StrictMode = q$5;
    react_production_min.Suspense = w$2;
    react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
    react_production_min.cloneElement = function(a, b2, e2) {
      if (null === a || void 0 === a)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
      var d2 = C$1({}, a.props), c2 = a.key, k2 = a.ref, h2 = a._owner;
      if (null != b2) {
        void 0 !== b2.ref && (k2 = b2.ref, h2 = K$1.current);
        void 0 !== b2.key && (c2 = "" + b2.key);
        if (a.type && a.type.defaultProps)
          var g2 = a.type.defaultProps;
        for (f2 in b2)
          J.call(b2, f2) && !L$1.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
      }
      var f2 = arguments.length - 2;
      if (1 === f2)
        d2.children = e2;
      else if (1 < f2) {
        g2 = Array(f2);
        for (var m2 = 0; m2 < f2; m2++)
          g2[m2] = arguments[m2 + 2];
        d2.children = g2;
      }
      return { $$typeof: l$4, type: a.type, key: c2, ref: k2, props: d2, _owner: h2 };
    };
    react_production_min.createContext = function(a) {
      a = { $$typeof: u$3, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
      a.Provider = { $$typeof: t$4, _context: a };
      return a.Consumer = a;
    };
    react_production_min.createElement = M$1;
    react_production_min.createFactory = function(a) {
      var b2 = M$1.bind(null, a);
      b2.type = a;
      return b2;
    };
    react_production_min.createRef = function() {
      return { current: null };
    };
    react_production_min.forwardRef = function(a) {
      return { $$typeof: v$4, render: a };
    };
    react_production_min.isValidElement = O$1;
    react_production_min.lazy = function(a) {
      return { $$typeof: y$1, _payload: { _status: -1, _result: a }, _init: T$1 };
    };
    react_production_min.memo = function(a, b2) {
      return { $$typeof: x$1, type: a, compare: void 0 === b2 ? null : b2 };
    };
    react_production_min.startTransition = function(a) {
      var b2 = V$1.transition;
      V$1.transition = {};
      try {
        a();
      } finally {
        V$1.transition = b2;
      }
    };
    react_production_min.unstable_act = function() {
      throw Error("act(...) is not supported in production builds of React.");
    };
    react_production_min.useCallback = function(a, b2) {
      return U$1.current.useCallback(a, b2);
    };
    react_production_min.useContext = function(a) {
      return U$1.current.useContext(a);
    };
    react_production_min.useDebugValue = function() {
    };
    react_production_min.useDeferredValue = function(a) {
      return U$1.current.useDeferredValue(a);
    };
    react_production_min.useEffect = function(a, b2) {
      return U$1.current.useEffect(a, b2);
    };
    react_production_min.useId = function() {
      return U$1.current.useId();
    };
    react_production_min.useImperativeHandle = function(a, b2, e2) {
      return U$1.current.useImperativeHandle(a, b2, e2);
    };
    react_production_min.useInsertionEffect = function(a, b2) {
      return U$1.current.useInsertionEffect(a, b2);
    };
    react_production_min.useLayoutEffect = function(a, b2) {
      return U$1.current.useLayoutEffect(a, b2);
    };
    react_production_min.useMemo = function(a, b2) {
      return U$1.current.useMemo(a, b2);
    };
    react_production_min.useReducer = function(a, b2, e2) {
      return U$1.current.useReducer(a, b2, e2);
    };
    react_production_min.useRef = function(a) {
      return U$1.current.useRef(a);
    };
    react_production_min.useState = function(a) {
      return U$1.current.useState(a);
    };
    react_production_min.useSyncExternalStore = function(a, b2, e2) {
      return U$1.current.useSyncExternalStore(a, b2, e2);
    };
    react_production_min.useTransition = function() {
      return U$1.current.useTransition();
    };
    react_production_min.version = "18.2.0";
    {
      react.exports = react_production_min;
    }
    var reactExports = react.exports;
    const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
    const React$1 = /* @__PURE__ */ _mergeNamespaces({
      __proto__: null,
      default: React
    }, [reactExports]);
    /**
     * @license React
     * react-jsx-runtime.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var f$2 = reactExports, k$3 = Symbol.for("react.element"), l$3 = Symbol.for("react.fragment"), m$4 = Object.prototype.hasOwnProperty, n$4 = f$2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$5 = { key: true, ref: true, __self: true, __source: true };
    function q$4(c2, a, g2) {
      var b2, d2 = {}, e2 = null, h2 = null;
      void 0 !== g2 && (e2 = "" + g2);
      void 0 !== a.key && (e2 = "" + a.key);
      void 0 !== a.ref && (h2 = a.ref);
      for (b2 in a)
        m$4.call(a, b2) && !p$5.hasOwnProperty(b2) && (d2[b2] = a[b2]);
      if (c2 && c2.defaultProps)
        for (b2 in a = c2.defaultProps, a)
          void 0 === d2[b2] && (d2[b2] = a[b2]);
      return { $$typeof: k$3, type: c2, key: e2, ref: h2, props: d2, _owner: n$4.current };
    }
    reactJsxRuntime_production_min.Fragment = l$3;
    reactJsxRuntime_production_min.jsx = q$4;
    reactJsxRuntime_production_min.jsxs = q$4;
    {
      jsxRuntime.exports = reactJsxRuntime_production_min;
    }
    var jsxRuntimeExports = jsxRuntime.exports;
    var client = {};
    var reactDom = { exports: {} };
    var reactDom_production_min = {};
    var scheduler = { exports: {} };
    var scheduler_production_min = {};
    /**
     * @license React
     * scheduler.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    (function(exports2) {
      function f2(a, b2) {
        var c2 = a.length;
        a.push(b2);
        a:
          for (; 0 < c2; ) {
            var d2 = c2 - 1 >>> 1, e2 = a[d2];
            if (0 < g2(e2, b2))
              a[d2] = b2, a[c2] = e2, c2 = d2;
            else
              break a;
          }
      }
      function h2(a) {
        return 0 === a.length ? null : a[0];
      }
      function k2(a) {
        if (0 === a.length)
          return null;
        var b2 = a[0], c2 = a.pop();
        if (c2 !== b2) {
          a[0] = c2;
          a:
            for (var d2 = 0, e2 = a.length, w2 = e2 >>> 1; d2 < w2; ) {
              var m2 = 2 * (d2 + 1) - 1, C2 = a[m2], n2 = m2 + 1, x2 = a[n2];
              if (0 > g2(C2, c2))
                n2 < e2 && 0 > g2(x2, C2) ? (a[d2] = x2, a[n2] = c2, d2 = n2) : (a[d2] = C2, a[m2] = c2, d2 = m2);
              else if (n2 < e2 && 0 > g2(x2, c2))
                a[d2] = x2, a[n2] = c2, d2 = n2;
              else
                break a;
            }
        }
        return b2;
      }
      function g2(a, b2) {
        var c2 = a.sortIndex - b2.sortIndex;
        return 0 !== c2 ? c2 : a.id - b2.id;
      }
      if ("object" === typeof performance && "function" === typeof performance.now) {
        var l2 = performance;
        exports2.unstable_now = function() {
          return l2.now();
        };
      } else {
        var p2 = Date, q2 = p2.now();
        exports2.unstable_now = function() {
          return p2.now() - q2;
        };
      }
      var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
      "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function G2(a) {
        for (var b2 = h2(t2); null !== b2; ) {
          if (null === b2.callback)
            k2(t2);
          else if (b2.startTime <= a)
            k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
          else
            break;
          b2 = h2(t2);
        }
      }
      function H2(a) {
        B2 = false;
        G2(a);
        if (!A2)
          if (null !== h2(r2))
            A2 = true, I2(J2);
          else {
            var b2 = h2(t2);
            null !== b2 && K2(H2, b2.startTime - a);
          }
      }
      function J2(a, b2) {
        A2 = false;
        B2 && (B2 = false, E2(L2), L2 = -1);
        z2 = true;
        var c2 = y2;
        try {
          G2(b2);
          for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a && !M2()); ) {
            var d2 = v2.callback;
            if ("function" === typeof d2) {
              v2.callback = null;
              y2 = v2.priorityLevel;
              var e2 = d2(v2.expirationTime <= b2);
              b2 = exports2.unstable_now();
              "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
              G2(b2);
            } else
              k2(r2);
            v2 = h2(r2);
          }
          if (null !== v2)
            var w2 = true;
          else {
            var m2 = h2(t2);
            null !== m2 && K2(H2, m2.startTime - b2);
            w2 = false;
          }
          return w2;
        } finally {
          v2 = null, y2 = c2, z2 = false;
        }
      }
      var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
      function M2() {
        return exports2.unstable_now() - Q2 < P2 ? false : true;
      }
      function R2() {
        if (null !== O2) {
          var a = exports2.unstable_now();
          Q2 = a;
          var b2 = true;
          try {
            b2 = O2(true, a);
          } finally {
            b2 ? S2() : (N2 = false, O2 = null);
          }
        } else
          N2 = false;
      }
      var S2;
      if ("function" === typeof F2)
        S2 = function() {
          F2(R2);
        };
      else if ("undefined" !== typeof MessageChannel) {
        var T2 = new MessageChannel(), U2 = T2.port2;
        T2.port1.onmessage = R2;
        S2 = function() {
          U2.postMessage(null);
        };
      } else
        S2 = function() {
          D2(R2, 0);
        };
      function I2(a) {
        O2 = a;
        N2 || (N2 = true, S2());
      }
      function K2(a, b2) {
        L2 = D2(function() {
          a(exports2.unstable_now());
        }, b2);
      }
      exports2.unstable_IdlePriority = 5;
      exports2.unstable_ImmediatePriority = 1;
      exports2.unstable_LowPriority = 4;
      exports2.unstable_NormalPriority = 3;
      exports2.unstable_Profiling = null;
      exports2.unstable_UserBlockingPriority = 2;
      exports2.unstable_cancelCallback = function(a) {
        a.callback = null;
      };
      exports2.unstable_continueExecution = function() {
        A2 || z2 || (A2 = true, I2(J2));
      };
      exports2.unstable_forceFrameRate = function(a) {
        0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a ? Math.floor(1e3 / a) : 5;
      };
      exports2.unstable_getCurrentPriorityLevel = function() {
        return y2;
      };
      exports2.unstable_getFirstCallbackNode = function() {
        return h2(r2);
      };
      exports2.unstable_next = function(a) {
        switch (y2) {
          case 1:
          case 2:
          case 3:
            var b2 = 3;
            break;
          default:
            b2 = y2;
        }
        var c2 = y2;
        y2 = b2;
        try {
          return a();
        } finally {
          y2 = c2;
        }
      };
      exports2.unstable_pauseExecution = function() {
      };
      exports2.unstable_requestPaint = function() {
      };
      exports2.unstable_runWithPriority = function(a, b2) {
        switch (a) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            a = 3;
        }
        var c2 = y2;
        y2 = a;
        try {
          return b2();
        } finally {
          y2 = c2;
        }
      };
      exports2.unstable_scheduleCallback = function(a, b2, c2) {
        var d2 = exports2.unstable_now();
        "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
        switch (a) {
          case 1:
            var e2 = -1;
            break;
          case 2:
            e2 = 250;
            break;
          case 5:
            e2 = 1073741823;
            break;
          case 4:
            e2 = 1e4;
            break;
          default:
            e2 = 5e3;
        }
        e2 = c2 + e2;
        a = { id: u2++, callback: b2, priorityLevel: a, startTime: c2, expirationTime: e2, sortIndex: -1 };
        c2 > d2 ? (a.sortIndex = c2, f2(t2, a), null === h2(r2) && a === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d2))) : (a.sortIndex = e2, f2(r2, a), A2 || z2 || (A2 = true, I2(J2)));
        return a;
      };
      exports2.unstable_shouldYield = M2;
      exports2.unstable_wrapCallback = function(a) {
        var b2 = y2;
        return function() {
          var c2 = y2;
          y2 = b2;
          try {
            return a.apply(this, arguments);
          } finally {
            y2 = c2;
          }
        };
      };
    })(scheduler_production_min);
    {
      scheduler.exports = scheduler_production_min;
    }
    var schedulerExports = scheduler.exports;
    /**
     * @license React
     * react-dom.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var aa = reactExports, ca = schedulerExports;
    function p$4(a) {
      for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c2 = 1; c2 < arguments.length; c2++)
        b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
      return "Minified React error #" + a + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var da = /* @__PURE__ */ new Set(), ea = {};
    function fa(a, b2) {
      ha(a, b2);
      ha(a + "Capture", b2);
    }
    function ha(a, b2) {
      ea[a] = b2;
      for (a = 0; a < b2.length; a++)
        da.add(b2[a]);
    }
    var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
    function oa(a) {
      if (ja.call(ma, a))
        return true;
      if (ja.call(la, a))
        return false;
      if (ka.test(a))
        return ma[a] = true;
      la[a] = true;
      return false;
    }
    function pa(a, b2, c2, d2) {
      if (null !== c2 && 0 === c2.type)
        return false;
      switch (typeof b2) {
        case "function":
        case "symbol":
          return true;
        case "boolean":
          if (d2)
            return false;
          if (null !== c2)
            return !c2.acceptsBooleans;
          a = a.toLowerCase().slice(0, 5);
          return "data-" !== a && "aria-" !== a;
        default:
          return false;
      }
    }
    function qa(a, b2, c2, d2) {
      if (null === b2 || "undefined" === typeof b2 || pa(a, b2, c2, d2))
        return true;
      if (d2)
        return false;
      if (null !== c2)
        switch (c2.type) {
          case 3:
            return !b2;
          case 4:
            return false === b2;
          case 5:
            return isNaN(b2);
          case 6:
            return isNaN(b2) || 1 > b2;
        }
      return false;
    }
    function v$3(a, b2, c2, d2, e2, f2, g2) {
      this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
      this.attributeName = d2;
      this.attributeNamespace = e2;
      this.mustUseProperty = c2;
      this.propertyName = a;
      this.type = b2;
      this.sanitizeURL = f2;
      this.removeEmptyString = g2;
    }
    var z$1 = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
      z$1[a] = new v$3(a, 0, false, a, null, false, false);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
      var b2 = a[0];
      z$1[b2] = new v$3(b2, 1, false, a[1], null, false, false);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
      z$1[a] = new v$3(a, 2, false, a.toLowerCase(), null, false, false);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
      z$1[a] = new v$3(a, 2, false, a, null, false, false);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
      z$1[a] = new v$3(a, 3, false, a.toLowerCase(), null, false, false);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a) {
      z$1[a] = new v$3(a, 3, true, a, null, false, false);
    });
    ["capture", "download"].forEach(function(a) {
      z$1[a] = new v$3(a, 4, false, a, null, false, false);
    });
    ["cols", "rows", "size", "span"].forEach(function(a) {
      z$1[a] = new v$3(a, 6, false, a, null, false, false);
    });
    ["rowSpan", "start"].forEach(function(a) {
      z$1[a] = new v$3(a, 5, false, a.toLowerCase(), null, false, false);
    });
    var ra = /[\-:]([a-z])/g;
    function sa(a) {
      return a[1].toUpperCase();
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
      var b2 = a.replace(
        ra,
        sa
      );
      z$1[b2] = new v$3(b2, 1, false, a, null, false, false);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
      var b2 = a.replace(ra, sa);
      z$1[b2] = new v$3(b2, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
      var b2 = a.replace(ra, sa);
      z$1[b2] = new v$3(b2, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a) {
      z$1[a] = new v$3(a, 1, false, a.toLowerCase(), null, false, false);
    });
    z$1.xlinkHref = new v$3("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
    ["src", "href", "action", "formAction"].forEach(function(a) {
      z$1[a] = new v$3(a, 1, false, a.toLowerCase(), null, true, true);
    });
    function ta(a, b2, c2, d2) {
      var e2 = z$1.hasOwnProperty(b2) ? z$1[b2] : null;
      if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1])
        qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a.removeAttribute(b2) : a.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a.setAttributeNS(d2, b2, c2) : a.setAttribute(b2, c2)));
    }
    var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
    var Ia = Symbol.for("react.offscreen");
    var Ja = Symbol.iterator;
    function Ka(a) {
      if (null === a || "object" !== typeof a)
        return null;
      a = Ja && a[Ja] || a["@@iterator"];
      return "function" === typeof a ? a : null;
    }
    var A$1 = Object.assign, La;
    function Ma(a) {
      if (void 0 === La)
        try {
          throw Error();
        } catch (c2) {
          var b2 = c2.stack.trim().match(/\n( *(at )?)/);
          La = b2 && b2[1] || "";
        }
      return "\n" + La + a;
    }
    var Na = false;
    function Oa(a, b2) {
      if (!a || Na)
        return "";
      Na = true;
      var c2 = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (b2)
          if (b2 = function() {
            throw Error();
          }, Object.defineProperty(b2.prototype, "props", { set: function() {
            throw Error();
          } }), "object" === typeof Reflect && Reflect.construct) {
            try {
              Reflect.construct(b2, []);
            } catch (l2) {
              var d2 = l2;
            }
            Reflect.construct(a, [], b2);
          } else {
            try {
              b2.call();
            } catch (l2) {
              d2 = l2;
            }
            a.call(b2.prototype);
          }
        else {
          try {
            throw Error();
          } catch (l2) {
            d2 = l2;
          }
          a();
        }
      } catch (l2) {
        if (l2 && d2 && "string" === typeof l2.stack) {
          for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
            h2--;
          for (; 1 <= g2 && 0 <= h2; g2--, h2--)
            if (e2[g2] !== f2[h2]) {
              if (1 !== g2 || 1 !== h2) {
                do
                  if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
                    var k2 = "\n" + e2[g2].replace(" at new ", " at ");
                    a.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a.displayName));
                    return k2;
                  }
                while (1 <= g2 && 0 <= h2);
              }
              break;
            }
        }
      } finally {
        Na = false, Error.prepareStackTrace = c2;
      }
      return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
    }
    function Pa(a) {
      switch (a.tag) {
        case 5:
          return Ma(a.type);
        case 16:
          return Ma("Lazy");
        case 13:
          return Ma("Suspense");
        case 19:
          return Ma("SuspenseList");
        case 0:
        case 2:
        case 15:
          return a = Oa(a.type, false), a;
        case 11:
          return a = Oa(a.type.render, false), a;
        case 1:
          return a = Oa(a.type, true), a;
        default:
          return "";
      }
    }
    function Qa(a) {
      if (null == a)
        return null;
      if ("function" === typeof a)
        return a.displayName || a.name || null;
      if ("string" === typeof a)
        return a;
      switch (a) {
        case ya:
          return "Fragment";
        case wa:
          return "Portal";
        case Aa:
          return "Profiler";
        case za:
          return "StrictMode";
        case Ea:
          return "Suspense";
        case Fa:
          return "SuspenseList";
      }
      if ("object" === typeof a)
        switch (a.$$typeof) {
          case Ca:
            return (a.displayName || "Context") + ".Consumer";
          case Ba:
            return (a._context.displayName || "Context") + ".Provider";
          case Da:
            var b2 = a.render;
            a = a.displayName;
            a || (a = b2.displayName || b2.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
            return a;
          case Ga:
            return b2 = a.displayName || null, null !== b2 ? b2 : Qa(a.type) || "Memo";
          case Ha:
            b2 = a._payload;
            a = a._init;
            try {
              return Qa(a(b2));
            } catch (c2) {
            }
        }
      return null;
    }
    function Ra(a) {
      var b2 = a.type;
      switch (a.tag) {
        case 24:
          return "Cache";
        case 9:
          return (b2.displayName || "Context") + ".Consumer";
        case 10:
          return (b2._context.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return a = b2.render, a = a.displayName || a.name || "", b2.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 5:
          return b2;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return Qa(b2);
        case 8:
          return b2 === za ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
          if ("function" === typeof b2)
            return b2.displayName || b2.name || null;
          if ("string" === typeof b2)
            return b2;
      }
      return null;
    }
    function Sa(a) {
      switch (typeof a) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return a;
        case "object":
          return a;
        default:
          return "";
      }
    }
    function Ta(a) {
      var b2 = a.type;
      return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
    }
    function Ua(a) {
      var b2 = Ta(a) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a.constructor.prototype, b2), d2 = "" + a[b2];
      if (!a.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
        var e2 = c2.get, f2 = c2.set;
        Object.defineProperty(a, b2, { configurable: true, get: function() {
          return e2.call(this);
        }, set: function(a2) {
          d2 = "" + a2;
          f2.call(this, a2);
        } });
        Object.defineProperty(a, b2, { enumerable: c2.enumerable });
        return { getValue: function() {
          return d2;
        }, setValue: function(a2) {
          d2 = "" + a2;
        }, stopTracking: function() {
          a._valueTracker = null;
          delete a[b2];
        } };
      }
    }
    function Va(a) {
      a._valueTracker || (a._valueTracker = Ua(a));
    }
    function Wa(a) {
      if (!a)
        return false;
      var b2 = a._valueTracker;
      if (!b2)
        return true;
      var c2 = b2.getValue();
      var d2 = "";
      a && (d2 = Ta(a) ? a.checked ? "true" : "false" : a.value);
      a = d2;
      return a !== c2 ? (b2.setValue(a), true) : false;
    }
    function Xa(a) {
      a = a || ("undefined" !== typeof document ? document : void 0);
      if ("undefined" === typeof a)
        return null;
      try {
        return a.activeElement || a.body;
      } catch (b2) {
        return a.body;
      }
    }
    function Ya(a, b2) {
      var c2 = b2.checked;
      return A$1({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a._wrapperState.initialChecked });
    }
    function Za(a, b2) {
      var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
      c2 = Sa(null != b2.value ? b2.value : c2);
      a._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
    }
    function ab(a, b2) {
      b2 = b2.checked;
      null != b2 && ta(a, "checked", b2, false);
    }
    function bb(a, b2) {
      ab(a, b2);
      var c2 = Sa(b2.value), d2 = b2.type;
      if (null != c2)
        if ("number" === d2) {
          if (0 === c2 && "" === a.value || a.value != c2)
            a.value = "" + c2;
        } else
          a.value !== "" + c2 && (a.value = "" + c2);
      else if ("submit" === d2 || "reset" === d2) {
        a.removeAttribute("value");
        return;
      }
      b2.hasOwnProperty("value") ? cb(a, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a, b2.type, Sa(b2.defaultValue));
      null == b2.checked && null != b2.defaultChecked && (a.defaultChecked = !!b2.defaultChecked);
    }
    function db(a, b2, c2) {
      if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
        var d2 = b2.type;
        if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
          return;
        b2 = "" + a._wrapperState.initialValue;
        c2 || b2 === a.value || (a.value = b2);
        a.defaultValue = b2;
      }
      c2 = a.name;
      "" !== c2 && (a.name = "");
      a.defaultChecked = !!a._wrapperState.initialChecked;
      "" !== c2 && (a.name = c2);
    }
    function cb(a, b2, c2) {
      if ("number" !== b2 || Xa(a.ownerDocument) !== a)
        null == c2 ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c2 && (a.defaultValue = "" + c2);
    }
    var eb = Array.isArray;
    function fb(a, b2, c2, d2) {
      a = a.options;
      if (b2) {
        b2 = {};
        for (var e2 = 0; e2 < c2.length; e2++)
          b2["$" + c2[e2]] = true;
        for (c2 = 0; c2 < a.length; c2++)
          e2 = b2.hasOwnProperty("$" + a[c2].value), a[c2].selected !== e2 && (a[c2].selected = e2), e2 && d2 && (a[c2].defaultSelected = true);
      } else {
        c2 = "" + Sa(c2);
        b2 = null;
        for (e2 = 0; e2 < a.length; e2++) {
          if (a[e2].value === c2) {
            a[e2].selected = true;
            d2 && (a[e2].defaultSelected = true);
            return;
          }
          null !== b2 || a[e2].disabled || (b2 = a[e2]);
        }
        null !== b2 && (b2.selected = true);
      }
    }
    function gb(a, b2) {
      if (null != b2.dangerouslySetInnerHTML)
        throw Error(p$4(91));
      return A$1({}, b2, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
    }
    function hb(a, b2) {
      var c2 = b2.value;
      if (null == c2) {
        c2 = b2.children;
        b2 = b2.defaultValue;
        if (null != c2) {
          if (null != b2)
            throw Error(p$4(92));
          if (eb(c2)) {
            if (1 < c2.length)
              throw Error(p$4(93));
            c2 = c2[0];
          }
          b2 = c2;
        }
        null == b2 && (b2 = "");
        c2 = b2;
      }
      a._wrapperState = { initialValue: Sa(c2) };
    }
    function ib(a, b2) {
      var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
      null != c2 && (c2 = "" + c2, c2 !== a.value && (a.value = c2), null == b2.defaultValue && a.defaultValue !== c2 && (a.defaultValue = c2));
      null != d2 && (a.defaultValue = "" + d2);
    }
    function jb(a) {
      var b2 = a.textContent;
      b2 === a._wrapperState.initialValue && "" !== b2 && null !== b2 && (a.value = b2);
    }
    function kb(a) {
      switch (a) {
        case "svg":
          return "http://www.w3.org/2000/svg";
        case "math":
          return "http://www.w3.org/1998/Math/MathML";
        default:
          return "http://www.w3.org/1999/xhtml";
      }
    }
    function lb(a, b2) {
      return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b2) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a;
    }
    var mb, nb = function(a) {
      return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
        MSApp.execUnsafeLocalFunction(function() {
          return a(b2, c2, d2, e2);
        });
      } : a;
    }(function(a, b2) {
      if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a)
        a.innerHTML = b2;
      else {
        mb = mb || document.createElement("div");
        mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
        for (b2 = mb.firstChild; a.firstChild; )
          a.removeChild(a.firstChild);
        for (; b2.firstChild; )
          a.appendChild(b2.firstChild);
      }
    });
    function ob(a, b2) {
      if (b2) {
        var c2 = a.firstChild;
        if (c2 && c2 === a.lastChild && 3 === c2.nodeType) {
          c2.nodeValue = b2;
          return;
        }
      }
      a.textContent = b2;
    }
    var pb = {
      animationIterationCount: true,
      aspectRatio: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      columns: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridArea: true,
      gridRow: true,
      gridRowEnd: true,
      gridRowSpan: true,
      gridRowStart: true,
      gridColumn: true,
      gridColumnEnd: true,
      gridColumnSpan: true,
      gridColumnStart: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true
    }, qb = ["Webkit", "ms", "Moz", "O"];
    Object.keys(pb).forEach(function(a) {
      qb.forEach(function(b2) {
        b2 = b2 + a.charAt(0).toUpperCase() + a.substring(1);
        pb[b2] = pb[a];
      });
    });
    function rb(a, b2, c2) {
      return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a) && pb[a] ? ("" + b2).trim() : b2 + "px";
    }
    function sb(a, b2) {
      a = a.style;
      for (var c2 in b2)
        if (b2.hasOwnProperty(c2)) {
          var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
          "float" === c2 && (c2 = "cssFloat");
          d2 ? a.setProperty(c2, e2) : a[c2] = e2;
        }
    }
    var tb = A$1({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
    function ub(a, b2) {
      if (b2) {
        if (tb[a] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
          throw Error(p$4(137, a));
        if (null != b2.dangerouslySetInnerHTML) {
          if (null != b2.children)
            throw Error(p$4(60));
          if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML))
            throw Error(p$4(61));
        }
        if (null != b2.style && "object" !== typeof b2.style)
          throw Error(p$4(62));
      }
    }
    function vb(a, b2) {
      if (-1 === a.indexOf("-"))
        return "string" === typeof b2.is;
      switch (a) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    var wb = null;
    function xb(a) {
      a = a.target || a.srcElement || window;
      a.correspondingUseElement && (a = a.correspondingUseElement);
      return 3 === a.nodeType ? a.parentNode : a;
    }
    var yb = null, zb = null, Ab = null;
    function Bb(a) {
      if (a = Cb(a)) {
        if ("function" !== typeof yb)
          throw Error(p$4(280));
        var b2 = a.stateNode;
        b2 && (b2 = Db(b2), yb(a.stateNode, a.type, b2));
      }
    }
    function Eb(a) {
      zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
    }
    function Fb() {
      if (zb) {
        var a = zb, b2 = Ab;
        Ab = zb = null;
        Bb(a);
        if (b2)
          for (a = 0; a < b2.length; a++)
            Bb(b2[a]);
      }
    }
    function Gb(a, b2) {
      return a(b2);
    }
    function Hb() {
    }
    var Ib = false;
    function Jb(a, b2, c2) {
      if (Ib)
        return a(b2, c2);
      Ib = true;
      try {
        return Gb(a, b2, c2);
      } finally {
        if (Ib = false, null !== zb || null !== Ab)
          Hb(), Fb();
      }
    }
    function Kb(a, b2) {
      var c2 = a.stateNode;
      if (null === c2)
        return null;
      var d2 = Db(c2);
      if (null === d2)
        return null;
      c2 = d2[b2];
      a:
        switch (b2) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (d2 = !d2.disabled) || (a = a.type, d2 = !("button" === a || "input" === a || "select" === a || "textarea" === a));
            a = !d2;
            break a;
          default:
            a = false;
        }
      if (a)
        return null;
      if (c2 && "function" !== typeof c2)
        throw Error(p$4(231, b2, typeof c2));
      return c2;
    }
    var Lb = false;
    if (ia)
      try {
        var Mb = {};
        Object.defineProperty(Mb, "passive", { get: function() {
          Lb = true;
        } });
        window.addEventListener("test", Mb, Mb);
        window.removeEventListener("test", Mb, Mb);
      } catch (a) {
        Lb = false;
      }
    function Nb(a, b2, c2, d2, e2, f2, g2, h2, k2) {
      var l2 = Array.prototype.slice.call(arguments, 3);
      try {
        b2.apply(c2, l2);
      } catch (m2) {
        this.onError(m2);
      }
    }
    var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a) {
      Ob = true;
      Pb = a;
    } };
    function Tb(a, b2, c2, d2, e2, f2, g2, h2, k2) {
      Ob = false;
      Pb = null;
      Nb.apply(Sb, arguments);
    }
    function Ub(a, b2, c2, d2, e2, f2, g2, h2, k2) {
      Tb.apply(this, arguments);
      if (Ob) {
        if (Ob) {
          var l2 = Pb;
          Ob = false;
          Pb = null;
        } else
          throw Error(p$4(198));
        Qb || (Qb = true, Rb = l2);
      }
    }
    function Vb(a) {
      var b2 = a, c2 = a;
      if (a.alternate)
        for (; b2.return; )
          b2 = b2.return;
      else {
        a = b2;
        do
          b2 = a, 0 !== (b2.flags & 4098) && (c2 = b2.return), a = b2.return;
        while (a);
      }
      return 3 === b2.tag ? c2 : null;
    }
    function Wb(a) {
      if (13 === a.tag) {
        var b2 = a.memoizedState;
        null === b2 && (a = a.alternate, null !== a && (b2 = a.memoizedState));
        if (null !== b2)
          return b2.dehydrated;
      }
      return null;
    }
    function Xb(a) {
      if (Vb(a) !== a)
        throw Error(p$4(188));
    }
    function Yb(a) {
      var b2 = a.alternate;
      if (!b2) {
        b2 = Vb(a);
        if (null === b2)
          throw Error(p$4(188));
        return b2 !== a ? null : a;
      }
      for (var c2 = a, d2 = b2; ; ) {
        var e2 = c2.return;
        if (null === e2)
          break;
        var f2 = e2.alternate;
        if (null === f2) {
          d2 = e2.return;
          if (null !== d2) {
            c2 = d2;
            continue;
          }
          break;
        }
        if (e2.child === f2.child) {
          for (f2 = e2.child; f2; ) {
            if (f2 === c2)
              return Xb(e2), a;
            if (f2 === d2)
              return Xb(e2), b2;
            f2 = f2.sibling;
          }
          throw Error(p$4(188));
        }
        if (c2.return !== d2.return)
          c2 = e2, d2 = f2;
        else {
          for (var g2 = false, h2 = e2.child; h2; ) {
            if (h2 === c2) {
              g2 = true;
              c2 = e2;
              d2 = f2;
              break;
            }
            if (h2 === d2) {
              g2 = true;
              d2 = e2;
              c2 = f2;
              break;
            }
            h2 = h2.sibling;
          }
          if (!g2) {
            for (h2 = f2.child; h2; ) {
              if (h2 === c2) {
                g2 = true;
                c2 = f2;
                d2 = e2;
                break;
              }
              if (h2 === d2) {
                g2 = true;
                d2 = f2;
                c2 = e2;
                break;
              }
              h2 = h2.sibling;
            }
            if (!g2)
              throw Error(p$4(189));
          }
        }
        if (c2.alternate !== d2)
          throw Error(p$4(190));
      }
      if (3 !== c2.tag)
        throw Error(p$4(188));
      return c2.stateNode.current === c2 ? a : b2;
    }
    function Zb(a) {
      a = Yb(a);
      return null !== a ? $b(a) : null;
    }
    function $b(a) {
      if (5 === a.tag || 6 === a.tag)
        return a;
      for (a = a.child; null !== a; ) {
        var b2 = $b(a);
        if (null !== b2)
          return b2;
        a = a.sibling;
      }
      return null;
    }
    var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
    function mc(a) {
      if (lc && "function" === typeof lc.onCommitFiberRoot)
        try {
          lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
        } catch (b2) {
        }
    }
    var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
    function nc(a) {
      a >>>= 0;
      return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
    }
    var rc = 64, sc = 4194304;
    function tc(a) {
      switch (a & -a) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return a & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return a & 130023424;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 1073741824;
        default:
          return a;
      }
    }
    function uc(a, b2) {
      var c2 = a.pendingLanes;
      if (0 === c2)
        return 0;
      var d2 = 0, e2 = a.suspendedLanes, f2 = a.pingedLanes, g2 = c2 & 268435455;
      if (0 !== g2) {
        var h2 = g2 & ~e2;
        0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
      } else
        g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
      if (0 === d2)
        return 0;
      if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240)))
        return b2;
      0 !== (d2 & 4) && (d2 |= c2 & 16);
      b2 = a.entangledLanes;
      if (0 !== b2)
        for (a = a.entanglements, b2 &= d2; 0 < b2; )
          c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a[c2], b2 &= ~e2;
      return d2;
    }
    function vc(a, b2) {
      switch (a) {
        case 1:
        case 2:
        case 4:
          return b2 + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return b2 + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function wc(a, b2) {
      for (var c2 = a.suspendedLanes, d2 = a.pingedLanes, e2 = a.expirationTimes, f2 = a.pendingLanes; 0 < f2; ) {
        var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
        if (-1 === k2) {
          if (0 === (h2 & c2) || 0 !== (h2 & d2))
            e2[g2] = vc(h2, b2);
        } else
          k2 <= b2 && (a.expiredLanes |= h2);
        f2 &= ~h2;
      }
    }
    function xc(a) {
      a = a.pendingLanes & -1073741825;
      return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
    }
    function yc() {
      var a = rc;
      rc <<= 1;
      0 === (rc & 4194240) && (rc = 64);
      return a;
    }
    function zc(a) {
      for (var b2 = [], c2 = 0; 31 > c2; c2++)
        b2.push(a);
      return b2;
    }
    function Ac(a, b2, c2) {
      a.pendingLanes |= b2;
      536870912 !== b2 && (a.suspendedLanes = 0, a.pingedLanes = 0);
      a = a.eventTimes;
      b2 = 31 - oc(b2);
      a[b2] = c2;
    }
    function Bc(a, b2) {
      var c2 = a.pendingLanes & ~b2;
      a.pendingLanes = b2;
      a.suspendedLanes = 0;
      a.pingedLanes = 0;
      a.expiredLanes &= b2;
      a.mutableReadLanes &= b2;
      a.entangledLanes &= b2;
      b2 = a.entanglements;
      var d2 = a.eventTimes;
      for (a = a.expirationTimes; 0 < c2; ) {
        var e2 = 31 - oc(c2), f2 = 1 << e2;
        b2[e2] = 0;
        d2[e2] = -1;
        a[e2] = -1;
        c2 &= ~f2;
      }
    }
    function Cc(a, b2) {
      var c2 = a.entangledLanes |= b2;
      for (a = a.entanglements; c2; ) {
        var d2 = 31 - oc(c2), e2 = 1 << d2;
        e2 & b2 | a[d2] & b2 && (a[d2] |= b2);
        c2 &= ~e2;
      }
    }
    var C = 0;
    function Dc(a) {
      a &= -a;
      return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
    }
    var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
    function Sc(a, b2) {
      switch (a) {
        case "focusin":
        case "focusout":
          Lc = null;
          break;
        case "dragenter":
        case "dragleave":
          Mc = null;
          break;
        case "mouseover":
        case "mouseout":
          Nc = null;
          break;
        case "pointerover":
        case "pointerout":
          Oc.delete(b2.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          Pc.delete(b2.pointerId);
      }
    }
    function Tc(a, b2, c2, d2, e2, f2) {
      if (null === a || a.nativeEvent !== f2)
        return a = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a;
      a.eventSystemFlags |= d2;
      b2 = a.targetContainers;
      null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
      return a;
    }
    function Uc(a, b2, c2, d2, e2) {
      switch (b2) {
        case "focusin":
          return Lc = Tc(Lc, a, b2, c2, d2, e2), true;
        case "dragenter":
          return Mc = Tc(Mc, a, b2, c2, d2, e2), true;
        case "mouseover":
          return Nc = Tc(Nc, a, b2, c2, d2, e2), true;
        case "pointerover":
          var f2 = e2.pointerId;
          Oc.set(f2, Tc(Oc.get(f2) || null, a, b2, c2, d2, e2));
          return true;
        case "gotpointercapture":
          return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a, b2, c2, d2, e2)), true;
      }
      return false;
    }
    function Vc(a) {
      var b2 = Wc(a.target);
      if (null !== b2) {
        var c2 = Vb(b2);
        if (null !== c2) {
          if (b2 = c2.tag, 13 === b2) {
            if (b2 = Wb(c2), null !== b2) {
              a.blockedOn = b2;
              Ic(a.priority, function() {
                Gc(c2);
              });
              return;
            }
          } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
            a.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
            return;
          }
        }
      }
      a.blockedOn = null;
    }
    function Xc(a) {
      if (null !== a.blockedOn)
        return false;
      for (var b2 = a.targetContainers; 0 < b2.length; ) {
        var c2 = Yc(a.domEventName, a.eventSystemFlags, b2[0], a.nativeEvent);
        if (null === c2) {
          c2 = a.nativeEvent;
          var d2 = new c2.constructor(c2.type, c2);
          wb = d2;
          c2.target.dispatchEvent(d2);
          wb = null;
        } else
          return b2 = Cb(c2), null !== b2 && Fc(b2), a.blockedOn = c2, false;
        b2.shift();
      }
      return true;
    }
    function Zc(a, b2, c2) {
      Xc(a) && c2.delete(b2);
    }
    function $c() {
      Jc = false;
      null !== Lc && Xc(Lc) && (Lc = null);
      null !== Mc && Xc(Mc) && (Mc = null);
      null !== Nc && Xc(Nc) && (Nc = null);
      Oc.forEach(Zc);
      Pc.forEach(Zc);
    }
    function ad(a, b2) {
      a.blockedOn === b2 && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
    }
    function bd(a) {
      function b2(b3) {
        return ad(b3, a);
      }
      if (0 < Kc.length) {
        ad(Kc[0], a);
        for (var c2 = 1; c2 < Kc.length; c2++) {
          var d2 = Kc[c2];
          d2.blockedOn === a && (d2.blockedOn = null);
        }
      }
      null !== Lc && ad(Lc, a);
      null !== Mc && ad(Mc, a);
      null !== Nc && ad(Nc, a);
      Oc.forEach(b2);
      Pc.forEach(b2);
      for (c2 = 0; c2 < Qc.length; c2++)
        d2 = Qc[c2], d2.blockedOn === a && (d2.blockedOn = null);
      for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); )
        Vc(c2), null === c2.blockedOn && Qc.shift();
    }
    var cd = ua.ReactCurrentBatchConfig, dd = true;
    function ed(a, b2, c2, d2) {
      var e2 = C, f2 = cd.transition;
      cd.transition = null;
      try {
        C = 1, fd(a, b2, c2, d2);
      } finally {
        C = e2, cd.transition = f2;
      }
    }
    function gd(a, b2, c2, d2) {
      var e2 = C, f2 = cd.transition;
      cd.transition = null;
      try {
        C = 4, fd(a, b2, c2, d2);
      } finally {
        C = e2, cd.transition = f2;
      }
    }
    function fd(a, b2, c2, d2) {
      if (dd) {
        var e2 = Yc(a, b2, c2, d2);
        if (null === e2)
          hd(a, b2, d2, id$2, c2), Sc(a, d2);
        else if (Uc(e2, a, b2, c2, d2))
          d2.stopPropagation();
        else if (Sc(a, d2), b2 & 4 && -1 < Rc.indexOf(a)) {
          for (; null !== e2; ) {
            var f2 = Cb(e2);
            null !== f2 && Ec(f2);
            f2 = Yc(a, b2, c2, d2);
            null === f2 && hd(a, b2, d2, id$2, c2);
            if (f2 === e2)
              break;
            e2 = f2;
          }
          null !== e2 && d2.stopPropagation();
        } else
          hd(a, b2, d2, null, c2);
      }
    }
    var id$2 = null;
    function Yc(a, b2, c2, d2) {
      id$2 = null;
      a = xb(d2);
      a = Wc(a);
      if (null !== a)
        if (b2 = Vb(a), null === b2)
          a = null;
        else if (c2 = b2.tag, 13 === c2) {
          a = Wb(b2);
          if (null !== a)
            return a;
          a = null;
        } else if (3 === c2) {
          if (b2.stateNode.current.memoizedState.isDehydrated)
            return 3 === b2.tag ? b2.stateNode.containerInfo : null;
          a = null;
        } else
          b2 !== a && (a = null);
      id$2 = a;
      return null;
    }
    function jd(a) {
      switch (a) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return 1;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return 4;
        case "message":
          switch (ec()) {
            case fc:
              return 1;
            case gc:
              return 4;
            case hc:
            case ic:
              return 16;
            case jc:
              return 536870912;
            default:
              return 16;
          }
        default:
          return 16;
      }
    }
    var kd = null, ld = null, md = null;
    function nd() {
      if (md)
        return md;
      var a, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
      for (a = 0; a < c2 && b2[a] === e2[a]; a++)
        ;
      var g2 = c2 - a;
      for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++)
        ;
      return md = e2.slice(a, 1 < d2 ? 1 - d2 : void 0);
    }
    function od(a) {
      var b2 = a.keyCode;
      "charCode" in a ? (a = a.charCode, 0 === a && 13 === b2 && (a = 13)) : a = b2;
      10 === a && (a = 13);
      return 32 <= a || 13 === a ? a : 0;
    }
    function pd() {
      return true;
    }
    function qd() {
      return false;
    }
    function rd(a) {
      function b2(b3, d2, e2, f2, g2) {
        this._reactName = b3;
        this._targetInst = e2;
        this.type = d2;
        this.nativeEvent = f2;
        this.target = g2;
        this.currentTarget = null;
        for (var c2 in a)
          a.hasOwnProperty(c2) && (b3 = a[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
        this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
        this.isPropagationStopped = qd;
        return this;
      }
      A$1(b2.prototype, { preventDefault: function() {
        this.defaultPrevented = true;
        var a2 = this.nativeEvent;
        a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
      }, stopPropagation: function() {
        var a2 = this.nativeEvent;
        a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
      }, persist: function() {
      }, isPersistent: pd });
      return b2;
    }
    var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
      return a.timeStamp || Date.now();
    }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$1({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$1({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
      return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
    }, movementX: function(a) {
      if ("movementX" in a)
        return a.movementX;
      a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
      return wd;
    }, movementY: function(a) {
      return "movementY" in a ? a.movementY : xd;
    } }), Bd = rd(Ad), Cd = A$1({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$1({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$1({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$1({}, sd, { clipboardData: function(a) {
      return "clipboardData" in a ? a.clipboardData : window.clipboardData;
    } }), Jd = rd(Id), Kd = A$1({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, Nd = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
    function Pd(a) {
      var b2 = this.nativeEvent;
      return b2.getModifierState ? b2.getModifierState(a) : (a = Od[a]) ? !!b2[a] : false;
    }
    function zd() {
      return Pd;
    }
    var Qd = A$1({}, ud, { key: function(a) {
      if (a.key) {
        var b2 = Md[a.key] || a.key;
        if ("Unidentified" !== b2)
          return b2;
      }
      return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
    }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
      return "keypress" === a.type ? od(a) : 0;
    }, keyCode: function(a) {
      return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
    }, which: function(a) {
      return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
    } }), Rd = rd(Qd), Sd = A$1({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$1({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$1({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$1({}, Ad, {
      deltaX: function(a) {
        return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
      },
      deltaY: function(a) {
        return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
    ia && "documentMode" in document && (be = document.documentMode);
    var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
    function ge(a, b2) {
      switch (a) {
        case "keyup":
          return -1 !== $d.indexOf(b2.keyCode);
        case "keydown":
          return 229 !== b2.keyCode;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    function he(a) {
      a = a.detail;
      return "object" === typeof a && "data" in a ? a.data : null;
    }
    var ie = false;
    function je(a, b2) {
      switch (a) {
        case "compositionend":
          return he(b2);
        case "keypress":
          if (32 !== b2.which)
            return null;
          fe = true;
          return ee;
        case "textInput":
          return a = b2.data, a === ee && fe ? null : a;
        default:
          return null;
      }
    }
    function ke(a, b2) {
      if (ie)
        return "compositionend" === a || !ae && ge(a, b2) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
      switch (a) {
        case "paste":
          return null;
        case "keypress":
          if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
            if (b2.char && 1 < b2.char.length)
              return b2.char;
            if (b2.which)
              return String.fromCharCode(b2.which);
          }
          return null;
        case "compositionend":
          return de && "ko" !== b2.locale ? null : b2.data;
        default:
          return null;
      }
    }
    var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
    function me(a) {
      var b2 = a && a.nodeName && a.nodeName.toLowerCase();
      return "input" === b2 ? !!le[a.type] : "textarea" === b2 ? true : false;
    }
    function ne(a, b2, c2, d2) {
      Eb(d2);
      b2 = oe(b2, "onChange");
      0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a.push({ event: c2, listeners: b2 }));
    }
    var pe = null, qe = null;
    function re(a) {
      se(a, 0);
    }
    function te(a) {
      var b2 = ue(a);
      if (Wa(b2))
        return a;
    }
    function ve(a, b2) {
      if ("change" === a)
        return b2;
    }
    var we = false;
    if (ia) {
      var xe;
      if (ia) {
        var ye = "oninput" in document;
        if (!ye) {
          var ze = document.createElement("div");
          ze.setAttribute("oninput", "return;");
          ye = "function" === typeof ze.oninput;
        }
        xe = ye;
      } else
        xe = false;
      we = xe && (!document.documentMode || 9 < document.documentMode);
    }
    function Ae() {
      pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
    }
    function Be(a) {
      if ("value" === a.propertyName && te(qe)) {
        var b2 = [];
        ne(b2, qe, a, xb(a));
        Jb(re, b2);
      }
    }
    function Ce(a, b2, c2) {
      "focusin" === a ? (Ae(), pe = b2, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
    }
    function De(a) {
      if ("selectionchange" === a || "keyup" === a || "keydown" === a)
        return te(qe);
    }
    function Ee(a, b2) {
      if ("click" === a)
        return te(b2);
    }
    function Fe(a, b2) {
      if ("input" === a || "change" === a)
        return te(b2);
    }
    function Ge(a, b2) {
      return a === b2 && (0 !== a || 1 / a === 1 / b2) || a !== a && b2 !== b2;
    }
    var He = "function" === typeof Object.is ? Object.is : Ge;
    function Ie(a, b2) {
      if (He(a, b2))
        return true;
      if ("object" !== typeof a || null === a || "object" !== typeof b2 || null === b2)
        return false;
      var c2 = Object.keys(a), d2 = Object.keys(b2);
      if (c2.length !== d2.length)
        return false;
      for (d2 = 0; d2 < c2.length; d2++) {
        var e2 = c2[d2];
        if (!ja.call(b2, e2) || !He(a[e2], b2[e2]))
          return false;
      }
      return true;
    }
    function Je(a) {
      for (; a && a.firstChild; )
        a = a.firstChild;
      return a;
    }
    function Ke(a, b2) {
      var c2 = Je(a);
      a = 0;
      for (var d2; c2; ) {
        if (3 === c2.nodeType) {
          d2 = a + c2.textContent.length;
          if (a <= b2 && d2 >= b2)
            return { node: c2, offset: b2 - a };
          a = d2;
        }
        a: {
          for (; c2; ) {
            if (c2.nextSibling) {
              c2 = c2.nextSibling;
              break a;
            }
            c2 = c2.parentNode;
          }
          c2 = void 0;
        }
        c2 = Je(c2);
      }
    }
    function Le(a, b2) {
      return a && b2 ? a === b2 ? true : a && 3 === a.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a, b2.parentNode) : "contains" in a ? a.contains(b2) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b2) & 16) : false : false;
    }
    function Me() {
      for (var a = window, b2 = Xa(); b2 instanceof a.HTMLIFrameElement; ) {
        try {
          var c2 = "string" === typeof b2.contentWindow.location.href;
        } catch (d2) {
          c2 = false;
        }
        if (c2)
          a = b2.contentWindow;
        else
          break;
        b2 = Xa(a.document);
      }
      return b2;
    }
    function Ne(a) {
      var b2 = a && a.nodeName && a.nodeName.toLowerCase();
      return b2 && ("input" === b2 && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b2 || "true" === a.contentEditable);
    }
    function Oe(a) {
      var b2 = Me(), c2 = a.focusedElem, d2 = a.selectionRange;
      if (b2 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
        if (null !== d2 && Ne(c2)) {
          if (b2 = d2.start, a = d2.end, void 0 === a && (a = b2), "selectionStart" in c2)
            c2.selectionStart = b2, c2.selectionEnd = Math.min(a, c2.value.length);
          else if (a = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a.getSelection) {
            a = a.getSelection();
            var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
            d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
            !a.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
            e2 = Ke(c2, f2);
            var g2 = Ke(
              c2,
              d2
            );
            e2 && g2 && (1 !== a.rangeCount || a.anchorNode !== e2.node || a.anchorOffset !== e2.offset || a.focusNode !== g2.node || a.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a.removeAllRanges(), f2 > d2 ? (a.addRange(b2), a.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a.addRange(b2)));
          }
        }
        b2 = [];
        for (a = c2; a = a.parentNode; )
          1 === a.nodeType && b2.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
        "function" === typeof c2.focus && c2.focus();
        for (c2 = 0; c2 < b2.length; c2++)
          a = b2[c2], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
      }
    }
    var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
    function Ue(a, b2, c2) {
      var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
      Te || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Ie(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a.push({ event: b2, listeners: d2 }), b2.target = Qe)));
    }
    function Ve(a, b2) {
      var c2 = {};
      c2[a.toLowerCase()] = b2.toLowerCase();
      c2["Webkit" + a] = "webkit" + b2;
      c2["Moz" + a] = "moz" + b2;
      return c2;
    }
    var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
    ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
    function Ze(a) {
      if (Xe[a])
        return Xe[a];
      if (!We[a])
        return a;
      var b2 = We[a], c2;
      for (c2 in b2)
        if (b2.hasOwnProperty(c2) && c2 in Ye)
          return Xe[a] = b2[c2];
      return a;
    }
    var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    function ff(a, b2) {
      df.set(a, b2);
      fa(b2, [a]);
    }
    for (var gf = 0; gf < ef.length; gf++) {
      var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
      ff(jf, "on" + kf);
    }
    ff($e, "onAnimationEnd");
    ff(af, "onAnimationIteration");
    ff(bf, "onAnimationStart");
    ff("dblclick", "onDoubleClick");
    ff("focusin", "onFocus");
    ff("focusout", "onBlur");
    ff(cf, "onTransitionEnd");
    ha("onMouseEnter", ["mouseout", "mouseover"]);
    ha("onMouseLeave", ["mouseout", "mouseover"]);
    ha("onPointerEnter", ["pointerout", "pointerover"]);
    ha("onPointerLeave", ["pointerout", "pointerover"]);
    fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
    fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
    fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
    fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
    function nf(a, b2, c2) {
      var d2 = a.type || "unknown-event";
      a.currentTarget = c2;
      Ub(d2, b2, void 0, a);
      a.currentTarget = null;
    }
    function se(a, b2) {
      b2 = 0 !== (b2 & 4);
      for (var c2 = 0; c2 < a.length; c2++) {
        var d2 = a[c2], e2 = d2.event;
        d2 = d2.listeners;
        a: {
          var f2 = void 0;
          if (b2)
            for (var g2 = d2.length - 1; 0 <= g2; g2--) {
              var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
              h2 = h2.listener;
              if (k2 !== f2 && e2.isPropagationStopped())
                break a;
              nf(e2, h2, l2);
              f2 = k2;
            }
          else
            for (g2 = 0; g2 < d2.length; g2++) {
              h2 = d2[g2];
              k2 = h2.instance;
              l2 = h2.currentTarget;
              h2 = h2.listener;
              if (k2 !== f2 && e2.isPropagationStopped())
                break a;
              nf(e2, h2, l2);
              f2 = k2;
            }
        }
      }
      if (Qb)
        throw a = Rb, Qb = false, Rb = null, a;
    }
    function D(a, b2) {
      var c2 = b2[of];
      void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
      var d2 = a + "__bubble";
      c2.has(d2) || (pf(b2, a, 2, false), c2.add(d2));
    }
    function qf(a, b2, c2) {
      var d2 = 0;
      b2 && (d2 |= 4);
      pf(c2, a, d2, b2);
    }
    var rf = "_reactListening" + Math.random().toString(36).slice(2);
    function sf(a) {
      if (!a[rf]) {
        a[rf] = true;
        da.forEach(function(b3) {
          "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a), qf(b3, true, a));
        });
        var b2 = 9 === a.nodeType ? a : a.ownerDocument;
        null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
      }
    }
    function pf(a, b2, c2, d2) {
      switch (jd(b2)) {
        case 1:
          var e2 = ed;
          break;
        case 4:
          e2 = gd;
          break;
        default:
          e2 = fd;
      }
      c2 = e2.bind(null, b2, c2, a);
      e2 = void 0;
      !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
      d2 ? void 0 !== e2 ? a.addEventListener(b2, c2, { capture: true, passive: e2 }) : a.addEventListener(b2, c2, true) : void 0 !== e2 ? a.addEventListener(b2, c2, { passive: e2 }) : a.addEventListener(b2, c2, false);
    }
    function hd(a, b2, c2, d2, e2) {
      var f2 = d2;
      if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2)
        a:
          for (; ; ) {
            if (null === d2)
              return;
            var g2 = d2.tag;
            if (3 === g2 || 4 === g2) {
              var h2 = d2.stateNode.containerInfo;
              if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
                break;
              if (4 === g2)
                for (g2 = d2.return; null !== g2; ) {
                  var k2 = g2.tag;
                  if (3 === k2 || 4 === k2) {
                    if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                      return;
                  }
                  g2 = g2.return;
                }
              for (; null !== h2; ) {
                g2 = Wc(h2);
                if (null === g2)
                  return;
                k2 = g2.tag;
                if (5 === k2 || 6 === k2) {
                  d2 = f2 = g2;
                  continue a;
                }
                h2 = h2.parentNode;
              }
            }
            d2 = d2.return;
          }
      Jb(function() {
        var d3 = f2, e3 = xb(c2), g3 = [];
        a: {
          var h3 = df.get(a);
          if (void 0 !== h3) {
            var k3 = td, n2 = a;
            switch (a) {
              case "keypress":
                if (0 === od(c2))
                  break a;
              case "keydown":
              case "keyup":
                k3 = Rd;
                break;
              case "focusin":
                n2 = "focus";
                k3 = Fd;
                break;
              case "focusout":
                n2 = "blur";
                k3 = Fd;
                break;
              case "beforeblur":
              case "afterblur":
                k3 = Fd;
                break;
              case "click":
                if (2 === c2.button)
                  break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                k3 = Bd;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                k3 = Dd;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                k3 = Vd;
                break;
              case $e:
              case af:
              case bf:
                k3 = Hd;
                break;
              case cf:
                k3 = Xd;
                break;
              case "scroll":
                k3 = vd;
                break;
              case "wheel":
                k3 = Zd;
                break;
              case "copy":
              case "cut":
              case "paste":
                k3 = Jd;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                k3 = Td;
            }
            var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
            t2 = [];
            for (var w2 = d3, u2; null !== w2; ) {
              u2 = w2;
              var F2 = u2.stateNode;
              5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
              if (J2)
                break;
              w2 = w2.return;
            }
            0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
          }
        }
        if (0 === (b2 & 7)) {
          a: {
            h3 = "mouseover" === a || "pointerover" === a;
            k3 = "mouseout" === a || "pointerout" === a;
            if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf]))
              break a;
            if (k3 || h3) {
              h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
              if (k3) {
                if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
                  n2 = null;
              } else
                k3 = null, n2 = d3;
              if (k3 !== n2) {
                t2 = Bd;
                F2 = "onMouseLeave";
                x2 = "onMouseEnter";
                w2 = "mouse";
                if ("pointerout" === a || "pointerover" === a)
                  t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
                J2 = null == k3 ? h3 : ue(k3);
                u2 = null == n2 ? h3 : ue(n2);
                h3 = new t2(F2, w2 + "leave", k3, c2, e3);
                h3.target = J2;
                h3.relatedTarget = u2;
                F2 = null;
                Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
                J2 = F2;
                if (k3 && n2)
                  b: {
                    t2 = k3;
                    x2 = n2;
                    w2 = 0;
                    for (u2 = t2; u2; u2 = vf(u2))
                      w2++;
                    u2 = 0;
                    for (F2 = x2; F2; F2 = vf(F2))
                      u2++;
                    for (; 0 < w2 - u2; )
                      t2 = vf(t2), w2--;
                    for (; 0 < u2 - w2; )
                      x2 = vf(x2), u2--;
                    for (; w2--; ) {
                      if (t2 === x2 || null !== x2 && t2 === x2.alternate)
                        break b;
                      t2 = vf(t2);
                      x2 = vf(x2);
                    }
                    t2 = null;
                  }
                else
                  t2 = null;
                null !== k3 && wf(g3, h3, k3, t2, false);
                null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
              }
            }
          }
          a: {
            h3 = d3 ? ue(d3) : window;
            k3 = h3.nodeName && h3.nodeName.toLowerCase();
            if ("select" === k3 || "input" === k3 && "file" === h3.type)
              var na = ve;
            else if (me(h3))
              if (we)
                na = Fe;
              else {
                na = De;
                var xa = Ce;
              }
            else
              (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
            if (na && (na = na(a, d3))) {
              ne(g3, na, c2, e3);
              break a;
            }
            xa && xa(a, h3, d3);
            "focusout" === a && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
          }
          xa = d3 ? ue(d3) : window;
          switch (a) {
            case "focusin":
              if (me(xa) || "true" === xa.contentEditable)
                Qe = xa, Re = d3, Se = null;
              break;
            case "focusout":
              Se = Re = Qe = null;
              break;
            case "mousedown":
              Te = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              Te = false;
              Ue(g3, c2, e3);
              break;
            case "selectionchange":
              if (Pe)
                break;
            case "keydown":
            case "keyup":
              Ue(g3, c2, e3);
          }
          var $a;
          if (ae)
            b: {
              switch (a) {
                case "compositionstart":
                  var ba = "onCompositionStart";
                  break b;
                case "compositionend":
                  ba = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  ba = "onCompositionUpdate";
                  break b;
              }
              ba = void 0;
            }
          else
            ie ? ge(a, c2) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c2.keyCode && (ba = "onCompositionStart");
          ba && (de && "ko" !== c2.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d3, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c2), null !== $a && (ba.data = $a))));
          if ($a = ce ? je(a, c2) : ke(a, c2))
            d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
        }
        se(g3, b2);
      });
    }
    function tf(a, b2, c2) {
      return { instance: a, listener: b2, currentTarget: c2 };
    }
    function oe(a, b2) {
      for (var c2 = b2 + "Capture", d2 = []; null !== a; ) {
        var e2 = a, f2 = e2.stateNode;
        5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a, c2), null != f2 && d2.unshift(tf(a, f2, e2)), f2 = Kb(a, b2), null != f2 && d2.push(tf(a, f2, e2)));
        a = a.return;
      }
      return d2;
    }
    function vf(a) {
      if (null === a)
        return null;
      do
        a = a.return;
      while (a && 5 !== a.tag);
      return a ? a : null;
    }
    function wf(a, b2, c2, d2, e2) {
      for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
        var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
        if (null !== k2 && k2 === d2)
          break;
        5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
        c2 = c2.return;
      }
      0 !== g2.length && a.push({ event: b2, listeners: g2 });
    }
    var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
    function zf(a) {
      return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
    }
    function Af(a, b2, c2) {
      b2 = zf(b2);
      if (zf(a) !== b2 && c2)
        throw Error(p$4(425));
    }
    function Bf() {
    }
    var Cf = null, Df = null;
    function Ef(a, b2) {
      return "textarea" === a || "noscript" === a || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
    }
    var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
      return Hf.resolve(null).then(a).catch(If);
    } : Ff;
    function If(a) {
      setTimeout(function() {
        throw a;
      });
    }
    function Kf(a, b2) {
      var c2 = b2, d2 = 0;
      do {
        var e2 = c2.nextSibling;
        a.removeChild(c2);
        if (e2 && 8 === e2.nodeType)
          if (c2 = e2.data, "/$" === c2) {
            if (0 === d2) {
              a.removeChild(e2);
              bd(b2);
              return;
            }
            d2--;
          } else
            "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
        c2 = e2;
      } while (c2);
      bd(b2);
    }
    function Lf(a) {
      for (; null != a; a = a.nextSibling) {
        var b2 = a.nodeType;
        if (1 === b2 || 3 === b2)
          break;
        if (8 === b2) {
          b2 = a.data;
          if ("$" === b2 || "$!" === b2 || "$?" === b2)
            break;
          if ("/$" === b2)
            return null;
        }
      }
      return a;
    }
    function Mf(a) {
      a = a.previousSibling;
      for (var b2 = 0; a; ) {
        if (8 === a.nodeType) {
          var c2 = a.data;
          if ("$" === c2 || "$!" === c2 || "$?" === c2) {
            if (0 === b2)
              return a;
            b2--;
          } else
            "/$" === c2 && b2++;
        }
        a = a.previousSibling;
      }
      return null;
    }
    var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
    function Wc(a) {
      var b2 = a[Of];
      if (b2)
        return b2;
      for (var c2 = a.parentNode; c2; ) {
        if (b2 = c2[uf] || c2[Of]) {
          c2 = b2.alternate;
          if (null !== b2.child || null !== c2 && null !== c2.child)
            for (a = Mf(a); null !== a; ) {
              if (c2 = a[Of])
                return c2;
              a = Mf(a);
            }
          return b2;
        }
        a = c2;
        c2 = a.parentNode;
      }
      return null;
    }
    function Cb(a) {
      a = a[Of] || a[uf];
      return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
    }
    function ue(a) {
      if (5 === a.tag || 6 === a.tag)
        return a.stateNode;
      throw Error(p$4(33));
    }
    function Db(a) {
      return a[Pf] || null;
    }
    var Sf = [], Tf = -1;
    function Uf(a) {
      return { current: a };
    }
    function E(a) {
      0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
    }
    function G(a, b2) {
      Tf++;
      Sf[Tf] = a.current;
      a.current = b2;
    }
    var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
    function Yf(a, b2) {
      var c2 = a.type.contextTypes;
      if (!c2)
        return Vf;
      var d2 = a.stateNode;
      if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
        return d2.__reactInternalMemoizedMaskedChildContext;
      var e2 = {}, f2;
      for (f2 in c2)
        e2[f2] = b2[f2];
      d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b2, a.__reactInternalMemoizedMaskedChildContext = e2);
      return e2;
    }
    function Zf(a) {
      a = a.childContextTypes;
      return null !== a && void 0 !== a;
    }
    function $f() {
      E(Wf);
      E(H);
    }
    function ag(a, b2, c2) {
      if (H.current !== Vf)
        throw Error(p$4(168));
      G(H, b2);
      G(Wf, c2);
    }
    function bg(a, b2, c2) {
      var d2 = a.stateNode;
      b2 = b2.childContextTypes;
      if ("function" !== typeof d2.getChildContext)
        return c2;
      d2 = d2.getChildContext();
      for (var e2 in d2)
        if (!(e2 in b2))
          throw Error(p$4(108, Ra(a) || "Unknown", e2));
      return A$1({}, c2, d2);
    }
    function cg(a) {
      a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
      Xf = H.current;
      G(H, a);
      G(Wf, Wf.current);
      return true;
    }
    function dg(a, b2, c2) {
      var d2 = a.stateNode;
      if (!d2)
        throw Error(p$4(169));
      c2 ? (a = bg(a, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
      G(Wf, c2);
    }
    var eg = null, fg = false, gg = false;
    function hg(a) {
      null === eg ? eg = [a] : eg.push(a);
    }
    function ig(a) {
      fg = true;
      hg(a);
    }
    function jg() {
      if (!gg && null !== eg) {
        gg = true;
        var a = 0, b2 = C;
        try {
          var c2 = eg;
          for (C = 1; a < c2.length; a++) {
            var d2 = c2[a];
            do
              d2 = d2(true);
            while (null !== d2);
          }
          eg = null;
          fg = false;
        } catch (e2) {
          throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e2;
        } finally {
          C = b2, gg = false;
        }
      }
      return null;
    }
    var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
    function tg(a, b2) {
      kg[lg++] = ng;
      kg[lg++] = mg;
      mg = a;
      ng = b2;
    }
    function ug(a, b2, c2) {
      og[pg++] = rg;
      og[pg++] = sg;
      og[pg++] = qg;
      qg = a;
      var d2 = rg;
      a = sg;
      var e2 = 32 - oc(d2) - 1;
      d2 &= ~(1 << e2);
      c2 += 1;
      var f2 = 32 - oc(b2) + e2;
      if (30 < f2) {
        var g2 = e2 - e2 % 5;
        f2 = (d2 & (1 << g2) - 1).toString(32);
        d2 >>= g2;
        e2 -= g2;
        rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
        sg = f2 + a;
      } else
        rg = 1 << f2 | c2 << e2 | d2, sg = a;
    }
    function vg(a) {
      null !== a.return && (tg(a, 1), ug(a, 1, 0));
    }
    function wg(a) {
      for (; a === mg; )
        mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
      for (; a === qg; )
        qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
    }
    var xg = null, yg = null, I = false, zg = null;
    function Ag(a, b2) {
      var c2 = Bg(5, null, null, 0);
      c2.elementType = "DELETED";
      c2.stateNode = b2;
      c2.return = a;
      b2 = a.deletions;
      null === b2 ? (a.deletions = [c2], a.flags |= 16) : b2.push(c2);
    }
    function Cg(a, b2) {
      switch (a.tag) {
        case 5:
          var c2 = a.type;
          b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
          return null !== b2 ? (a.stateNode = b2, xg = a, yg = Lf(b2.firstChild), true) : false;
        case 6:
          return b2 = "" === a.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a.stateNode = b2, xg = a, yg = null, true) : false;
        case 13:
          return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a, a.child = c2, xg = a, yg = null, true) : false;
        default:
          return false;
      }
    }
    function Dg(a) {
      return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
    }
    function Eg(a) {
      if (I) {
        var b2 = yg;
        if (b2) {
          var c2 = b2;
          if (!Cg(a, b2)) {
            if (Dg(a))
              throw Error(p$4(418));
            b2 = Lf(c2.nextSibling);
            var d2 = xg;
            b2 && Cg(a, b2) ? Ag(d2, c2) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
          }
        } else {
          if (Dg(a))
            throw Error(p$4(418));
          a.flags = a.flags & -4097 | 2;
          I = false;
          xg = a;
        }
      }
    }
    function Fg(a) {
      for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; )
        a = a.return;
      xg = a;
    }
    function Gg(a) {
      if (a !== xg)
        return false;
      if (!I)
        return Fg(a), I = true, false;
      var b2;
      (b2 = 3 !== a.tag) && !(b2 = 5 !== a.tag) && (b2 = a.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a.type, a.memoizedProps));
      if (b2 && (b2 = yg)) {
        if (Dg(a))
          throw Hg(), Error(p$4(418));
        for (; b2; )
          Ag(a, b2), b2 = Lf(b2.nextSibling);
      }
      Fg(a);
      if (13 === a.tag) {
        a = a.memoizedState;
        a = null !== a ? a.dehydrated : null;
        if (!a)
          throw Error(p$4(317));
        a: {
          a = a.nextSibling;
          for (b2 = 0; a; ) {
            if (8 === a.nodeType) {
              var c2 = a.data;
              if ("/$" === c2) {
                if (0 === b2) {
                  yg = Lf(a.nextSibling);
                  break a;
                }
                b2--;
              } else
                "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
            }
            a = a.nextSibling;
          }
          yg = null;
        }
      } else
        yg = xg ? Lf(a.stateNode.nextSibling) : null;
      return true;
    }
    function Hg() {
      for (var a = yg; a; )
        a = Lf(a.nextSibling);
    }
    function Ig() {
      yg = xg = null;
      I = false;
    }
    function Jg(a) {
      null === zg ? zg = [a] : zg.push(a);
    }
    var Kg = ua.ReactCurrentBatchConfig;
    function Lg(a, b2) {
      if (a && a.defaultProps) {
        b2 = A$1({}, b2);
        a = a.defaultProps;
        for (var c2 in a)
          void 0 === b2[c2] && (b2[c2] = a[c2]);
        return b2;
      }
      return b2;
    }
    var Mg = Uf(null), Ng = null, Og = null, Pg = null;
    function Qg() {
      Pg = Og = Ng = null;
    }
    function Rg(a) {
      var b2 = Mg.current;
      E(Mg);
      a._currentValue = b2;
    }
    function Sg(a, b2, c2) {
      for (; null !== a; ) {
        var d2 = a.alternate;
        (a.childLanes & b2) !== b2 ? (a.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
        if (a === c2)
          break;
        a = a.return;
      }
    }
    function Tg(a, b2) {
      Ng = a;
      Pg = Og = null;
      a = a.dependencies;
      null !== a && null !== a.firstContext && (0 !== (a.lanes & b2) && (Ug = true), a.firstContext = null);
    }
    function Vg(a) {
      var b2 = a._currentValue;
      if (Pg !== a)
        if (a = { context: a, memoizedValue: b2, next: null }, null === Og) {
          if (null === Ng)
            throw Error(p$4(308));
          Og = a;
          Ng.dependencies = { lanes: 0, firstContext: a };
        } else
          Og = Og.next = a;
      return b2;
    }
    var Wg = null;
    function Xg(a) {
      null === Wg ? Wg = [a] : Wg.push(a);
    }
    function Yg(a, b2, c2, d2) {
      var e2 = b2.interleaved;
      null === e2 ? (c2.next = c2, Xg(b2)) : (c2.next = e2.next, e2.next = c2);
      b2.interleaved = c2;
      return Zg(a, d2);
    }
    function Zg(a, b2) {
      a.lanes |= b2;
      var c2 = a.alternate;
      null !== c2 && (c2.lanes |= b2);
      c2 = a;
      for (a = a.return; null !== a; )
        a.childLanes |= b2, c2 = a.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a, a = a.return;
      return 3 === c2.tag ? c2.stateNode : null;
    }
    var $g = false;
    function ah(a) {
      a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
    }
    function bh(a, b2) {
      a = a.updateQueue;
      b2.updateQueue === a && (b2.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
    }
    function ch(a, b2) {
      return { eventTime: a, lane: b2, tag: 0, payload: null, callback: null, next: null };
    }
    function dh(a, b2, c2) {
      var d2 = a.updateQueue;
      if (null === d2)
        return null;
      d2 = d2.shared;
      if (0 !== (K & 2)) {
        var e2 = d2.pending;
        null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
        d2.pending = b2;
        return Zg(a, c2);
      }
      e2 = d2.interleaved;
      null === e2 ? (b2.next = b2, Xg(d2)) : (b2.next = e2.next, e2.next = b2);
      d2.interleaved = b2;
      return Zg(a, c2);
    }
    function eh(a, b2, c2) {
      b2 = b2.updateQueue;
      if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
        var d2 = b2.lanes;
        d2 &= a.pendingLanes;
        c2 |= d2;
        b2.lanes = c2;
        Cc(a, c2);
      }
    }
    function fh(a, b2) {
      var c2 = a.updateQueue, d2 = a.alternate;
      if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
        var e2 = null, f2 = null;
        c2 = c2.firstBaseUpdate;
        if (null !== c2) {
          do {
            var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
            null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
            c2 = c2.next;
          } while (null !== c2);
          null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
        } else
          e2 = f2 = b2;
        c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
        a.updateQueue = c2;
        return;
      }
      a = c2.lastBaseUpdate;
      null === a ? c2.firstBaseUpdate = b2 : a.next = b2;
      c2.lastBaseUpdate = b2;
    }
    function gh(a, b2, c2, d2) {
      var e2 = a.updateQueue;
      $g = false;
      var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
      if (null !== h2) {
        e2.shared.pending = null;
        var k2 = h2, l2 = k2.next;
        k2.next = null;
        null === g2 ? f2 = l2 : g2.next = l2;
        g2 = k2;
        var m2 = a.alternate;
        null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
      }
      if (null !== f2) {
        var q2 = e2.baseState;
        g2 = 0;
        m2 = l2 = k2 = null;
        h2 = f2;
        do {
          var r2 = h2.lane, y2 = h2.eventTime;
          if ((d2 & r2) === r2) {
            null !== m2 && (m2 = m2.next = {
              eventTime: y2,
              lane: 0,
              tag: h2.tag,
              payload: h2.payload,
              callback: h2.callback,
              next: null
            });
            a: {
              var n2 = a, t2 = h2;
              r2 = b2;
              y2 = c2;
              switch (t2.tag) {
                case 1:
                  n2 = t2.payload;
                  if ("function" === typeof n2) {
                    q2 = n2.call(y2, q2, r2);
                    break a;
                  }
                  q2 = n2;
                  break a;
                case 3:
                  n2.flags = n2.flags & -65537 | 128;
                case 0:
                  n2 = t2.payload;
                  r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
                  if (null === r2 || void 0 === r2)
                    break a;
                  q2 = A$1({}, q2, r2);
                  break a;
                case 2:
                  $g = true;
              }
            }
            null !== h2.callback && 0 !== h2.lane && (a.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
          } else
            y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
          h2 = h2.next;
          if (null === h2)
            if (h2 = e2.shared.pending, null === h2)
              break;
            else
              r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
        } while (1);
        null === m2 && (k2 = q2);
        e2.baseState = k2;
        e2.firstBaseUpdate = l2;
        e2.lastBaseUpdate = m2;
        b2 = e2.shared.interleaved;
        if (null !== b2) {
          e2 = b2;
          do
            g2 |= e2.lane, e2 = e2.next;
          while (e2 !== b2);
        } else
          null === f2 && (e2.shared.lanes = 0);
        hh |= g2;
        a.lanes = g2;
        a.memoizedState = q2;
      }
    }
    function ih(a, b2, c2) {
      a = b2.effects;
      b2.effects = null;
      if (null !== a)
        for (b2 = 0; b2 < a.length; b2++) {
          var d2 = a[b2], e2 = d2.callback;
          if (null !== e2) {
            d2.callback = null;
            d2 = c2;
            if ("function" !== typeof e2)
              throw Error(p$4(191, e2));
            e2.call(d2);
          }
        }
    }
    var jh = new aa.Component().refs;
    function kh(a, b2, c2, d2) {
      b2 = a.memoizedState;
      c2 = c2(d2, b2);
      c2 = null === c2 || void 0 === c2 ? b2 : A$1({}, b2, c2);
      a.memoizedState = c2;
      0 === a.lanes && (a.updateQueue.baseState = c2);
    }
    var nh = { isMounted: function(a) {
      return (a = a._reactInternals) ? Vb(a) === a : false;
    }, enqueueSetState: function(a, b2, c2) {
      a = a._reactInternals;
      var d2 = L(), e2 = lh(a), f2 = ch(d2, e2);
      f2.payload = b2;
      void 0 !== c2 && null !== c2 && (f2.callback = c2);
      b2 = dh(a, f2, e2);
      null !== b2 && (mh(b2, a, e2, d2), eh(b2, a, e2));
    }, enqueueReplaceState: function(a, b2, c2) {
      a = a._reactInternals;
      var d2 = L(), e2 = lh(a), f2 = ch(d2, e2);
      f2.tag = 1;
      f2.payload = b2;
      void 0 !== c2 && null !== c2 && (f2.callback = c2);
      b2 = dh(a, f2, e2);
      null !== b2 && (mh(b2, a, e2, d2), eh(b2, a, e2));
    }, enqueueForceUpdate: function(a, b2) {
      a = a._reactInternals;
      var c2 = L(), d2 = lh(a), e2 = ch(c2, d2);
      e2.tag = 2;
      void 0 !== b2 && null !== b2 && (e2.callback = b2);
      b2 = dh(a, e2, d2);
      null !== b2 && (mh(b2, a, d2, c2), eh(b2, a, d2));
    } };
    function oh(a, b2, c2, d2, e2, f2, g2) {
      a = a.stateNode;
      return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie(c2, d2) || !Ie(e2, f2) : true;
    }
    function ph(a, b2, c2) {
      var d2 = false, e2 = Vf;
      var f2 = b2.contextType;
      "object" === typeof f2 && null !== f2 ? f2 = Vg(f2) : (e2 = Zf(b2) ? Xf : H.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a, e2) : Vf);
      b2 = new b2(c2, f2);
      a.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
      b2.updater = nh;
      a.stateNode = b2;
      b2._reactInternals = a;
      d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e2, a.__reactInternalMemoizedMaskedChildContext = f2);
      return b2;
    }
    function qh(a, b2, c2, d2) {
      a = b2.state;
      "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
      "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
      b2.state !== a && nh.enqueueReplaceState(b2, b2.state, null);
    }
    function rh(a, b2, c2, d2) {
      var e2 = a.stateNode;
      e2.props = c2;
      e2.state = a.memoizedState;
      e2.refs = jh;
      ah(a);
      var f2 = b2.contextType;
      "object" === typeof f2 && null !== f2 ? e2.context = Vg(f2) : (f2 = Zf(b2) ? Xf : H.current, e2.context = Yf(a, f2));
      e2.state = a.memoizedState;
      f2 = b2.getDerivedStateFromProps;
      "function" === typeof f2 && (kh(a, b2, f2, c2), e2.state = a.memoizedState);
      "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && nh.enqueueReplaceState(e2, e2.state, null), gh(a, c2, e2, d2), e2.state = a.memoizedState);
      "function" === typeof e2.componentDidMount && (a.flags |= 4194308);
    }
    function sh(a, b2, c2) {
      a = c2.ref;
      if (null !== a && "function" !== typeof a && "object" !== typeof a) {
        if (c2._owner) {
          c2 = c2._owner;
          if (c2) {
            if (1 !== c2.tag)
              throw Error(p$4(309));
            var d2 = c2.stateNode;
          }
          if (!d2)
            throw Error(p$4(147, a));
          var e2 = d2, f2 = "" + a;
          if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2)
            return b2.ref;
          b2 = function(a2) {
            var b3 = e2.refs;
            b3 === jh && (b3 = e2.refs = {});
            null === a2 ? delete b3[f2] : b3[f2] = a2;
          };
          b2._stringRef = f2;
          return b2;
        }
        if ("string" !== typeof a)
          throw Error(p$4(284));
        if (!c2._owner)
          throw Error(p$4(290, a));
      }
      return a;
    }
    function th(a, b2) {
      a = Object.prototype.toString.call(b2);
      throw Error(p$4(31, "[object Object]" === a ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a));
    }
    function uh(a) {
      var b2 = a._init;
      return b2(a._payload);
    }
    function vh$1(a) {
      function b2(b3, c3) {
        if (a) {
          var d3 = b3.deletions;
          null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
        }
      }
      function c2(c3, d3) {
        if (!a)
          return null;
        for (; null !== d3; )
          b2(c3, d3), d3 = d3.sibling;
        return null;
      }
      function d2(a2, b3) {
        for (a2 = /* @__PURE__ */ new Map(); null !== b3; )
          null !== b3.key ? a2.set(b3.key, b3) : a2.set(b3.index, b3), b3 = b3.sibling;
        return a2;
      }
      function e2(a2, b3) {
        a2 = wh(a2, b3);
        a2.index = 0;
        a2.sibling = null;
        return a2;
      }
      function f2(b3, c3, d3) {
        b3.index = d3;
        if (!a)
          return b3.flags |= 1048576, c3;
        d3 = b3.alternate;
        if (null !== d3)
          return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
        b3.flags |= 2;
        return c3;
      }
      function g2(b3) {
        a && null === b3.alternate && (b3.flags |= 2);
        return b3;
      }
      function h2(a2, b3, c3, d3) {
        if (null === b3 || 6 !== b3.tag)
          return b3 = xh(c3, a2.mode, d3), b3.return = a2, b3;
        b3 = e2(b3, c3);
        b3.return = a2;
        return b3;
      }
      function k2(a2, b3, c3, d3) {
        var f3 = c3.type;
        if (f3 === ya)
          return m2(a2, b3, c3.props.children, d3, c3.key);
        if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && uh(f3) === b3.type))
          return d3 = e2(b3, c3.props), d3.ref = sh(a2, b3, c3), d3.return = a2, d3;
        d3 = yh(c3.type, c3.key, c3.props, null, a2.mode, d3);
        d3.ref = sh(a2, b3, c3);
        d3.return = a2;
        return d3;
      }
      function l2(a2, b3, c3, d3) {
        if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
          return b3 = zh(c3, a2.mode, d3), b3.return = a2, b3;
        b3 = e2(b3, c3.children || []);
        b3.return = a2;
        return b3;
      }
      function m2(a2, b3, c3, d3, f3) {
        if (null === b3 || 7 !== b3.tag)
          return b3 = Ah(c3, a2.mode, d3, f3), b3.return = a2, b3;
        b3 = e2(b3, c3);
        b3.return = a2;
        return b3;
      }
      function q2(a2, b3, c3) {
        if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3)
          return b3 = xh("" + b3, a2.mode, c3), b3.return = a2, b3;
        if ("object" === typeof b3 && null !== b3) {
          switch (b3.$$typeof) {
            case va:
              return c3 = yh(b3.type, b3.key, b3.props, null, a2.mode, c3), c3.ref = sh(a2, null, b3), c3.return = a2, c3;
            case wa:
              return b3 = zh(b3, a2.mode, c3), b3.return = a2, b3;
            case Ha:
              var d3 = b3._init;
              return q2(a2, d3(b3._payload), c3);
          }
          if (eb(b3) || Ka(b3))
            return b3 = Ah(b3, a2.mode, c3, null), b3.return = a2, b3;
          th(a2, b3);
        }
        return null;
      }
      function r2(a2, b3, c3, d3) {
        var e3 = null !== b3 ? b3.key : null;
        if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3)
          return null !== e3 ? null : h2(a2, b3, "" + c3, d3);
        if ("object" === typeof c3 && null !== c3) {
          switch (c3.$$typeof) {
            case va:
              return c3.key === e3 ? k2(a2, b3, c3, d3) : null;
            case wa:
              return c3.key === e3 ? l2(a2, b3, c3, d3) : null;
            case Ha:
              return e3 = c3._init, r2(
                a2,
                b3,
                e3(c3._payload),
                d3
              );
          }
          if (eb(c3) || Ka(c3))
            return null !== e3 ? null : m2(a2, b3, c3, d3, null);
          th(a2, c3);
        }
        return null;
      }
      function y2(a2, b3, c3, d3, e3) {
        if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3)
          return a2 = a2.get(c3) || null, h2(b3, a2, "" + d3, e3);
        if ("object" === typeof d3 && null !== d3) {
          switch (d3.$$typeof) {
            case va:
              return a2 = a2.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a2, d3, e3);
            case wa:
              return a2 = a2.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a2, d3, e3);
            case Ha:
              var f3 = d3._init;
              return y2(a2, b3, c3, f3(d3._payload), e3);
          }
          if (eb(d3) || Ka(d3))
            return a2 = a2.get(c3) || null, m2(b3, a2, d3, e3, null);
          th(b3, d3);
        }
        return null;
      }
      function n2(e3, g3, h3, k3) {
        for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
          u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
          var n3 = r2(e3, u2, h3[w2], k3);
          if (null === n3) {
            null === u2 && (u2 = x2);
            break;
          }
          a && u2 && null === n3.alternate && b2(e3, u2);
          g3 = f2(n3, g3, w2);
          null === m3 ? l3 = n3 : m3.sibling = n3;
          m3 = n3;
          u2 = x2;
        }
        if (w2 === h3.length)
          return c2(e3, u2), I && tg(e3, w2), l3;
        if (null === u2) {
          for (; w2 < h3.length; w2++)
            u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
          I && tg(e3, w2);
          return l3;
        }
        for (u2 = d2(e3, u2); w2 < h3.length; w2++)
          x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
        a && u2.forEach(function(a2) {
          return b2(e3, a2);
        });
        I && tg(e3, w2);
        return l3;
      }
      function t2(e3, g3, h3, k3) {
        var l3 = Ka(h3);
        if ("function" !== typeof l3)
          throw Error(p$4(150));
        h3 = l3.call(h3);
        if (null == h3)
          throw Error(p$4(151));
        for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
          m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
          var t3 = r2(e3, m3, n3.value, k3);
          if (null === t3) {
            null === m3 && (m3 = x2);
            break;
          }
          a && m3 && null === t3.alternate && b2(e3, m3);
          g3 = f2(t3, g3, w2);
          null === u2 ? l3 = t3 : u2.sibling = t3;
          u2 = t3;
          m3 = x2;
        }
        if (n3.done)
          return c2(
            e3,
            m3
          ), I && tg(e3, w2), l3;
        if (null === m3) {
          for (; !n3.done; w2++, n3 = h3.next())
            n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
          I && tg(e3, w2);
          return l3;
        }
        for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next())
          n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
        a && m3.forEach(function(a2) {
          return b2(e3, a2);
        });
        I && tg(e3, w2);
        return l3;
      }
      function J2(a2, d3, f3, h3) {
        "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
        if ("object" === typeof f3 && null !== f3) {
          switch (f3.$$typeof) {
            case va:
              a: {
                for (var k3 = f3.key, l3 = d3; null !== l3; ) {
                  if (l3.key === k3) {
                    k3 = f3.type;
                    if (k3 === ya) {
                      if (7 === l3.tag) {
                        c2(a2, l3.sibling);
                        d3 = e2(l3, f3.props.children);
                        d3.return = a2;
                        a2 = d3;
                        break a;
                      }
                    } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && uh(k3) === l3.type) {
                      c2(a2, l3.sibling);
                      d3 = e2(l3, f3.props);
                      d3.ref = sh(a2, l3, f3);
                      d3.return = a2;
                      a2 = d3;
                      break a;
                    }
                    c2(a2, l3);
                    break;
                  } else
                    b2(a2, l3);
                  l3 = l3.sibling;
                }
                f3.type === ya ? (d3 = Ah(f3.props.children, a2.mode, h3, f3.key), d3.return = a2, a2 = d3) : (h3 = yh(f3.type, f3.key, f3.props, null, a2.mode, h3), h3.ref = sh(a2, d3, f3), h3.return = a2, a2 = h3);
              }
              return g2(a2);
            case wa:
              a: {
                for (l3 = f3.key; null !== d3; ) {
                  if (d3.key === l3)
                    if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                      c2(a2, d3.sibling);
                      d3 = e2(d3, f3.children || []);
                      d3.return = a2;
                      a2 = d3;
                      break a;
                    } else {
                      c2(a2, d3);
                      break;
                    }
                  else
                    b2(a2, d3);
                  d3 = d3.sibling;
                }
                d3 = zh(f3, a2.mode, h3);
                d3.return = a2;
                a2 = d3;
              }
              return g2(a2);
            case Ha:
              return l3 = f3._init, J2(a2, d3, l3(f3._payload), h3);
          }
          if (eb(f3))
            return n2(a2, d3, f3, h3);
          if (Ka(f3))
            return t2(a2, d3, f3, h3);
          th(a2, f3);
        }
        return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a2, d3.sibling), d3 = e2(d3, f3), d3.return = a2, a2 = d3) : (c2(a2, d3), d3 = xh(f3, a2.mode, h3), d3.return = a2, a2 = d3), g2(a2)) : c2(a2, d3);
      }
      return J2;
    }
    var Bh = vh$1(true), Ch = vh$1(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
    function Hh(a) {
      if (a === Dh)
        throw Error(p$4(174));
      return a;
    }
    function Ih(a, b2) {
      G(Gh, b2);
      G(Fh, a);
      G(Eh, Dh);
      a = b2.nodeType;
      switch (a) {
        case 9:
        case 11:
          b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
          break;
        default:
          a = 8 === a ? b2.parentNode : b2, b2 = a.namespaceURI || null, a = a.tagName, b2 = lb(b2, a);
      }
      E(Eh);
      G(Eh, b2);
    }
    function Jh() {
      E(Eh);
      E(Fh);
      E(Gh);
    }
    function Kh(a) {
      Hh(Gh.current);
      var b2 = Hh(Eh.current);
      var c2 = lb(b2, a.type);
      b2 !== c2 && (G(Fh, a), G(Eh, c2));
    }
    function Lh(a) {
      Fh.current === a && (E(Eh), E(Fh));
    }
    var M = Uf(0);
    function Mh(a) {
      for (var b2 = a; null !== b2; ) {
        if (13 === b2.tag) {
          var c2 = b2.memoizedState;
          if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
            return b2;
        } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
          if (0 !== (b2.flags & 128))
            return b2;
        } else if (null !== b2.child) {
          b2.child.return = b2;
          b2 = b2.child;
          continue;
        }
        if (b2 === a)
          break;
        for (; null === b2.sibling; ) {
          if (null === b2.return || b2.return === a)
            return null;
          b2 = b2.return;
        }
        b2.sibling.return = b2.return;
        b2 = b2.sibling;
      }
      return null;
    }
    var Nh = [];
    function Oh() {
      for (var a = 0; a < Nh.length; a++)
        Nh[a]._workInProgressVersionPrimary = null;
      Nh.length = 0;
    }
    var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N = null, O = null, P = null, Sh = false, Th = false, Uh = 0, Vh = 0;
    function Q() {
      throw Error(p$4(321));
    }
    function Wh(a, b2) {
      if (null === b2)
        return false;
      for (var c2 = 0; c2 < b2.length && c2 < a.length; c2++)
        if (!He(a[c2], b2[c2]))
          return false;
      return true;
    }
    function Xh(a, b2, c2, d2, e2, f2) {
      Rh = f2;
      N = b2;
      b2.memoizedState = null;
      b2.updateQueue = null;
      b2.lanes = 0;
      Ph.current = null === a || null === a.memoizedState ? Yh : Zh;
      a = c2(d2, e2);
      if (Th) {
        f2 = 0;
        do {
          Th = false;
          Uh = 0;
          if (25 <= f2)
            throw Error(p$4(301));
          f2 += 1;
          P = O = null;
          b2.updateQueue = null;
          Ph.current = $h;
          a = c2(d2, e2);
        } while (Th);
      }
      Ph.current = ai;
      b2 = null !== O && null !== O.next;
      Rh = 0;
      P = O = N = null;
      Sh = false;
      if (b2)
        throw Error(p$4(300));
      return a;
    }
    function bi() {
      var a = 0 !== Uh;
      Uh = 0;
      return a;
    }
    function ci() {
      var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      null === P ? N.memoizedState = P = a : P = P.next = a;
      return P;
    }
    function di() {
      if (null === O) {
        var a = N.alternate;
        a = null !== a ? a.memoizedState : null;
      } else
        a = O.next;
      var b2 = null === P ? N.memoizedState : P.next;
      if (null !== b2)
        P = b2, O = a;
      else {
        if (null === a)
          throw Error(p$4(310));
        O = a;
        a = { memoizedState: O.memoizedState, baseState: O.baseState, baseQueue: O.baseQueue, queue: O.queue, next: null };
        null === P ? N.memoizedState = P = a : P = P.next = a;
      }
      return P;
    }
    function ei(a, b2) {
      return "function" === typeof b2 ? b2(a) : b2;
    }
    function fi(a) {
      var b2 = di(), c2 = b2.queue;
      if (null === c2)
        throw Error(p$4(311));
      c2.lastRenderedReducer = a;
      var d2 = O, e2 = d2.baseQueue, f2 = c2.pending;
      if (null !== f2) {
        if (null !== e2) {
          var g2 = e2.next;
          e2.next = f2.next;
          f2.next = g2;
        }
        d2.baseQueue = e2 = f2;
        c2.pending = null;
      }
      if (null !== e2) {
        f2 = e2.next;
        d2 = d2.baseState;
        var h2 = g2 = null, k2 = null, l2 = f2;
        do {
          var m2 = l2.lane;
          if ((Rh & m2) === m2)
            null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a(d2, l2.action);
          else {
            var q2 = {
              lane: m2,
              action: l2.action,
              hasEagerState: l2.hasEagerState,
              eagerState: l2.eagerState,
              next: null
            };
            null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
            N.lanes |= m2;
            hh |= m2;
          }
          l2 = l2.next;
        } while (null !== l2 && l2 !== f2);
        null === k2 ? g2 = d2 : k2.next = h2;
        He(d2, b2.memoizedState) || (Ug = true);
        b2.memoizedState = d2;
        b2.baseState = g2;
        b2.baseQueue = k2;
        c2.lastRenderedState = d2;
      }
      a = c2.interleaved;
      if (null !== a) {
        e2 = a;
        do
          f2 = e2.lane, N.lanes |= f2, hh |= f2, e2 = e2.next;
        while (e2 !== a);
      } else
        null === e2 && (c2.lanes = 0);
      return [b2.memoizedState, c2.dispatch];
    }
    function gi(a) {
      var b2 = di(), c2 = b2.queue;
      if (null === c2)
        throw Error(p$4(311));
      c2.lastRenderedReducer = a;
      var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
      if (null !== e2) {
        c2.pending = null;
        var g2 = e2 = e2.next;
        do
          f2 = a(f2, g2.action), g2 = g2.next;
        while (g2 !== e2);
        He(f2, b2.memoizedState) || (Ug = true);
        b2.memoizedState = f2;
        null === b2.baseQueue && (b2.baseState = f2);
        c2.lastRenderedState = f2;
      }
      return [f2, d2];
    }
    function hi() {
    }
    function ii(a, b2) {
      var c2 = N, d2 = di(), e2 = b2(), f2 = !He(d2.memoizedState, e2);
      f2 && (d2.memoizedState = e2, Ug = true);
      d2 = d2.queue;
      ji(ki.bind(null, c2, d2, a), [a]);
      if (d2.getSnapshot !== b2 || f2 || null !== P && P.memoizedState.tag & 1) {
        c2.flags |= 2048;
        li(9, mi.bind(null, c2, d2, e2, b2), void 0, null);
        if (null === R)
          throw Error(p$4(349));
        0 !== (Rh & 30) || ni(c2, b2, e2);
      }
      return e2;
    }
    function ni(a, b2, c2) {
      a.flags |= 16384;
      a = { getSnapshot: b2, value: c2 };
      b2 = N.updateQueue;
      null === b2 ? (b2 = { lastEffect: null, stores: null }, N.updateQueue = b2, b2.stores = [a]) : (c2 = b2.stores, null === c2 ? b2.stores = [a] : c2.push(a));
    }
    function mi(a, b2, c2, d2) {
      b2.value = c2;
      b2.getSnapshot = d2;
      oi(b2) && pi(a);
    }
    function ki(a, b2, c2) {
      return c2(function() {
        oi(b2) && pi(a);
      });
    }
    function oi(a) {
      var b2 = a.getSnapshot;
      a = a.value;
      try {
        var c2 = b2();
        return !He(a, c2);
      } catch (d2) {
        return true;
      }
    }
    function pi(a) {
      var b2 = Zg(a, 1);
      null !== b2 && mh(b2, a, 1, -1);
    }
    function qi(a) {
      var b2 = ci();
      "function" === typeof a && (a = a());
      b2.memoizedState = b2.baseState = a;
      a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a };
      b2.queue = a;
      a = a.dispatch = ri.bind(null, N, a);
      return [b2.memoizedState, a];
    }
    function li(a, b2, c2, d2) {
      a = { tag: a, create: b2, destroy: c2, deps: d2, next: null };
      b2 = N.updateQueue;
      null === b2 ? (b2 = { lastEffect: null, stores: null }, N.updateQueue = b2, b2.lastEffect = a.next = a) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a.next = a : (d2 = c2.next, c2.next = a, a.next = d2, b2.lastEffect = a));
      return a;
    }
    function si() {
      return di().memoizedState;
    }
    function ti(a, b2, c2, d2) {
      var e2 = ci();
      N.flags |= a;
      e2.memoizedState = li(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
    }
    function ui(a, b2, c2, d2) {
      var e2 = di();
      d2 = void 0 === d2 ? null : d2;
      var f2 = void 0;
      if (null !== O) {
        var g2 = O.memoizedState;
        f2 = g2.destroy;
        if (null !== d2 && Wh(d2, g2.deps)) {
          e2.memoizedState = li(b2, c2, f2, d2);
          return;
        }
      }
      N.flags |= a;
      e2.memoizedState = li(1 | b2, c2, f2, d2);
    }
    function vi(a, b2) {
      return ti(8390656, 8, a, b2);
    }
    function ji(a, b2) {
      return ui(2048, 8, a, b2);
    }
    function wi(a, b2) {
      return ui(4, 2, a, b2);
    }
    function xi(a, b2) {
      return ui(4, 4, a, b2);
    }
    function yi(a, b2) {
      if ("function" === typeof b2)
        return a = a(), b2(a), function() {
          b2(null);
        };
      if (null !== b2 && void 0 !== b2)
        return a = a(), b2.current = a, function() {
          b2.current = null;
        };
    }
    function zi(a, b2, c2) {
      c2 = null !== c2 && void 0 !== c2 ? c2.concat([a]) : null;
      return ui(4, 4, yi.bind(null, b2, a), c2);
    }
    function Ai() {
    }
    function Bi(a, b2) {
      var c2 = di();
      b2 = void 0 === b2 ? null : b2;
      var d2 = c2.memoizedState;
      if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
        return d2[0];
      c2.memoizedState = [a, b2];
      return a;
    }
    function Ci(a, b2) {
      var c2 = di();
      b2 = void 0 === b2 ? null : b2;
      var d2 = c2.memoizedState;
      if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
        return d2[0];
      a = a();
      c2.memoizedState = [a, b2];
      return a;
    }
    function Di(a, b2, c2) {
      if (0 === (Rh & 21))
        return a.baseState && (a.baseState = false, Ug = true), a.memoizedState = c2;
      He(c2, b2) || (c2 = yc(), N.lanes |= c2, hh |= c2, a.baseState = true);
      return b2;
    }
    function Ei(a, b2) {
      var c2 = C;
      C = 0 !== c2 && 4 > c2 ? c2 : 4;
      a(true);
      var d2 = Qh.transition;
      Qh.transition = {};
      try {
        a(false), b2();
      } finally {
        C = c2, Qh.transition = d2;
      }
    }
    function Fi() {
      return di().memoizedState;
    }
    function Gi(a, b2, c2) {
      var d2 = lh(a);
      c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
      if (Hi(a))
        Ii(b2, c2);
      else if (c2 = Yg(a, b2, c2, d2), null !== c2) {
        var e2 = L();
        mh(c2, a, d2, e2);
        Ji(c2, b2, d2);
      }
    }
    function ri(a, b2, c2) {
      var d2 = lh(a), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
      if (Hi(a))
        Ii(b2, e2);
      else {
        var f2 = a.alternate;
        if (0 === a.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2))
          try {
            var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
            e2.hasEagerState = true;
            e2.eagerState = h2;
            if (He(h2, g2)) {
              var k2 = b2.interleaved;
              null === k2 ? (e2.next = e2, Xg(b2)) : (e2.next = k2.next, k2.next = e2);
              b2.interleaved = e2;
              return;
            }
          } catch (l2) {
          } finally {
          }
        c2 = Yg(a, b2, e2, d2);
        null !== c2 && (e2 = L(), mh(c2, a, d2, e2), Ji(c2, b2, d2));
      }
    }
    function Hi(a) {
      var b2 = a.alternate;
      return a === N || null !== b2 && b2 === N;
    }
    function Ii(a, b2) {
      Th = Sh = true;
      var c2 = a.pending;
      null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
      a.pending = b2;
    }
    function Ji(a, b2, c2) {
      if (0 !== (c2 & 4194240)) {
        var d2 = b2.lanes;
        d2 &= a.pendingLanes;
        c2 |= d2;
        b2.lanes = c2;
        Cc(a, c2);
      }
    }
    var ai = { readContext: Vg, useCallback: Q, useContext: Q, useEffect: Q, useImperativeHandle: Q, useInsertionEffect: Q, useLayoutEffect: Q, useMemo: Q, useReducer: Q, useRef: Q, useState: Q, useDebugValue: Q, useDeferredValue: Q, useTransition: Q, useMutableSource: Q, useSyncExternalStore: Q, useId: Q, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a, b2) {
      ci().memoizedState = [a, void 0 === b2 ? null : b2];
      return a;
    }, useContext: Vg, useEffect: vi, useImperativeHandle: function(a, b2, c2) {
      c2 = null !== c2 && void 0 !== c2 ? c2.concat([a]) : null;
      return ti(
        4194308,
        4,
        yi.bind(null, b2, a),
        c2
      );
    }, useLayoutEffect: function(a, b2) {
      return ti(4194308, 4, a, b2);
    }, useInsertionEffect: function(a, b2) {
      return ti(4, 2, a, b2);
    }, useMemo: function(a, b2) {
      var c2 = ci();
      b2 = void 0 === b2 ? null : b2;
      a = a();
      c2.memoizedState = [a, b2];
      return a;
    }, useReducer: function(a, b2, c2) {
      var d2 = ci();
      b2 = void 0 !== c2 ? c2(b2) : b2;
      d2.memoizedState = d2.baseState = b2;
      a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b2 };
      d2.queue = a;
      a = a.dispatch = Gi.bind(null, N, a);
      return [d2.memoizedState, a];
    }, useRef: function(a) {
      var b2 = ci();
      a = { current: a };
      return b2.memoizedState = a;
    }, useState: qi, useDebugValue: Ai, useDeferredValue: function(a) {
      return ci().memoizedState = a;
    }, useTransition: function() {
      var a = qi(false), b2 = a[0];
      a = Ei.bind(null, a[1]);
      ci().memoizedState = a;
      return [b2, a];
    }, useMutableSource: function() {
    }, useSyncExternalStore: function(a, b2, c2) {
      var d2 = N, e2 = ci();
      if (I) {
        if (void 0 === c2)
          throw Error(p$4(407));
        c2 = c2();
      } else {
        c2 = b2();
        if (null === R)
          throw Error(p$4(349));
        0 !== (Rh & 30) || ni(d2, b2, c2);
      }
      e2.memoizedState = c2;
      var f2 = { value: c2, getSnapshot: b2 };
      e2.queue = f2;
      vi(ki.bind(
        null,
        d2,
        f2,
        a
      ), [a]);
      d2.flags |= 2048;
      li(9, mi.bind(null, d2, f2, c2, b2), void 0, null);
      return c2;
    }, useId: function() {
      var a = ci(), b2 = R.identifierPrefix;
      if (I) {
        var c2 = sg;
        var d2 = rg;
        c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
        b2 = ":" + b2 + "R" + c2;
        c2 = Uh++;
        0 < c2 && (b2 += "H" + c2.toString(32));
        b2 += ":";
      } else
        c2 = Vh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
      return a.memoizedState = b2;
    }, unstable_isNewReconciler: false }, Zh = {
      readContext: Vg,
      useCallback: Bi,
      useContext: Vg,
      useEffect: ji,
      useImperativeHandle: zi,
      useInsertionEffect: wi,
      useLayoutEffect: xi,
      useMemo: Ci,
      useReducer: fi,
      useRef: si,
      useState: function() {
        return fi(ei);
      },
      useDebugValue: Ai,
      useDeferredValue: function(a) {
        var b2 = di();
        return Di(b2, O.memoizedState, a);
      },
      useTransition: function() {
        var a = fi(ei)[0], b2 = di().memoizedState;
        return [a, b2];
      },
      useMutableSource: hi,
      useSyncExternalStore: ii,
      useId: Fi,
      unstable_isNewReconciler: false
    }, $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
      return gi(ei);
    }, useDebugValue: Ai, useDeferredValue: function(a) {
      var b2 = di();
      return null === O ? b2.memoizedState = a : Di(b2, O.memoizedState, a);
    }, useTransition: function() {
      var a = gi(ei)[0], b2 = di().memoizedState;
      return [a, b2];
    }, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
    function Ki(a, b2) {
      try {
        var c2 = "", d2 = b2;
        do
          c2 += Pa(d2), d2 = d2.return;
        while (d2);
        var e2 = c2;
      } catch (f2) {
        e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
      }
      return { value: a, source: b2, stack: e2, digest: null };
    }
    function Li(a, b2, c2) {
      return { value: a, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
    }
    function Mi(a, b2) {
      try {
        console.error(b2.value);
      } catch (c2) {
        setTimeout(function() {
          throw c2;
        });
      }
    }
    var Ni = "function" === typeof WeakMap ? WeakMap : Map;
    function Oi(a, b2, c2) {
      c2 = ch(-1, c2);
      c2.tag = 3;
      c2.payload = { element: null };
      var d2 = b2.value;
      c2.callback = function() {
        Pi || (Pi = true, Qi = d2);
        Mi(a, b2);
      };
      return c2;
    }
    function Ri(a, b2, c2) {
      c2 = ch(-1, c2);
      c2.tag = 3;
      var d2 = a.type.getDerivedStateFromError;
      if ("function" === typeof d2) {
        var e2 = b2.value;
        c2.payload = function() {
          return d2(e2);
        };
        c2.callback = function() {
          Mi(a, b2);
        };
      }
      var f2 = a.stateNode;
      null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
        Mi(a, b2);
        "function" !== typeof d2 && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
        var c3 = b2.stack;
        this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
      });
      return c2;
    }
    function Ti(a, b2, c2) {
      var d2 = a.pingCache;
      if (null === d2) {
        d2 = a.pingCache = new Ni();
        var e2 = /* @__PURE__ */ new Set();
        d2.set(b2, e2);
      } else
        e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
      e2.has(c2) || (e2.add(c2), a = Ui.bind(null, a, b2, c2), b2.then(a, a));
    }
    function Vi(a) {
      do {
        var b2;
        if (b2 = 13 === a.tag)
          b2 = a.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
        if (b2)
          return a;
        a = a.return;
      } while (null !== a);
      return null;
    }
    function Wi(a, b2, c2, d2, e2) {
      if (0 === (a.mode & 1))
        return a === b2 ? a.flags |= 65536 : (a.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = ch(-1, 1), b2.tag = 2, dh(c2, b2, 1))), c2.lanes |= 1), a;
      a.flags |= 65536;
      a.lanes = e2;
      return a;
    }
    var Xi = ua.ReactCurrentOwner, Ug = false;
    function Yi(a, b2, c2, d2) {
      b2.child = null === a ? Ch(b2, null, c2, d2) : Bh(b2, a.child, c2, d2);
    }
    function Zi(a, b2, c2, d2, e2) {
      c2 = c2.render;
      var f2 = b2.ref;
      Tg(b2, e2);
      d2 = Xh(a, b2, c2, d2, f2, e2);
      c2 = bi();
      if (null !== a && !Ug)
        return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e2, $i(a, b2, e2);
      I && c2 && vg(b2);
      b2.flags |= 1;
      Yi(a, b2, d2, e2);
      return b2.child;
    }
    function aj(a, b2, c2, d2, e2) {
      if (null === a) {
        var f2 = c2.type;
        if ("function" === typeof f2 && !bj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
          return b2.tag = 15, b2.type = f2, cj(a, b2, f2, d2, e2);
        a = yh(c2.type, null, d2, b2, b2.mode, e2);
        a.ref = b2.ref;
        a.return = b2;
        return b2.child = a;
      }
      f2 = a.child;
      if (0 === (a.lanes & e2)) {
        var g2 = f2.memoizedProps;
        c2 = c2.compare;
        c2 = null !== c2 ? c2 : Ie;
        if (c2(g2, d2) && a.ref === b2.ref)
          return $i(a, b2, e2);
      }
      b2.flags |= 1;
      a = wh(f2, d2);
      a.ref = b2.ref;
      a.return = b2;
      return b2.child = a;
    }
    function cj(a, b2, c2, d2, e2) {
      if (null !== a) {
        var f2 = a.memoizedProps;
        if (Ie(f2, d2) && a.ref === b2.ref)
          if (Ug = false, b2.pendingProps = d2 = f2, 0 !== (a.lanes & e2))
            0 !== (a.flags & 131072) && (Ug = true);
          else
            return b2.lanes = a.lanes, $i(a, b2, e2);
      }
      return dj(a, b2, c2, d2, e2);
    }
    function ej(a, b2, c2) {
      var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a ? a.memoizedState : null;
      if ("hidden" === d2.mode)
        if (0 === (b2.mode & 1))
          b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(fj, gj), gj |= c2;
        else {
          if (0 === (c2 & 1073741824))
            return a = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b2.updateQueue = null, G(fj, gj), gj |= a, null;
          b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
          d2 = null !== f2 ? f2.baseLanes : c2;
          G(fj, gj);
          gj |= d2;
        }
      else
        null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G(fj, gj), gj |= d2;
      Yi(a, b2, e2, c2);
      return b2.child;
    }
    function hj(a, b2) {
      var c2 = b2.ref;
      if (null === a && null !== c2 || null !== a && a.ref !== c2)
        b2.flags |= 512, b2.flags |= 2097152;
    }
    function dj(a, b2, c2, d2, e2) {
      var f2 = Zf(c2) ? Xf : H.current;
      f2 = Yf(b2, f2);
      Tg(b2, e2);
      c2 = Xh(a, b2, c2, d2, f2, e2);
      d2 = bi();
      if (null !== a && !Ug)
        return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e2, $i(a, b2, e2);
      I && d2 && vg(b2);
      b2.flags |= 1;
      Yi(a, b2, c2, e2);
      return b2.child;
    }
    function ij(a, b2, c2, d2, e2) {
      if (Zf(c2)) {
        var f2 = true;
        cg(b2);
      } else
        f2 = false;
      Tg(b2, e2);
      if (null === b2.stateNode)
        jj(a, b2), ph(b2, c2, d2), rh(b2, c2, d2, e2), d2 = true;
      else if (null === a) {
        var g2 = b2.stateNode, h2 = b2.memoizedProps;
        g2.props = h2;
        var k2 = g2.context, l2 = c2.contextType;
        "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c2) ? Xf : H.current, l2 = Yf(b2, l2));
        var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
        q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && qh(b2, g2, d2, l2);
        $g = false;
        var r2 = b2.memoizedState;
        g2.state = r2;
        gh(b2, d2, g2, e2);
        k2 = b2.memoizedState;
        h2 !== d2 || r2 !== k2 || Wf.current || $g ? ("function" === typeof m2 && (kh(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = $g || oh(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
      } else {
        g2 = b2.stateNode;
        bh(a, b2);
        h2 = b2.memoizedProps;
        l2 = b2.type === b2.elementType ? h2 : Lg(b2.type, h2);
        g2.props = l2;
        q2 = b2.pendingProps;
        r2 = g2.context;
        k2 = c2.contextType;
        "object" === typeof k2 && null !== k2 ? k2 = Vg(k2) : (k2 = Zf(c2) ? Xf : H.current, k2 = Yf(b2, k2));
        var y2 = c2.getDerivedStateFromProps;
        (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && qh(b2, g2, d2, k2);
        $g = false;
        r2 = b2.memoizedState;
        g2.state = r2;
        gh(b2, d2, g2, e2);
        var n2 = b2.memoizedState;
        h2 !== q2 || r2 !== n2 || Wf.current || $g ? ("function" === typeof y2 && (kh(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = $g || oh(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 1024), d2 = false);
      }
      return kj(a, b2, c2, d2, f2, e2);
    }
    function kj(a, b2, c2, d2, e2, f2) {
      hj(a, b2);
      var g2 = 0 !== (b2.flags & 128);
      if (!d2 && !g2)
        return e2 && dg(b2, c2, false), $i(a, b2, f2);
      d2 = b2.stateNode;
      Xi.current = b2;
      var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
      b2.flags |= 1;
      null !== a && g2 ? (b2.child = Bh(b2, a.child, null, f2), b2.child = Bh(b2, null, h2, f2)) : Yi(a, b2, h2, f2);
      b2.memoizedState = d2.state;
      e2 && dg(b2, c2, true);
      return b2.child;
    }
    function lj(a) {
      var b2 = a.stateNode;
      b2.pendingContext ? ag(a, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a, b2.context, false);
      Ih(a, b2.containerInfo);
    }
    function mj(a, b2, c2, d2, e2) {
      Ig();
      Jg(e2);
      b2.flags |= 256;
      Yi(a, b2, c2, d2);
      return b2.child;
    }
    var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
    function oj(a) {
      return { baseLanes: a, cachePool: null, transitions: null };
    }
    function pj(a, b2, c2) {
      var d2 = b2.pendingProps, e2 = M.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
      (h2 = g2) || (h2 = null !== a && null === a.memoizedState ? false : 0 !== (e2 & 2));
      if (h2)
        f2 = true, b2.flags &= -129;
      else if (null === a || null !== a.memoizedState)
        e2 |= 1;
      G(M, e2 & 1);
      if (null === a) {
        Eg(b2);
        a = b2.memoizedState;
        if (null !== a && (a = a.dehydrated, null !== a))
          return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
        g2 = d2.children;
        a = d2.fallback;
        return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = qj(g2, d2, 0, null), a = Ah(a, d2, c2, null), f2.return = b2, a.return = b2, f2.sibling = a, b2.child = f2, b2.child.memoizedState = oj(c2), b2.memoizedState = nj, a) : rj(b2, g2);
      }
      e2 = a.memoizedState;
      if (null !== e2 && (h2 = e2.dehydrated, null !== h2))
        return sj(a, b2, g2, d2, h2, e2, c2);
      if (f2) {
        f2 = d2.fallback;
        g2 = b2.mode;
        e2 = a.child;
        h2 = e2.sibling;
        var k2 = { mode: "hidden", children: d2.children };
        0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = wh(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
        null !== h2 ? f2 = wh(h2, f2) : (f2 = Ah(f2, g2, c2, null), f2.flags |= 2);
        f2.return = b2;
        d2.return = b2;
        d2.sibling = f2;
        b2.child = d2;
        d2 = f2;
        f2 = b2.child;
        g2 = a.child.memoizedState;
        g2 = null === g2 ? oj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
        f2.memoizedState = g2;
        f2.childLanes = a.childLanes & ~c2;
        b2.memoizedState = nj;
        return d2;
      }
      f2 = a.child;
      a = f2.sibling;
      d2 = wh(f2, { mode: "visible", children: d2.children });
      0 === (b2.mode & 1) && (d2.lanes = c2);
      d2.return = b2;
      d2.sibling = null;
      null !== a && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a], b2.flags |= 16) : c2.push(a));
      b2.child = d2;
      b2.memoizedState = null;
      return d2;
    }
    function rj(a, b2) {
      b2 = qj({ mode: "visible", children: b2 }, a.mode, 0, null);
      b2.return = a;
      return a.child = b2;
    }
    function tj(a, b2, c2, d2) {
      null !== d2 && Jg(d2);
      Bh(b2, a.child, null, c2);
      a = rj(b2, b2.pendingProps.children);
      a.flags |= 2;
      b2.memoizedState = null;
      return a;
    }
    function sj(a, b2, c2, d2, e2, f2, g2) {
      if (c2) {
        if (b2.flags & 256)
          return b2.flags &= -257, d2 = Li(Error(p$4(422))), tj(a, b2, g2, d2);
        if (null !== b2.memoizedState)
          return b2.child = a.child, b2.flags |= 128, null;
        f2 = d2.fallback;
        e2 = b2.mode;
        d2 = qj({ mode: "visible", children: d2.children }, e2, 0, null);
        f2 = Ah(f2, e2, g2, null);
        f2.flags |= 2;
        d2.return = b2;
        f2.return = b2;
        d2.sibling = f2;
        b2.child = d2;
        0 !== (b2.mode & 1) && Bh(b2, a.child, null, g2);
        b2.child.memoizedState = oj(g2);
        b2.memoizedState = nj;
        return f2;
      }
      if (0 === (b2.mode & 1))
        return tj(a, b2, g2, null);
      if ("$!" === e2.data) {
        d2 = e2.nextSibling && e2.nextSibling.dataset;
        if (d2)
          var h2 = d2.dgst;
        d2 = h2;
        f2 = Error(p$4(419));
        d2 = Li(f2, d2, void 0);
        return tj(a, b2, g2, d2);
      }
      h2 = 0 !== (g2 & a.childLanes);
      if (Ug || h2) {
        d2 = R;
        if (null !== d2) {
          switch (g2 & -g2) {
            case 4:
              e2 = 2;
              break;
            case 16:
              e2 = 8;
              break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              e2 = 32;
              break;
            case 536870912:
              e2 = 268435456;
              break;
            default:
              e2 = 0;
          }
          e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
          0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, Zg(a, e2), mh(d2, a, e2, -1));
        }
        uj();
        d2 = Li(Error(p$4(421)));
        return tj(a, b2, g2, d2);
      }
      if ("$?" === e2.data)
        return b2.flags |= 128, b2.child = a.child, b2 = vj.bind(null, a), e2._reactRetry = b2, null;
      a = f2.treeContext;
      yg = Lf(e2.nextSibling);
      xg = b2;
      I = true;
      zg = null;
      null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b2);
      b2 = rj(b2, d2.children);
      b2.flags |= 4096;
      return b2;
    }
    function wj(a, b2, c2) {
      a.lanes |= b2;
      var d2 = a.alternate;
      null !== d2 && (d2.lanes |= b2);
      Sg(a.return, b2, c2);
    }
    function xj(a, b2, c2, d2, e2) {
      var f2 = a.memoizedState;
      null === f2 ? a.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
    }
    function yj(a, b2, c2) {
      var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
      Yi(a, b2, d2.children, c2);
      d2 = M.current;
      if (0 !== (d2 & 2))
        d2 = d2 & 1 | 2, b2.flags |= 128;
      else {
        if (null !== a && 0 !== (a.flags & 128))
          a:
            for (a = b2.child; null !== a; ) {
              if (13 === a.tag)
                null !== a.memoizedState && wj(a, c2, b2);
              else if (19 === a.tag)
                wj(a, c2, b2);
              else if (null !== a.child) {
                a.child.return = a;
                a = a.child;
                continue;
              }
              if (a === b2)
                break a;
              for (; null === a.sibling; ) {
                if (null === a.return || a.return === b2)
                  break a;
                a = a.return;
              }
              a.sibling.return = a.return;
              a = a.sibling;
            }
        d2 &= 1;
      }
      G(M, d2);
      if (0 === (b2.mode & 1))
        b2.memoizedState = null;
      else
        switch (e2) {
          case "forwards":
            c2 = b2.child;
            for (e2 = null; null !== c2; )
              a = c2.alternate, null !== a && null === Mh(a) && (e2 = c2), c2 = c2.sibling;
            c2 = e2;
            null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
            xj(b2, false, e2, c2, f2);
            break;
          case "backwards":
            c2 = null;
            e2 = b2.child;
            for (b2.child = null; null !== e2; ) {
              a = e2.alternate;
              if (null !== a && null === Mh(a)) {
                b2.child = e2;
                break;
              }
              a = e2.sibling;
              e2.sibling = c2;
              c2 = e2;
              e2 = a;
            }
            xj(b2, true, c2, null, f2);
            break;
          case "together":
            xj(b2, false, null, null, void 0);
            break;
          default:
            b2.memoizedState = null;
        }
      return b2.child;
    }
    function jj(a, b2) {
      0 === (b2.mode & 1) && null !== a && (a.alternate = null, b2.alternate = null, b2.flags |= 2);
    }
    function $i(a, b2, c2) {
      null !== a && (b2.dependencies = a.dependencies);
      hh |= b2.lanes;
      if (0 === (c2 & b2.childLanes))
        return null;
      if (null !== a && b2.child !== a.child)
        throw Error(p$4(153));
      if (null !== b2.child) {
        a = b2.child;
        c2 = wh(a, a.pendingProps);
        b2.child = c2;
        for (c2.return = b2; null !== a.sibling; )
          a = a.sibling, c2 = c2.sibling = wh(a, a.pendingProps), c2.return = b2;
        c2.sibling = null;
      }
      return b2.child;
    }
    function zj(a, b2, c2) {
      switch (b2.tag) {
        case 3:
          lj(b2);
          Ig();
          break;
        case 5:
          Kh(b2);
          break;
        case 1:
          Zf(b2.type) && cg(b2);
          break;
        case 4:
          Ih(b2, b2.stateNode.containerInfo);
          break;
        case 10:
          var d2 = b2.type._context, e2 = b2.memoizedProps.value;
          G(Mg, d2._currentValue);
          d2._currentValue = e2;
          break;
        case 13:
          d2 = b2.memoizedState;
          if (null !== d2) {
            if (null !== d2.dehydrated)
              return G(M, M.current & 1), b2.flags |= 128, null;
            if (0 !== (c2 & b2.child.childLanes))
              return pj(a, b2, c2);
            G(M, M.current & 1);
            a = $i(a, b2, c2);
            return null !== a ? a.sibling : null;
          }
          G(M, M.current & 1);
          break;
        case 19:
          d2 = 0 !== (c2 & b2.childLanes);
          if (0 !== (a.flags & 128)) {
            if (d2)
              return yj(a, b2, c2);
            b2.flags |= 128;
          }
          e2 = b2.memoizedState;
          null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
          G(M, M.current);
          if (d2)
            break;
          else
            return null;
        case 22:
        case 23:
          return b2.lanes = 0, ej(a, b2, c2);
      }
      return $i(a, b2, c2);
    }
    var Aj, Bj, Cj, Dj;
    Aj = function(a, b2) {
      for (var c2 = b2.child; null !== c2; ) {
        if (5 === c2.tag || 6 === c2.tag)
          a.appendChild(c2.stateNode);
        else if (4 !== c2.tag && null !== c2.child) {
          c2.child.return = c2;
          c2 = c2.child;
          continue;
        }
        if (c2 === b2)
          break;
        for (; null === c2.sibling; ) {
          if (null === c2.return || c2.return === b2)
            return;
          c2 = c2.return;
        }
        c2.sibling.return = c2.return;
        c2 = c2.sibling;
      }
    };
    Bj = function() {
    };
    Cj = function(a, b2, c2, d2) {
      var e2 = a.memoizedProps;
      if (e2 !== d2) {
        a = b2.stateNode;
        Hh(Eh.current);
        var f2 = null;
        switch (c2) {
          case "input":
            e2 = Ya(a, e2);
            d2 = Ya(a, d2);
            f2 = [];
            break;
          case "select":
            e2 = A$1({}, e2, { value: void 0 });
            d2 = A$1({}, d2, { value: void 0 });
            f2 = [];
            break;
          case "textarea":
            e2 = gb(a, e2);
            d2 = gb(a, d2);
            f2 = [];
            break;
          default:
            "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a.onclick = Bf);
        }
        ub(c2, d2);
        var g2;
        c2 = null;
        for (l2 in e2)
          if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
            if ("style" === l2) {
              var h2 = e2[l2];
              for (g2 in h2)
                h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
            } else
              "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
        for (l2 in d2) {
          var k2 = d2[l2];
          h2 = null != e2 ? e2[l2] : void 0;
          if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
            if ("style" === l2)
              if (h2) {
                for (g2 in h2)
                  !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
                for (g2 in k2)
                  k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
              } else
                c2 || (f2 || (f2 = []), f2.push(
                  l2,
                  c2
                )), c2 = k2;
            else
              "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D("scroll", a), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
        }
        c2 && (f2 = f2 || []).push("style", c2);
        var l2 = f2;
        if (b2.updateQueue = l2)
          b2.flags |= 4;
      }
    };
    Dj = function(a, b2, c2, d2) {
      c2 !== d2 && (b2.flags |= 4);
    };
    function Ej(a, b2) {
      if (!I)
        switch (a.tailMode) {
          case "hidden":
            b2 = a.tail;
            for (var c2 = null; null !== b2; )
              null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
            null === c2 ? a.tail = null : c2.sibling = null;
            break;
          case "collapsed":
            c2 = a.tail;
            for (var d2 = null; null !== c2; )
              null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
            null === d2 ? b2 || null === a.tail ? a.tail = null : a.tail.sibling = null : d2.sibling = null;
        }
    }
    function S(a) {
      var b2 = null !== a.alternate && a.alternate.child === a.child, c2 = 0, d2 = 0;
      if (b2)
        for (var e2 = a.child; null !== e2; )
          c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a, e2 = e2.sibling;
      else
        for (e2 = a.child; null !== e2; )
          c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a, e2 = e2.sibling;
      a.subtreeFlags |= d2;
      a.childLanes = c2;
      return b2;
    }
    function Fj(a, b2, c2) {
      var d2 = b2.pendingProps;
      wg(b2);
      switch (b2.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return S(b2), null;
        case 1:
          return Zf(b2.type) && $f(), S(b2), null;
        case 3:
          d2 = b2.stateNode;
          Jh();
          E(Wf);
          E(H);
          Oh();
          d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
          if (null === a || null === a.child)
            Gg(b2) ? b2.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Gj(zg), zg = null));
          Bj(a, b2);
          S(b2);
          return null;
        case 5:
          Lh(b2);
          var e2 = Hh(Gh.current);
          c2 = b2.type;
          if (null !== a && null != b2.stateNode)
            Cj(a, b2, c2, d2, e2), a.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
          else {
            if (!d2) {
              if (null === b2.stateNode)
                throw Error(p$4(166));
              S(b2);
              return null;
            }
            a = Hh(Eh.current);
            if (Gg(b2)) {
              d2 = b2.stateNode;
              c2 = b2.type;
              var f2 = b2.memoizedProps;
              d2[Of] = b2;
              d2[Pf] = f2;
              a = 0 !== (b2.mode & 1);
              switch (c2) {
                case "dialog":
                  D("cancel", d2);
                  D("close", d2);
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D("load", d2);
                  break;
                case "video":
                case "audio":
                  for (e2 = 0; e2 < lf.length; e2++)
                    D(lf[e2], d2);
                  break;
                case "source":
                  D("error", d2);
                  break;
                case "img":
                case "image":
                case "link":
                  D(
                    "error",
                    d2
                  );
                  D("load", d2);
                  break;
                case "details":
                  D("toggle", d2);
                  break;
                case "input":
                  Za(d2, f2);
                  D("invalid", d2);
                  break;
                case "select":
                  d2._wrapperState = { wasMultiple: !!f2.multiple };
                  D("invalid", d2);
                  break;
                case "textarea":
                  hb(d2, f2), D("invalid", d2);
              }
              ub(c2, f2);
              e2 = null;
              for (var g2 in f2)
                if (f2.hasOwnProperty(g2)) {
                  var h2 = f2[g2];
                  "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                    d2.textContent,
                    h2,
                    a
                  ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D("scroll", d2);
                }
              switch (c2) {
                case "input":
                  Va(d2);
                  db(d2, f2, true);
                  break;
                case "textarea":
                  Va(d2);
                  jb(d2);
                  break;
                case "select":
                case "option":
                  break;
                default:
                  "function" === typeof f2.onClick && (d2.onclick = Bf);
              }
              d2 = e2;
              b2.updateQueue = d2;
              null !== d2 && (b2.flags |= 4);
            } else {
              g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
              "http://www.w3.org/1999/xhtml" === a && (a = kb(c2));
              "http://www.w3.org/1999/xhtml" === a ? "script" === c2 ? (a = g2.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d2.is ? a = g2.createElement(c2, { is: d2.is }) : (a = g2.createElement(c2), "select" === c2 && (g2 = a, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a = g2.createElementNS(a, c2);
              a[Of] = b2;
              a[Pf] = d2;
              Aj(a, b2, false, false);
              b2.stateNode = a;
              a: {
                g2 = vb(c2, d2);
                switch (c2) {
                  case "dialog":
                    D("cancel", a);
                    D("close", a);
                    e2 = d2;
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    D("load", a);
                    e2 = d2;
                    break;
                  case "video":
                  case "audio":
                    for (e2 = 0; e2 < lf.length; e2++)
                      D(lf[e2], a);
                    e2 = d2;
                    break;
                  case "source":
                    D("error", a);
                    e2 = d2;
                    break;
                  case "img":
                  case "image":
                  case "link":
                    D(
                      "error",
                      a
                    );
                    D("load", a);
                    e2 = d2;
                    break;
                  case "details":
                    D("toggle", a);
                    e2 = d2;
                    break;
                  case "input":
                    Za(a, d2);
                    e2 = Ya(a, d2);
                    D("invalid", a);
                    break;
                  case "option":
                    e2 = d2;
                    break;
                  case "select":
                    a._wrapperState = { wasMultiple: !!d2.multiple };
                    e2 = A$1({}, d2, { value: void 0 });
                    D("invalid", a);
                    break;
                  case "textarea":
                    hb(a, d2);
                    e2 = gb(a, d2);
                    D("invalid", a);
                    break;
                  default:
                    e2 = d2;
                }
                ub(c2, e2);
                h2 = e2;
                for (f2 in h2)
                  if (h2.hasOwnProperty(f2)) {
                    var k2 = h2[f2];
                    "style" === f2 ? sb(a, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a, k2) : "number" === typeof k2 && ob(a, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D("scroll", a) : null != k2 && ta(a, f2, k2, g2));
                  }
                switch (c2) {
                  case "input":
                    Va(a);
                    db(a, d2, false);
                    break;
                  case "textarea":
                    Va(a);
                    jb(a);
                    break;
                  case "option":
                    null != d2.value && a.setAttribute("value", "" + Sa(d2.value));
                    break;
                  case "select":
                    a.multiple = !!d2.multiple;
                    f2 = d2.value;
                    null != f2 ? fb(a, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                      a,
                      !!d2.multiple,
                      d2.defaultValue,
                      true
                    );
                    break;
                  default:
                    "function" === typeof e2.onClick && (a.onclick = Bf);
                }
                switch (c2) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    d2 = !!d2.autoFocus;
                    break a;
                  case "img":
                    d2 = true;
                    break a;
                  default:
                    d2 = false;
                }
              }
              d2 && (b2.flags |= 4);
            }
            null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
          }
          S(b2);
          return null;
        case 6:
          if (a && null != b2.stateNode)
            Dj(a, b2, a.memoizedProps, d2);
          else {
            if ("string" !== typeof d2 && null === b2.stateNode)
              throw Error(p$4(166));
            c2 = Hh(Gh.current);
            Hh(Eh.current);
            if (Gg(b2)) {
              d2 = b2.stateNode;
              c2 = b2.memoizedProps;
              d2[Of] = b2;
              if (f2 = d2.nodeValue !== c2) {
                if (a = xg, null !== a)
                  switch (a.tag) {
                    case 3:
                      Af(d2.nodeValue, c2, 0 !== (a.mode & 1));
                      break;
                    case 5:
                      true !== a.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a.mode & 1));
                  }
              }
              f2 && (b2.flags |= 4);
            } else
              d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
          }
          S(b2);
          return null;
        case 13:
          E(M);
          d2 = b2.memoizedState;
          if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
            if (I && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128))
              Hg(), Ig(), b2.flags |= 98560, f2 = false;
            else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
              if (null === a) {
                if (!f2)
                  throw Error(p$4(318));
                f2 = b2.memoizedState;
                f2 = null !== f2 ? f2.dehydrated : null;
                if (!f2)
                  throw Error(p$4(317));
                f2[Of] = b2;
              } else
                Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
              S(b2);
              f2 = false;
            } else
              null !== zg && (Gj(zg), zg = null), f2 = true;
            if (!f2)
              return b2.flags & 65536 ? b2 : null;
          }
          if (0 !== (b2.flags & 128))
            return b2.lanes = c2, b2;
          d2 = null !== d2;
          d2 !== (null !== a && null !== a.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a || 0 !== (M.current & 1) ? 0 === T && (T = 3) : uj()));
          null !== b2.updateQueue && (b2.flags |= 4);
          S(b2);
          return null;
        case 4:
          return Jh(), Bj(a, b2), null === a && sf(b2.stateNode.containerInfo), S(b2), null;
        case 10:
          return Rg(b2.type._context), S(b2), null;
        case 17:
          return Zf(b2.type) && $f(), S(b2), null;
        case 19:
          E(M);
          f2 = b2.memoizedState;
          if (null === f2)
            return S(b2), null;
          d2 = 0 !== (b2.flags & 128);
          g2 = f2.rendering;
          if (null === g2)
            if (d2)
              Ej(f2, false);
            else {
              if (0 !== T || null !== a && 0 !== (a.flags & 128))
                for (a = b2.child; null !== a; ) {
                  g2 = Mh(a);
                  if (null !== g2) {
                    b2.flags |= 128;
                    Ej(f2, false);
                    d2 = g2.updateQueue;
                    null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
                    b2.subtreeFlags = 0;
                    d2 = c2;
                    for (c2 = b2.child; null !== c2; )
                      f2 = c2, a = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a = g2.dependencies, f2.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c2 = c2.sibling;
                    G(M, M.current & 1 | 2);
                    return b2.child;
                  }
                  a = a.sibling;
                }
              null !== f2.tail && B() > Hj && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
            }
          else {
            if (!d2)
              if (a = Mh(g2), null !== a) {
                if (b2.flags |= 128, d2 = true, c2 = a.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Ej(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I)
                  return S(b2), null;
              } else
                2 * B() - f2.renderingStartTime > Hj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
            f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
          }
          if (null !== f2.tail)
            return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B(), b2.sibling = null, c2 = M.current, G(M, d2 ? c2 & 1 | 2 : c2 & 1), b2;
          S(b2);
          return null;
        case 22:
        case 23:
          return Ij(), d2 = null !== b2.memoizedState, null !== a && null !== a.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (gj & 1073741824) && (S(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S(b2), null;
        case 24:
          return null;
        case 25:
          return null;
      }
      throw Error(p$4(156, b2.tag));
    }
    function Jj(a, b2) {
      wg(b2);
      switch (b2.tag) {
        case 1:
          return Zf(b2.type) && $f(), a = b2.flags, a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
        case 3:
          return Jh(), E(Wf), E(H), Oh(), a = b2.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b2.flags = a & -65537 | 128, b2) : null;
        case 5:
          return Lh(b2), null;
        case 13:
          E(M);
          a = b2.memoizedState;
          if (null !== a && null !== a.dehydrated) {
            if (null === b2.alternate)
              throw Error(p$4(340));
            Ig();
          }
          a = b2.flags;
          return a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
        case 19:
          return E(M), null;
        case 4:
          return Jh(), null;
        case 10:
          return Rg(b2.type._context), null;
        case 22:
        case 23:
          return Ij(), null;
        case 24:
          return null;
        default:
          return null;
      }
    }
    var Kj = false, U = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
    function Mj(a, b2) {
      var c2 = a.ref;
      if (null !== c2)
        if ("function" === typeof c2)
          try {
            c2(null);
          } catch (d2) {
            W(a, b2, d2);
          }
        else
          c2.current = null;
    }
    function Nj(a, b2, c2) {
      try {
        c2();
      } catch (d2) {
        W(a, b2, d2);
      }
    }
    var Oj = false;
    function Pj(a, b2) {
      Cf = dd;
      a = Me();
      if (Ne(a)) {
        if ("selectionStart" in a)
          var c2 = { start: a.selectionStart, end: a.selectionEnd };
        else
          a: {
            c2 = (c2 = a.ownerDocument) && c2.defaultView || window;
            var d2 = c2.getSelection && c2.getSelection();
            if (d2 && 0 !== d2.rangeCount) {
              c2 = d2.anchorNode;
              var e2 = d2.anchorOffset, f2 = d2.focusNode;
              d2 = d2.focusOffset;
              try {
                c2.nodeType, f2.nodeType;
              } catch (F2) {
                c2 = null;
                break a;
              }
              var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a, r2 = null;
              b:
                for (; ; ) {
                  for (var y2; ; ) {
                    q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
                    q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
                    3 === q2.nodeType && (g2 += q2.nodeValue.length);
                    if (null === (y2 = q2.firstChild))
                      break;
                    r2 = q2;
                    q2 = y2;
                  }
                  for (; ; ) {
                    if (q2 === a)
                      break b;
                    r2 === c2 && ++l2 === e2 && (h2 = g2);
                    r2 === f2 && ++m2 === d2 && (k2 = g2);
                    if (null !== (y2 = q2.nextSibling))
                      break;
                    q2 = r2;
                    r2 = q2.parentNode;
                  }
                  q2 = y2;
                }
              c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
            } else
              c2 = null;
          }
        c2 = c2 || { start: 0, end: 0 };
      } else
        c2 = null;
      Df = { focusedElem: a, selectionRange: c2 };
      dd = false;
      for (V = b2; null !== V; )
        if (b2 = V, a = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a)
          a.return = b2, V = a;
        else
          for (; null !== V; ) {
            b2 = V;
            try {
              var n2 = b2.alternate;
              if (0 !== (b2.flags & 1024))
                switch (b2.tag) {
                  case 0:
                  case 11:
                  case 15:
                    break;
                  case 1:
                    if (null !== n2) {
                      var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Lg(b2.type, t2), J2);
                      x2.__reactInternalSnapshotBeforeUpdate = w2;
                    }
                    break;
                  case 3:
                    var u2 = b2.stateNode.containerInfo;
                    1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                    break;
                  case 5:
                  case 6:
                  case 4:
                  case 17:
                    break;
                  default:
                    throw Error(p$4(163));
                }
            } catch (F2) {
              W(b2, b2.return, F2);
            }
            a = b2.sibling;
            if (null !== a) {
              a.return = b2.return;
              V = a;
              break;
            }
            V = b2.return;
          }
      n2 = Oj;
      Oj = false;
      return n2;
    }
    function Qj(a, b2, c2) {
      var d2 = b2.updateQueue;
      d2 = null !== d2 ? d2.lastEffect : null;
      if (null !== d2) {
        var e2 = d2 = d2.next;
        do {
          if ((e2.tag & a) === a) {
            var f2 = e2.destroy;
            e2.destroy = void 0;
            void 0 !== f2 && Nj(b2, c2, f2);
          }
          e2 = e2.next;
        } while (e2 !== d2);
      }
    }
    function Rj(a, b2) {
      b2 = b2.updateQueue;
      b2 = null !== b2 ? b2.lastEffect : null;
      if (null !== b2) {
        var c2 = b2 = b2.next;
        do {
          if ((c2.tag & a) === a) {
            var d2 = c2.create;
            c2.destroy = d2();
          }
          c2 = c2.next;
        } while (c2 !== b2);
      }
    }
    function Sj(a) {
      var b2 = a.ref;
      if (null !== b2) {
        var c2 = a.stateNode;
        switch (a.tag) {
          case 5:
            a = c2;
            break;
          default:
            a = c2;
        }
        "function" === typeof b2 ? b2(a) : b2.current = a;
      }
    }
    function Tj(a) {
      var b2 = a.alternate;
      null !== b2 && (a.alternate = null, Tj(b2));
      a.child = null;
      a.deletions = null;
      a.sibling = null;
      5 === a.tag && (b2 = a.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
      a.stateNode = null;
      a.return = null;
      a.dependencies = null;
      a.memoizedProps = null;
      a.memoizedState = null;
      a.pendingProps = null;
      a.stateNode = null;
      a.updateQueue = null;
    }
    function Uj(a) {
      return 5 === a.tag || 3 === a.tag || 4 === a.tag;
    }
    function Vj(a) {
      a:
        for (; ; ) {
          for (; null === a.sibling; ) {
            if (null === a.return || Uj(a.return))
              return null;
            a = a.return;
          }
          a.sibling.return = a.return;
          for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
            if (a.flags & 2)
              continue a;
            if (null === a.child || 4 === a.tag)
              continue a;
            else
              a.child.return = a, a = a.child;
          }
          if (!(a.flags & 2))
            return a.stateNode;
        }
    }
    function Wj(a, b2, c2) {
      var d2 = a.tag;
      if (5 === d2 || 6 === d2)
        a = a.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a, b2) : c2.insertBefore(a, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a, c2)) : (b2 = c2, b2.appendChild(a)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
      else if (4 !== d2 && (a = a.child, null !== a))
        for (Wj(a, b2, c2), a = a.sibling; null !== a; )
          Wj(a, b2, c2), a = a.sibling;
    }
    function Xj(a, b2, c2) {
      var d2 = a.tag;
      if (5 === d2 || 6 === d2)
        a = a.stateNode, b2 ? c2.insertBefore(a, b2) : c2.appendChild(a);
      else if (4 !== d2 && (a = a.child, null !== a))
        for (Xj(a, b2, c2), a = a.sibling; null !== a; )
          Xj(a, b2, c2), a = a.sibling;
    }
    var X = null, Yj = false;
    function Zj(a, b2, c2) {
      for (c2 = c2.child; null !== c2; )
        ak(a, b2, c2), c2 = c2.sibling;
    }
    function ak(a, b2, c2) {
      if (lc && "function" === typeof lc.onCommitFiberUnmount)
        try {
          lc.onCommitFiberUnmount(kc, c2);
        } catch (h2) {
        }
      switch (c2.tag) {
        case 5:
          U || Mj(c2, b2);
        case 6:
          var d2 = X, e2 = Yj;
          X = null;
          Zj(a, b2, c2);
          X = d2;
          Yj = e2;
          null !== X && (Yj ? (a = X, c2 = c2.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c2) : a.removeChild(c2)) : X.removeChild(c2.stateNode));
          break;
        case 18:
          null !== X && (Yj ? (a = X, c2 = c2.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c2) : 1 === a.nodeType && Kf(a, c2), bd(a)) : Kf(X, c2.stateNode));
          break;
        case 4:
          d2 = X;
          e2 = Yj;
          X = c2.stateNode.containerInfo;
          Yj = true;
          Zj(a, b2, c2);
          X = d2;
          Yj = e2;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          if (!U && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
            e2 = d2 = d2.next;
            do {
              var f2 = e2, g2 = f2.destroy;
              f2 = f2.tag;
              void 0 !== g2 && (0 !== (f2 & 2) ? Nj(c2, b2, g2) : 0 !== (f2 & 4) && Nj(c2, b2, g2));
              e2 = e2.next;
            } while (e2 !== d2);
          }
          Zj(a, b2, c2);
          break;
        case 1:
          if (!U && (Mj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount))
            try {
              d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
            } catch (h2) {
              W(c2, b2, h2);
            }
          Zj(a, b2, c2);
          break;
        case 21:
          Zj(a, b2, c2);
          break;
        case 22:
          c2.mode & 1 ? (U = (d2 = U) || null !== c2.memoizedState, Zj(a, b2, c2), U = d2) : Zj(a, b2, c2);
          break;
        default:
          Zj(a, b2, c2);
      }
    }
    function bk(a) {
      var b2 = a.updateQueue;
      if (null !== b2) {
        a.updateQueue = null;
        var c2 = a.stateNode;
        null === c2 && (c2 = a.stateNode = new Lj());
        b2.forEach(function(b3) {
          var d2 = ck.bind(null, a, b3);
          c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
        });
      }
    }
    function dk(a, b2) {
      var c2 = b2.deletions;
      if (null !== c2)
        for (var d2 = 0; d2 < c2.length; d2++) {
          var e2 = c2[d2];
          try {
            var f2 = a, g2 = b2, h2 = g2;
            a:
              for (; null !== h2; ) {
                switch (h2.tag) {
                  case 5:
                    X = h2.stateNode;
                    Yj = false;
                    break a;
                  case 3:
                    X = h2.stateNode.containerInfo;
                    Yj = true;
                    break a;
                  case 4:
                    X = h2.stateNode.containerInfo;
                    Yj = true;
                    break a;
                }
                h2 = h2.return;
              }
            if (null === X)
              throw Error(p$4(160));
            ak(f2, g2, e2);
            X = null;
            Yj = false;
            var k2 = e2.alternate;
            null !== k2 && (k2.return = null);
            e2.return = null;
          } catch (l2) {
            W(e2, b2, l2);
          }
        }
      if (b2.subtreeFlags & 12854)
        for (b2 = b2.child; null !== b2; )
          ek(b2, a), b2 = b2.sibling;
    }
    function ek(a, b2) {
      var c2 = a.alternate, d2 = a.flags;
      switch (a.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          dk(b2, a);
          fk(a);
          if (d2 & 4) {
            try {
              Qj(3, a, a.return), Rj(3, a);
            } catch (t2) {
              W(a, a.return, t2);
            }
            try {
              Qj(5, a, a.return);
            } catch (t2) {
              W(a, a.return, t2);
            }
          }
          break;
        case 1:
          dk(b2, a);
          fk(a);
          d2 & 512 && null !== c2 && Mj(c2, c2.return);
          break;
        case 5:
          dk(b2, a);
          fk(a);
          d2 & 512 && null !== c2 && Mj(c2, c2.return);
          if (a.flags & 32) {
            var e2 = a.stateNode;
            try {
              ob(e2, "");
            } catch (t2) {
              W(a, a.return, t2);
            }
          }
          if (d2 & 4 && (e2 = a.stateNode, null != e2)) {
            var f2 = a.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a.type, k2 = a.updateQueue;
            a.updateQueue = null;
            if (null !== k2)
              try {
                "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
                vb(h2, g2);
                var l2 = vb(h2, f2);
                for (g2 = 0; g2 < k2.length; g2 += 2) {
                  var m2 = k2[g2], q2 = k2[g2 + 1];
                  "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
                }
                switch (h2) {
                  case "input":
                    bb(e2, f2);
                    break;
                  case "textarea":
                    ib(e2, f2);
                    break;
                  case "select":
                    var r2 = e2._wrapperState.wasMultiple;
                    e2._wrapperState.wasMultiple = !!f2.multiple;
                    var y2 = f2.value;
                    null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                      e2,
                      !!f2.multiple,
                      f2.defaultValue,
                      true
                    ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
                }
                e2[Pf] = f2;
              } catch (t2) {
                W(a, a.return, t2);
              }
          }
          break;
        case 6:
          dk(b2, a);
          fk(a);
          if (d2 & 4) {
            if (null === a.stateNode)
              throw Error(p$4(162));
            e2 = a.stateNode;
            f2 = a.memoizedProps;
            try {
              e2.nodeValue = f2;
            } catch (t2) {
              W(a, a.return, t2);
            }
          }
          break;
        case 3:
          dk(b2, a);
          fk(a);
          if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated)
            try {
              bd(b2.containerInfo);
            } catch (t2) {
              W(a, a.return, t2);
            }
          break;
        case 4:
          dk(b2, a);
          fk(a);
          break;
        case 13:
          dk(b2, a);
          fk(a);
          e2 = a.child;
          e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (gk = B()));
          d2 & 4 && bk(a);
          break;
        case 22:
          m2 = null !== c2 && null !== c2.memoizedState;
          a.mode & 1 ? (U = (l2 = U) || m2, dk(b2, a), U = l2) : dk(b2, a);
          fk(a);
          if (d2 & 8192) {
            l2 = null !== a.memoizedState;
            if ((a.stateNode.isHidden = l2) && !m2 && 0 !== (a.mode & 1))
              for (V = a, m2 = a.child; null !== m2; ) {
                for (q2 = V = m2; null !== V; ) {
                  r2 = V;
                  y2 = r2.child;
                  switch (r2.tag) {
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                      Qj(4, r2, r2.return);
                      break;
                    case 1:
                      Mj(r2, r2.return);
                      var n2 = r2.stateNode;
                      if ("function" === typeof n2.componentWillUnmount) {
                        d2 = r2;
                        c2 = r2.return;
                        try {
                          b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                        } catch (t2) {
                          W(d2, c2, t2);
                        }
                      }
                      break;
                    case 5:
                      Mj(r2, r2.return);
                      break;
                    case 22:
                      if (null !== r2.memoizedState) {
                        hk(q2);
                        continue;
                      }
                  }
                  null !== y2 ? (y2.return = r2, V = y2) : hk(q2);
                }
                m2 = m2.sibling;
              }
            a:
              for (m2 = null, q2 = a; ; ) {
                if (5 === q2.tag) {
                  if (null === m2) {
                    m2 = q2;
                    try {
                      e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                    } catch (t2) {
                      W(a, a.return, t2);
                    }
                  }
                } else if (6 === q2.tag) {
                  if (null === m2)
                    try {
                      q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                    } catch (t2) {
                      W(a, a.return, t2);
                    }
                } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a) && null !== q2.child) {
                  q2.child.return = q2;
                  q2 = q2.child;
                  continue;
                }
                if (q2 === a)
                  break a;
                for (; null === q2.sibling; ) {
                  if (null === q2.return || q2.return === a)
                    break a;
                  m2 === q2 && (m2 = null);
                  q2 = q2.return;
                }
                m2 === q2 && (m2 = null);
                q2.sibling.return = q2.return;
                q2 = q2.sibling;
              }
          }
          break;
        case 19:
          dk(b2, a);
          fk(a);
          d2 & 4 && bk(a);
          break;
        case 21:
          break;
        default:
          dk(
            b2,
            a
          ), fk(a);
      }
    }
    function fk(a) {
      var b2 = a.flags;
      if (b2 & 2) {
        try {
          a: {
            for (var c2 = a.return; null !== c2; ) {
              if (Uj(c2)) {
                var d2 = c2;
                break a;
              }
              c2 = c2.return;
            }
            throw Error(p$4(160));
          }
          switch (d2.tag) {
            case 5:
              var e2 = d2.stateNode;
              d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
              var f2 = Vj(a);
              Xj(a, f2, e2);
              break;
            case 3:
            case 4:
              var g2 = d2.stateNode.containerInfo, h2 = Vj(a);
              Wj(a, h2, g2);
              break;
            default:
              throw Error(p$4(161));
          }
        } catch (k2) {
          W(a, a.return, k2);
        }
        a.flags &= -3;
      }
      b2 & 4096 && (a.flags &= -4097);
    }
    function ik(a, b2, c2) {
      V = a;
      jk(a);
    }
    function jk(a, b2, c2) {
      for (var d2 = 0 !== (a.mode & 1); null !== V; ) {
        var e2 = V, f2 = e2.child;
        if (22 === e2.tag && d2) {
          var g2 = null !== e2.memoizedState || Kj;
          if (!g2) {
            var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U;
            h2 = Kj;
            var l2 = U;
            Kj = g2;
            if ((U = k2) && !l2)
              for (V = e2; null !== V; )
                g2 = V, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? kk(e2) : null !== k2 ? (k2.return = g2, V = k2) : kk(e2);
            for (; null !== f2; )
              V = f2, jk(f2), f2 = f2.sibling;
            V = e2;
            Kj = h2;
            U = l2;
          }
          lk(a);
        } else
          0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V = f2) : lk(a);
      }
    }
    function lk(a) {
      for (; null !== V; ) {
        var b2 = V;
        if (0 !== (b2.flags & 8772)) {
          var c2 = b2.alternate;
          try {
            if (0 !== (b2.flags & 8772))
              switch (b2.tag) {
                case 0:
                case 11:
                case 15:
                  U || Rj(5, b2);
                  break;
                case 1:
                  var d2 = b2.stateNode;
                  if (b2.flags & 4 && !U)
                    if (null === c2)
                      d2.componentDidMount();
                    else {
                      var e2 = b2.elementType === b2.type ? c2.memoizedProps : Lg(b2.type, c2.memoizedProps);
                      d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                    }
                  var f2 = b2.updateQueue;
                  null !== f2 && ih(b2, f2, d2);
                  break;
                case 3:
                  var g2 = b2.updateQueue;
                  if (null !== g2) {
                    c2 = null;
                    if (null !== b2.child)
                      switch (b2.child.tag) {
                        case 5:
                          c2 = b2.child.stateNode;
                          break;
                        case 1:
                          c2 = b2.child.stateNode;
                      }
                    ih(b2, g2, c2);
                  }
                  break;
                case 5:
                  var h2 = b2.stateNode;
                  if (null === c2 && b2.flags & 4) {
                    c2 = h2;
                    var k2 = b2.memoizedProps;
                    switch (b2.type) {
                      case "button":
                      case "input":
                      case "select":
                      case "textarea":
                        k2.autoFocus && c2.focus();
                        break;
                      case "img":
                        k2.src && (c2.src = k2.src);
                    }
                  }
                  break;
                case 6:
                  break;
                case 4:
                  break;
                case 12:
                  break;
                case 13:
                  if (null === b2.memoizedState) {
                    var l2 = b2.alternate;
                    if (null !== l2) {
                      var m2 = l2.memoizedState;
                      if (null !== m2) {
                        var q2 = m2.dehydrated;
                        null !== q2 && bd(q2);
                      }
                    }
                  }
                  break;
                case 19:
                case 17:
                case 21:
                case 22:
                case 23:
                case 25:
                  break;
                default:
                  throw Error(p$4(163));
              }
            U || b2.flags & 512 && Sj(b2);
          } catch (r2) {
            W(b2, b2.return, r2);
          }
        }
        if (b2 === a) {
          V = null;
          break;
        }
        c2 = b2.sibling;
        if (null !== c2) {
          c2.return = b2.return;
          V = c2;
          break;
        }
        V = b2.return;
      }
    }
    function hk(a) {
      for (; null !== V; ) {
        var b2 = V;
        if (b2 === a) {
          V = null;
          break;
        }
        var c2 = b2.sibling;
        if (null !== c2) {
          c2.return = b2.return;
          V = c2;
          break;
        }
        V = b2.return;
      }
    }
    function kk(a) {
      for (; null !== V; ) {
        var b2 = V;
        try {
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              var c2 = b2.return;
              try {
                Rj(4, b2);
              } catch (k2) {
                W(b2, c2, k2);
              }
              break;
            case 1:
              var d2 = b2.stateNode;
              if ("function" === typeof d2.componentDidMount) {
                var e2 = b2.return;
                try {
                  d2.componentDidMount();
                } catch (k2) {
                  W(b2, e2, k2);
                }
              }
              var f2 = b2.return;
              try {
                Sj(b2);
              } catch (k2) {
                W(b2, f2, k2);
              }
              break;
            case 5:
              var g2 = b2.return;
              try {
                Sj(b2);
              } catch (k2) {
                W(b2, g2, k2);
              }
          }
        } catch (k2) {
          W(b2, b2.return, k2);
        }
        if (b2 === a) {
          V = null;
          break;
        }
        var h2 = b2.sibling;
        if (null !== h2) {
          h2.return = b2.return;
          V = h2;
          break;
        }
        V = b2.return;
      }
    }
    var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K = 0, R = null, Y = null, Z = 0, gj = 0, fj = Uf(0), T = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = Infinity, vk = null, Pi = false, Qi = null, Si = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
    function L() {
      return 0 !== (K & 6) ? B() : -1 !== Bk ? Bk : Bk = B();
    }
    function lh(a) {
      if (0 === (a.mode & 1))
        return 1;
      if (0 !== (K & 2) && 0 !== Z)
        return Z & -Z;
      if (null !== Kg.transition)
        return 0 === Ck && (Ck = yc()), Ck;
      a = C;
      if (0 !== a)
        return a;
      a = window.event;
      a = void 0 === a ? 16 : jd(a.type);
      return a;
    }
    function mh(a, b2, c2, d2) {
      if (50 < zk)
        throw zk = 0, Ak = null, Error(p$4(185));
      Ac(a, c2, d2);
      if (0 === (K & 2) || a !== R)
        a === R && (0 === (K & 2) && (rk |= c2), 4 === T && Dk(a, Z)), Ek(a, d2), 1 === c2 && 0 === K && 0 === (b2.mode & 1) && (Hj = B() + 500, fg && jg());
    }
    function Ek(a, b2) {
      var c2 = a.callbackNode;
      wc(a, b2);
      var d2 = uc(a, a === R ? Z : 0);
      if (0 === d2)
        null !== c2 && bc(c2), a.callbackNode = null, a.callbackPriority = 0;
      else if (b2 = d2 & -d2, a.callbackPriority !== b2) {
        null != c2 && bc(c2);
        if (1 === b2)
          0 === a.tag ? ig(Fk.bind(null, a)) : hg(Fk.bind(null, a)), Jf(function() {
            0 === (K & 6) && jg();
          }), c2 = null;
        else {
          switch (Dc(d2)) {
            case 1:
              c2 = fc;
              break;
            case 4:
              c2 = gc;
              break;
            case 16:
              c2 = hc;
              break;
            case 536870912:
              c2 = jc;
              break;
            default:
              c2 = hc;
          }
          c2 = Gk(c2, Hk.bind(null, a));
        }
        a.callbackPriority = b2;
        a.callbackNode = c2;
      }
    }
    function Hk(a, b2) {
      Bk = -1;
      Ck = 0;
      if (0 !== (K & 6))
        throw Error(p$4(327));
      var c2 = a.callbackNode;
      if (Ik() && a.callbackNode !== c2)
        return null;
      var d2 = uc(a, a === R ? Z : 0);
      if (0 === d2)
        return null;
      if (0 !== (d2 & 30) || 0 !== (d2 & a.expiredLanes) || b2)
        b2 = Jk(a, d2);
      else {
        b2 = d2;
        var e2 = K;
        K |= 2;
        var f2 = Kk();
        if (R !== a || Z !== b2)
          vk = null, Hj = B() + 500, Lk(a, b2);
        do
          try {
            Mk();
            break;
          } catch (h2) {
            Nk(a, h2);
          }
        while (1);
        Qg();
        nk.current = f2;
        K = e2;
        null !== Y ? b2 = 0 : (R = null, Z = 0, b2 = T);
      }
      if (0 !== b2) {
        2 === b2 && (e2 = xc(a), 0 !== e2 && (d2 = e2, b2 = Ok(a, e2)));
        if (1 === b2)
          throw c2 = qk, Lk(a, 0), Dk(a, d2), Ek(a, B()), c2;
        if (6 === b2)
          Dk(a, d2);
        else {
          e2 = a.current.alternate;
          if (0 === (d2 & 30) && !Pk(e2) && (b2 = Jk(a, d2), 2 === b2 && (f2 = xc(a), 0 !== f2 && (d2 = f2, b2 = Ok(a, f2))), 1 === b2))
            throw c2 = qk, Lk(a, 0), Dk(a, d2), Ek(a, B()), c2;
          a.finishedWork = e2;
          a.finishedLanes = d2;
          switch (b2) {
            case 0:
            case 1:
              throw Error(p$4(345));
            case 2:
              Qk(a, uk, vk);
              break;
            case 3:
              Dk(a, d2);
              if ((d2 & 130023424) === d2 && (b2 = gk + 500 - B(), 10 < b2)) {
                if (0 !== uc(a, 0))
                  break;
                e2 = a.suspendedLanes;
                if ((e2 & d2) !== d2) {
                  L();
                  a.pingedLanes |= a.suspendedLanes & e2;
                  break;
                }
                a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), b2);
                break;
              }
              Qk(a, uk, vk);
              break;
            case 4:
              Dk(a, d2);
              if ((d2 & 4194240) === d2)
                break;
              b2 = a.eventTimes;
              for (e2 = -1; 0 < d2; ) {
                var g2 = 31 - oc(d2);
                f2 = 1 << g2;
                g2 = b2[g2];
                g2 > e2 && (e2 = g2);
                d2 &= ~f2;
              }
              d2 = e2;
              d2 = B() - d2;
              d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * mk(d2 / 1960)) - d2;
              if (10 < d2) {
                a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), d2);
                break;
              }
              Qk(a, uk, vk);
              break;
            case 5:
              Qk(a, uk, vk);
              break;
            default:
              throw Error(p$4(329));
          }
        }
      }
      Ek(a, B());
      return a.callbackNode === c2 ? Hk.bind(null, a) : null;
    }
    function Ok(a, b2) {
      var c2 = tk;
      a.current.memoizedState.isDehydrated && (Lk(a, b2).flags |= 256);
      a = Jk(a, b2);
      2 !== a && (b2 = uk, uk = c2, null !== b2 && Gj(b2));
      return a;
    }
    function Gj(a) {
      null === uk ? uk = a : uk.push.apply(uk, a);
    }
    function Pk(a) {
      for (var b2 = a; ; ) {
        if (b2.flags & 16384) {
          var c2 = b2.updateQueue;
          if (null !== c2 && (c2 = c2.stores, null !== c2))
            for (var d2 = 0; d2 < c2.length; d2++) {
              var e2 = c2[d2], f2 = e2.getSnapshot;
              e2 = e2.value;
              try {
                if (!He(f2(), e2))
                  return false;
              } catch (g2) {
                return false;
              }
            }
        }
        c2 = b2.child;
        if (b2.subtreeFlags & 16384 && null !== c2)
          c2.return = b2, b2 = c2;
        else {
          if (b2 === a)
            break;
          for (; null === b2.sibling; ) {
            if (null === b2.return || b2.return === a)
              return true;
            b2 = b2.return;
          }
          b2.sibling.return = b2.return;
          b2 = b2.sibling;
        }
      }
      return true;
    }
    function Dk(a, b2) {
      b2 &= ~sk;
      b2 &= ~rk;
      a.suspendedLanes |= b2;
      a.pingedLanes &= ~b2;
      for (a = a.expirationTimes; 0 < b2; ) {
        var c2 = 31 - oc(b2), d2 = 1 << c2;
        a[c2] = -1;
        b2 &= ~d2;
      }
    }
    function Fk(a) {
      if (0 !== (K & 6))
        throw Error(p$4(327));
      Ik();
      var b2 = uc(a, 0);
      if (0 === (b2 & 1))
        return Ek(a, B()), null;
      var c2 = Jk(a, b2);
      if (0 !== a.tag && 2 === c2) {
        var d2 = xc(a);
        0 !== d2 && (b2 = d2, c2 = Ok(a, d2));
      }
      if (1 === c2)
        throw c2 = qk, Lk(a, 0), Dk(a, b2), Ek(a, B()), c2;
      if (6 === c2)
        throw Error(p$4(345));
      a.finishedWork = a.current.alternate;
      a.finishedLanes = b2;
      Qk(a, uk, vk);
      Ek(a, B());
      return null;
    }
    function Rk(a, b2) {
      var c2 = K;
      K |= 1;
      try {
        return a(b2);
      } finally {
        K = c2, 0 === K && (Hj = B() + 500, fg && jg());
      }
    }
    function Sk(a) {
      null !== xk && 0 === xk.tag && 0 === (K & 6) && Ik();
      var b2 = K;
      K |= 1;
      var c2 = pk.transition, d2 = C;
      try {
        if (pk.transition = null, C = 1, a)
          return a();
      } finally {
        C = d2, pk.transition = c2, K = b2, 0 === (K & 6) && jg();
      }
    }
    function Ij() {
      gj = fj.current;
      E(fj);
    }
    function Lk(a, b2) {
      a.finishedWork = null;
      a.finishedLanes = 0;
      var c2 = a.timeoutHandle;
      -1 !== c2 && (a.timeoutHandle = -1, Gf(c2));
      if (null !== Y)
        for (c2 = Y.return; null !== c2; ) {
          var d2 = c2;
          wg(d2);
          switch (d2.tag) {
            case 1:
              d2 = d2.type.childContextTypes;
              null !== d2 && void 0 !== d2 && $f();
              break;
            case 3:
              Jh();
              E(Wf);
              E(H);
              Oh();
              break;
            case 5:
              Lh(d2);
              break;
            case 4:
              Jh();
              break;
            case 13:
              E(M);
              break;
            case 19:
              E(M);
              break;
            case 10:
              Rg(d2.type._context);
              break;
            case 22:
            case 23:
              Ij();
          }
          c2 = c2.return;
        }
      R = a;
      Y = a = wh(a.current, null);
      Z = gj = b2;
      T = 0;
      qk = null;
      sk = rk = hh = 0;
      uk = tk = null;
      if (null !== Wg) {
        for (b2 = 0; b2 < Wg.length; b2++)
          if (c2 = Wg[b2], d2 = c2.interleaved, null !== d2) {
            c2.interleaved = null;
            var e2 = d2.next, f2 = c2.pending;
            if (null !== f2) {
              var g2 = f2.next;
              f2.next = e2;
              d2.next = g2;
            }
            c2.pending = d2;
          }
        Wg = null;
      }
      return a;
    }
    function Nk(a, b2) {
      do {
        var c2 = Y;
        try {
          Qg();
          Ph.current = ai;
          if (Sh) {
            for (var d2 = N.memoizedState; null !== d2; ) {
              var e2 = d2.queue;
              null !== e2 && (e2.pending = null);
              d2 = d2.next;
            }
            Sh = false;
          }
          Rh = 0;
          P = O = N = null;
          Th = false;
          Uh = 0;
          ok.current = null;
          if (null === c2 || null === c2.return) {
            T = 1;
            qk = b2;
            Y = null;
            break;
          }
          a: {
            var f2 = a, g2 = c2.return, h2 = c2, k2 = b2;
            b2 = Z;
            h2.flags |= 32768;
            if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
              var l2 = k2, m2 = h2, q2 = m2.tag;
              if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
                var r2 = m2.alternate;
                r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
              }
              var y2 = Vi(g2);
              if (null !== y2) {
                y2.flags &= -257;
                Wi(y2, g2, h2, f2, b2);
                y2.mode & 1 && Ti(f2, l2, b2);
                b2 = y2;
                k2 = l2;
                var n2 = b2.updateQueue;
                if (null === n2) {
                  var t2 = /* @__PURE__ */ new Set();
                  t2.add(k2);
                  b2.updateQueue = t2;
                } else
                  n2.add(k2);
                break a;
              } else {
                if (0 === (b2 & 1)) {
                  Ti(f2, l2, b2);
                  uj();
                  break a;
                }
                k2 = Error(p$4(426));
              }
            } else if (I && h2.mode & 1) {
              var J2 = Vi(g2);
              if (null !== J2) {
                0 === (J2.flags & 65536) && (J2.flags |= 256);
                Wi(J2, g2, h2, f2, b2);
                Jg(Ki(k2, h2));
                break a;
              }
            }
            f2 = k2 = Ki(k2, h2);
            4 !== T && (T = 2);
            null === tk ? tk = [f2] : tk.push(f2);
            f2 = g2;
            do {
              switch (f2.tag) {
                case 3:
                  f2.flags |= 65536;
                  b2 &= -b2;
                  f2.lanes |= b2;
                  var x2 = Oi(f2, k2, b2);
                  fh(f2, x2);
                  break a;
                case 1:
                  h2 = k2;
                  var w2 = f2.type, u2 = f2.stateNode;
                  if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Si || !Si.has(u2)))) {
                    f2.flags |= 65536;
                    b2 &= -b2;
                    f2.lanes |= b2;
                    var F2 = Ri(f2, h2, b2);
                    fh(f2, F2);
                    break a;
                  }
              }
              f2 = f2.return;
            } while (null !== f2);
          }
          Tk(c2);
        } catch (na) {
          b2 = na;
          Y === c2 && null !== c2 && (Y = c2 = c2.return);
          continue;
        }
        break;
      } while (1);
    }
    function Kk() {
      var a = nk.current;
      nk.current = ai;
      return null === a ? ai : a;
    }
    function uj() {
      if (0 === T || 3 === T || 2 === T)
        T = 4;
      null === R || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R, Z);
    }
    function Jk(a, b2) {
      var c2 = K;
      K |= 2;
      var d2 = Kk();
      if (R !== a || Z !== b2)
        vk = null, Lk(a, b2);
      do
        try {
          Uk();
          break;
        } catch (e2) {
          Nk(a, e2);
        }
      while (1);
      Qg();
      K = c2;
      nk.current = d2;
      if (null !== Y)
        throw Error(p$4(261));
      R = null;
      Z = 0;
      return T;
    }
    function Uk() {
      for (; null !== Y; )
        Vk(Y);
    }
    function Mk() {
      for (; null !== Y && !cc(); )
        Vk(Y);
    }
    function Vk(a) {
      var b2 = Wk(a.alternate, a, gj);
      a.memoizedProps = a.pendingProps;
      null === b2 ? Tk(a) : Y = b2;
      ok.current = null;
    }
    function Tk(a) {
      var b2 = a;
      do {
        var c2 = b2.alternate;
        a = b2.return;
        if (0 === (b2.flags & 32768)) {
          if (c2 = Fj(c2, b2, gj), null !== c2) {
            Y = c2;
            return;
          }
        } else {
          c2 = Jj(c2, b2);
          if (null !== c2) {
            c2.flags &= 32767;
            Y = c2;
            return;
          }
          if (null !== a)
            a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
          else {
            T = 6;
            Y = null;
            return;
          }
        }
        b2 = b2.sibling;
        if (null !== b2) {
          Y = b2;
          return;
        }
        Y = b2 = a;
      } while (null !== b2);
      0 === T && (T = 5);
    }
    function Qk(a, b2, c2) {
      var d2 = C, e2 = pk.transition;
      try {
        pk.transition = null, C = 1, Xk(a, b2, c2, d2);
      } finally {
        pk.transition = e2, C = d2;
      }
      return null;
    }
    function Xk(a, b2, c2, d2) {
      do
        Ik();
      while (null !== xk);
      if (0 !== (K & 6))
        throw Error(p$4(327));
      c2 = a.finishedWork;
      var e2 = a.finishedLanes;
      if (null === c2)
        return null;
      a.finishedWork = null;
      a.finishedLanes = 0;
      if (c2 === a.current)
        throw Error(p$4(177));
      a.callbackNode = null;
      a.callbackPriority = 0;
      var f2 = c2.lanes | c2.childLanes;
      Bc(a, f2);
      a === R && (Y = R = null, Z = 0);
      0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || wk || (wk = true, Gk(hc, function() {
        Ik();
        return null;
      }));
      f2 = 0 !== (c2.flags & 15990);
      if (0 !== (c2.subtreeFlags & 15990) || f2) {
        f2 = pk.transition;
        pk.transition = null;
        var g2 = C;
        C = 1;
        var h2 = K;
        K |= 4;
        ok.current = null;
        Pj(a, c2);
        ek(c2, a);
        Oe(Df);
        dd = !!Cf;
        Df = Cf = null;
        a.current = c2;
        ik(c2);
        dc();
        K = h2;
        C = g2;
        pk.transition = f2;
      } else
        a.current = c2;
      wk && (wk = false, xk = a, yk = e2);
      f2 = a.pendingLanes;
      0 === f2 && (Si = null);
      mc(c2.stateNode);
      Ek(a, B());
      if (null !== b2)
        for (d2 = a.onRecoverableError, c2 = 0; c2 < b2.length; c2++)
          e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
      if (Pi)
        throw Pi = false, a = Qi, Qi = null, a;
      0 !== (yk & 1) && 0 !== a.tag && Ik();
      f2 = a.pendingLanes;
      0 !== (f2 & 1) ? a === Ak ? zk++ : (zk = 0, Ak = a) : zk = 0;
      jg();
      return null;
    }
    function Ik() {
      if (null !== xk) {
        var a = Dc(yk), b2 = pk.transition, c2 = C;
        try {
          pk.transition = null;
          C = 16 > a ? 16 : a;
          if (null === xk)
            var d2 = false;
          else {
            a = xk;
            xk = null;
            yk = 0;
            if (0 !== (K & 6))
              throw Error(p$4(331));
            var e2 = K;
            K |= 4;
            for (V = a.current; null !== V; ) {
              var f2 = V, g2 = f2.child;
              if (0 !== (V.flags & 16)) {
                var h2 = f2.deletions;
                if (null !== h2) {
                  for (var k2 = 0; k2 < h2.length; k2++) {
                    var l2 = h2[k2];
                    for (V = l2; null !== V; ) {
                      var m2 = V;
                      switch (m2.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Qj(8, m2, f2);
                      }
                      var q2 = m2.child;
                      if (null !== q2)
                        q2.return = m2, V = q2;
                      else
                        for (; null !== V; ) {
                          m2 = V;
                          var r2 = m2.sibling, y2 = m2.return;
                          Tj(m2);
                          if (m2 === l2) {
                            V = null;
                            break;
                          }
                          if (null !== r2) {
                            r2.return = y2;
                            V = r2;
                            break;
                          }
                          V = y2;
                        }
                    }
                  }
                  var n2 = f2.alternate;
                  if (null !== n2) {
                    var t2 = n2.child;
                    if (null !== t2) {
                      n2.child = null;
                      do {
                        var J2 = t2.sibling;
                        t2.sibling = null;
                        t2 = J2;
                      } while (null !== t2);
                    }
                  }
                  V = f2;
                }
              }
              if (0 !== (f2.subtreeFlags & 2064) && null !== g2)
                g2.return = f2, V = g2;
              else
                b:
                  for (; null !== V; ) {
                    f2 = V;
                    if (0 !== (f2.flags & 2048))
                      switch (f2.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Qj(9, f2, f2.return);
                      }
                    var x2 = f2.sibling;
                    if (null !== x2) {
                      x2.return = f2.return;
                      V = x2;
                      break b;
                    }
                    V = f2.return;
                  }
            }
            var w2 = a.current;
            for (V = w2; null !== V; ) {
              g2 = V;
              var u2 = g2.child;
              if (0 !== (g2.subtreeFlags & 2064) && null !== u2)
                u2.return = g2, V = u2;
              else
                b:
                  for (g2 = w2; null !== V; ) {
                    h2 = V;
                    if (0 !== (h2.flags & 2048))
                      try {
                        switch (h2.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Rj(9, h2);
                        }
                      } catch (na) {
                        W(h2, h2.return, na);
                      }
                    if (h2 === g2) {
                      V = null;
                      break b;
                    }
                    var F2 = h2.sibling;
                    if (null !== F2) {
                      F2.return = h2.return;
                      V = F2;
                      break b;
                    }
                    V = h2.return;
                  }
            }
            K = e2;
            jg();
            if (lc && "function" === typeof lc.onPostCommitFiberRoot)
              try {
                lc.onPostCommitFiberRoot(kc, a);
              } catch (na) {
              }
            d2 = true;
          }
          return d2;
        } finally {
          C = c2, pk.transition = b2;
        }
      }
      return false;
    }
    function Yk(a, b2, c2) {
      b2 = Ki(c2, b2);
      b2 = Oi(a, b2, 1);
      a = dh(a, b2, 1);
      b2 = L();
      null !== a && (Ac(a, 1, b2), Ek(a, b2));
    }
    function W(a, b2, c2) {
      if (3 === a.tag)
        Yk(a, a, c2);
      else
        for (; null !== b2; ) {
          if (3 === b2.tag) {
            Yk(b2, a, c2);
            break;
          } else if (1 === b2.tag) {
            var d2 = b2.stateNode;
            if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Si || !Si.has(d2))) {
              a = Ki(c2, a);
              a = Ri(b2, a, 1);
              b2 = dh(b2, a, 1);
              a = L();
              null !== b2 && (Ac(b2, 1, a), Ek(b2, a));
              break;
            }
          }
          b2 = b2.return;
        }
    }
    function Ui(a, b2, c2) {
      var d2 = a.pingCache;
      null !== d2 && d2.delete(b2);
      b2 = L();
      a.pingedLanes |= a.suspendedLanes & c2;
      R === a && (Z & c2) === c2 && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - gk ? Lk(a, 0) : sk |= c2);
      Ek(a, b2);
    }
    function Zk(a, b2) {
      0 === b2 && (0 === (a.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
      var c2 = L();
      a = Zg(a, b2);
      null !== a && (Ac(a, b2, c2), Ek(a, c2));
    }
    function vj(a) {
      var b2 = a.memoizedState, c2 = 0;
      null !== b2 && (c2 = b2.retryLane);
      Zk(a, c2);
    }
    function ck(a, b2) {
      var c2 = 0;
      switch (a.tag) {
        case 13:
          var d2 = a.stateNode;
          var e2 = a.memoizedState;
          null !== e2 && (c2 = e2.retryLane);
          break;
        case 19:
          d2 = a.stateNode;
          break;
        default:
          throw Error(p$4(314));
      }
      null !== d2 && d2.delete(b2);
      Zk(a, c2);
    }
    var Wk;
    Wk = function(a, b2, c2) {
      if (null !== a)
        if (a.memoizedProps !== b2.pendingProps || Wf.current)
          Ug = true;
        else {
          if (0 === (a.lanes & c2) && 0 === (b2.flags & 128))
            return Ug = false, zj(a, b2, c2);
          Ug = 0 !== (a.flags & 131072) ? true : false;
        }
      else
        Ug = false, I && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
      b2.lanes = 0;
      switch (b2.tag) {
        case 2:
          var d2 = b2.type;
          jj(a, b2);
          a = b2.pendingProps;
          var e2 = Yf(b2, H.current);
          Tg(b2, c2);
          e2 = Xh(null, b2, d2, a, e2, c2);
          var f2 = bi();
          b2.flags |= 1;
          "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, ah(b2), e2.updater = nh, b2.stateNode = e2, e2._reactInternals = b2, rh(b2, d2, a, c2), b2 = kj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I && f2 && vg(b2), Yi(null, b2, e2, c2), b2 = b2.child);
          return b2;
        case 16:
          d2 = b2.elementType;
          a: {
            jj(a, b2);
            a = b2.pendingProps;
            e2 = d2._init;
            d2 = e2(d2._payload);
            b2.type = d2;
            e2 = b2.tag = $k(d2);
            a = Lg(d2, a);
            switch (e2) {
              case 0:
                b2 = dj(null, b2, d2, a, c2);
                break a;
              case 1:
                b2 = ij(null, b2, d2, a, c2);
                break a;
              case 11:
                b2 = Zi(null, b2, d2, a, c2);
                break a;
              case 14:
                b2 = aj(null, b2, d2, Lg(d2.type, a), c2);
                break a;
            }
            throw Error(p$4(
              306,
              d2,
              ""
            ));
          }
          return b2;
        case 0:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), dj(a, b2, d2, e2, c2);
        case 1:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), ij(a, b2, d2, e2, c2);
        case 3:
          a: {
            lj(b2);
            if (null === a)
              throw Error(p$4(387));
            d2 = b2.pendingProps;
            f2 = b2.memoizedState;
            e2 = f2.element;
            bh(a, b2);
            gh(b2, d2, null, c2);
            var g2 = b2.memoizedState;
            d2 = g2.element;
            if (f2.isDehydrated)
              if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
                e2 = Ki(Error(p$4(423)), b2);
                b2 = mj(a, b2, d2, c2, e2);
                break a;
              } else if (d2 !== e2) {
                e2 = Ki(Error(p$4(424)), b2);
                b2 = mj(a, b2, d2, c2, e2);
                break a;
              } else
                for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I = true, zg = null, c2 = Ch(b2, null, d2, c2), b2.child = c2; c2; )
                  c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
            else {
              Ig();
              if (d2 === e2) {
                b2 = $i(a, b2, c2);
                break a;
              }
              Yi(a, b2, d2, c2);
            }
            b2 = b2.child;
          }
          return b2;
        case 5:
          return Kh(b2), null === a && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a ? a.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), hj(a, b2), Yi(a, b2, g2, c2), b2.child;
        case 6:
          return null === a && Eg(b2), null;
        case 13:
          return pj(a, b2, c2);
        case 4:
          return Ih(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a ? b2.child = Bh(b2, null, d2, c2) : Yi(a, b2, d2, c2), b2.child;
        case 11:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), Zi(a, b2, d2, e2, c2);
        case 7:
          return Yi(a, b2, b2.pendingProps, c2), b2.child;
        case 8:
          return Yi(a, b2, b2.pendingProps.children, c2), b2.child;
        case 12:
          return Yi(a, b2, b2.pendingProps.children, c2), b2.child;
        case 10:
          a: {
            d2 = b2.type._context;
            e2 = b2.pendingProps;
            f2 = b2.memoizedProps;
            g2 = e2.value;
            G(Mg, d2._currentValue);
            d2._currentValue = g2;
            if (null !== f2)
              if (He(f2.value, g2)) {
                if (f2.children === e2.children && !Wf.current) {
                  b2 = $i(a, b2, c2);
                  break a;
                }
              } else
                for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
                  var h2 = f2.dependencies;
                  if (null !== h2) {
                    g2 = f2.child;
                    for (var k2 = h2.firstContext; null !== k2; ) {
                      if (k2.context === d2) {
                        if (1 === f2.tag) {
                          k2 = ch(-1, c2 & -c2);
                          k2.tag = 2;
                          var l2 = f2.updateQueue;
                          if (null !== l2) {
                            l2 = l2.shared;
                            var m2 = l2.pending;
                            null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                            l2.pending = k2;
                          }
                        }
                        f2.lanes |= c2;
                        k2 = f2.alternate;
                        null !== k2 && (k2.lanes |= c2);
                        Sg(
                          f2.return,
                          c2,
                          b2
                        );
                        h2.lanes |= c2;
                        break;
                      }
                      k2 = k2.next;
                    }
                  } else if (10 === f2.tag)
                    g2 = f2.type === b2.type ? null : f2.child;
                  else if (18 === f2.tag) {
                    g2 = f2.return;
                    if (null === g2)
                      throw Error(p$4(341));
                    g2.lanes |= c2;
                    h2 = g2.alternate;
                    null !== h2 && (h2.lanes |= c2);
                    Sg(g2, c2, b2);
                    g2 = f2.sibling;
                  } else
                    g2 = f2.child;
                  if (null !== g2)
                    g2.return = f2;
                  else
                    for (g2 = f2; null !== g2; ) {
                      if (g2 === b2) {
                        g2 = null;
                        break;
                      }
                      f2 = g2.sibling;
                      if (null !== f2) {
                        f2.return = g2.return;
                        g2 = f2;
                        break;
                      }
                      g2 = g2.return;
                    }
                  f2 = g2;
                }
            Yi(a, b2, e2.children, c2);
            b2 = b2.child;
          }
          return b2;
        case 9:
          return e2 = b2.type, d2 = b2.pendingProps.children, Tg(b2, c2), e2 = Vg(e2), d2 = d2(e2), b2.flags |= 1, Yi(a, b2, d2, c2), b2.child;
        case 14:
          return d2 = b2.type, e2 = Lg(d2, b2.pendingProps), e2 = Lg(d2.type, e2), aj(a, b2, d2, e2, c2);
        case 15:
          return cj(a, b2, b2.type, b2.pendingProps, c2);
        case 17:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), jj(a, b2), b2.tag = 1, Zf(d2) ? (a = true, cg(b2)) : a = false, Tg(b2, c2), ph(b2, d2, e2), rh(b2, d2, e2, c2), kj(null, b2, d2, true, a, c2);
        case 19:
          return yj(a, b2, c2);
        case 22:
          return ej(a, b2, c2);
      }
      throw Error(p$4(156, b2.tag));
    };
    function Gk(a, b2) {
      return ac(a, b2);
    }
    function al(a, b2, c2, d2) {
      this.tag = a;
      this.key = c2;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.ref = null;
      this.pendingProps = b2;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = d2;
      this.subtreeFlags = this.flags = 0;
      this.deletions = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
    }
    function Bg(a, b2, c2, d2) {
      return new al(a, b2, c2, d2);
    }
    function bj(a) {
      a = a.prototype;
      return !(!a || !a.isReactComponent);
    }
    function $k(a) {
      if ("function" === typeof a)
        return bj(a) ? 1 : 0;
      if (void 0 !== a && null !== a) {
        a = a.$$typeof;
        if (a === Da)
          return 11;
        if (a === Ga)
          return 14;
      }
      return 2;
    }
    function wh(a, b2) {
      var c2 = a.alternate;
      null === c2 ? (c2 = Bg(a.tag, b2, a.key, a.mode), c2.elementType = a.elementType, c2.type = a.type, c2.stateNode = a.stateNode, c2.alternate = a, a.alternate = c2) : (c2.pendingProps = b2, c2.type = a.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
      c2.flags = a.flags & 14680064;
      c2.childLanes = a.childLanes;
      c2.lanes = a.lanes;
      c2.child = a.child;
      c2.memoizedProps = a.memoizedProps;
      c2.memoizedState = a.memoizedState;
      c2.updateQueue = a.updateQueue;
      b2 = a.dependencies;
      c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
      c2.sibling = a.sibling;
      c2.index = a.index;
      c2.ref = a.ref;
      return c2;
    }
    function yh(a, b2, c2, d2, e2, f2) {
      var g2 = 2;
      d2 = a;
      if ("function" === typeof a)
        bj(a) && (g2 = 1);
      else if ("string" === typeof a)
        g2 = 5;
      else
        a:
          switch (a) {
            case ya:
              return Ah(c2.children, e2, f2, b2);
            case za:
              g2 = 8;
              e2 |= 8;
              break;
            case Aa:
              return a = Bg(12, c2, b2, e2 | 2), a.elementType = Aa, a.lanes = f2, a;
            case Ea:
              return a = Bg(13, c2, b2, e2), a.elementType = Ea, a.lanes = f2, a;
            case Fa:
              return a = Bg(19, c2, b2, e2), a.elementType = Fa, a.lanes = f2, a;
            case Ia:
              return qj(c2, e2, f2, b2);
            default:
              if ("object" === typeof a && null !== a)
                switch (a.$$typeof) {
                  case Ba:
                    g2 = 10;
                    break a;
                  case Ca:
                    g2 = 9;
                    break a;
                  case Da:
                    g2 = 11;
                    break a;
                  case Ga:
                    g2 = 14;
                    break a;
                  case Ha:
                    g2 = 16;
                    d2 = null;
                    break a;
                }
              throw Error(p$4(130, null == a ? a : typeof a, ""));
          }
      b2 = Bg(g2, c2, b2, e2);
      b2.elementType = a;
      b2.type = d2;
      b2.lanes = f2;
      return b2;
    }
    function Ah(a, b2, c2, d2) {
      a = Bg(7, a, d2, b2);
      a.lanes = c2;
      return a;
    }
    function qj(a, b2, c2, d2) {
      a = Bg(22, a, d2, b2);
      a.elementType = Ia;
      a.lanes = c2;
      a.stateNode = { isHidden: false };
      return a;
    }
    function xh(a, b2, c2) {
      a = Bg(6, a, null, b2);
      a.lanes = c2;
      return a;
    }
    function zh(a, b2, c2) {
      b2 = Bg(4, null !== a.children ? a.children : [], a.key, b2);
      b2.lanes = c2;
      b2.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
      return b2;
    }
    function bl(a, b2, c2, d2, e2) {
      this.tag = b2;
      this.containerInfo = a;
      this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = -1;
      this.callbackNode = this.pendingContext = this.context = null;
      this.callbackPriority = 0;
      this.eventTimes = zc(0);
      this.expirationTimes = zc(-1);
      this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = zc(0);
      this.identifierPrefix = d2;
      this.onRecoverableError = e2;
      this.mutableSourceEagerHydrationData = null;
    }
    function cl(a, b2, c2, d2, e2, f2, g2, h2, k2) {
      a = new bl(a, b2, c2, h2, k2);
      1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
      f2 = Bg(3, null, null, b2);
      a.current = f2;
      f2.stateNode = a;
      f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
      ah(f2);
      return a;
    }
    function dl(a, b2, c2) {
      var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a, containerInfo: b2, implementation: c2 };
    }
    function el(a) {
      if (!a)
        return Vf;
      a = a._reactInternals;
      a: {
        if (Vb(a) !== a || 1 !== a.tag)
          throw Error(p$4(170));
        var b2 = a;
        do {
          switch (b2.tag) {
            case 3:
              b2 = b2.stateNode.context;
              break a;
            case 1:
              if (Zf(b2.type)) {
                b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
                break a;
              }
          }
          b2 = b2.return;
        } while (null !== b2);
        throw Error(p$4(171));
      }
      if (1 === a.tag) {
        var c2 = a.type;
        if (Zf(c2))
          return bg(a, c2, b2);
      }
      return b2;
    }
    function fl(a, b2, c2, d2, e2, f2, g2, h2, k2) {
      a = cl(c2, d2, true, a, e2, f2, g2, h2, k2);
      a.context = el(null);
      c2 = a.current;
      d2 = L();
      e2 = lh(c2);
      f2 = ch(d2, e2);
      f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
      dh(c2, f2, e2);
      a.current.lanes = e2;
      Ac(a, e2, d2);
      Ek(a, d2);
      return a;
    }
    function gl(a, b2, c2, d2) {
      var e2 = b2.current, f2 = L(), g2 = lh(e2);
      c2 = el(c2);
      null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
      b2 = ch(f2, g2);
      b2.payload = { element: a };
      d2 = void 0 === d2 ? null : d2;
      null !== d2 && (b2.callback = d2);
      a = dh(e2, b2, g2);
      null !== a && (mh(a, e2, g2, f2), eh(a, e2, g2));
      return g2;
    }
    function hl(a) {
      a = a.current;
      if (!a.child)
        return null;
      switch (a.child.tag) {
        case 5:
          return a.child.stateNode;
        default:
          return a.child.stateNode;
      }
    }
    function il(a, b2) {
      a = a.memoizedState;
      if (null !== a && null !== a.dehydrated) {
        var c2 = a.retryLane;
        a.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
      }
    }
    function jl(a, b2) {
      il(a, b2);
      (a = a.alternate) && il(a, b2);
    }
    function kl() {
      return null;
    }
    var ll = "function" === typeof reportError ? reportError : function(a) {
      console.error(a);
    };
    function ml(a) {
      this._internalRoot = a;
    }
    nl.prototype.render = ml.prototype.render = function(a) {
      var b2 = this._internalRoot;
      if (null === b2)
        throw Error(p$4(409));
      gl(a, b2, null, null);
    };
    nl.prototype.unmount = ml.prototype.unmount = function() {
      var a = this._internalRoot;
      if (null !== a) {
        this._internalRoot = null;
        var b2 = a.containerInfo;
        Sk(function() {
          gl(null, a, null, null);
        });
        b2[uf] = null;
      }
    };
    function nl(a) {
      this._internalRoot = a;
    }
    nl.prototype.unstable_scheduleHydration = function(a) {
      if (a) {
        var b2 = Hc();
        a = { blockedOn: null, target: a, priority: b2 };
        for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++)
          ;
        Qc.splice(c2, 0, a);
        0 === c2 && Vc(a);
      }
    };
    function ol(a) {
      return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
    }
    function pl(a) {
      return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
    }
    function ql() {
    }
    function rl(a, b2, c2, d2, e2) {
      if (e2) {
        if ("function" === typeof d2) {
          var f2 = d2;
          d2 = function() {
            var a2 = hl(g2);
            f2.call(a2);
          };
        }
        var g2 = fl(b2, d2, a, 0, null, false, false, "", ql);
        a._reactRootContainer = g2;
        a[uf] = g2.current;
        sf(8 === a.nodeType ? a.parentNode : a);
        Sk();
        return g2;
      }
      for (; e2 = a.lastChild; )
        a.removeChild(e2);
      if ("function" === typeof d2) {
        var h2 = d2;
        d2 = function() {
          var a2 = hl(k2);
          h2.call(a2);
        };
      }
      var k2 = cl(a, 0, false, null, null, false, false, "", ql);
      a._reactRootContainer = k2;
      a[uf] = k2.current;
      sf(8 === a.nodeType ? a.parentNode : a);
      Sk(function() {
        gl(b2, k2, c2, d2);
      });
      return k2;
    }
    function sl(a, b2, c2, d2, e2) {
      var f2 = c2._reactRootContainer;
      if (f2) {
        var g2 = f2;
        if ("function" === typeof e2) {
          var h2 = e2;
          e2 = function() {
            var a2 = hl(g2);
            h2.call(a2);
          };
        }
        gl(b2, g2, a, e2);
      } else
        g2 = rl(c2, b2, a, e2, d2);
      return hl(g2);
    }
    Ec = function(a) {
      switch (a.tag) {
        case 3:
          var b2 = a.stateNode;
          if (b2.current.memoizedState.isDehydrated) {
            var c2 = tc(b2.pendingLanes);
            0 !== c2 && (Cc(b2, c2 | 1), Ek(b2, B()), 0 === (K & 6) && (Hj = B() + 500, jg()));
          }
          break;
        case 13:
          Sk(function() {
            var b3 = Zg(a, 1);
            if (null !== b3) {
              var c3 = L();
              mh(b3, a, 1, c3);
            }
          }), jl(a, 1);
      }
    };
    Fc = function(a) {
      if (13 === a.tag) {
        var b2 = Zg(a, 134217728);
        if (null !== b2) {
          var c2 = L();
          mh(b2, a, 134217728, c2);
        }
        jl(a, 134217728);
      }
    };
    Gc = function(a) {
      if (13 === a.tag) {
        var b2 = lh(a), c2 = Zg(a, b2);
        if (null !== c2) {
          var d2 = L();
          mh(c2, a, b2, d2);
        }
        jl(a, b2);
      }
    };
    Hc = function() {
      return C;
    };
    Ic = function(a, b2) {
      var c2 = C;
      try {
        return C = a, b2();
      } finally {
        C = c2;
      }
    };
    yb = function(a, b2, c2) {
      switch (b2) {
        case "input":
          bb(a, c2);
          b2 = c2.name;
          if ("radio" === c2.type && null != b2) {
            for (c2 = a; c2.parentNode; )
              c2 = c2.parentNode;
            c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
            for (b2 = 0; b2 < c2.length; b2++) {
              var d2 = c2[b2];
              if (d2 !== a && d2.form === a.form) {
                var e2 = Db(d2);
                if (!e2)
                  throw Error(p$4(90));
                Wa(d2);
                bb(d2, e2);
              }
            }
          }
          break;
        case "textarea":
          ib(a, c2);
          break;
        case "select":
          b2 = c2.value, null != b2 && fb(a, !!c2.multiple, b2, false);
      }
    };
    Gb = Rk;
    Hb = Sk;
    var tl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
    var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
      a = Zb(a);
      return null === a ? null : a.stateNode;
    }, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
    if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
      var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!wl.isDisabled && wl.supportsFiber)
        try {
          kc = wl.inject(vl), lc = wl;
        } catch (a) {
        }
    }
    reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
    reactDom_production_min.createPortal = function(a, b2) {
      var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (!ol(b2))
        throw Error(p$4(200));
      return dl(a, b2, null, c2);
    };
    reactDom_production_min.createRoot = function(a, b2) {
      if (!ol(a))
        throw Error(p$4(299));
      var c2 = false, d2 = "", e2 = ll;
      null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
      b2 = cl(a, 1, false, null, null, c2, false, d2, e2);
      a[uf] = b2.current;
      sf(8 === a.nodeType ? a.parentNode : a);
      return new ml(b2);
    };
    reactDom_production_min.findDOMNode = function(a) {
      if (null == a)
        return null;
      if (1 === a.nodeType)
        return a;
      var b2 = a._reactInternals;
      if (void 0 === b2) {
        if ("function" === typeof a.render)
          throw Error(p$4(188));
        a = Object.keys(a).join(",");
        throw Error(p$4(268, a));
      }
      a = Zb(b2);
      a = null === a ? null : a.stateNode;
      return a;
    };
    reactDom_production_min.flushSync = function(a) {
      return Sk(a);
    };
    reactDom_production_min.hydrate = function(a, b2, c2) {
      if (!pl(b2))
        throw Error(p$4(200));
      return sl(null, a, b2, true, c2);
    };
    reactDom_production_min.hydrateRoot = function(a, b2, c2) {
      if (!ol(a))
        throw Error(p$4(405));
      var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = ll;
      null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
      b2 = fl(b2, null, a, 1, null != c2 ? c2 : null, e2, false, f2, g2);
      a[uf] = b2.current;
      sf(a);
      if (d2)
        for (a = 0; a < d2.length; a++)
          c2 = d2[a], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
            c2,
            e2
          );
      return new nl(b2);
    };
    reactDom_production_min.render = function(a, b2, c2) {
      if (!pl(b2))
        throw Error(p$4(200));
      return sl(null, a, b2, false, c2);
    };
    reactDom_production_min.unmountComponentAtNode = function(a) {
      if (!pl(a))
        throw Error(p$4(40));
      return a._reactRootContainer ? (Sk(function() {
        sl(null, null, a, false, function() {
          a._reactRootContainer = null;
          a[uf] = null;
        });
      }), true) : false;
    };
    reactDom_production_min.unstable_batchedUpdates = Rk;
    reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b2, c2, d2) {
      if (!pl(c2))
        throw Error(p$4(200));
      if (null == a || void 0 === a._reactInternals)
        throw Error(p$4(38));
      return sl(a, b2, c2, false, d2);
    };
    reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
    function checkDCE() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
        return;
      }
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
      } catch (err) {
        console.error(err);
      }
    }
    {
      checkDCE();
      reactDom.exports = reactDom_production_min;
    }
    var reactDomExports = reactDom.exports;
    const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
    const ReactDOM$1 = /* @__PURE__ */ _mergeNamespaces({
      __proto__: null,
      default: ReactDOM
    }, [reactDomExports]);
    var m$3 = reactDomExports;
    {
      client.createRoot = m$3.createRoot;
      client.hydrateRoot = m$3.hydrateRoot;
    }
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge$1(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        Object.keys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      Object.keys(source).forEach(function(key) {
        if (!options.isMergeableObject(source[key]) || !target[key]) {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        } else {
          destination[key] = deepmerge$1(target[key], source[key], options);
        }
      });
      return destination;
    }
    function deepmerge$1(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge$1.all = function deepmergeAll(array2, options) {
      if (!Array.isArray(array2)) {
        throw new Error("first argument should be an array");
      }
      return array2.reduce(function(prev2, next2) {
        return deepmerge$1(prev2, next2, options);
      }, {});
    };
    var deepmerge_1 = deepmerge$1;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var Symbol$1 = root.Symbol;
    var objectProto$d = Object.prototype;
    var hasOwnProperty$b = objectProto$d.hasOwnProperty;
    var nativeObjectToString$1 = objectProto$d.toString;
    var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty$b.call(value, symToStringTag$1), tag = value[symToStringTag$1];
      try {
        value[symToStringTag$1] = void 0;
        var unmasked = true;
      } catch (e2) {
      }
      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }
    var objectProto$c = Object.prototype;
    var nativeObjectToString = objectProto$c.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var objectTag$3 = "[object Object]";
    var funcProto$2 = Function.prototype, objectProto$b = Object.prototype;
    var funcToString$2 = funcProto$2.toString;
    var hasOwnProperty$a = objectProto$b.hasOwnProperty;
    var objectCtorString = funcToString$2.call(Object);
    function isPlainObject$2(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty$a.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString$2.call(Ctor) == objectCtorString;
    }
    var isArray$2 = Array.isArray;
    var keyList = Object.keys;
    var hasProp = Object.prototype.hasOwnProperty;
    var hasElementType = typeof Element !== "undefined";
    function equal(a, b2) {
      if (a === b2)
        return true;
      if (a && b2 && typeof a == "object" && typeof b2 == "object") {
        var arrA = isArray$2(a), arrB = isArray$2(b2), i, length2, key;
        if (arrA && arrB) {
          length2 = a.length;
          if (length2 != b2.length)
            return false;
          for (i = length2; i-- !== 0; )
            if (!equal(a[i], b2[i]))
              return false;
          return true;
        }
        if (arrA != arrB)
          return false;
        var dateA = a instanceof Date, dateB = b2 instanceof Date;
        if (dateA != dateB)
          return false;
        if (dateA && dateB)
          return a.getTime() == b2.getTime();
        var regexpA = a instanceof RegExp, regexpB = b2 instanceof RegExp;
        if (regexpA != regexpB)
          return false;
        if (regexpA && regexpB)
          return a.toString() == b2.toString();
        var keys2 = keyList(a);
        length2 = keys2.length;
        if (length2 !== keyList(b2).length)
          return false;
        for (i = length2; i-- !== 0; )
          if (!hasProp.call(b2, keys2[i]))
            return false;
        if (hasElementType && a instanceof Element && b2 instanceof Element)
          return a === b2;
        for (i = length2; i-- !== 0; ) {
          key = keys2[i];
          if (key === "_owner" && a.$$typeof) {
            continue;
          } else {
            if (!equal(a[key], b2[key]))
              return false;
          }
        }
        return true;
      }
      return a !== a && b2 !== b2;
    }
    var reactFastCompare = function exportedEqual(a, b2) {
      try {
        return equal(a, b2);
      } catch (error) {
        if (error.message && error.message.match(/stack|recursion/i) || error.number === -2146828260) {
          console.warn("Warning: react-fast-compare does not handle circular references.", error.name, error.message);
          return false;
        }
        throw error;
      }
    };
    const isEqual = /* @__PURE__ */ getDefaultExportFromCjs(reactFastCompare);
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function assocIndexOf(array2, key) {
      var length2 = array2.length;
      while (length2--) {
        if (eq(array2[length2][0], key)) {
          return length2;
        }
      }
      return -1;
    }
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    function ListCache(entries) {
      var index = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function isObject$3(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
    function isFunction$2(value) {
      if (!isObject$3(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
    }
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var funcProto$1 = Function.prototype;
    var funcToString$1 = funcProto$1.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString$1.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype, objectProto$a = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty$9 = objectProto$a.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty$9).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject$3(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction$2(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function getValue$1(object2, key) {
      return object2 == null ? void 0 : object2[key];
    }
    function getNative(object2, key) {
      var value = getValue$1(object2, key);
      return baseIsNative(value) ? value : void 0;
    }
    var Map$1 = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
    var objectProto$9 = Object.prototype;
    var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED$1 ? void 0 : result;
      }
      return hasOwnProperty$8.call(data, key) ? data[key] : void 0;
    }
    var objectProto$8 = Object.prototype;
    var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty$7.call(data, key);
    }
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    function Hash(entries) {
      var index = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map$1 || ListCache)(),
        "string": new Hash()
      };
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    function MapCache(entries) {
      var index = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayEach(array2, iteratee) {
      var index = -1, length2 = array2 == null ? 0 : array2.length;
      while (++index < length2) {
        if (iteratee(array2[index], index, array2) === false) {
          break;
        }
      }
      return array2;
    }
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e2) {
      }
    }();
    function baseAssignValue(object2, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object2, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object2[key] = value;
      }
    }
    var objectProto$7 = Object.prototype;
    var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
    function assignValue(object2, key, value) {
      var objValue = object2[key];
      if (!(hasOwnProperty$6.call(object2, key) && eq(objValue, value)) || value === void 0 && !(key in object2)) {
        baseAssignValue(object2, key, value);
      }
    }
    function copyObject(source, props, object2, customizer) {
      var isNew = !object2;
      object2 || (object2 = {});
      var index = -1, length2 = props.length;
      while (++index < length2) {
        var key = props[index];
        var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object2, key, newValue);
        } else {
          assignValue(object2, key, newValue);
        }
      }
      return object2;
    }
    function baseTimes(n2, iteratee) {
      var index = -1, result = Array(n2);
      while (++index < n2) {
        result[index] = iteratee(index);
      }
      return result;
    }
    var argsTag$2 = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag$2;
    }
    var objectProto$6 = Object.prototype;
    var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
    var propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty$5.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
    };
    var isArray$1 = Array.isArray;
    function stubFalse() {
      return false;
    }
    var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
    var Buffer$2 = moduleExports$2 ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer$2 ? Buffer$2.isBuffer : void 0;
    var isBuffer$1 = nativeIsBuffer || stubFalse;
    var MAX_SAFE_INTEGER$1 = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length2) {
      var type = typeof value;
      length2 = length2 == null ? MAX_SAFE_INTEGER$1 : length2;
      return !!length2 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
    }
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1 = "[object Function]", mapTag$4 = "[object Map]", numberTag$2 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$2 = "[object String]", weakMapTag$2 = "[object WeakMap]";
    var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
    typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$2] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$2] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
    var freeProcess = moduleExports$1 && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e2) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray$1 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    var objectProto$5 = Object.prototype;
    var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray$1(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty$4.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length2)))) {
          result.push(key);
        }
      }
      return result;
    }
    var objectProto$4 = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$4;
      return value === proto;
    }
    var nativeKeys = overArg(Object.keys, Object);
    var objectProto$3 = Object.prototype;
    var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
    function baseKeys(object2) {
      if (!isPrototype(object2)) {
        return nativeKeys(object2);
      }
      var result = [];
      for (var key in Object(object2)) {
        if (hasOwnProperty$3.call(object2, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction$2(value);
    }
    function keys(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
    }
    function baseAssign(object2, source) {
      return object2 && copyObject(source, keys(source), object2);
    }
    function nativeKeysIn(object2) {
      var result = [];
      if (object2 != null) {
        for (var key in Object(object2)) {
          result.push(key);
        }
      }
      return result;
    }
    var objectProto$2 = Object.prototype;
    var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
    function baseKeysIn(object2) {
      if (!isObject$3(object2)) {
        return nativeKeysIn(object2);
      }
      var isProto = isPrototype(object2), result = [];
      for (var key in object2) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty$2.call(object2, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function keysIn(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
    }
    function baseAssignIn(object2, source) {
      return object2 && copyObject(source, keysIn(source), object2);
    }
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer$1 = moduleExports ? root.Buffer : void 0, allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length2 = buffer.length, result = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
      buffer.copy(result);
      return result;
    }
    function copyArray(source, array2) {
      var index = -1, length2 = source.length;
      array2 || (array2 = Array(length2));
      while (++index < length2) {
        array2[index] = source[index];
      }
      return array2;
    }
    function arrayFilter(array2, predicate) {
      var index = -1, length2 = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
      while (++index < length2) {
        var value = array2[index];
        if (predicate(value, index, array2)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function stubArray() {
      return [];
    }
    var objectProto$1 = Object.prototype;
    var propertyIsEnumerable = objectProto$1.propertyIsEnumerable;
    var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object2) {
      if (object2 == null) {
        return [];
      }
      object2 = Object(object2);
      return arrayFilter(nativeGetSymbols$1(object2), function(symbol) {
        return propertyIsEnumerable.call(object2, symbol);
      });
    };
    function copySymbols(source, object2) {
      return copyObject(source, getSymbols(source), object2);
    }
    function arrayPush(array2, values2) {
      var index = -1, length2 = values2.length, offset2 = array2.length;
      while (++index < length2) {
        array2[offset2 + index] = values2[index];
      }
      return array2;
    }
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object2) {
      var result = [];
      while (object2) {
        arrayPush(result, getSymbols(object2));
        object2 = getPrototype(object2);
      }
      return result;
    };
    function copySymbolsIn(source, object2) {
      return copyObject(source, getSymbolsIn(source), object2);
    }
    function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
      var result = keysFunc(object2);
      return isArray$1(object2) ? result : arrayPush(result, symbolsFunc(object2));
    }
    function getAllKeys(object2) {
      return baseGetAllKeys(object2, keys, getSymbols);
    }
    function getAllKeysIn(object2) {
      return baseGetAllKeys(object2, keysIn, getSymbolsIn);
    }
    var DataView = getNative(root, "DataView");
    var Promise$1 = getNative(root, "Promise");
    var Set$1 = getNative(root, "Set");
    var WeakMap$1 = getNative(root, "WeakMap");
    var mapTag$3 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$3 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
    var dataViewTag$2 = "[object DataView]";
    var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map$1 && getTag(new Map$1()) != mapTag$3 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$3 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag$1) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag$2;
            case mapCtorString:
              return mapTag$3;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag$3;
            case weakMapCtorString:
              return weakMapTag$1;
          }
        }
        return result;
      };
    }
    const getTag$1 = getTag;
    var objectProto = Object.prototype;
    var hasOwnProperty$1 = objectProto.hasOwnProperty;
    function initCloneArray(array2) {
      var length2 = array2.length, result = new array2.constructor(length2);
      if (length2 && typeof array2[0] == "string" && hasOwnProperty$1.call(array2, "index")) {
        result.index = array2.index;
        result.input = array2.input;
      }
      return result;
    }
    var Uint8Array$1 = root.Uint8Array;
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
      return result;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$2 = "[object Symbol]";
    var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
    function initCloneByTag(object2, tag, isDeep) {
      var Ctor = object2.constructor;
      switch (tag) {
        case arrayBufferTag$1:
          return cloneArrayBuffer(object2);
        case boolTag$1:
        case dateTag$1:
          return new Ctor(+object2);
        case dataViewTag$1:
          return cloneDataView(object2, isDeep);
        case float32Tag$1:
        case float64Tag$1:
        case int8Tag$1:
        case int16Tag$1:
        case int32Tag$1:
        case uint8Tag$1:
        case uint8ClampedTag$1:
        case uint16Tag$1:
        case uint32Tag$1:
          return cloneTypedArray(object2, isDeep);
        case mapTag$2:
          return new Ctor();
        case numberTag$1:
        case stringTag$1:
          return new Ctor(object2);
        case regexpTag$1:
          return cloneRegExp(object2);
        case setTag$2:
          return new Ctor();
        case symbolTag$2:
          return cloneSymbol(object2);
      }
    }
    var objectCreate = Object.create;
    var baseCreate = /* @__PURE__ */ function() {
      function object2() {
      }
      return function(proto) {
        if (!isObject$3(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object2.prototype = proto;
        var result = new object2();
        object2.prototype = void 0;
        return result;
      };
    }();
    function initCloneObject(object2) {
      return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate(getPrototype(object2)) : {};
    }
    var mapTag$1 = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag$1(value) == mapTag$1;
    }
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    var setTag$1 = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag$1(value) == setTag$1;
    }
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key, object2, stack) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
      if (customizer) {
        result = object2 ? customizer(value, key, object2, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject$3(value)) {
        return value;
      }
      var isArr = isArray$1(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag$1(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer$1(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object2) {
          result = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object2 ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key2) {
          result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
      });
      return result;
    }
    var CLONE_SYMBOLS_FLAG = 4;
    function clone$1(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }
    function arrayMap(array2, iteratee) {
      var index = -1, length2 = array2 == null ? 0 : array2.length, result = Array(length2);
      while (++index < length2) {
        result[index] = iteratee(array2[index], index, array2);
      }
      return result;
    }
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize$2(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize$2.Cache || MapCache)();
      return memoized;
    }
    memoize$2.Cache = MapCache;
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize$2(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string2) {
      var result = [];
      if (string2.charCodeAt(0) === 46) {
        result.push("");
      }
      string2.replace(rePropName, function(match2, number2, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match2);
      });
      return result;
    });
    const stringToPath$1 = stringToPath;
    var INFINITY$1 = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
    }
    var INFINITY = 1 / 0;
    var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString$1 = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray$1(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString$1 ? symbolToString$1.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toString$2(value) {
      return value == null ? "" : baseToString(value);
    }
    function toPath(value) {
      if (isArray$1(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath$1(toString$2(value)));
    }
    var reactIs$1 = { exports: {} };
    var reactIs_production_min$1 = {};
    /** @license React v16.13.1
     * react-is.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var b$1 = "function" === typeof Symbol && Symbol.for, c$1 = b$1 ? Symbol.for("react.element") : 60103, d$1 = b$1 ? Symbol.for("react.portal") : 60106, e$2 = b$1 ? Symbol.for("react.fragment") : 60107, f$1 = b$1 ? Symbol.for("react.strict_mode") : 60108, g$1 = b$1 ? Symbol.for("react.profiler") : 60114, h$3 = b$1 ? Symbol.for("react.provider") : 60109, k$2 = b$1 ? Symbol.for("react.context") : 60110, l$2 = b$1 ? Symbol.for("react.async_mode") : 60111, m$2 = b$1 ? Symbol.for("react.concurrent_mode") : 60111, n$3 = b$1 ? Symbol.for("react.forward_ref") : 60112, p$3 = b$1 ? Symbol.for("react.suspense") : 60113, q$3 = b$1 ? Symbol.for("react.suspense_list") : 60120, r$3 = b$1 ? Symbol.for("react.memo") : 60115, t$3 = b$1 ? Symbol.for("react.lazy") : 60116, v$2 = b$1 ? Symbol.for("react.block") : 60121, w$1 = b$1 ? Symbol.for("react.fundamental") : 60117, x = b$1 ? Symbol.for("react.responder") : 60118, y = b$1 ? Symbol.for("react.scope") : 60119;
    function z(a) {
      if ("object" === typeof a && null !== a) {
        var u2 = a.$$typeof;
        switch (u2) {
          case c$1:
            switch (a = a.type, a) {
              case l$2:
              case m$2:
              case e$2:
              case g$1:
              case f$1:
              case p$3:
                return a;
              default:
                switch (a = a && a.$$typeof, a) {
                  case k$2:
                  case n$3:
                  case t$3:
                  case r$3:
                  case h$3:
                    return a;
                  default:
                    return u2;
                }
            }
          case d$1:
            return u2;
        }
      }
    }
    function A(a) {
      return z(a) === m$2;
    }
    reactIs_production_min$1.AsyncMode = l$2;
    reactIs_production_min$1.ConcurrentMode = m$2;
    reactIs_production_min$1.ContextConsumer = k$2;
    reactIs_production_min$1.ContextProvider = h$3;
    reactIs_production_min$1.Element = c$1;
    reactIs_production_min$1.ForwardRef = n$3;
    reactIs_production_min$1.Fragment = e$2;
    reactIs_production_min$1.Lazy = t$3;
    reactIs_production_min$1.Memo = r$3;
    reactIs_production_min$1.Portal = d$1;
    reactIs_production_min$1.Profiler = g$1;
    reactIs_production_min$1.StrictMode = f$1;
    reactIs_production_min$1.Suspense = p$3;
    reactIs_production_min$1.isAsyncMode = function(a) {
      return A(a) || z(a) === l$2;
    };
    reactIs_production_min$1.isConcurrentMode = A;
    reactIs_production_min$1.isContextConsumer = function(a) {
      return z(a) === k$2;
    };
    reactIs_production_min$1.isContextProvider = function(a) {
      return z(a) === h$3;
    };
    reactIs_production_min$1.isElement = function(a) {
      return "object" === typeof a && null !== a && a.$$typeof === c$1;
    };
    reactIs_production_min$1.isForwardRef = function(a) {
      return z(a) === n$3;
    };
    reactIs_production_min$1.isFragment = function(a) {
      return z(a) === e$2;
    };
    reactIs_production_min$1.isLazy = function(a) {
      return z(a) === t$3;
    };
    reactIs_production_min$1.isMemo = function(a) {
      return z(a) === r$3;
    };
    reactIs_production_min$1.isPortal = function(a) {
      return z(a) === d$1;
    };
    reactIs_production_min$1.isProfiler = function(a) {
      return z(a) === g$1;
    };
    reactIs_production_min$1.isStrictMode = function(a) {
      return z(a) === f$1;
    };
    reactIs_production_min$1.isSuspense = function(a) {
      return z(a) === p$3;
    };
    reactIs_production_min$1.isValidElementType = function(a) {
      return "string" === typeof a || "function" === typeof a || a === e$2 || a === m$2 || a === g$1 || a === f$1 || a === p$3 || a === q$3 || "object" === typeof a && null !== a && (a.$$typeof === t$3 || a.$$typeof === r$3 || a.$$typeof === h$3 || a.$$typeof === k$2 || a.$$typeof === n$3 || a.$$typeof === w$1 || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v$2);
    };
    reactIs_production_min$1.typeOf = z;
    {
      reactIs$1.exports = reactIs_production_min$1;
    }
    var reactIsExports = reactIs$1.exports;
    var reactIs = reactIsExports;
    var FORWARD_REF_STATICS = {
      "$$typeof": true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      "$$typeof": true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
    function _extends$5() {
      _extends$5 = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends$5.apply(this, arguments);
    }
    function _objectWithoutPropertiesLoose$3(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    var FormikContext = /* @__PURE__ */ reactExports.createContext(void 0);
    FormikContext.displayName = "FormikContext";
    FormikContext.Provider;
    FormikContext.Consumer;
    function useFormikContext() {
      var formik = reactExports.useContext(FormikContext);
      return formik;
    }
    var isFunction$1 = function isFunction2(obj) {
      return typeof obj === "function";
    };
    var isObject$2 = function isObject2(obj) {
      return obj !== null && typeof obj === "object";
    };
    var isInteger = function isInteger2(obj) {
      return String(Math.floor(Number(obj))) === obj;
    };
    var isString$2 = function isString2(obj) {
      return Object.prototype.toString.call(obj) === "[object String]";
    };
    var isPromise = function isPromise2(value) {
      return isObject$2(value) && isFunction$1(value.then);
    };
    function getIn$1(obj, key, def, p2) {
      if (p2 === void 0) {
        p2 = 0;
      }
      var path = toPath(key);
      while (obj && p2 < path.length) {
        obj = obj[path[p2++]];
      }
      if (p2 !== path.length && !obj) {
        return def;
      }
      return obj === void 0 ? def : obj;
    }
    function setIn(obj, path, value) {
      var res = clone$1(obj);
      var resVal = res;
      var i = 0;
      var pathArray = toPath(path);
      for (; i < pathArray.length - 1; i++) {
        var currentPath = pathArray[i];
        var currentObj = getIn$1(obj, pathArray.slice(0, i + 1));
        if (currentObj && (isObject$2(currentObj) || Array.isArray(currentObj))) {
          resVal = resVal[currentPath] = clone$1(currentObj);
        } else {
          var nextPath = pathArray[i + 1];
          resVal = resVal[currentPath] = isInteger(nextPath) && Number(nextPath) >= 0 ? [] : {};
        }
      }
      if ((i === 0 ? obj : resVal)[pathArray[i]] === value) {
        return obj;
      }
      if (value === void 0) {
        delete resVal[pathArray[i]];
      } else {
        resVal[pathArray[i]] = value;
      }
      if (i === 0 && value === void 0) {
        delete res[pathArray[i]];
      }
      return res;
    }
    function setNestedObjectValues(object2, value, visited, response) {
      if (visited === void 0) {
        visited = /* @__PURE__ */ new WeakMap();
      }
      if (response === void 0) {
        response = {};
      }
      for (var _i = 0, _Object$keys = Object.keys(object2); _i < _Object$keys.length; _i++) {
        var k2 = _Object$keys[_i];
        var val = object2[k2];
        if (isObject$2(val)) {
          if (!visited.get(val)) {
            visited.set(val, true);
            response[k2] = Array.isArray(val) ? [] : {};
            setNestedObjectValues(val, value, visited, response[k2]);
          }
        } else {
          response[k2] = value;
        }
      }
      return response;
    }
    function formikReducer(state, msg) {
      switch (msg.type) {
        case "SET_VALUES":
          return _extends$5({}, state, {
            values: msg.payload
          });
        case "SET_TOUCHED":
          return _extends$5({}, state, {
            touched: msg.payload
          });
        case "SET_ERRORS":
          if (isEqual(state.errors, msg.payload)) {
            return state;
          }
          return _extends$5({}, state, {
            errors: msg.payload
          });
        case "SET_STATUS":
          return _extends$5({}, state, {
            status: msg.payload
          });
        case "SET_ISSUBMITTING":
          return _extends$5({}, state, {
            isSubmitting: msg.payload
          });
        case "SET_ISVALIDATING":
          return _extends$5({}, state, {
            isValidating: msg.payload
          });
        case "SET_FIELD_VALUE":
          return _extends$5({}, state, {
            values: setIn(state.values, msg.payload.field, msg.payload.value)
          });
        case "SET_FIELD_TOUCHED":
          return _extends$5({}, state, {
            touched: setIn(state.touched, msg.payload.field, msg.payload.value)
          });
        case "SET_FIELD_ERROR":
          return _extends$5({}, state, {
            errors: setIn(state.errors, msg.payload.field, msg.payload.value)
          });
        case "RESET_FORM":
          return _extends$5({}, state, msg.payload);
        case "SET_FORMIK_STATE":
          return msg.payload(state);
        case "SUBMIT_ATTEMPT":
          return _extends$5({}, state, {
            touched: setNestedObjectValues(state.values, true),
            isSubmitting: true,
            submitCount: state.submitCount + 1
          });
        case "SUBMIT_FAILURE":
          return _extends$5({}, state, {
            isSubmitting: false
          });
        case "SUBMIT_SUCCESS":
          return _extends$5({}, state, {
            isSubmitting: false
          });
        default:
          return state;
      }
    }
    var emptyErrors = {};
    var emptyTouched = {};
    function useFormik(_ref) {
      var _ref$validateOnChange = _ref.validateOnChange, validateOnChange = _ref$validateOnChange === void 0 ? true : _ref$validateOnChange, _ref$validateOnBlur = _ref.validateOnBlur, validateOnBlur = _ref$validateOnBlur === void 0 ? true : _ref$validateOnBlur, _ref$validateOnMount = _ref.validateOnMount, validateOnMount = _ref$validateOnMount === void 0 ? false : _ref$validateOnMount, isInitialValid = _ref.isInitialValid, _ref$enableReinitiali = _ref.enableReinitialize, enableReinitialize = _ref$enableReinitiali === void 0 ? false : _ref$enableReinitiali, onSubmit = _ref.onSubmit, rest = _objectWithoutPropertiesLoose$3(_ref, ["validateOnChange", "validateOnBlur", "validateOnMount", "isInitialValid", "enableReinitialize", "onSubmit"]);
      var props = _extends$5({
        validateOnChange,
        validateOnBlur,
        validateOnMount,
        onSubmit
      }, rest);
      var initialValues = reactExports.useRef(props.initialValues);
      var initialErrors = reactExports.useRef(props.initialErrors || emptyErrors);
      var initialTouched = reactExports.useRef(props.initialTouched || emptyTouched);
      var initialStatus = reactExports.useRef(props.initialStatus);
      var isMounted = reactExports.useRef(false);
      var fieldRegistry = reactExports.useRef({});
      reactExports.useEffect(function() {
        isMounted.current = true;
        return function() {
          isMounted.current = false;
        };
      }, []);
      var _React$useState = reactExports.useState(0), setIteration = _React$useState[1];
      var stateRef = reactExports.useRef({
        values: props.initialValues,
        errors: props.initialErrors || emptyErrors,
        touched: props.initialTouched || emptyTouched,
        status: props.initialStatus,
        isSubmitting: false,
        isValidating: false,
        submitCount: 0
      });
      var state = stateRef.current;
      var dispatch = reactExports.useCallback(function(action) {
        var prev2 = stateRef.current;
        stateRef.current = formikReducer(prev2, action);
        if (prev2 !== stateRef.current)
          setIteration(function(x2) {
            return x2 + 1;
          });
      }, []);
      var runValidateHandler = reactExports.useCallback(function(values2, field) {
        return new Promise(function(resolve, reject) {
          var maybePromisedErrors = props.validate(values2, field);
          if (maybePromisedErrors == null) {
            resolve(emptyErrors);
          } else if (isPromise(maybePromisedErrors)) {
            maybePromisedErrors.then(function(errors) {
              resolve(errors || emptyErrors);
            }, function(actualException) {
              reject(actualException);
            });
          } else {
            resolve(maybePromisedErrors);
          }
        });
      }, [props.validate]);
      var runValidationSchema = reactExports.useCallback(function(values2, field) {
        var validationSchema = props.validationSchema;
        var schema = isFunction$1(validationSchema) ? validationSchema(field) : validationSchema;
        var promise = field && schema.validateAt ? schema.validateAt(field, values2) : validateYupSchema(values2, schema);
        return new Promise(function(resolve, reject) {
          promise.then(function() {
            resolve(emptyErrors);
          }, function(err) {
            if (err.name === "ValidationError") {
              resolve(yupToFormErrors(err));
            } else {
              reject(err);
            }
          });
        });
      }, [props.validationSchema]);
      var runSingleFieldLevelValidation = reactExports.useCallback(function(field, value) {
        return new Promise(function(resolve) {
          return resolve(fieldRegistry.current[field].validate(value));
        });
      }, []);
      var runFieldLevelValidations = reactExports.useCallback(function(values2) {
        var fieldKeysWithValidation = Object.keys(fieldRegistry.current).filter(function(f2) {
          return isFunction$1(fieldRegistry.current[f2].validate);
        });
        var fieldValidations = fieldKeysWithValidation.length > 0 ? fieldKeysWithValidation.map(function(f2) {
          return runSingleFieldLevelValidation(f2, getIn$1(values2, f2));
        }) : [Promise.resolve("DO_NOT_DELETE_YOU_WILL_BE_FIRED")];
        return Promise.all(fieldValidations).then(function(fieldErrorsList) {
          return fieldErrorsList.reduce(function(prev2, curr, index) {
            if (curr === "DO_NOT_DELETE_YOU_WILL_BE_FIRED") {
              return prev2;
            }
            if (curr) {
              prev2 = setIn(prev2, fieldKeysWithValidation[index], curr);
            }
            return prev2;
          }, {});
        });
      }, [runSingleFieldLevelValidation]);
      var runAllValidations = reactExports.useCallback(function(values2) {
        return Promise.all([runFieldLevelValidations(values2), props.validationSchema ? runValidationSchema(values2) : {}, props.validate ? runValidateHandler(values2) : {}]).then(function(_ref2) {
          var fieldErrors = _ref2[0], schemaErrors = _ref2[1], validateErrors = _ref2[2];
          var combinedErrors = deepmerge_1.all([fieldErrors, schemaErrors, validateErrors], {
            arrayMerge
          });
          return combinedErrors;
        });
      }, [props.validate, props.validationSchema, runFieldLevelValidations, runValidateHandler, runValidationSchema]);
      var validateFormWithHighPriority = useEventCallback$1(function(values2) {
        if (values2 === void 0) {
          values2 = state.values;
        }
        dispatch({
          type: "SET_ISVALIDATING",
          payload: true
        });
        return runAllValidations(values2).then(function(combinedErrors) {
          if (!!isMounted.current) {
            dispatch({
              type: "SET_ISVALIDATING",
              payload: false
            });
            dispatch({
              type: "SET_ERRORS",
              payload: combinedErrors
            });
          }
          return combinedErrors;
        });
      });
      reactExports.useEffect(function() {
        if (validateOnMount && isMounted.current === true && isEqual(initialValues.current, props.initialValues)) {
          validateFormWithHighPriority(initialValues.current);
        }
      }, [validateOnMount, validateFormWithHighPriority]);
      var resetForm = reactExports.useCallback(function(nextState) {
        var values2 = nextState && nextState.values ? nextState.values : initialValues.current;
        var errors = nextState && nextState.errors ? nextState.errors : initialErrors.current ? initialErrors.current : props.initialErrors || {};
        var touched = nextState && nextState.touched ? nextState.touched : initialTouched.current ? initialTouched.current : props.initialTouched || {};
        var status = nextState && nextState.status ? nextState.status : initialStatus.current ? initialStatus.current : props.initialStatus;
        initialValues.current = values2;
        initialErrors.current = errors;
        initialTouched.current = touched;
        initialStatus.current = status;
        var dispatchFn = function dispatchFn2() {
          dispatch({
            type: "RESET_FORM",
            payload: {
              isSubmitting: !!nextState && !!nextState.isSubmitting,
              errors,
              touched,
              status,
              values: values2,
              isValidating: !!nextState && !!nextState.isValidating,
              submitCount: !!nextState && !!nextState.submitCount && typeof nextState.submitCount === "number" ? nextState.submitCount : 0
            }
          });
        };
        if (props.onReset) {
          var maybePromisedOnReset = props.onReset(state.values, imperativeMethods);
          if (isPromise(maybePromisedOnReset)) {
            maybePromisedOnReset.then(dispatchFn);
          } else {
            dispatchFn();
          }
        } else {
          dispatchFn();
        }
      }, [props.initialErrors, props.initialStatus, props.initialTouched, props.onReset]);
      reactExports.useEffect(function() {
        if (isMounted.current === true && !isEqual(initialValues.current, props.initialValues)) {
          if (enableReinitialize) {
            initialValues.current = props.initialValues;
            resetForm();
            if (validateOnMount) {
              validateFormWithHighPriority(initialValues.current);
            }
          }
        }
      }, [enableReinitialize, props.initialValues, resetForm, validateOnMount, validateFormWithHighPriority]);
      reactExports.useEffect(function() {
        if (enableReinitialize && isMounted.current === true && !isEqual(initialErrors.current, props.initialErrors)) {
          initialErrors.current = props.initialErrors || emptyErrors;
          dispatch({
            type: "SET_ERRORS",
            payload: props.initialErrors || emptyErrors
          });
        }
      }, [enableReinitialize, props.initialErrors]);
      reactExports.useEffect(function() {
        if (enableReinitialize && isMounted.current === true && !isEqual(initialTouched.current, props.initialTouched)) {
          initialTouched.current = props.initialTouched || emptyTouched;
          dispatch({
            type: "SET_TOUCHED",
            payload: props.initialTouched || emptyTouched
          });
        }
      }, [enableReinitialize, props.initialTouched]);
      reactExports.useEffect(function() {
        if (enableReinitialize && isMounted.current === true && !isEqual(initialStatus.current, props.initialStatus)) {
          initialStatus.current = props.initialStatus;
          dispatch({
            type: "SET_STATUS",
            payload: props.initialStatus
          });
        }
      }, [enableReinitialize, props.initialStatus, props.initialTouched]);
      var validateField = useEventCallback$1(function(name) {
        if (fieldRegistry.current[name] && isFunction$1(fieldRegistry.current[name].validate)) {
          var value = getIn$1(state.values, name);
          var maybePromise = fieldRegistry.current[name].validate(value);
          if (isPromise(maybePromise)) {
            dispatch({
              type: "SET_ISVALIDATING",
              payload: true
            });
            return maybePromise.then(function(x2) {
              return x2;
            }).then(function(error) {
              dispatch({
                type: "SET_FIELD_ERROR",
                payload: {
                  field: name,
                  value: error
                }
              });
              dispatch({
                type: "SET_ISVALIDATING",
                payload: false
              });
            });
          } else {
            dispatch({
              type: "SET_FIELD_ERROR",
              payload: {
                field: name,
                value: maybePromise
              }
            });
            return Promise.resolve(maybePromise);
          }
        } else if (props.validationSchema) {
          dispatch({
            type: "SET_ISVALIDATING",
            payload: true
          });
          return runValidationSchema(state.values, name).then(function(x2) {
            return x2;
          }).then(function(error) {
            dispatch({
              type: "SET_FIELD_ERROR",
              payload: {
                field: name,
                value: getIn$1(error, name)
              }
            });
            dispatch({
              type: "SET_ISVALIDATING",
              payload: false
            });
          });
        }
        return Promise.resolve();
      });
      var registerField = reactExports.useCallback(function(name, _ref3) {
        var validate = _ref3.validate;
        fieldRegistry.current[name] = {
          validate
        };
      }, []);
      var unregisterField = reactExports.useCallback(function(name) {
        delete fieldRegistry.current[name];
      }, []);
      var setTouched = useEventCallback$1(function(touched, shouldValidate) {
        dispatch({
          type: "SET_TOUCHED",
          payload: touched
        });
        var willValidate = shouldValidate === void 0 ? validateOnBlur : shouldValidate;
        return willValidate ? validateFormWithHighPriority(state.values) : Promise.resolve();
      });
      var setErrors = reactExports.useCallback(function(errors) {
        dispatch({
          type: "SET_ERRORS",
          payload: errors
        });
      }, []);
      var setValues = useEventCallback$1(function(values2, shouldValidate) {
        var resolvedValues = isFunction$1(values2) ? values2(state.values) : values2;
        dispatch({
          type: "SET_VALUES",
          payload: resolvedValues
        });
        var willValidate = shouldValidate === void 0 ? validateOnChange : shouldValidate;
        return willValidate ? validateFormWithHighPriority(resolvedValues) : Promise.resolve();
      });
      var setFieldError = reactExports.useCallback(function(field, value) {
        dispatch({
          type: "SET_FIELD_ERROR",
          payload: {
            field,
            value
          }
        });
      }, []);
      var setFieldValue = useEventCallback$1(function(field, value, shouldValidate) {
        dispatch({
          type: "SET_FIELD_VALUE",
          payload: {
            field,
            value
          }
        });
        var willValidate = shouldValidate === void 0 ? validateOnChange : shouldValidate;
        return willValidate ? validateFormWithHighPriority(setIn(state.values, field, value)) : Promise.resolve();
      });
      var executeChange = reactExports.useCallback(function(eventOrTextValue, maybePath) {
        var field = maybePath;
        var val = eventOrTextValue;
        var parsed;
        if (!isString$2(eventOrTextValue)) {
          if (eventOrTextValue.persist) {
            eventOrTextValue.persist();
          }
          var target = eventOrTextValue.target ? eventOrTextValue.target : eventOrTextValue.currentTarget;
          var type = target.type, name = target.name, id2 = target.id, value = target.value, checked = target.checked, outerHTML = target.outerHTML, options = target.options, multiple = target.multiple;
          field = maybePath ? maybePath : name ? name : id2;
          if (!field && false) {
            warnAboutMissingIdentifier({
              htmlContent: outerHTML,
              documentationAnchorLink: "handlechange-e-reactchangeeventany--void",
              handlerName: "handleChange"
            });
          }
          val = /number|range/.test(type) ? (parsed = parseFloat(value), isNaN(parsed) ? "" : parsed) : /checkbox/.test(type) ? getValueForCheckbox(getIn$1(state.values, field), checked, value) : options && multiple ? getSelectedValues(options) : value;
        }
        if (field) {
          setFieldValue(field, val);
        }
      }, [setFieldValue, state.values]);
      var handleChange = useEventCallback$1(function(eventOrPath) {
        if (isString$2(eventOrPath)) {
          return function(event) {
            return executeChange(event, eventOrPath);
          };
        } else {
          executeChange(eventOrPath);
        }
      });
      var setFieldTouched = useEventCallback$1(function(field, touched, shouldValidate) {
        if (touched === void 0) {
          touched = true;
        }
        dispatch({
          type: "SET_FIELD_TOUCHED",
          payload: {
            field,
            value: touched
          }
        });
        var willValidate = shouldValidate === void 0 ? validateOnBlur : shouldValidate;
        return willValidate ? validateFormWithHighPriority(state.values) : Promise.resolve();
      });
      var executeBlur = reactExports.useCallback(function(e2, path) {
        if (e2.persist) {
          e2.persist();
        }
        var _e$target = e2.target, name = _e$target.name, id2 = _e$target.id, outerHTML = _e$target.outerHTML;
        var field = path ? path : name ? name : id2;
        if (!field && false) {
          warnAboutMissingIdentifier({
            htmlContent: outerHTML,
            documentationAnchorLink: "handleblur-e-any--void",
            handlerName: "handleBlur"
          });
        }
        setFieldTouched(field, true);
      }, [setFieldTouched]);
      var handleBlur = useEventCallback$1(function(eventOrString) {
        if (isString$2(eventOrString)) {
          return function(event) {
            return executeBlur(event, eventOrString);
          };
        } else {
          executeBlur(eventOrString);
        }
      });
      var setFormikState = reactExports.useCallback(function(stateOrCb) {
        if (isFunction$1(stateOrCb)) {
          dispatch({
            type: "SET_FORMIK_STATE",
            payload: stateOrCb
          });
        } else {
          dispatch({
            type: "SET_FORMIK_STATE",
            payload: function payload() {
              return stateOrCb;
            }
          });
        }
      }, []);
      var setStatus = reactExports.useCallback(function(status) {
        dispatch({
          type: "SET_STATUS",
          payload: status
        });
      }, []);
      var setSubmitting = reactExports.useCallback(function(isSubmitting) {
        dispatch({
          type: "SET_ISSUBMITTING",
          payload: isSubmitting
        });
      }, []);
      var submitForm = useEventCallback$1(function() {
        dispatch({
          type: "SUBMIT_ATTEMPT"
        });
        return validateFormWithHighPriority().then(function(combinedErrors) {
          var isInstanceOfError = combinedErrors instanceof Error;
          var isActuallyValid = !isInstanceOfError && Object.keys(combinedErrors).length === 0;
          if (isActuallyValid) {
            var promiseOrUndefined;
            try {
              promiseOrUndefined = executeSubmit();
              if (promiseOrUndefined === void 0) {
                return;
              }
            } catch (error) {
              throw error;
            }
            return Promise.resolve(promiseOrUndefined).then(function(result) {
              if (!!isMounted.current) {
                dispatch({
                  type: "SUBMIT_SUCCESS"
                });
              }
              return result;
            })["catch"](function(_errors) {
              if (!!isMounted.current) {
                dispatch({
                  type: "SUBMIT_FAILURE"
                });
                throw _errors;
              }
            });
          } else if (!!isMounted.current) {
            dispatch({
              type: "SUBMIT_FAILURE"
            });
            if (isInstanceOfError) {
              throw combinedErrors;
            }
          }
          return;
        });
      });
      var handleSubmit = useEventCallback$1(function(e2) {
        if (e2 && e2.preventDefault && isFunction$1(e2.preventDefault)) {
          e2.preventDefault();
        }
        if (e2 && e2.stopPropagation && isFunction$1(e2.stopPropagation)) {
          e2.stopPropagation();
        }
        submitForm()["catch"](function(reason) {
          console.warn("Warning: An unhandled error was caught from submitForm()", reason);
        });
      });
      var imperativeMethods = {
        resetForm,
        validateForm: validateFormWithHighPriority,
        validateField,
        setErrors,
        setFieldError,
        setFieldTouched,
        setFieldValue,
        setStatus,
        setSubmitting,
        setTouched,
        setValues,
        setFormikState,
        submitForm
      };
      var executeSubmit = useEventCallback$1(function() {
        return onSubmit(state.values, imperativeMethods);
      });
      var handleReset = useEventCallback$1(function(e2) {
        if (e2 && e2.preventDefault && isFunction$1(e2.preventDefault)) {
          e2.preventDefault();
        }
        if (e2 && e2.stopPropagation && isFunction$1(e2.stopPropagation)) {
          e2.stopPropagation();
        }
        resetForm();
      });
      var getFieldMeta = reactExports.useCallback(function(name) {
        return {
          value: getIn$1(state.values, name),
          error: getIn$1(state.errors, name),
          touched: !!getIn$1(state.touched, name),
          initialValue: getIn$1(initialValues.current, name),
          initialTouched: !!getIn$1(initialTouched.current, name),
          initialError: getIn$1(initialErrors.current, name)
        };
      }, [state.errors, state.touched, state.values]);
      var getFieldHelpers = reactExports.useCallback(function(name) {
        return {
          setValue: function setValue(value, shouldValidate) {
            return setFieldValue(name, value, shouldValidate);
          },
          setTouched: function setTouched2(value, shouldValidate) {
            return setFieldTouched(name, value, shouldValidate);
          },
          setError: function setError(value) {
            return setFieldError(name, value);
          }
        };
      }, [setFieldValue, setFieldTouched, setFieldError]);
      var getFieldProps = reactExports.useCallback(function(nameOrOptions) {
        var isAnObject = isObject$2(nameOrOptions);
        var name = isAnObject ? nameOrOptions.name : nameOrOptions;
        var valueState = getIn$1(state.values, name);
        var field = {
          name,
          value: valueState,
          onChange: handleChange,
          onBlur: handleBlur
        };
        if (isAnObject) {
          var type = nameOrOptions.type, valueProp = nameOrOptions.value, is = nameOrOptions.as, multiple = nameOrOptions.multiple;
          if (type === "checkbox") {
            if (valueProp === void 0) {
              field.checked = !!valueState;
            } else {
              field.checked = !!(Array.isArray(valueState) && ~valueState.indexOf(valueProp));
              field.value = valueProp;
            }
          } else if (type === "radio") {
            field.checked = valueState === valueProp;
            field.value = valueProp;
          } else if (is === "select" && multiple) {
            field.value = field.value || [];
            field.multiple = true;
          }
        }
        return field;
      }, [handleBlur, handleChange, state.values]);
      var dirty = reactExports.useMemo(function() {
        return !isEqual(initialValues.current, state.values);
      }, [initialValues.current, state.values]);
      var isValid = reactExports.useMemo(function() {
        return typeof isInitialValid !== "undefined" ? dirty ? state.errors && Object.keys(state.errors).length === 0 : isInitialValid !== false && isFunction$1(isInitialValid) ? isInitialValid(props) : isInitialValid : state.errors && Object.keys(state.errors).length === 0;
      }, [isInitialValid, dirty, state.errors, props]);
      var ctx = _extends$5({}, state, {
        initialValues: initialValues.current,
        initialErrors: initialErrors.current,
        initialTouched: initialTouched.current,
        initialStatus: initialStatus.current,
        handleBlur,
        handleChange,
        handleReset,
        handleSubmit,
        resetForm,
        setErrors,
        setFormikState,
        setFieldTouched,
        setFieldValue,
        setFieldError,
        setStatus,
        setSubmitting,
        setTouched,
        setValues,
        submitForm,
        validateForm: validateFormWithHighPriority,
        validateField,
        isValid,
        dirty,
        unregisterField,
        registerField,
        getFieldProps,
        getFieldMeta,
        getFieldHelpers,
        validateOnBlur,
        validateOnChange,
        validateOnMount
      });
      return ctx;
    }
    function warnAboutMissingIdentifier(_ref4) {
      var htmlContent = _ref4.htmlContent, documentationAnchorLink = _ref4.documentationAnchorLink, handlerName = _ref4.handlerName;
      console.warn("Warning: Formik called `" + handlerName + "`, but you forgot to pass an `id` or `name` attribute to your input:\n    " + htmlContent + "\n    Formik cannot determine which value to update. For more info see https://formik.org/docs/api/formik#" + documentationAnchorLink + "\n  ");
    }
    function yupToFormErrors(yupError) {
      var errors = {};
      if (yupError.inner) {
        if (yupError.inner.length === 0) {
          return setIn(errors, yupError.path, yupError.message);
        }
        for (var _iterator = yupError.inner, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ; ) {
          var _ref5;
          if (_isArray) {
            if (_i >= _iterator.length)
              break;
            _ref5 = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done)
              break;
            _ref5 = _i.value;
          }
          var err = _ref5;
          if (!getIn$1(errors, err.path)) {
            errors = setIn(errors, err.path, err.message);
          }
        }
      }
      return errors;
    }
    function validateYupSchema(values2, schema, sync, context) {
      if (sync === void 0) {
        sync = false;
      }
      var normalizedValues = prepareDataForValidation(values2);
      return schema[sync ? "validateSync" : "validate"](normalizedValues, {
        abortEarly: false,
        context: context || normalizedValues
      });
    }
    function prepareDataForValidation(values2) {
      var data = Array.isArray(values2) ? [] : {};
      for (var k2 in values2) {
        if (Object.prototype.hasOwnProperty.call(values2, k2)) {
          var key = String(k2);
          if (Array.isArray(values2[key]) === true) {
            data[key] = values2[key].map(function(value) {
              if (Array.isArray(value) === true || isPlainObject$2(value)) {
                return prepareDataForValidation(value);
              } else {
                return value !== "" ? value : void 0;
              }
            });
          } else if (isPlainObject$2(values2[key])) {
            data[key] = prepareDataForValidation(values2[key]);
          } else {
            data[key] = values2[key] !== "" ? values2[key] : void 0;
          }
        }
      }
      return data;
    }
    function arrayMerge(target, source, options) {
      var destination = target.slice();
      source.forEach(function merge2(e2, i) {
        if (typeof destination[i] === "undefined") {
          var cloneRequested = options.clone !== false;
          var shouldClone = cloneRequested && options.isMergeableObject(e2);
          destination[i] = shouldClone ? deepmerge_1(Array.isArray(e2) ? [] : {}, e2, options) : e2;
        } else if (options.isMergeableObject(e2)) {
          destination[i] = deepmerge_1(target[i], e2, options);
        } else if (target.indexOf(e2) === -1) {
          destination.push(e2);
        }
      });
      return destination;
    }
    function getSelectedValues(options) {
      return Array.from(options).filter(function(el2) {
        return el2.selected;
      }).map(function(el2) {
        return el2.value;
      });
    }
    function getValueForCheckbox(currentValue, checked, valueProp) {
      if (typeof currentValue === "boolean") {
        return Boolean(checked);
      }
      var currentArrayOfValues = [];
      var isValueInArray = false;
      var index = -1;
      if (!Array.isArray(currentValue)) {
        if (!valueProp || valueProp == "true" || valueProp == "false") {
          return Boolean(checked);
        }
      } else {
        currentArrayOfValues = currentValue;
        index = currentValue.indexOf(valueProp);
        isValueInArray = index >= 0;
      }
      if (checked && valueProp && !isValueInArray) {
        return currentArrayOfValues.concat(valueProp);
      }
      if (!isValueInArray) {
        return currentArrayOfValues;
      }
      return currentArrayOfValues.slice(0, index).concat(currentArrayOfValues.slice(index + 1));
    }
    var useIsomorphicLayoutEffect$2 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
    function useEventCallback$1(fn) {
      var ref = reactExports.useRef(fn);
      useIsomorphicLayoutEffect$2(function() {
        ref.current = fn;
      });
      return reactExports.useCallback(function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return ref.current.apply(void 0, args);
      }, []);
    }
    var Form = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var action = props.action, rest = _objectWithoutPropertiesLoose$3(props, ["action"]);
      var _action = action != null ? action : "#";
      var _useFormikContext = useFormikContext(), handleReset = _useFormikContext.handleReset, handleSubmit = _useFormikContext.handleSubmit;
      return reactExports.createElement("form", _extends$5({
        onSubmit: handleSubmit,
        ref,
        onReset: handleReset,
        action: _action
      }, rest));
    });
    Form.displayName = "Form";
    /**
     * @remix-run/router v1.15.0
     *
     * Copyright (c) Remix Software Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    function _extends$4() {
      _extends$4 = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends$4.apply(this, arguments);
    }
    var Action;
    (function(Action2) {
      Action2["Pop"] = "POP";
      Action2["Push"] = "PUSH";
      Action2["Replace"] = "REPLACE";
    })(Action || (Action = {}));
    const PopStateEventType = "popstate";
    function createBrowserHistory(options) {
      if (options === void 0) {
        options = {};
      }
      function createBrowserLocation(window2, globalHistory) {
        let {
          pathname,
          search,
          hash: hash2
        } = window2.location;
        return createLocation(
          "",
          {
            pathname,
            search,
            hash: hash2
          },
          // state defaults to `null` because `window.history.state` does
          globalHistory.state && globalHistory.state.usr || null,
          globalHistory.state && globalHistory.state.key || "default"
        );
      }
      function createBrowserHref(window2, to) {
        return typeof to === "string" ? to : createPath(to);
      }
      return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
    }
    function invariant$1(value, message) {
      if (value === false || value === null || typeof value === "undefined") {
        throw new Error(message);
      }
    }
    function warning(cond, message) {
      if (!cond) {
        if (typeof console !== "undefined")
          console.warn(message);
        try {
          throw new Error(message);
        } catch (e2) {
        }
      }
    }
    function createKey() {
      return Math.random().toString(36).substr(2, 8);
    }
    function getHistoryState(location, index) {
      return {
        usr: location.state,
        key: location.key,
        idx: index
      };
    }
    function createLocation(current, to, state, key) {
      if (state === void 0) {
        state = null;
      }
      let location = _extends$4({
        pathname: typeof current === "string" ? current : current.pathname,
        search: "",
        hash: ""
      }, typeof to === "string" ? parsePath(to) : to, {
        state,
        // TODO: This could be cleaned up.  push/replace should probably just take
        // full Locations now and avoid the need to run through this flow at all
        // But that's a pretty big refactor to the current test suite so going to
        // keep as is for the time being and just let any incoming keys take precedence
        key: to && to.key || key || createKey()
      });
      return location;
    }
    function createPath(_ref) {
      let {
        pathname = "/",
        search = "",
        hash: hash2 = ""
      } = _ref;
      if (search && search !== "?")
        pathname += search.charAt(0) === "?" ? search : "?" + search;
      if (hash2 && hash2 !== "#")
        pathname += hash2.charAt(0) === "#" ? hash2 : "#" + hash2;
      return pathname;
    }
    function parsePath(path) {
      let parsedPath = {};
      if (path) {
        let hashIndex = path.indexOf("#");
        if (hashIndex >= 0) {
          parsedPath.hash = path.substr(hashIndex);
          path = path.substr(0, hashIndex);
        }
        let searchIndex = path.indexOf("?");
        if (searchIndex >= 0) {
          parsedPath.search = path.substr(searchIndex);
          path = path.substr(0, searchIndex);
        }
        if (path) {
          parsedPath.pathname = path;
        }
      }
      return parsedPath;
    }
    function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
      if (options === void 0) {
        options = {};
      }
      let {
        window: window2 = document.defaultView,
        v5Compat = false
      } = options;
      let globalHistory = window2.history;
      let action = Action.Pop;
      let listener = null;
      let index = getIndex();
      if (index == null) {
        index = 0;
        globalHistory.replaceState(_extends$4({}, globalHistory.state, {
          idx: index
        }), "");
      }
      function getIndex() {
        let state = globalHistory.state || {
          idx: null
        };
        return state.idx;
      }
      function handlePop() {
        action = Action.Pop;
        let nextIndex = getIndex();
        let delta = nextIndex == null ? null : nextIndex - index;
        index = nextIndex;
        if (listener) {
          listener({
            action,
            location: history.location,
            delta
          });
        }
      }
      function push(to, state) {
        action = Action.Push;
        let location = createLocation(history.location, to, state);
        if (validateLocation)
          validateLocation(location, to);
        index = getIndex() + 1;
        let historyState = getHistoryState(location, index);
        let url = history.createHref(location);
        try {
          globalHistory.pushState(historyState, "", url);
        } catch (error) {
          if (error instanceof DOMException && error.name === "DataCloneError") {
            throw error;
          }
          window2.location.assign(url);
        }
        if (v5Compat && listener) {
          listener({
            action,
            location: history.location,
            delta: 1
          });
        }
      }
      function replace2(to, state) {
        action = Action.Replace;
        let location = createLocation(history.location, to, state);
        if (validateLocation)
          validateLocation(location, to);
        index = getIndex();
        let historyState = getHistoryState(location, index);
        let url = history.createHref(location);
        globalHistory.replaceState(historyState, "", url);
        if (v5Compat && listener) {
          listener({
            action,
            location: history.location,
            delta: 0
          });
        }
      }
      function createURL(to) {
        let base = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
        let href = typeof to === "string" ? to : createPath(to);
        invariant$1(base, "No window.location.(origin|href) available to create URL for href: " + href);
        return new URL(href, base);
      }
      let history = {
        get action() {
          return action;
        },
        get location() {
          return getLocation(window2, globalHistory);
        },
        listen(fn) {
          if (listener) {
            throw new Error("A history only accepts one active listener");
          }
          window2.addEventListener(PopStateEventType, handlePop);
          listener = fn;
          return () => {
            window2.removeEventListener(PopStateEventType, handlePop);
            listener = null;
          };
        },
        createHref(to) {
          return createHref(window2, to);
        },
        createURL,
        encodeLocation(to) {
          let url = createURL(to);
          return {
            pathname: url.pathname,
            search: url.search,
            hash: url.hash
          };
        },
        push,
        replace: replace2,
        go(n2) {
          return globalHistory.go(n2);
        }
      };
      return history;
    }
    var ResultType;
    (function(ResultType2) {
      ResultType2["data"] = "data";
      ResultType2["deferred"] = "deferred";
      ResultType2["redirect"] = "redirect";
      ResultType2["error"] = "error";
    })(ResultType || (ResultType = {}));
    const immutableRouteKeys = /* @__PURE__ */ new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
    function isIndexRoute(route) {
      return route.index === true;
    }
    function convertRoutesToDataRoutes(routes, mapRouteProperties2, parentPath, manifest) {
      if (parentPath === void 0) {
        parentPath = [];
      }
      if (manifest === void 0) {
        manifest = {};
      }
      return routes.map((route, index) => {
        let treePath = [...parentPath, index];
        let id2 = typeof route.id === "string" ? route.id : treePath.join("-");
        invariant$1(route.index !== true || !route.children, "Cannot specify children on an index route");
        invariant$1(!manifest[id2], 'Found a route id collision on id "' + id2 + `".  Route id's must be globally unique within Data Router usages`);
        if (isIndexRoute(route)) {
          let indexRoute = _extends$4({}, route, mapRouteProperties2(route), {
            id: id2
          });
          manifest[id2] = indexRoute;
          return indexRoute;
        } else {
          let pathOrLayoutRoute = _extends$4({}, route, mapRouteProperties2(route), {
            id: id2,
            children: void 0
          });
          manifest[id2] = pathOrLayoutRoute;
          if (route.children) {
            pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties2, treePath, manifest);
          }
          return pathOrLayoutRoute;
        }
      });
    }
    function matchRoutes(routes, locationArg, basename) {
      if (basename === void 0) {
        basename = "/";
      }
      let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
      let pathname = stripBasename(location.pathname || "/", basename);
      if (pathname == null) {
        return null;
      }
      let branches = flattenRoutes(routes);
      rankRouteBranches(branches);
      let matches = null;
      for (let i = 0; matches == null && i < branches.length; ++i) {
        matches = matchRouteBranch(
          branches[i],
          // Incoming pathnames are generally encoded from either window.location
          // or from router.navigate, but we want to match against the unencoded
          // paths in the route definitions.  Memory router locations won't be
          // encoded here but there also shouldn't be anything to decode so this
          // should be a safe operation.  This avoids needing matchRoutes to be
          // history-aware.
          safelyDecodeURI(pathname)
        );
      }
      return matches;
    }
    function convertRouteMatchToUiMatch(match2, loaderData) {
      let {
        route,
        pathname,
        params
      } = match2;
      return {
        id: route.id,
        pathname,
        params,
        data: loaderData[route.id],
        handle: route.handle
      };
    }
    function flattenRoutes(routes, branches, parentsMeta, parentPath) {
      if (branches === void 0) {
        branches = [];
      }
      if (parentsMeta === void 0) {
        parentsMeta = [];
      }
      if (parentPath === void 0) {
        parentPath = "";
      }
      let flattenRoute = (route, index, relativePath) => {
        let meta = {
          relativePath: relativePath === void 0 ? route.path || "" : relativePath,
          caseSensitive: route.caseSensitive === true,
          childrenIndex: index,
          route
        };
        if (meta.relativePath.startsWith("/")) {
          invariant$1(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
          meta.relativePath = meta.relativePath.slice(parentPath.length);
        }
        let path = joinPaths([parentPath, meta.relativePath]);
        let routesMeta = parentsMeta.concat(meta);
        if (route.children && route.children.length > 0) {
          invariant$1(
            // Our types know better, but runtime JS may not!
            // @ts-expect-error
            route.index !== true,
            "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
          );
          flattenRoutes(route.children, branches, routesMeta, path);
        }
        if (route.path == null && !route.index) {
          return;
        }
        branches.push({
          path,
          score: computeScore(path, route.index),
          routesMeta
        });
      };
      routes.forEach((route, index) => {
        var _route$path;
        if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
          flattenRoute(route, index);
        } else {
          for (let exploded of explodeOptionalSegments(route.path)) {
            flattenRoute(route, index, exploded);
          }
        }
      });
      return branches;
    }
    function explodeOptionalSegments(path) {
      let segments = path.split("/");
      if (segments.length === 0)
        return [];
      let [first, ...rest] = segments;
      let isOptional = first.endsWith("?");
      let required = first.replace(/\?$/, "");
      if (rest.length === 0) {
        return isOptional ? [required, ""] : [required];
      }
      let restExploded = explodeOptionalSegments(rest.join("/"));
      let result = [];
      result.push(...restExploded.map((subpath) => subpath === "" ? required : [required, subpath].join("/")));
      if (isOptional) {
        result.push(...restExploded);
      }
      return result.map((exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded);
    }
    function rankRouteBranches(branches) {
      branches.sort((a, b2) => a.score !== b2.score ? b2.score - a.score : compareIndexes(a.routesMeta.map((meta) => meta.childrenIndex), b2.routesMeta.map((meta) => meta.childrenIndex)));
    }
    const paramRe = /^:[\w-]+$/;
    const dynamicSegmentValue = 3;
    const indexRouteValue = 2;
    const emptySegmentValue = 1;
    const staticSegmentValue = 10;
    const splatPenalty = -2;
    const isSplat = (s) => s === "*";
    function computeScore(path, index) {
      let segments = path.split("/");
      let initialScore = segments.length;
      if (segments.some(isSplat)) {
        initialScore += splatPenalty;
      }
      if (index) {
        initialScore += indexRouteValue;
      }
      return segments.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
    }
    function compareIndexes(a, b2) {
      let siblings = a.length === b2.length && a.slice(0, -1).every((n2, i) => n2 === b2[i]);
      return siblings ? (
        // If two routes are siblings, we should try to match the earlier sibling
        // first. This allows people to have fine-grained control over the matching
        // behavior by simply putting routes with identical paths in the order they
        // want them tried.
        a[a.length - 1] - b2[b2.length - 1]
      ) : (
        // Otherwise, it doesn't really make sense to rank non-siblings by index,
        // so they sort equally.
        0
      );
    }
    function matchRouteBranch(branch, pathname) {
      let {
        routesMeta
      } = branch;
      let matchedParams = {};
      let matchedPathname = "/";
      let matches = [];
      for (let i = 0; i < routesMeta.length; ++i) {
        let meta = routesMeta[i];
        let end2 = i === routesMeta.length - 1;
        let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
        let match2 = matchPath({
          path: meta.relativePath,
          caseSensitive: meta.caseSensitive,
          end: end2
        }, remainingPathname);
        if (!match2)
          return null;
        Object.assign(matchedParams, match2.params);
        let route = meta.route;
        matches.push({
          // TODO: Can this as be avoided?
          params: matchedParams,
          pathname: joinPaths([matchedPathname, match2.pathname]),
          pathnameBase: normalizePathname(joinPaths([matchedPathname, match2.pathnameBase])),
          route
        });
        if (match2.pathnameBase !== "/") {
          matchedPathname = joinPaths([matchedPathname, match2.pathnameBase]);
        }
      }
      return matches;
    }
    function matchPath(pattern, pathname) {
      if (typeof pattern === "string") {
        pattern = {
          path: pattern,
          caseSensitive: false,
          end: true
        };
      }
      let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
      let match2 = pathname.match(matcher);
      if (!match2)
        return null;
      let matchedPathname = match2[0];
      let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
      let captureGroups = match2.slice(1);
      let params = compiledParams.reduce((memo2, _ref, index) => {
        let {
          paramName,
          isOptional
        } = _ref;
        if (paramName === "*") {
          let splatValue = captureGroups[index] || "";
          pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
        }
        const value = captureGroups[index];
        if (isOptional && !value) {
          memo2[paramName] = void 0;
        } else {
          memo2[paramName] = safelyDecodeURIComponent(value || "", paramName);
        }
        return memo2;
      }, {});
      return {
        params,
        pathname: matchedPathname,
        pathnameBase,
        pattern
      };
    }
    function compilePath(path, caseSensitive, end2) {
      if (caseSensitive === void 0) {
        caseSensitive = false;
      }
      if (end2 === void 0) {
        end2 = true;
      }
      warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
      let params = [];
      let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (_2, paramName, isOptional) => {
        params.push({
          paramName,
          isOptional: isOptional != null
        });
        return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
      });
      if (path.endsWith("*")) {
        params.push({
          paramName: "*"
        });
        regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
      } else if (end2) {
        regexpSource += "\\/*$";
      } else if (path !== "" && path !== "/") {
        regexpSource += "(?:(?=\\/|$))";
      } else
        ;
      let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
      return [matcher, params];
    }
    function safelyDecodeURI(value) {
      try {
        return decodeURI(value);
      } catch (error) {
        warning(false, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error + ")."));
        return value;
      }
    }
    function safelyDecodeURIComponent(value, paramName) {
      try {
        return decodeURIComponent(value);
      } catch (error) {
        warning(false, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error + ")."));
        return value;
      }
    }
    function stripBasename(pathname, basename) {
      if (basename === "/")
        return pathname;
      if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
        return null;
      }
      let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
      let nextChar = pathname.charAt(startIndex);
      if (nextChar && nextChar !== "/") {
        return null;
      }
      return pathname.slice(startIndex) || "/";
    }
    function resolvePath(to, fromPathname) {
      if (fromPathname === void 0) {
        fromPathname = "/";
      }
      let {
        pathname: toPathname,
        search = "",
        hash: hash2 = ""
      } = typeof to === "string" ? parsePath(to) : to;
      let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
      return {
        pathname,
        search: normalizeSearch(search),
        hash: normalizeHash(hash2)
      };
    }
    function resolvePathname(relativePath, fromPathname) {
      let segments = fromPathname.replace(/\/+$/, "").split("/");
      let relativeSegments = relativePath.split("/");
      relativeSegments.forEach((segment) => {
        if (segment === "..") {
          if (segments.length > 1)
            segments.pop();
        } else if (segment !== ".") {
          segments.push(segment);
        }
      });
      return segments.length > 1 ? segments.join("/") : "/";
    }
    function getInvalidPathError(char2, field, dest, path) {
      return "Cannot include a '" + char2 + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
    }
    function getPathContributingMatches(matches) {
      return matches.filter((match2, index) => index === 0 || match2.route.path && match2.route.path.length > 0);
    }
    function getResolveToMatches(matches, v7_relativeSplatPath) {
      let pathMatches = getPathContributingMatches(matches);
      if (v7_relativeSplatPath) {
        return pathMatches.map((match2, idx) => idx === matches.length - 1 ? match2.pathname : match2.pathnameBase);
      }
      return pathMatches.map((match2) => match2.pathnameBase);
    }
    function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
      if (isPathRelative === void 0) {
        isPathRelative = false;
      }
      let to;
      if (typeof toArg === "string") {
        to = parsePath(toArg);
      } else {
        to = _extends$4({}, toArg);
        invariant$1(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
        invariant$1(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
        invariant$1(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
      }
      let isEmptyPath = toArg === "" || to.pathname === "";
      let toPathname = isEmptyPath ? "/" : to.pathname;
      let from2;
      if (toPathname == null) {
        from2 = locationPathname;
      } else {
        let routePathnameIndex = routePathnames.length - 1;
        if (!isPathRelative && toPathname.startsWith("..")) {
          let toSegments = toPathname.split("/");
          while (toSegments[0] === "..") {
            toSegments.shift();
            routePathnameIndex -= 1;
          }
          to.pathname = toSegments.join("/");
        }
        from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
      }
      let path = resolvePath(to, from2);
      let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
      let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
      if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
        path.pathname += "/";
      }
      return path;
    }
    const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
    const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
    const normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
    const normalizeHash = (hash2) => !hash2 || hash2 === "#" ? "" : hash2.startsWith("#") ? hash2 : "#" + hash2;
    class ErrorResponseImpl {
      constructor(status, statusText, data, internal) {
        if (internal === void 0) {
          internal = false;
        }
        this.status = status;
        this.statusText = statusText || "";
        this.internal = internal;
        if (data instanceof Error) {
          this.data = data.toString();
          this.error = data;
        } else {
          this.data = data;
        }
      }
    }
    function isRouteErrorResponse(error) {
      return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
    }
    const validMutationMethodsArr = ["post", "put", "patch", "delete"];
    const validMutationMethods = new Set(validMutationMethodsArr);
    const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
    const validRequestMethods = new Set(validRequestMethodsArr);
    const redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
    const redirectPreserveMethodStatusCodes = /* @__PURE__ */ new Set([307, 308]);
    const IDLE_NAVIGATION = {
      state: "idle",
      location: void 0,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      json: void 0,
      text: void 0
    };
    const IDLE_FETCHER = {
      state: "idle",
      data: void 0,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      json: void 0,
      text: void 0
    };
    const IDLE_BLOCKER = {
      state: "unblocked",
      proceed: void 0,
      reset: void 0,
      location: void 0
    };
    const ABSOLUTE_URL_REGEX$1 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
    const defaultMapRouteProperties = (route) => ({
      hasErrorBoundary: Boolean(route.hasErrorBoundary)
    });
    const TRANSITIONS_STORAGE_KEY = "remix-router-transitions";
    function createRouter(init) {
      const routerWindow = init.window ? init.window : typeof window !== "undefined" ? window : void 0;
      const isBrowser2 = typeof routerWindow !== "undefined" && typeof routerWindow.document !== "undefined" && typeof routerWindow.document.createElement !== "undefined";
      const isServer = !isBrowser2;
      invariant$1(init.routes.length > 0, "You must provide a non-empty routes array to createRouter");
      let mapRouteProperties2;
      if (init.mapRouteProperties) {
        mapRouteProperties2 = init.mapRouteProperties;
      } else if (init.detectErrorBoundary) {
        let detectErrorBoundary = init.detectErrorBoundary;
        mapRouteProperties2 = (route) => ({
          hasErrorBoundary: detectErrorBoundary(route)
        });
      } else {
        mapRouteProperties2 = defaultMapRouteProperties;
      }
      let manifest = {};
      let dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties2, void 0, manifest);
      let inFlightDataRoutes;
      let basename = init.basename || "/";
      let future = _extends$4({
        v7_fetcherPersist: false,
        v7_normalizeFormMethod: false,
        v7_partialHydration: false,
        v7_prependBasename: false,
        v7_relativeSplatPath: false
      }, init.future);
      let unlistenHistory = null;
      let subscribers = /* @__PURE__ */ new Set();
      let savedScrollPositions = null;
      let getScrollRestorationKey = null;
      let getScrollPosition = null;
      let initialScrollRestored = init.hydrationData != null;
      let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);
      let initialErrors = null;
      if (initialMatches == null) {
        let error = getInternalRouterError(404, {
          pathname: init.history.location.pathname
        });
        let {
          matches,
          route
        } = getShortCircuitMatches(dataRoutes);
        initialMatches = matches;
        initialErrors = {
          [route.id]: error
        };
      }
      let initialized;
      let hasLazyRoutes = initialMatches.some((m2) => m2.route.lazy);
      let hasLoaders = initialMatches.some((m2) => m2.route.loader);
      if (hasLazyRoutes) {
        initialized = false;
      } else if (!hasLoaders) {
        initialized = true;
      } else if (future.v7_partialHydration) {
        let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;
        let errors = init.hydrationData ? init.hydrationData.errors : null;
        initialized = initialMatches.every((m2) => m2.route.loader && m2.route.loader.hydrate !== true && (loaderData && loaderData[m2.route.id] !== void 0 || errors && errors[m2.route.id] !== void 0));
      } else {
        initialized = init.hydrationData != null;
      }
      let router;
      let state = {
        historyAction: init.history.action,
        location: init.history.location,
        matches: initialMatches,
        initialized,
        navigation: IDLE_NAVIGATION,
        // Don't restore on initial updateState() if we were SSR'd
        restoreScrollPosition: init.hydrationData != null ? false : null,
        preventScrollReset: false,
        revalidation: "idle",
        loaderData: init.hydrationData && init.hydrationData.loaderData || {},
        actionData: init.hydrationData && init.hydrationData.actionData || null,
        errors: init.hydrationData && init.hydrationData.errors || initialErrors,
        fetchers: /* @__PURE__ */ new Map(),
        blockers: /* @__PURE__ */ new Map()
      };
      let pendingAction = Action.Pop;
      let pendingPreventScrollReset = false;
      let pendingNavigationController;
      let pendingViewTransitionEnabled = false;
      let appliedViewTransitions = /* @__PURE__ */ new Map();
      let removePageHideEventListener = null;
      let isUninterruptedRevalidation = false;
      let isRevalidationRequired = false;
      let cancelledDeferredRoutes = [];
      let cancelledFetcherLoads = [];
      let fetchControllers = /* @__PURE__ */ new Map();
      let incrementingLoadId = 0;
      let pendingNavigationLoadId = -1;
      let fetchReloadIds = /* @__PURE__ */ new Map();
      let fetchRedirectIds = /* @__PURE__ */ new Set();
      let fetchLoadMatches = /* @__PURE__ */ new Map();
      let activeFetchers = /* @__PURE__ */ new Map();
      let deletedFetchers = /* @__PURE__ */ new Set();
      let activeDeferreds = /* @__PURE__ */ new Map();
      let blockerFunctions = /* @__PURE__ */ new Map();
      let ignoreNextHistoryUpdate = false;
      function initialize() {
        unlistenHistory = init.history.listen((_ref) => {
          let {
            action: historyAction,
            location,
            delta
          } = _ref;
          if (ignoreNextHistoryUpdate) {
            ignoreNextHistoryUpdate = false;
            return;
          }
          warning(blockerFunctions.size === 0 || delta != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
          let blockerKey = shouldBlockNavigation({
            currentLocation: state.location,
            nextLocation: location,
            historyAction
          });
          if (blockerKey && delta != null) {
            ignoreNextHistoryUpdate = true;
            init.history.go(delta * -1);
            updateBlocker(blockerKey, {
              state: "blocked",
              location,
              proceed() {
                updateBlocker(blockerKey, {
                  state: "proceeding",
                  proceed: void 0,
                  reset: void 0,
                  location
                });
                init.history.go(delta);
              },
              reset() {
                let blockers = new Map(state.blockers);
                blockers.set(blockerKey, IDLE_BLOCKER);
                updateState({
                  blockers
                });
              }
            });
            return;
          }
          return startNavigation(historyAction, location);
        });
        if (isBrowser2) {
          restoreAppliedTransitions(routerWindow, appliedViewTransitions);
          let _saveAppliedTransitions = () => persistAppliedTransitions(routerWindow, appliedViewTransitions);
          routerWindow.addEventListener("pagehide", _saveAppliedTransitions);
          removePageHideEventListener = () => routerWindow.removeEventListener("pagehide", _saveAppliedTransitions);
        }
        if (!state.initialized) {
          startNavigation(Action.Pop, state.location, {
            initialHydration: true
          });
        }
        return router;
      }
      function dispose() {
        if (unlistenHistory) {
          unlistenHistory();
        }
        if (removePageHideEventListener) {
          removePageHideEventListener();
        }
        subscribers.clear();
        pendingNavigationController && pendingNavigationController.abort();
        state.fetchers.forEach((_2, key) => deleteFetcher(key));
        state.blockers.forEach((_2, key) => deleteBlocker(key));
      }
      function subscribe(fn) {
        subscribers.add(fn);
        return () => subscribers.delete(fn);
      }
      function updateState(newState, opts) {
        if (opts === void 0) {
          opts = {};
        }
        state = _extends$4({}, state, newState);
        let completedFetchers = [];
        let deletedFetchersKeys = [];
        if (future.v7_fetcherPersist) {
          state.fetchers.forEach((fetcher, key) => {
            if (fetcher.state === "idle") {
              if (deletedFetchers.has(key)) {
                deletedFetchersKeys.push(key);
              } else {
                completedFetchers.push(key);
              }
            }
          });
        }
        [...subscribers].forEach((subscriber) => subscriber(state, {
          deletedFetchers: deletedFetchersKeys,
          unstable_viewTransitionOpts: opts.viewTransitionOpts,
          unstable_flushSync: opts.flushSync === true
        }));
        if (future.v7_fetcherPersist) {
          completedFetchers.forEach((key) => state.fetchers.delete(key));
          deletedFetchersKeys.forEach((key) => deleteFetcher(key));
        }
      }
      function completeNavigation(location, newState, _temp) {
        var _location$state, _location$state2;
        let {
          flushSync
        } = _temp === void 0 ? {} : _temp;
        let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === "loading" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;
        let actionData;
        if (newState.actionData) {
          if (Object.keys(newState.actionData).length > 0) {
            actionData = newState.actionData;
          } else {
            actionData = null;
          }
        } else if (isActionReload) {
          actionData = state.actionData;
        } else {
          actionData = null;
        }
        let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;
        let blockers = state.blockers;
        if (blockers.size > 0) {
          blockers = new Map(blockers);
          blockers.forEach((_2, k2) => blockers.set(k2, IDLE_BLOCKER));
        }
        let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;
        if (inFlightDataRoutes) {
          dataRoutes = inFlightDataRoutes;
          inFlightDataRoutes = void 0;
        }
        if (isUninterruptedRevalidation)
          ;
        else if (pendingAction === Action.Pop)
          ;
        else if (pendingAction === Action.Push) {
          init.history.push(location, location.state);
        } else if (pendingAction === Action.Replace) {
          init.history.replace(location, location.state);
        }
        let viewTransitionOpts;
        if (pendingAction === Action.Pop) {
          let priorPaths = appliedViewTransitions.get(state.location.pathname);
          if (priorPaths && priorPaths.has(location.pathname)) {
            viewTransitionOpts = {
              currentLocation: state.location,
              nextLocation: location
            };
          } else if (appliedViewTransitions.has(location.pathname)) {
            viewTransitionOpts = {
              currentLocation: location,
              nextLocation: state.location
            };
          }
        } else if (pendingViewTransitionEnabled) {
          let toPaths = appliedViewTransitions.get(state.location.pathname);
          if (toPaths) {
            toPaths.add(location.pathname);
          } else {
            toPaths = /* @__PURE__ */ new Set([location.pathname]);
            appliedViewTransitions.set(state.location.pathname, toPaths);
          }
          viewTransitionOpts = {
            currentLocation: state.location,
            nextLocation: location
          };
        }
        updateState(_extends$4({}, newState, {
          actionData,
          loaderData,
          historyAction: pendingAction,
          location,
          initialized: true,
          navigation: IDLE_NAVIGATION,
          revalidation: "idle",
          restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),
          preventScrollReset,
          blockers
        }), {
          viewTransitionOpts,
          flushSync: flushSync === true
        });
        pendingAction = Action.Pop;
        pendingPreventScrollReset = false;
        pendingViewTransitionEnabled = false;
        isUninterruptedRevalidation = false;
        isRevalidationRequired = false;
        cancelledDeferredRoutes = [];
        cancelledFetcherLoads = [];
      }
      async function navigate(to, opts) {
        if (typeof to === "number") {
          init.history.go(to);
          return;
        }
        let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, to, future.v7_relativeSplatPath, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative);
        let {
          path,
          submission,
          error
        } = normalizeNavigateOptions(future.v7_normalizeFormMethod, false, normalizedPath, opts);
        let currentLocation = state.location;
        let nextLocation = createLocation(state.location, path, opts && opts.state);
        nextLocation = _extends$4({}, nextLocation, init.history.encodeLocation(nextLocation));
        let userReplace = opts && opts.replace != null ? opts.replace : void 0;
        let historyAction = Action.Push;
        if (userReplace === true) {
          historyAction = Action.Replace;
        } else if (userReplace === false)
          ;
        else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {
          historyAction = Action.Replace;
        }
        let preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === true : void 0;
        let flushSync = (opts && opts.unstable_flushSync) === true;
        let blockerKey = shouldBlockNavigation({
          currentLocation,
          nextLocation,
          historyAction
        });
        if (blockerKey) {
          updateBlocker(blockerKey, {
            state: "blocked",
            location: nextLocation,
            proceed() {
              updateBlocker(blockerKey, {
                state: "proceeding",
                proceed: void 0,
                reset: void 0,
                location: nextLocation
              });
              navigate(to, opts);
            },
            reset() {
              let blockers = new Map(state.blockers);
              blockers.set(blockerKey, IDLE_BLOCKER);
              updateState({
                blockers
              });
            }
          });
          return;
        }
        return await startNavigation(historyAction, nextLocation, {
          submission,
          // Send through the formData serialization error if we have one so we can
          // render at the right error boundary after we match routes
          pendingError: error,
          preventScrollReset,
          replace: opts && opts.replace,
          enableViewTransition: opts && opts.unstable_viewTransition,
          flushSync
        });
      }
      function revalidate() {
        interruptActiveLoads();
        updateState({
          revalidation: "loading"
        });
        if (state.navigation.state === "submitting") {
          return;
        }
        if (state.navigation.state === "idle") {
          startNavigation(state.historyAction, state.location, {
            startUninterruptedRevalidation: true
          });
          return;
        }
        startNavigation(pendingAction || state.historyAction, state.navigation.location, {
          overrideNavigation: state.navigation
        });
      }
      async function startNavigation(historyAction, location, opts) {
        pendingNavigationController && pendingNavigationController.abort();
        pendingNavigationController = null;
        pendingAction = historyAction;
        isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;
        saveScrollPosition(state.location, state.matches);
        pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
        pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;
        let routesToUse = inFlightDataRoutes || dataRoutes;
        let loadingNavigation = opts && opts.overrideNavigation;
        let matches = matchRoutes(routesToUse, location, basename);
        let flushSync = (opts && opts.flushSync) === true;
        if (!matches) {
          let error = getInternalRouterError(404, {
            pathname: location.pathname
          });
          let {
            matches: notFoundMatches,
            route
          } = getShortCircuitMatches(routesToUse);
          cancelActiveDeferreds();
          completeNavigation(location, {
            matches: notFoundMatches,
            loaderData: {},
            errors: {
              [route.id]: error
            }
          }, {
            flushSync
          });
          return;
        }
        if (state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {
          completeNavigation(location, {
            matches
          }, {
            flushSync
          });
          return;
        }
        pendingNavigationController = new AbortController();
        let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);
        let pendingActionData;
        let pendingError;
        if (opts && opts.pendingError) {
          pendingError = {
            [findNearestBoundary(matches).route.id]: opts.pendingError
          };
        } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {
          let actionOutput = await handleAction(request, location, opts.submission, matches, {
            replace: opts.replace,
            flushSync
          });
          if (actionOutput.shortCircuited) {
            return;
          }
          pendingActionData = actionOutput.pendingActionData;
          pendingError = actionOutput.pendingActionError;
          loadingNavigation = getLoadingNavigation(location, opts.submission);
          flushSync = false;
          request = new Request(request.url, {
            signal: request.signal
          });
        }
        let {
          shortCircuited,
          loaderData,
          errors
        } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, opts && opts.initialHydration === true, flushSync, pendingActionData, pendingError);
        if (shortCircuited) {
          return;
        }
        pendingNavigationController = null;
        completeNavigation(location, _extends$4({
          matches
        }, pendingActionData ? {
          actionData: pendingActionData
        } : {}, {
          loaderData,
          errors
        }));
      }
      async function handleAction(request, location, submission, matches, opts) {
        if (opts === void 0) {
          opts = {};
        }
        interruptActiveLoads();
        let navigation = getSubmittingNavigation(location, submission);
        updateState({
          navigation
        }, {
          flushSync: opts.flushSync === true
        });
        let result;
        let actionMatch = getTargetMatch(matches, location);
        if (!actionMatch.route.action && !actionMatch.route.lazy) {
          result = {
            type: ResultType.error,
            error: getInternalRouterError(405, {
              method: request.method,
              pathname: location.pathname,
              routeId: actionMatch.route.id
            })
          };
        } else {
          result = await callLoaderOrAction("action", request, actionMatch, matches, manifest, mapRouteProperties2, basename, future.v7_relativeSplatPath);
          if (request.signal.aborted) {
            return {
              shortCircuited: true
            };
          }
        }
        if (isRedirectResult(result)) {
          let replace2;
          if (opts && opts.replace != null) {
            replace2 = opts.replace;
          } else {
            replace2 = result.location === state.location.pathname + state.location.search;
          }
          await startRedirectNavigation(state, result, {
            submission,
            replace: replace2
          });
          return {
            shortCircuited: true
          };
        }
        if (isErrorResult(result)) {
          let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);
          if ((opts && opts.replace) !== true) {
            pendingAction = Action.Push;
          }
          return {
            // Send back an empty object we can use to clear out any prior actionData
            pendingActionData: {},
            pendingActionError: {
              [boundaryMatch.route.id]: result.error
            }
          };
        }
        if (isDeferredResult(result)) {
          throw getInternalRouterError(400, {
            type: "defer-action"
          });
        }
        return {
          pendingActionData: {
            [actionMatch.route.id]: result.data
          }
        };
      }
      async function handleLoaders(request, location, matches, overrideNavigation, submission, fetcherSubmission, replace2, initialHydration, flushSync, pendingActionData, pendingError) {
        let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);
        let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);
        let routesToUse = inFlightDataRoutes || dataRoutes;
        let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, future.v7_partialHydration && initialHydration === true, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError);
        cancelActiveDeferreds((routeId) => !(matches && matches.some((m2) => m2.route.id === routeId)) || matchesToLoad && matchesToLoad.some((m2) => m2.route.id === routeId));
        pendingNavigationLoadId = ++incrementingLoadId;
        if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {
          let updatedFetchers2 = markFetchRedirectsDone();
          completeNavigation(location, _extends$4({
            matches,
            loaderData: {},
            // Commit pending error if we're short circuiting
            errors: pendingError || null
          }, pendingActionData ? {
            actionData: pendingActionData
          } : {}, updatedFetchers2 ? {
            fetchers: new Map(state.fetchers)
          } : {}), {
            flushSync
          });
          return {
            shortCircuited: true
          };
        }
        if (!isUninterruptedRevalidation && (!future.v7_partialHydration || !initialHydration)) {
          revalidatingFetchers.forEach((rf2) => {
            let fetcher = state.fetchers.get(rf2.key);
            let revalidatingFetcher = getLoadingFetcher(void 0, fetcher ? fetcher.data : void 0);
            state.fetchers.set(rf2.key, revalidatingFetcher);
          });
          let actionData = pendingActionData || state.actionData;
          updateState(_extends$4({
            navigation: loadingNavigation
          }, actionData ? Object.keys(actionData).length === 0 ? {
            actionData: null
          } : {
            actionData
          } : {}, revalidatingFetchers.length > 0 ? {
            fetchers: new Map(state.fetchers)
          } : {}), {
            flushSync
          });
        }
        revalidatingFetchers.forEach((rf2) => {
          if (fetchControllers.has(rf2.key)) {
            abortFetcher(rf2.key);
          }
          if (rf2.controller) {
            fetchControllers.set(rf2.key, rf2.controller);
          }
        });
        let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((f2) => abortFetcher(f2.key));
        if (pendingNavigationController) {
          pendingNavigationController.signal.addEventListener("abort", abortPendingFetchRevalidations);
        }
        let {
          results,
          loaderResults,
          fetcherResults
        } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);
        if (request.signal.aborted) {
          return {
            shortCircuited: true
          };
        }
        if (pendingNavigationController) {
          pendingNavigationController.signal.removeEventListener("abort", abortPendingFetchRevalidations);
        }
        revalidatingFetchers.forEach((rf2) => fetchControllers.delete(rf2.key));
        let redirect = findRedirect(results);
        if (redirect) {
          if (redirect.idx >= matchesToLoad.length) {
            let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;
            fetchRedirectIds.add(fetcherKey);
          }
          await startRedirectNavigation(state, redirect.result, {
            replace: replace2
          });
          return {
            shortCircuited: true
          };
        }
        let {
          loaderData,
          errors
        } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds);
        activeDeferreds.forEach((deferredData, routeId) => {
          deferredData.subscribe((aborted) => {
            if (aborted || deferredData.done) {
              activeDeferreds.delete(routeId);
            }
          });
        });
        let updatedFetchers = markFetchRedirectsDone();
        let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);
        let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;
        return _extends$4({
          loaderData,
          errors
        }, shouldUpdateFetchers ? {
          fetchers: new Map(state.fetchers)
        } : {});
      }
      function fetch2(key, routeId, href, opts) {
        if (isServer) {
          throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");
        }
        if (fetchControllers.has(key))
          abortFetcher(key);
        let flushSync = (opts && opts.unstable_flushSync) === true;
        let routesToUse = inFlightDataRoutes || dataRoutes;
        let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, href, future.v7_relativeSplatPath, routeId, opts == null ? void 0 : opts.relative);
        let matches = matchRoutes(routesToUse, normalizedPath, basename);
        if (!matches) {
          setFetcherError(key, routeId, getInternalRouterError(404, {
            pathname: normalizedPath
          }), {
            flushSync
          });
          return;
        }
        let {
          path,
          submission,
          error
        } = normalizeNavigateOptions(future.v7_normalizeFormMethod, true, normalizedPath, opts);
        if (error) {
          setFetcherError(key, routeId, error, {
            flushSync
          });
          return;
        }
        let match2 = getTargetMatch(matches, path);
        pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
        if (submission && isMutationMethod(submission.formMethod)) {
          handleFetcherAction(key, routeId, path, match2, matches, flushSync, submission);
          return;
        }
        fetchLoadMatches.set(key, {
          routeId,
          path
        });
        handleFetcherLoader(key, routeId, path, match2, matches, flushSync, submission);
      }
      async function handleFetcherAction(key, routeId, path, match2, requestMatches, flushSync, submission) {
        interruptActiveLoads();
        fetchLoadMatches.delete(key);
        if (!match2.route.action && !match2.route.lazy) {
          let error = getInternalRouterError(405, {
            method: submission.formMethod,
            pathname: path,
            routeId
          });
          setFetcherError(key, routeId, error, {
            flushSync
          });
          return;
        }
        let existingFetcher = state.fetchers.get(key);
        updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {
          flushSync
        });
        let abortController = new AbortController();
        let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);
        fetchControllers.set(key, abortController);
        let originatingLoadId = incrementingLoadId;
        let actionResult = await callLoaderOrAction("action", fetchRequest, match2, requestMatches, manifest, mapRouteProperties2, basename, future.v7_relativeSplatPath);
        if (fetchRequest.signal.aborted) {
          if (fetchControllers.get(key) === abortController) {
            fetchControllers.delete(key);
          }
          return;
        }
        if (future.v7_fetcherPersist && deletedFetchers.has(key)) {
          if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {
            updateFetcherState(key, getDoneFetcher(void 0));
            return;
          }
        } else {
          if (isRedirectResult(actionResult)) {
            fetchControllers.delete(key);
            if (pendingNavigationLoadId > originatingLoadId) {
              updateFetcherState(key, getDoneFetcher(void 0));
              return;
            } else {
              fetchRedirectIds.add(key);
              updateFetcherState(key, getLoadingFetcher(submission));
              return startRedirectNavigation(state, actionResult, {
                fetcherSubmission: submission
              });
            }
          }
          if (isErrorResult(actionResult)) {
            setFetcherError(key, routeId, actionResult.error);
            return;
          }
        }
        if (isDeferredResult(actionResult)) {
          throw getInternalRouterError(400, {
            type: "defer-action"
          });
        }
        let nextLocation = state.navigation.location || state.location;
        let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);
        let routesToUse = inFlightDataRoutes || dataRoutes;
        let matches = state.navigation.state !== "idle" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;
        invariant$1(matches, "Didn't find any matches after fetcher action");
        let loadId = ++incrementingLoadId;
        fetchReloadIds.set(key, loadId);
        let loadFetcher = getLoadingFetcher(submission, actionResult.data);
        state.fetchers.set(key, loadFetcher);
        let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(
          init.history,
          state,
          matches,
          submission,
          nextLocation,
          false,
          isRevalidationRequired,
          cancelledDeferredRoutes,
          cancelledFetcherLoads,
          deletedFetchers,
          fetchLoadMatches,
          fetchRedirectIds,
          routesToUse,
          basename,
          {
            [match2.route.id]: actionResult.data
          },
          void 0
          // No need to send through errors since we short circuit above
        );
        revalidatingFetchers.filter((rf2) => rf2.key !== key).forEach((rf2) => {
          let staleKey = rf2.key;
          let existingFetcher2 = state.fetchers.get(staleKey);
          let revalidatingFetcher = getLoadingFetcher(void 0, existingFetcher2 ? existingFetcher2.data : void 0);
          state.fetchers.set(staleKey, revalidatingFetcher);
          if (fetchControllers.has(staleKey)) {
            abortFetcher(staleKey);
          }
          if (rf2.controller) {
            fetchControllers.set(staleKey, rf2.controller);
          }
        });
        updateState({
          fetchers: new Map(state.fetchers)
        });
        let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((rf2) => abortFetcher(rf2.key));
        abortController.signal.addEventListener("abort", abortPendingFetchRevalidations);
        let {
          results,
          loaderResults,
          fetcherResults
        } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);
        if (abortController.signal.aborted) {
          return;
        }
        abortController.signal.removeEventListener("abort", abortPendingFetchRevalidations);
        fetchReloadIds.delete(key);
        fetchControllers.delete(key);
        revalidatingFetchers.forEach((r2) => fetchControllers.delete(r2.key));
        let redirect = findRedirect(results);
        if (redirect) {
          if (redirect.idx >= matchesToLoad.length) {
            let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;
            fetchRedirectIds.add(fetcherKey);
          }
          return startRedirectNavigation(state, redirect.result);
        }
        let {
          loaderData,
          errors
        } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, void 0, revalidatingFetchers, fetcherResults, activeDeferreds);
        if (state.fetchers.has(key)) {
          let doneFetcher = getDoneFetcher(actionResult.data);
          state.fetchers.set(key, doneFetcher);
        }
        abortStaleFetchLoads(loadId);
        if (state.navigation.state === "loading" && loadId > pendingNavigationLoadId) {
          invariant$1(pendingAction, "Expected pending action");
          pendingNavigationController && pendingNavigationController.abort();
          completeNavigation(state.navigation.location, {
            matches,
            loaderData,
            errors,
            fetchers: new Map(state.fetchers)
          });
        } else {
          updateState({
            errors,
            loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors),
            fetchers: new Map(state.fetchers)
          });
          isRevalidationRequired = false;
        }
      }
      async function handleFetcherLoader(key, routeId, path, match2, matches, flushSync, submission) {
        let existingFetcher = state.fetchers.get(key);
        updateFetcherState(key, getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : void 0), {
          flushSync
        });
        let abortController = new AbortController();
        let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);
        fetchControllers.set(key, abortController);
        let originatingLoadId = incrementingLoadId;
        let result = await callLoaderOrAction("loader", fetchRequest, match2, matches, manifest, mapRouteProperties2, basename, future.v7_relativeSplatPath);
        if (isDeferredResult(result)) {
          result = await resolveDeferredData(result, fetchRequest.signal, true) || result;
        }
        if (fetchControllers.get(key) === abortController) {
          fetchControllers.delete(key);
        }
        if (fetchRequest.signal.aborted) {
          return;
        }
        if (deletedFetchers.has(key)) {
          updateFetcherState(key, getDoneFetcher(void 0));
          return;
        }
        if (isRedirectResult(result)) {
          if (pendingNavigationLoadId > originatingLoadId) {
            updateFetcherState(key, getDoneFetcher(void 0));
            return;
          } else {
            fetchRedirectIds.add(key);
            await startRedirectNavigation(state, result);
            return;
          }
        }
        if (isErrorResult(result)) {
          setFetcherError(key, routeId, result.error);
          return;
        }
        invariant$1(!isDeferredResult(result), "Unhandled fetcher deferred data");
        updateFetcherState(key, getDoneFetcher(result.data));
      }
      async function startRedirectNavigation(state2, redirect, _temp2) {
        let {
          submission,
          fetcherSubmission,
          replace: replace2
        } = _temp2 === void 0 ? {} : _temp2;
        if (redirect.revalidate) {
          isRevalidationRequired = true;
        }
        let redirectLocation = createLocation(state2.location, redirect.location, {
          _isRedirect: true
        });
        invariant$1(redirectLocation, "Expected a location on the redirect navigation");
        if (isBrowser2) {
          let isDocumentReload = false;
          if (redirect.reloadDocument) {
            isDocumentReload = true;
          } else if (ABSOLUTE_URL_REGEX$1.test(redirect.location)) {
            const url = init.history.createURL(redirect.location);
            isDocumentReload = // Hard reload if it's an absolute URL to a new origin
            url.origin !== routerWindow.location.origin || // Hard reload if it's an absolute URL that does not match our basename
            stripBasename(url.pathname, basename) == null;
          }
          if (isDocumentReload) {
            if (replace2) {
              routerWindow.location.replace(redirect.location);
            } else {
              routerWindow.location.assign(redirect.location);
            }
            return;
          }
        }
        pendingNavigationController = null;
        let redirectHistoryAction = replace2 === true ? Action.Replace : Action.Push;
        let {
          formMethod,
          formAction,
          formEncType
        } = state2.navigation;
        if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {
          submission = getSubmissionFromNavigation(state2.navigation);
        }
        let activeSubmission = submission || fetcherSubmission;
        if (redirectPreserveMethodStatusCodes.has(redirect.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {
          await startNavigation(redirectHistoryAction, redirectLocation, {
            submission: _extends$4({}, activeSubmission, {
              formAction: redirect.location
            }),
            // Preserve this flag across redirects
            preventScrollReset: pendingPreventScrollReset
          });
        } else {
          let overrideNavigation = getLoadingNavigation(redirectLocation, submission);
          await startNavigation(redirectHistoryAction, redirectLocation, {
            overrideNavigation,
            // Send fetcher submissions through for shouldRevalidate
            fetcherSubmission,
            // Preserve this flag across redirects
            preventScrollReset: pendingPreventScrollReset
          });
        }
      }
      async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {
        let results = await Promise.all([...matchesToLoad.map((match2) => callLoaderOrAction("loader", request, match2, matches, manifest, mapRouteProperties2, basename, future.v7_relativeSplatPath)), ...fetchersToLoad.map((f2) => {
          if (f2.matches && f2.match && f2.controller) {
            return callLoaderOrAction("loader", createClientSideRequest(init.history, f2.path, f2.controller.signal), f2.match, f2.matches, manifest, mapRouteProperties2, basename, future.v7_relativeSplatPath);
          } else {
            let error = {
              type: ResultType.error,
              error: getInternalRouterError(404, {
                pathname: f2.path
              })
            };
            return error;
          }
        })]);
        let loaderResults = results.slice(0, matchesToLoad.length);
        let fetcherResults = results.slice(matchesToLoad.length);
        await Promise.all([resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, loaderResults.map(() => request.signal), false, state.loaderData), resolveDeferredResults(currentMatches, fetchersToLoad.map((f2) => f2.match), fetcherResults, fetchersToLoad.map((f2) => f2.controller ? f2.controller.signal : null), true)]);
        return {
          results,
          loaderResults,
          fetcherResults
        };
      }
      function interruptActiveLoads() {
        isRevalidationRequired = true;
        cancelledDeferredRoutes.push(...cancelActiveDeferreds());
        fetchLoadMatches.forEach((_2, key) => {
          if (fetchControllers.has(key)) {
            cancelledFetcherLoads.push(key);
            abortFetcher(key);
          }
        });
      }
      function updateFetcherState(key, fetcher, opts) {
        if (opts === void 0) {
          opts = {};
        }
        state.fetchers.set(key, fetcher);
        updateState({
          fetchers: new Map(state.fetchers)
        }, {
          flushSync: (opts && opts.flushSync) === true
        });
      }
      function setFetcherError(key, routeId, error, opts) {
        if (opts === void 0) {
          opts = {};
        }
        let boundaryMatch = findNearestBoundary(state.matches, routeId);
        deleteFetcher(key);
        updateState({
          errors: {
            [boundaryMatch.route.id]: error
          },
          fetchers: new Map(state.fetchers)
        }, {
          flushSync: (opts && opts.flushSync) === true
        });
      }
      function getFetcher(key) {
        if (future.v7_fetcherPersist) {
          activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);
          if (deletedFetchers.has(key)) {
            deletedFetchers.delete(key);
          }
        }
        return state.fetchers.get(key) || IDLE_FETCHER;
      }
      function deleteFetcher(key) {
        let fetcher = state.fetchers.get(key);
        if (fetchControllers.has(key) && !(fetcher && fetcher.state === "loading" && fetchReloadIds.has(key))) {
          abortFetcher(key);
        }
        fetchLoadMatches.delete(key);
        fetchReloadIds.delete(key);
        fetchRedirectIds.delete(key);
        deletedFetchers.delete(key);
        state.fetchers.delete(key);
      }
      function deleteFetcherAndUpdateState(key) {
        if (future.v7_fetcherPersist) {
          let count = (activeFetchers.get(key) || 0) - 1;
          if (count <= 0) {
            activeFetchers.delete(key);
            deletedFetchers.add(key);
          } else {
            activeFetchers.set(key, count);
          }
        } else {
          deleteFetcher(key);
        }
        updateState({
          fetchers: new Map(state.fetchers)
        });
      }
      function abortFetcher(key) {
        let controller = fetchControllers.get(key);
        invariant$1(controller, "Expected fetch controller: " + key);
        controller.abort();
        fetchControllers.delete(key);
      }
      function markFetchersDone(keys2) {
        for (let key of keys2) {
          let fetcher = getFetcher(key);
          let doneFetcher = getDoneFetcher(fetcher.data);
          state.fetchers.set(key, doneFetcher);
        }
      }
      function markFetchRedirectsDone() {
        let doneKeys = [];
        let updatedFetchers = false;
        for (let key of fetchRedirectIds) {
          let fetcher = state.fetchers.get(key);
          invariant$1(fetcher, "Expected fetcher: " + key);
          if (fetcher.state === "loading") {
            fetchRedirectIds.delete(key);
            doneKeys.push(key);
            updatedFetchers = true;
          }
        }
        markFetchersDone(doneKeys);
        return updatedFetchers;
      }
      function abortStaleFetchLoads(landedId) {
        let yeetedKeys = [];
        for (let [key, id2] of fetchReloadIds) {
          if (id2 < landedId) {
            let fetcher = state.fetchers.get(key);
            invariant$1(fetcher, "Expected fetcher: " + key);
            if (fetcher.state === "loading") {
              abortFetcher(key);
              fetchReloadIds.delete(key);
              yeetedKeys.push(key);
            }
          }
        }
        markFetchersDone(yeetedKeys);
        return yeetedKeys.length > 0;
      }
      function getBlocker(key, fn) {
        let blocker = state.blockers.get(key) || IDLE_BLOCKER;
        if (blockerFunctions.get(key) !== fn) {
          blockerFunctions.set(key, fn);
        }
        return blocker;
      }
      function deleteBlocker(key) {
        state.blockers.delete(key);
        blockerFunctions.delete(key);
      }
      function updateBlocker(key, newBlocker) {
        let blocker = state.blockers.get(key) || IDLE_BLOCKER;
        invariant$1(blocker.state === "unblocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "proceeding" || blocker.state === "blocked" && newBlocker.state === "unblocked" || blocker.state === "proceeding" && newBlocker.state === "unblocked", "Invalid blocker state transition: " + blocker.state + " -> " + newBlocker.state);
        let blockers = new Map(state.blockers);
        blockers.set(key, newBlocker);
        updateState({
          blockers
        });
      }
      function shouldBlockNavigation(_ref2) {
        let {
          currentLocation,
          nextLocation,
          historyAction
        } = _ref2;
        if (blockerFunctions.size === 0) {
          return;
        }
        if (blockerFunctions.size > 1) {
          warning(false, "A router only supports one blocker at a time");
        }
        let entries = Array.from(blockerFunctions.entries());
        let [blockerKey, blockerFunction] = entries[entries.length - 1];
        let blocker = state.blockers.get(blockerKey);
        if (blocker && blocker.state === "proceeding") {
          return;
        }
        if (blockerFunction({
          currentLocation,
          nextLocation,
          historyAction
        })) {
          return blockerKey;
        }
      }
      function cancelActiveDeferreds(predicate) {
        let cancelledRouteIds = [];
        activeDeferreds.forEach((dfd, routeId) => {
          if (!predicate || predicate(routeId)) {
            dfd.cancel();
            cancelledRouteIds.push(routeId);
            activeDeferreds.delete(routeId);
          }
        });
        return cancelledRouteIds;
      }
      function enableScrollRestoration(positions, getPosition, getKey) {
        savedScrollPositions = positions;
        getScrollPosition = getPosition;
        getScrollRestorationKey = getKey || null;
        if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {
          initialScrollRestored = true;
          let y2 = getSavedScrollPosition(state.location, state.matches);
          if (y2 != null) {
            updateState({
              restoreScrollPosition: y2
            });
          }
        }
        return () => {
          savedScrollPositions = null;
          getScrollPosition = null;
          getScrollRestorationKey = null;
        };
      }
      function getScrollKey(location, matches) {
        if (getScrollRestorationKey) {
          let key = getScrollRestorationKey(location, matches.map((m2) => convertRouteMatchToUiMatch(m2, state.loaderData)));
          return key || location.key;
        }
        return location.key;
      }
      function saveScrollPosition(location, matches) {
        if (savedScrollPositions && getScrollPosition) {
          let key = getScrollKey(location, matches);
          savedScrollPositions[key] = getScrollPosition();
        }
      }
      function getSavedScrollPosition(location, matches) {
        if (savedScrollPositions) {
          let key = getScrollKey(location, matches);
          let y2 = savedScrollPositions[key];
          if (typeof y2 === "number") {
            return y2;
          }
        }
        return null;
      }
      function _internalSetRoutes(newRoutes) {
        manifest = {};
        inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties2, void 0, manifest);
      }
      router = {
        get basename() {
          return basename;
        },
        get future() {
          return future;
        },
        get state() {
          return state;
        },
        get routes() {
          return dataRoutes;
        },
        get window() {
          return routerWindow;
        },
        initialize,
        subscribe,
        enableScrollRestoration,
        navigate,
        fetch: fetch2,
        revalidate,
        // Passthrough to history-aware createHref used by useHref so we get proper
        // hash-aware URLs in DOM paths
        createHref: (to) => init.history.createHref(to),
        encodeLocation: (to) => init.history.encodeLocation(to),
        getFetcher,
        deleteFetcher: deleteFetcherAndUpdateState,
        dispose,
        getBlocker,
        deleteBlocker,
        _internalFetchControllers: fetchControllers,
        _internalActiveDeferreds: activeDeferreds,
        // TODO: Remove setRoutes, it's temporary to avoid dealing with
        // updating the tree while validating the update algorithm.
        _internalSetRoutes
      };
      return router;
    }
    function isSubmissionNavigation(opts) {
      return opts != null && ("formData" in opts && opts.formData != null || "body" in opts && opts.body !== void 0);
    }
    function normalizeTo(location, matches, basename, prependBasename, to, v7_relativeSplatPath, fromRouteId, relative) {
      let contextualMatches;
      let activeRouteMatch;
      if (fromRouteId) {
        contextualMatches = [];
        for (let match2 of matches) {
          contextualMatches.push(match2);
          if (match2.route.id === fromRouteId) {
            activeRouteMatch = match2;
            break;
          }
        }
      } else {
        contextualMatches = matches;
        activeRouteMatch = matches[matches.length - 1];
      }
      let path = resolveTo(to ? to : ".", getResolveToMatches(contextualMatches, v7_relativeSplatPath), stripBasename(location.pathname, basename) || location.pathname, relative === "path");
      if (to == null) {
        path.search = location.search;
        path.hash = location.hash;
      }
      if ((to == null || to === "" || to === ".") && activeRouteMatch && activeRouteMatch.route.index && !hasNakedIndexQuery(path.search)) {
        path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
      }
      if (prependBasename && basename !== "/") {
        path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
      }
      return createPath(path);
    }
    function normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {
      if (!opts || !isSubmissionNavigation(opts)) {
        return {
          path
        };
      }
      if (opts.formMethod && !isValidMethod(opts.formMethod)) {
        return {
          path,
          error: getInternalRouterError(405, {
            method: opts.formMethod
          })
        };
      }
      let getInvalidBodyError = () => ({
        path,
        error: getInternalRouterError(400, {
          type: "invalid-body"
        })
      });
      let rawFormMethod = opts.formMethod || "get";
      let formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();
      let formAction = stripHashFromPath(path);
      if (opts.body !== void 0) {
        if (opts.formEncType === "text/plain") {
          if (!isMutationMethod(formMethod)) {
            return getInvalidBodyError();
          }
          let text = typeof opts.body === "string" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ? (
            // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data
            Array.from(opts.body.entries()).reduce((acc, _ref3) => {
              let [name, value] = _ref3;
              return "" + acc + name + "=" + value + "\n";
            }, "")
          ) : String(opts.body);
          return {
            path,
            submission: {
              formMethod,
              formAction,
              formEncType: opts.formEncType,
              formData: void 0,
              json: void 0,
              text
            }
          };
        } else if (opts.formEncType === "application/json") {
          if (!isMutationMethod(formMethod)) {
            return getInvalidBodyError();
          }
          try {
            let json = typeof opts.body === "string" ? JSON.parse(opts.body) : opts.body;
            return {
              path,
              submission: {
                formMethod,
                formAction,
                formEncType: opts.formEncType,
                formData: void 0,
                json,
                text: void 0
              }
            };
          } catch (e2) {
            return getInvalidBodyError();
          }
        }
      }
      invariant$1(typeof FormData === "function", "FormData is not available in this environment");
      let searchParams;
      let formData;
      if (opts.formData) {
        searchParams = convertFormDataToSearchParams(opts.formData);
        formData = opts.formData;
      } else if (opts.body instanceof FormData) {
        searchParams = convertFormDataToSearchParams(opts.body);
        formData = opts.body;
      } else if (opts.body instanceof URLSearchParams) {
        searchParams = opts.body;
        formData = convertSearchParamsToFormData(searchParams);
      } else if (opts.body == null) {
        searchParams = new URLSearchParams();
        formData = new FormData();
      } else {
        try {
          searchParams = new URLSearchParams(opts.body);
          formData = convertSearchParamsToFormData(searchParams);
        } catch (e2) {
          return getInvalidBodyError();
        }
      }
      let submission = {
        formMethod,
        formAction,
        formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",
        formData,
        json: void 0,
        text: void 0
      };
      if (isMutationMethod(submission.formMethod)) {
        return {
          path,
          submission
        };
      }
      let parsedPath = parsePath(path);
      if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {
        searchParams.append("index", "");
      }
      parsedPath.search = "?" + searchParams;
      return {
        path: createPath(parsedPath),
        submission
      };
    }
    function getLoaderMatchesUntilBoundary(matches, boundaryId) {
      let boundaryMatches = matches;
      if (boundaryId) {
        let index = matches.findIndex((m2) => m2.route.id === boundaryId);
        if (index >= 0) {
          boundaryMatches = matches.slice(0, index);
        }
      }
      return boundaryMatches;
    }
    function getMatchesToLoad(history, state, matches, submission, location, isInitialLoad, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError) {
      let actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : void 0;
      let currentUrl = history.createURL(state.location);
      let nextUrl = history.createURL(location);
      let boundaryId = pendingError ? Object.keys(pendingError)[0] : void 0;
      let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);
      let navigationMatches = boundaryMatches.filter((match2, index) => {
        let {
          route
        } = match2;
        if (route.lazy) {
          return true;
        }
        if (route.loader == null) {
          return false;
        }
        if (isInitialLoad) {
          if (route.loader.hydrate) {
            return true;
          }
          return state.loaderData[route.id] === void 0 && // Don't re-run if the loader ran and threw an error
          (!state.errors || state.errors[route.id] === void 0);
        }
        if (isNewLoader(state.loaderData, state.matches[index], match2) || cancelledDeferredRoutes.some((id2) => id2 === match2.route.id)) {
          return true;
        }
        let currentRouteMatch = state.matches[index];
        let nextRouteMatch = match2;
        return shouldRevalidateLoader(match2, _extends$4({
          currentUrl,
          currentParams: currentRouteMatch.params,
          nextUrl,
          nextParams: nextRouteMatch.params
        }, submission, {
          actionResult,
          defaultShouldRevalidate: (
            // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
            isRevalidationRequired || // Clicked the same link, resubmitted a GET form
            currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders
            currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)
          )
        }));
      });
      let revalidatingFetchers = [];
      fetchLoadMatches.forEach((f2, key) => {
        if (isInitialLoad || !matches.some((m2) => m2.route.id === f2.routeId) || deletedFetchers.has(key)) {
          return;
        }
        let fetcherMatches = matchRoutes(routesToUse, f2.path, basename);
        if (!fetcherMatches) {
          revalidatingFetchers.push({
            key,
            routeId: f2.routeId,
            path: f2.path,
            matches: null,
            match: null,
            controller: null
          });
          return;
        }
        let fetcher = state.fetchers.get(key);
        let fetcherMatch = getTargetMatch(fetcherMatches, f2.path);
        let shouldRevalidate = false;
        if (fetchRedirectIds.has(key)) {
          shouldRevalidate = false;
        } else if (cancelledFetcherLoads.includes(key)) {
          shouldRevalidate = true;
        } else if (fetcher && fetcher.state !== "idle" && fetcher.data === void 0) {
          shouldRevalidate = isRevalidationRequired;
        } else {
          shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends$4({
            currentUrl,
            currentParams: state.matches[state.matches.length - 1].params,
            nextUrl,
            nextParams: matches[matches.length - 1].params
          }, submission, {
            actionResult,
            defaultShouldRevalidate: isRevalidationRequired
          }));
        }
        if (shouldRevalidate) {
          revalidatingFetchers.push({
            key,
            routeId: f2.routeId,
            path: f2.path,
            matches: fetcherMatches,
            match: fetcherMatch,
            controller: new AbortController()
          });
        }
      });
      return [navigationMatches, revalidatingFetchers];
    }
    function isNewLoader(currentLoaderData, currentMatch, match2) {
      let isNew = (
        // [a] -> [a, b]
        !currentMatch || // [a, b] -> [a, c]
        match2.route.id !== currentMatch.route.id
      );
      let isMissingData = currentLoaderData[match2.route.id] === void 0;
      return isNew || isMissingData;
    }
    function isNewRouteInstance(currentMatch, match2) {
      let currentPath = currentMatch.route.path;
      return (
        // param change for this match, /users/123 -> /users/456
        currentMatch.pathname !== match2.pathname || // splat param changed, which is not present in match.path
        // e.g. /files/images/avatar.jpg -> files/finances.xls
        currentPath != null && currentPath.endsWith("*") && currentMatch.params["*"] !== match2.params["*"]
      );
    }
    function shouldRevalidateLoader(loaderMatch, arg) {
      if (loaderMatch.route.shouldRevalidate) {
        let routeChoice = loaderMatch.route.shouldRevalidate(arg);
        if (typeof routeChoice === "boolean") {
          return routeChoice;
        }
      }
      return arg.defaultShouldRevalidate;
    }
    async function loadLazyRouteModule(route, mapRouteProperties2, manifest) {
      if (!route.lazy) {
        return;
      }
      let lazyRoute = await route.lazy();
      if (!route.lazy) {
        return;
      }
      let routeToUpdate = manifest[route.id];
      invariant$1(routeToUpdate, "No route found in manifest");
      let routeUpdates = {};
      for (let lazyRouteProperty in lazyRoute) {
        let staticRouteValue = routeToUpdate[lazyRouteProperty];
        let isPropertyStaticallyDefined = staticRouteValue !== void 0 && // This property isn't static since it should always be updated based
        // on the route updates
        lazyRouteProperty !== "hasErrorBoundary";
        warning(!isPropertyStaticallyDefined, 'Route "' + routeToUpdate.id + '" has a static property "' + lazyRouteProperty + '" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property "' + lazyRouteProperty + '" will be ignored.'));
        if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {
          routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];
        }
      }
      Object.assign(routeToUpdate, routeUpdates);
      Object.assign(routeToUpdate, _extends$4({}, mapRouteProperties2(routeToUpdate), {
        lazy: void 0
      }));
    }
    async function callLoaderOrAction(type, request, match2, matches, manifest, mapRouteProperties2, basename, v7_relativeSplatPath, opts) {
      if (opts === void 0) {
        opts = {};
      }
      let resultType;
      let result;
      let onReject;
      let runHandler = (handler) => {
        let reject;
        let abortPromise = new Promise((_2, r2) => reject = r2);
        onReject = () => reject();
        request.signal.addEventListener("abort", onReject);
        return Promise.race([handler({
          request,
          params: match2.params,
          context: opts.requestContext
        }), abortPromise]);
      };
      try {
        let handler = match2.route[type];
        if (match2.route.lazy) {
          if (handler) {
            let handlerError;
            let values2 = await Promise.all([
              // If the handler throws, don't let it immediately bubble out,
              // since we need to let the lazy() execution finish so we know if this
              // route has a boundary that can handle the error
              runHandler(handler).catch((e2) => {
                handlerError = e2;
              }),
              loadLazyRouteModule(match2.route, mapRouteProperties2, manifest)
            ]);
            if (handlerError) {
              throw handlerError;
            }
            result = values2[0];
          } else {
            await loadLazyRouteModule(match2.route, mapRouteProperties2, manifest);
            handler = match2.route[type];
            if (handler) {
              result = await runHandler(handler);
            } else if (type === "action") {
              let url = new URL(request.url);
              let pathname = url.pathname + url.search;
              throw getInternalRouterError(405, {
                method: request.method,
                pathname,
                routeId: match2.route.id
              });
            } else {
              return {
                type: ResultType.data,
                data: void 0
              };
            }
          }
        } else if (!handler) {
          let url = new URL(request.url);
          let pathname = url.pathname + url.search;
          throw getInternalRouterError(404, {
            pathname
          });
        } else {
          result = await runHandler(handler);
        }
        invariant$1(result !== void 0, "You defined " + (type === "action" ? "an action" : "a loader") + " for route " + ('"' + match2.route.id + "\" but didn't return anything from your `" + type + "` ") + "function. Please return a value or `null`.");
      } catch (e2) {
        resultType = ResultType.error;
        result = e2;
      } finally {
        if (onReject) {
          request.signal.removeEventListener("abort", onReject);
        }
      }
      if (isResponse(result)) {
        let status = result.status;
        if (redirectStatusCodes.has(status)) {
          let location = result.headers.get("Location");
          invariant$1(location, "Redirects returned/thrown from loaders/actions must have a Location header");
          if (!ABSOLUTE_URL_REGEX$1.test(location)) {
            location = normalizeTo(new URL(request.url), matches.slice(0, matches.indexOf(match2) + 1), basename, true, location, v7_relativeSplatPath);
          } else if (!opts.isStaticRequest) {
            let currentUrl = new URL(request.url);
            let url = location.startsWith("//") ? new URL(currentUrl.protocol + location) : new URL(location);
            let isSameBasename = stripBasename(url.pathname, basename) != null;
            if (url.origin === currentUrl.origin && isSameBasename) {
              location = url.pathname + url.search + url.hash;
            }
          }
          if (opts.isStaticRequest) {
            result.headers.set("Location", location);
            throw result;
          }
          return {
            type: ResultType.redirect,
            status,
            location,
            revalidate: result.headers.get("X-Remix-Revalidate") !== null,
            reloadDocument: result.headers.get("X-Remix-Reload-Document") !== null
          };
        }
        if (opts.isRouteRequest) {
          let queryRouteResponse = {
            type: resultType === ResultType.error ? ResultType.error : ResultType.data,
            response: result
          };
          throw queryRouteResponse;
        }
        let data;
        try {
          let contentType = result.headers.get("Content-Type");
          if (contentType && /\bapplication\/json\b/.test(contentType)) {
            if (result.body == null) {
              data = null;
            } else {
              data = await result.json();
            }
          } else {
            data = await result.text();
          }
        } catch (e2) {
          return {
            type: ResultType.error,
            error: e2
          };
        }
        if (resultType === ResultType.error) {
          return {
            type: resultType,
            error: new ErrorResponseImpl(status, result.statusText, data),
            headers: result.headers
          };
        }
        return {
          type: ResultType.data,
          data,
          statusCode: result.status,
          headers: result.headers
        };
      }
      if (resultType === ResultType.error) {
        return {
          type: resultType,
          error: result
        };
      }
      if (isDeferredData(result)) {
        var _result$init, _result$init2;
        return {
          type: ResultType.deferred,
          deferredData: result,
          statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,
          headers: ((_result$init2 = result.init) == null ? void 0 : _result$init2.headers) && new Headers(result.init.headers)
        };
      }
      return {
        type: ResultType.data,
        data: result
      };
    }
    function createClientSideRequest(history, location, signal, submission) {
      let url = history.createURL(stripHashFromPath(location)).toString();
      let init = {
        signal
      };
      if (submission && isMutationMethod(submission.formMethod)) {
        let {
          formMethod,
          formEncType
        } = submission;
        init.method = formMethod.toUpperCase();
        if (formEncType === "application/json") {
          init.headers = new Headers({
            "Content-Type": formEncType
          });
          init.body = JSON.stringify(submission.json);
        } else if (formEncType === "text/plain") {
          init.body = submission.text;
        } else if (formEncType === "application/x-www-form-urlencoded" && submission.formData) {
          init.body = convertFormDataToSearchParams(submission.formData);
        } else {
          init.body = submission.formData;
        }
      }
      return new Request(url, init);
    }
    function convertFormDataToSearchParams(formData) {
      let searchParams = new URLSearchParams();
      for (let [key, value] of formData.entries()) {
        searchParams.append(key, typeof value === "string" ? value : value.name);
      }
      return searchParams;
    }
    function convertSearchParamsToFormData(searchParams) {
      let formData = new FormData();
      for (let [key, value] of searchParams.entries()) {
        formData.append(key, value);
      }
      return formData;
    }
    function processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {
      let loaderData = {};
      let errors = null;
      let statusCode;
      let foundError = false;
      let loaderHeaders = {};
      results.forEach((result, index) => {
        let id2 = matchesToLoad[index].route.id;
        invariant$1(!isRedirectResult(result), "Cannot handle redirect results in processLoaderData");
        if (isErrorResult(result)) {
          let boundaryMatch = findNearestBoundary(matches, id2);
          let error = result.error;
          if (pendingError) {
            error = Object.values(pendingError)[0];
            pendingError = void 0;
          }
          errors = errors || {};
          if (errors[boundaryMatch.route.id] == null) {
            errors[boundaryMatch.route.id] = error;
          }
          loaderData[id2] = void 0;
          if (!foundError) {
            foundError = true;
            statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;
          }
          if (result.headers) {
            loaderHeaders[id2] = result.headers;
          }
        } else {
          if (isDeferredResult(result)) {
            activeDeferreds.set(id2, result.deferredData);
            loaderData[id2] = result.deferredData.data;
          } else {
            loaderData[id2] = result.data;
          }
          if (result.statusCode != null && result.statusCode !== 200 && !foundError) {
            statusCode = result.statusCode;
          }
          if (result.headers) {
            loaderHeaders[id2] = result.headers;
          }
        }
      });
      if (pendingError) {
        errors = pendingError;
        loaderData[Object.keys(pendingError)[0]] = void 0;
      }
      return {
        loaderData,
        errors,
        statusCode: statusCode || 200,
        loaderHeaders
      };
    }
    function processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {
      let {
        loaderData,
        errors
      } = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds);
      for (let index = 0; index < revalidatingFetchers.length; index++) {
        let {
          key,
          match: match2,
          controller
        } = revalidatingFetchers[index];
        invariant$1(fetcherResults !== void 0 && fetcherResults[index] !== void 0, "Did not find corresponding fetcher result");
        let result = fetcherResults[index];
        if (controller && controller.signal.aborted) {
          continue;
        } else if (isErrorResult(result)) {
          let boundaryMatch = findNearestBoundary(state.matches, match2 == null ? void 0 : match2.route.id);
          if (!(errors && errors[boundaryMatch.route.id])) {
            errors = _extends$4({}, errors, {
              [boundaryMatch.route.id]: result.error
            });
          }
          state.fetchers.delete(key);
        } else if (isRedirectResult(result)) {
          invariant$1(false, "Unhandled fetcher revalidation redirect");
        } else if (isDeferredResult(result)) {
          invariant$1(false, "Unhandled fetcher deferred data");
        } else {
          let doneFetcher = getDoneFetcher(result.data);
          state.fetchers.set(key, doneFetcher);
        }
      }
      return {
        loaderData,
        errors
      };
    }
    function mergeLoaderData(loaderData, newLoaderData, matches, errors) {
      let mergedLoaderData = _extends$4({}, newLoaderData);
      for (let match2 of matches) {
        let id2 = match2.route.id;
        if (newLoaderData.hasOwnProperty(id2)) {
          if (newLoaderData[id2] !== void 0) {
            mergedLoaderData[id2] = newLoaderData[id2];
          }
        } else if (loaderData[id2] !== void 0 && match2.route.loader) {
          mergedLoaderData[id2] = loaderData[id2];
        }
        if (errors && errors.hasOwnProperty(id2)) {
          break;
        }
      }
      return mergedLoaderData;
    }
    function findNearestBoundary(matches, routeId) {
      let eligibleMatches = routeId ? matches.slice(0, matches.findIndex((m2) => m2.route.id === routeId) + 1) : [...matches];
      return eligibleMatches.reverse().find((m2) => m2.route.hasErrorBoundary === true) || matches[0];
    }
    function getShortCircuitMatches(routes) {
      let route = routes.length === 1 ? routes[0] : routes.find((r2) => r2.index || !r2.path || r2.path === "/") || {
        id: "__shim-error-route__"
      };
      return {
        matches: [{
          params: {},
          pathname: "",
          pathnameBase: "",
          route
        }],
        route
      };
    }
    function getInternalRouterError(status, _temp5) {
      let {
        pathname,
        routeId,
        method,
        type
      } = _temp5 === void 0 ? {} : _temp5;
      let statusText = "Unknown Server Error";
      let errorMessage = "Unknown @remix-run/router error";
      if (status === 400) {
        statusText = "Bad Request";
        if (method && pathname && routeId) {
          errorMessage = "You made a " + method + ' request to "' + pathname + '" but ' + ('did not provide a `loader` for route "' + routeId + '", ') + "so there is no way to handle the request.";
        } else if (type === "defer-action") {
          errorMessage = "defer() is not supported in actions";
        } else if (type === "invalid-body") {
          errorMessage = "Unable to encode submission body";
        }
      } else if (status === 403) {
        statusText = "Forbidden";
        errorMessage = 'Route "' + routeId + '" does not match URL "' + pathname + '"';
      } else if (status === 404) {
        statusText = "Not Found";
        errorMessage = 'No route matches URL "' + pathname + '"';
      } else if (status === 405) {
        statusText = "Method Not Allowed";
        if (method && pathname && routeId) {
          errorMessage = "You made a " + method.toUpperCase() + ' request to "' + pathname + '" but ' + ('did not provide an `action` for route "' + routeId + '", ') + "so there is no way to handle the request.";
        } else if (method) {
          errorMessage = 'Invalid request method "' + method.toUpperCase() + '"';
        }
      }
      return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);
    }
    function findRedirect(results) {
      for (let i = results.length - 1; i >= 0; i--) {
        let result = results[i];
        if (isRedirectResult(result)) {
          return {
            result,
            idx: i
          };
        }
      }
    }
    function stripHashFromPath(path) {
      let parsedPath = typeof path === "string" ? parsePath(path) : path;
      return createPath(_extends$4({}, parsedPath, {
        hash: ""
      }));
    }
    function isHashChangeOnly(a, b2) {
      if (a.pathname !== b2.pathname || a.search !== b2.search) {
        return false;
      }
      if (a.hash === "") {
        return b2.hash !== "";
      } else if (a.hash === b2.hash) {
        return true;
      } else if (b2.hash !== "") {
        return true;
      }
      return false;
    }
    function isDeferredResult(result) {
      return result.type === ResultType.deferred;
    }
    function isErrorResult(result) {
      return result.type === ResultType.error;
    }
    function isRedirectResult(result) {
      return (result && result.type) === ResultType.redirect;
    }
    function isDeferredData(value) {
      let deferred = value;
      return deferred && typeof deferred === "object" && typeof deferred.data === "object" && typeof deferred.subscribe === "function" && typeof deferred.cancel === "function" && typeof deferred.resolveData === "function";
    }
    function isResponse(value) {
      return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
    }
    function isValidMethod(method) {
      return validRequestMethods.has(method.toLowerCase());
    }
    function isMutationMethod(method) {
      return validMutationMethods.has(method.toLowerCase());
    }
    async function resolveDeferredResults(currentMatches, matchesToLoad, results, signals, isFetcher, currentLoaderData) {
      for (let index = 0; index < results.length; index++) {
        let result = results[index];
        let match2 = matchesToLoad[index];
        if (!match2) {
          continue;
        }
        let currentMatch = currentMatches.find((m2) => m2.route.id === match2.route.id);
        let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match2) && (currentLoaderData && currentLoaderData[match2.route.id]) !== void 0;
        if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {
          let signal = signals[index];
          invariant$1(signal, "Expected an AbortSignal for revalidating fetcher deferred result");
          await resolveDeferredData(result, signal, isFetcher).then((result2) => {
            if (result2) {
              results[index] = result2 || results[index];
            }
          });
        }
      }
    }
    async function resolveDeferredData(result, signal, unwrap) {
      if (unwrap === void 0) {
        unwrap = false;
      }
      let aborted = await result.deferredData.resolveData(signal);
      if (aborted) {
        return;
      }
      if (unwrap) {
        try {
          return {
            type: ResultType.data,
            data: result.deferredData.unwrappedData
          };
        } catch (e2) {
          return {
            type: ResultType.error,
            error: e2
          };
        }
      }
      return {
        type: ResultType.data,
        data: result.deferredData.data
      };
    }
    function hasNakedIndexQuery(search) {
      return new URLSearchParams(search).getAll("index").some((v2) => v2 === "");
    }
    function getTargetMatch(matches, location) {
      let search = typeof location === "string" ? parsePath(location).search : location.search;
      if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || "")) {
        return matches[matches.length - 1];
      }
      let pathMatches = getPathContributingMatches(matches);
      return pathMatches[pathMatches.length - 1];
    }
    function getSubmissionFromNavigation(navigation) {
      let {
        formMethod,
        formAction,
        formEncType,
        text,
        formData,
        json
      } = navigation;
      if (!formMethod || !formAction || !formEncType) {
        return;
      }
      if (text != null) {
        return {
          formMethod,
          formAction,
          formEncType,
          formData: void 0,
          json: void 0,
          text
        };
      } else if (formData != null) {
        return {
          formMethod,
          formAction,
          formEncType,
          formData,
          json: void 0,
          text: void 0
        };
      } else if (json !== void 0) {
        return {
          formMethod,
          formAction,
          formEncType,
          formData: void 0,
          json,
          text: void 0
        };
      }
    }
    function getLoadingNavigation(location, submission) {
      if (submission) {
        let navigation = {
          state: "loading",
          location,
          formMethod: submission.formMethod,
          formAction: submission.formAction,
          formEncType: submission.formEncType,
          formData: submission.formData,
          json: submission.json,
          text: submission.text
        };
        return navigation;
      } else {
        let navigation = {
          state: "loading",
          location,
          formMethod: void 0,
          formAction: void 0,
          formEncType: void 0,
          formData: void 0,
          json: void 0,
          text: void 0
        };
        return navigation;
      }
    }
    function getSubmittingNavigation(location, submission) {
      let navigation = {
        state: "submitting",
        location,
        formMethod: submission.formMethod,
        formAction: submission.formAction,
        formEncType: submission.formEncType,
        formData: submission.formData,
        json: submission.json,
        text: submission.text
      };
      return navigation;
    }
    function getLoadingFetcher(submission, data) {
      if (submission) {
        let fetcher = {
          state: "loading",
          formMethod: submission.formMethod,
          formAction: submission.formAction,
          formEncType: submission.formEncType,
          formData: submission.formData,
          json: submission.json,
          text: submission.text,
          data
        };
        return fetcher;
      } else {
        let fetcher = {
          state: "loading",
          formMethod: void 0,
          formAction: void 0,
          formEncType: void 0,
          formData: void 0,
          json: void 0,
          text: void 0,
          data
        };
        return fetcher;
      }
    }
    function getSubmittingFetcher(submission, existingFetcher) {
      let fetcher = {
        state: "submitting",
        formMethod: submission.formMethod,
        formAction: submission.formAction,
        formEncType: submission.formEncType,
        formData: submission.formData,
        json: submission.json,
        text: submission.text,
        data: existingFetcher ? existingFetcher.data : void 0
      };
      return fetcher;
    }
    function getDoneFetcher(data) {
      let fetcher = {
        state: "idle",
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0,
        data
      };
      return fetcher;
    }
    function restoreAppliedTransitions(_window, transitions) {
      try {
        let sessionPositions = _window.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);
        if (sessionPositions) {
          let json = JSON.parse(sessionPositions);
          for (let [k2, v2] of Object.entries(json || {})) {
            if (v2 && Array.isArray(v2)) {
              transitions.set(k2, new Set(v2 || []));
            }
          }
        }
      } catch (e2) {
      }
    }
    function persistAppliedTransitions(_window, transitions) {
      if (transitions.size > 0) {
        let json = {};
        for (let [k2, v2] of transitions) {
          json[k2] = [...v2];
        }
        try {
          _window.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(json));
        } catch (error) {
          warning(false, "Failed to save applied view transitions in sessionStorage (" + error + ").");
        }
      }
    }
    /**
     * React Router v6.22.0
     *
     * Copyright (c) Remix Software Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    function _extends$3() {
      _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends$3.apply(this, arguments);
    }
    const DataRouterContext = /* @__PURE__ */ reactExports.createContext(null);
    const DataRouterStateContext = /* @__PURE__ */ reactExports.createContext(null);
    const NavigationContext = /* @__PURE__ */ reactExports.createContext(null);
    const LocationContext = /* @__PURE__ */ reactExports.createContext(null);
    const RouteContext = /* @__PURE__ */ reactExports.createContext({
      outlet: null,
      matches: [],
      isDataRoute: false
    });
    const RouteErrorContext = /* @__PURE__ */ reactExports.createContext(null);
    function useHref(to, _temp) {
      let {
        relative
      } = _temp === void 0 ? {} : _temp;
      !useInRouterContext() ? invariant$1(false) : void 0;
      let {
        basename,
        navigator: navigator2
      } = reactExports.useContext(NavigationContext);
      let {
        hash: hash2,
        pathname,
        search
      } = useResolvedPath(to, {
        relative
      });
      let joinedPathname = pathname;
      if (basename !== "/") {
        joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
      }
      return navigator2.createHref({
        pathname: joinedPathname,
        search,
        hash: hash2
      });
    }
    function useInRouterContext() {
      return reactExports.useContext(LocationContext) != null;
    }
    function useLocation() {
      !useInRouterContext() ? invariant$1(false) : void 0;
      return reactExports.useContext(LocationContext).location;
    }
    function useIsomorphicLayoutEffect$1(cb2) {
      let isStatic = reactExports.useContext(NavigationContext).static;
      if (!isStatic) {
        reactExports.useLayoutEffect(cb2);
      }
    }
    function useNavigate() {
      let {
        isDataRoute
      } = reactExports.useContext(RouteContext);
      return isDataRoute ? useNavigateStable() : useNavigateUnstable();
    }
    function useNavigateUnstable() {
      !useInRouterContext() ? invariant$1(false) : void 0;
      let dataRouterContext = reactExports.useContext(DataRouterContext);
      let {
        basename,
        future,
        navigator: navigator2
      } = reactExports.useContext(NavigationContext);
      let {
        matches
      } = reactExports.useContext(RouteContext);
      let {
        pathname: locationPathname
      } = useLocation();
      let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));
      let activeRef = reactExports.useRef(false);
      useIsomorphicLayoutEffect$1(() => {
        activeRef.current = true;
      });
      let navigate = reactExports.useCallback(function(to, options) {
        if (options === void 0) {
          options = {};
        }
        if (!activeRef.current)
          return;
        if (typeof to === "number") {
          navigator2.go(to);
          return;
        }
        let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
        if (dataRouterContext == null && basename !== "/") {
          path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
        }
        (!!options.replace ? navigator2.replace : navigator2.push)(path, options.state, options);
      }, [basename, navigator2, routePathnamesJson, locationPathname, dataRouterContext]);
      return navigate;
    }
    const OutletContext = /* @__PURE__ */ reactExports.createContext(null);
    function useOutlet(context) {
      let outlet = reactExports.useContext(RouteContext).outlet;
      if (outlet) {
        return /* @__PURE__ */ reactExports.createElement(OutletContext.Provider, {
          value: context
        }, outlet);
      }
      return outlet;
    }
    function useParams() {
      let {
        matches
      } = reactExports.useContext(RouteContext);
      let routeMatch = matches[matches.length - 1];
      return routeMatch ? routeMatch.params : {};
    }
    function useResolvedPath(to, _temp2) {
      let {
        relative
      } = _temp2 === void 0 ? {} : _temp2;
      let {
        future
      } = reactExports.useContext(NavigationContext);
      let {
        matches
      } = reactExports.useContext(RouteContext);
      let {
        pathname: locationPathname
      } = useLocation();
      let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));
      return reactExports.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
    }
    function useRoutesImpl(routes, locationArg, dataRouterState, future) {
      !useInRouterContext() ? invariant$1(false) : void 0;
      let {
        navigator: navigator2
      } = reactExports.useContext(NavigationContext);
      let {
        matches: parentMatches
      } = reactExports.useContext(RouteContext);
      let routeMatch = parentMatches[parentMatches.length - 1];
      let parentParams = routeMatch ? routeMatch.params : {};
      routeMatch ? routeMatch.pathname : "/";
      let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
      routeMatch && routeMatch.route;
      let locationFromContext = useLocation();
      let location;
      if (locationArg) {
        var _parsedLocationArg$pa;
        let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
        !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant$1(false) : void 0;
        location = parsedLocationArg;
      } else {
        location = locationFromContext;
      }
      let pathname = location.pathname || "/";
      let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
      let matches = matchRoutes(routes, {
        pathname: remainingPathname
      });
      let renderedMatches = _renderMatches(matches && matches.map((match2) => Object.assign({}, match2, {
        params: Object.assign({}, parentParams, match2.params),
        pathname: joinPaths([
          parentPathnameBase,
          // Re-encode pathnames that were decoded inside matchRoutes
          navigator2.encodeLocation ? navigator2.encodeLocation(match2.pathname).pathname : match2.pathname
        ]),
        pathnameBase: match2.pathnameBase === "/" ? parentPathnameBase : joinPaths([
          parentPathnameBase,
          // Re-encode pathnames that were decoded inside matchRoutes
          navigator2.encodeLocation ? navigator2.encodeLocation(match2.pathnameBase).pathname : match2.pathnameBase
        ])
      })), parentMatches, dataRouterState, future);
      if (locationArg && renderedMatches) {
        return /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
          value: {
            location: _extends$3({
              pathname: "/",
              search: "",
              hash: "",
              state: null,
              key: "default"
            }, location),
            navigationType: Action.Pop
          }
        }, renderedMatches);
      }
      return renderedMatches;
    }
    function DefaultErrorComponent() {
      let error = useRouteError();
      let message = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
      let stack = error instanceof Error ? error.stack : null;
      let lightgrey = "rgba(200,200,200, 0.5)";
      let preStyles = {
        padding: "0.5rem",
        backgroundColor: lightgrey
      };
      let devInfo = null;
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ reactExports.createElement("h3", {
        style: {
          fontStyle: "italic"
        }
      }, message), stack ? /* @__PURE__ */ reactExports.createElement("pre", {
        style: preStyles
      }, stack) : null, devInfo);
    }
    const defaultErrorElement = /* @__PURE__ */ reactExports.createElement(DefaultErrorComponent, null);
    class RenderErrorBoundary extends reactExports.Component {
      constructor(props) {
        super(props);
        this.state = {
          location: props.location,
          revalidation: props.revalidation,
          error: props.error
        };
      }
      static getDerivedStateFromError(error) {
        return {
          error
        };
      }
      static getDerivedStateFromProps(props, state) {
        if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
          return {
            error: props.error,
            location: props.location,
            revalidation: props.revalidation
          };
        }
        return {
          error: props.error !== void 0 ? props.error : state.error,
          location: state.location,
          revalidation: props.revalidation || state.revalidation
        };
      }
      componentDidCatch(error, errorInfo) {
        console.error("React Router caught the following error during render", error, errorInfo);
      }
      render() {
        return this.state.error !== void 0 ? /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
          value: this.props.routeContext
        }, /* @__PURE__ */ reactExports.createElement(RouteErrorContext.Provider, {
          value: this.state.error,
          children: this.props.component
        })) : this.props.children;
      }
    }
    function RenderedRoute(_ref) {
      let {
        routeContext,
        match: match2,
        children
      } = _ref;
      let dataRouterContext = reactExports.useContext(DataRouterContext);
      if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match2.route.errorElement || match2.route.ErrorBoundary)) {
        dataRouterContext.staticContext._deepestRenderedBoundaryId = match2.route.id;
      }
      return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
        value: routeContext
      }, children);
    }
    function _renderMatches(matches, parentMatches, dataRouterState, future) {
      var _dataRouterState2;
      if (parentMatches === void 0) {
        parentMatches = [];
      }
      if (dataRouterState === void 0) {
        dataRouterState = null;
      }
      if (future === void 0) {
        future = null;
      }
      if (matches == null) {
        var _dataRouterState;
        if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {
          matches = dataRouterState.matches;
        } else {
          return null;
        }
      }
      let renderedMatches = matches;
      let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;
      if (errors != null) {
        let errorIndex = renderedMatches.findIndex((m2) => m2.route.id && (errors == null ? void 0 : errors[m2.route.id]));
        !(errorIndex >= 0) ? invariant$1(false) : void 0;
        renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
      }
      let renderFallback = false;
      let fallbackIndex = -1;
      if (dataRouterState && future && future.v7_partialHydration) {
        for (let i = 0; i < renderedMatches.length; i++) {
          let match2 = renderedMatches[i];
          if (match2.route.HydrateFallback || match2.route.hydrateFallbackElement) {
            fallbackIndex = i;
          }
          if (match2.route.id) {
            let {
              loaderData,
              errors: errors2
            } = dataRouterState;
            let needsToRunLoader = match2.route.loader && loaderData[match2.route.id] === void 0 && (!errors2 || errors2[match2.route.id] === void 0);
            if (match2.route.lazy || needsToRunLoader) {
              renderFallback = true;
              if (fallbackIndex >= 0) {
                renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
              } else {
                renderedMatches = [renderedMatches[0]];
              }
              break;
            }
          }
        }
      }
      return renderedMatches.reduceRight((outlet, match2, index) => {
        let error;
        let shouldRenderHydrateFallback = false;
        let errorElement = null;
        let hydrateFallbackElement = null;
        if (dataRouterState) {
          error = errors && match2.route.id ? errors[match2.route.id] : void 0;
          errorElement = match2.route.errorElement || defaultErrorElement;
          if (renderFallback) {
            if (fallbackIndex < 0 && index === 0) {
              warningOnce("route-fallback", false);
              shouldRenderHydrateFallback = true;
              hydrateFallbackElement = null;
            } else if (fallbackIndex === index) {
              shouldRenderHydrateFallback = true;
              hydrateFallbackElement = match2.route.hydrateFallbackElement || null;
            }
          }
        }
        let matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1));
        let getChildren = () => {
          let children;
          if (error) {
            children = errorElement;
          } else if (shouldRenderHydrateFallback) {
            children = hydrateFallbackElement;
          } else if (match2.route.Component) {
            children = /* @__PURE__ */ reactExports.createElement(match2.route.Component, null);
          } else if (match2.route.element) {
            children = match2.route.element;
          } else {
            children = outlet;
          }
          return /* @__PURE__ */ reactExports.createElement(RenderedRoute, {
            match: match2,
            routeContext: {
              outlet,
              matches: matches2,
              isDataRoute: dataRouterState != null
            },
            children
          });
        };
        return dataRouterState && (match2.route.ErrorBoundary || match2.route.errorElement || index === 0) ? /* @__PURE__ */ reactExports.createElement(RenderErrorBoundary, {
          location: dataRouterState.location,
          revalidation: dataRouterState.revalidation,
          component: errorElement,
          error,
          children: getChildren(),
          routeContext: {
            outlet: null,
            matches: matches2,
            isDataRoute: true
          }
        }) : getChildren();
      }, null);
    }
    var DataRouterHook$1 = /* @__PURE__ */ function(DataRouterHook2) {
      DataRouterHook2["UseBlocker"] = "useBlocker";
      DataRouterHook2["UseRevalidator"] = "useRevalidator";
      DataRouterHook2["UseNavigateStable"] = "useNavigate";
      return DataRouterHook2;
    }(DataRouterHook$1 || {});
    var DataRouterStateHook$1 = /* @__PURE__ */ function(DataRouterStateHook2) {
      DataRouterStateHook2["UseBlocker"] = "useBlocker";
      DataRouterStateHook2["UseLoaderData"] = "useLoaderData";
      DataRouterStateHook2["UseActionData"] = "useActionData";
      DataRouterStateHook2["UseRouteError"] = "useRouteError";
      DataRouterStateHook2["UseNavigation"] = "useNavigation";
      DataRouterStateHook2["UseRouteLoaderData"] = "useRouteLoaderData";
      DataRouterStateHook2["UseMatches"] = "useMatches";
      DataRouterStateHook2["UseRevalidator"] = "useRevalidator";
      DataRouterStateHook2["UseNavigateStable"] = "useNavigate";
      DataRouterStateHook2["UseRouteId"] = "useRouteId";
      return DataRouterStateHook2;
    }(DataRouterStateHook$1 || {});
    function useDataRouterContext(hookName) {
      let ctx = reactExports.useContext(DataRouterContext);
      !ctx ? invariant$1(false) : void 0;
      return ctx;
    }
    function useDataRouterState(hookName) {
      let state = reactExports.useContext(DataRouterStateContext);
      !state ? invariant$1(false) : void 0;
      return state;
    }
    function useRouteContext(hookName) {
      let route = reactExports.useContext(RouteContext);
      !route ? invariant$1(false) : void 0;
      return route;
    }
    function useCurrentRouteId(hookName) {
      let route = useRouteContext();
      let thisRoute = route.matches[route.matches.length - 1];
      !thisRoute.route.id ? invariant$1(false) : void 0;
      return thisRoute.route.id;
    }
    function useRouteError() {
      var _state$errors;
      let error = reactExports.useContext(RouteErrorContext);
      let state = useDataRouterState(DataRouterStateHook$1.UseRouteError);
      let routeId = useCurrentRouteId(DataRouterStateHook$1.UseRouteError);
      if (error !== void 0) {
        return error;
      }
      return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
    }
    function useNavigateStable() {
      let {
        router
      } = useDataRouterContext(DataRouterHook$1.UseNavigateStable);
      let id2 = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable);
      let activeRef = reactExports.useRef(false);
      useIsomorphicLayoutEffect$1(() => {
        activeRef.current = true;
      });
      let navigate = reactExports.useCallback(function(to, options) {
        if (options === void 0) {
          options = {};
        }
        if (!activeRef.current)
          return;
        if (typeof to === "number") {
          router.navigate(to);
        } else {
          router.navigate(to, _extends$3({
            fromRouteId: id2
          }, options));
        }
      }, [router, id2]);
      return navigate;
    }
    const alreadyWarned = {};
    function warningOnce(key, cond, message) {
      if (!cond && !alreadyWarned[key]) {
        alreadyWarned[key] = true;
      }
    }
    function Navigate(_ref4) {
      let {
        to,
        replace: replace2,
        state,
        relative
      } = _ref4;
      !useInRouterContext() ? invariant$1(false) : void 0;
      let {
        future,
        static: isStatic
      } = reactExports.useContext(NavigationContext);
      let {
        matches
      } = reactExports.useContext(RouteContext);
      let {
        pathname: locationPathname
      } = useLocation();
      let navigate = useNavigate();
      let path = resolveTo(to, getResolveToMatches(matches, future.v7_relativeSplatPath), locationPathname, relative === "path");
      let jsonPath = JSON.stringify(path);
      reactExports.useEffect(() => navigate(JSON.parse(jsonPath), {
        replace: replace2,
        state,
        relative
      }), [navigate, jsonPath, relative, replace2, state]);
      return null;
    }
    function Outlet(props) {
      return useOutlet(props.context);
    }
    function Router(_ref5) {
      let {
        basename: basenameProp = "/",
        children = null,
        location: locationProp,
        navigationType = Action.Pop,
        navigator: navigator2,
        static: staticProp = false,
        future
      } = _ref5;
      !!useInRouterContext() ? invariant$1(false) : void 0;
      let basename = basenameProp.replace(/^\/*/, "/");
      let navigationContext = reactExports.useMemo(() => ({
        basename,
        navigator: navigator2,
        static: staticProp,
        future: _extends$3({
          v7_relativeSplatPath: false
        }, future)
      }), [basename, future, navigator2, staticProp]);
      if (typeof locationProp === "string") {
        locationProp = parsePath(locationProp);
      }
      let {
        pathname = "/",
        search = "",
        hash: hash2 = "",
        state = null,
        key = "default"
      } = locationProp;
      let locationContext = reactExports.useMemo(() => {
        let trailingPathname = stripBasename(pathname, basename);
        if (trailingPathname == null) {
          return null;
        }
        return {
          location: {
            pathname: trailingPathname,
            search,
            hash: hash2,
            state,
            key
          },
          navigationType
        };
      }, [basename, pathname, search, hash2, state, key, navigationType]);
      if (locationContext == null) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, {
        value: navigationContext
      }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
        children,
        value: locationContext
      }));
    }
    new Promise(() => {
    });
    function mapRouteProperties(route) {
      let updates = {
        // Note: this check also occurs in createRoutesFromChildren so update
        // there if you change this -- please and thank you!
        hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null
      };
      if (route.Component) {
        Object.assign(updates, {
          element: /* @__PURE__ */ reactExports.createElement(route.Component),
          Component: void 0
        });
      }
      if (route.HydrateFallback) {
        Object.assign(updates, {
          hydrateFallbackElement: /* @__PURE__ */ reactExports.createElement(route.HydrateFallback),
          HydrateFallback: void 0
        });
      }
      if (route.ErrorBoundary) {
        Object.assign(updates, {
          errorElement: /* @__PURE__ */ reactExports.createElement(route.ErrorBoundary),
          ErrorBoundary: void 0
        });
      }
      return updates;
    }
    /**
     * React Router DOM v6.22.0
     *
     * Copyright (c) Remix Software Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    function _extends$2() {
      _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends$2.apply(this, arguments);
    }
    function _objectWithoutPropertiesLoose$2(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function isModifiedEvent(event) {
      return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
    }
    function shouldProcessLinkClick(event, target) {
      return event.button === 0 && // Ignore everything but left clicks
      (!target || target === "_self") && // Let browser handle "target=_blank" etc.
      !isModifiedEvent(event);
    }
    const _excluded$1e = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "unstable_viewTransition"];
    const REACT_ROUTER_VERSION = "6";
    try {
      window.__reactRouterVersion = REACT_ROUTER_VERSION;
    } catch (e2) {
    }
    function createBrowserRouter(routes, opts) {
      return createRouter({
        basename: opts == null ? void 0 : opts.basename,
        future: _extends$2({}, opts == null ? void 0 : opts.future, {
          v7_prependBasename: true
        }),
        history: createBrowserHistory({
          window: opts == null ? void 0 : opts.window
        }),
        hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),
        routes,
        mapRouteProperties,
        window: opts == null ? void 0 : opts.window
      }).initialize();
    }
    function parseHydrationData() {
      var _window;
      let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;
      if (state && state.errors) {
        state = _extends$2({}, state, {
          errors: deserializeErrors(state.errors)
        });
      }
      return state;
    }
    function deserializeErrors(errors) {
      if (!errors)
        return null;
      let entries = Object.entries(errors);
      let serialized = {};
      for (let [key, val] of entries) {
        if (val && val.__type === "RouteErrorResponse") {
          serialized[key] = new ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);
        } else if (val && val.__type === "Error") {
          if (val.__subType) {
            let ErrorConstructor = window[val.__subType];
            if (typeof ErrorConstructor === "function") {
              try {
                let error = new ErrorConstructor(val.message);
                error.stack = "";
                serialized[key] = error;
              } catch (e2) {
              }
            }
          }
          if (serialized[key] == null) {
            let error = new Error(val.message);
            error.stack = "";
            serialized[key] = error;
          }
        } else {
          serialized[key] = val;
        }
      }
      return serialized;
    }
    const ViewTransitionContext = /* @__PURE__ */ reactExports.createContext({
      isTransitioning: false
    });
    const FetchersContext = /* @__PURE__ */ reactExports.createContext(/* @__PURE__ */ new Map());
    const START_TRANSITION = "startTransition";
    const startTransitionImpl = React$1[START_TRANSITION];
    const FLUSH_SYNC = "flushSync";
    const flushSyncImpl = ReactDOM$1[FLUSH_SYNC];
    function startTransitionSafe(cb2) {
      if (startTransitionImpl) {
        startTransitionImpl(cb2);
      } else {
        cb2();
      }
    }
    function flushSyncSafe(cb2) {
      if (flushSyncImpl) {
        flushSyncImpl(cb2);
      } else {
        cb2();
      }
    }
    class Deferred {
      constructor() {
        this.status = "pending";
        this.promise = new Promise((resolve, reject) => {
          this.resolve = (value) => {
            if (this.status === "pending") {
              this.status = "resolved";
              resolve(value);
            }
          };
          this.reject = (reason) => {
            if (this.status === "pending") {
              this.status = "rejected";
              reject(reason);
            }
          };
        });
      }
    }
    function RouterProvider(_ref) {
      let {
        fallbackElement,
        router,
        future
      } = _ref;
      let [state, setStateImpl] = reactExports.useState(router.state);
      let [pendingState, setPendingState] = reactExports.useState();
      let [vtContext, setVtContext] = reactExports.useState({
        isTransitioning: false
      });
      let [renderDfd, setRenderDfd] = reactExports.useState();
      let [transition, setTransition] = reactExports.useState();
      let [interruption, setInterruption] = reactExports.useState();
      let fetcherData = reactExports.useRef(/* @__PURE__ */ new Map());
      let {
        v7_startTransition
      } = future || {};
      let optInStartTransition = reactExports.useCallback((cb2) => {
        if (v7_startTransition) {
          startTransitionSafe(cb2);
        } else {
          cb2();
        }
      }, [v7_startTransition]);
      let setState = reactExports.useCallback((newState, _ref2) => {
        let {
          deletedFetchers,
          unstable_flushSync: flushSync,
          unstable_viewTransitionOpts: viewTransitionOpts
        } = _ref2;
        deletedFetchers.forEach((key) => fetcherData.current.delete(key));
        newState.fetchers.forEach((fetcher, key) => {
          if (fetcher.data !== void 0) {
            fetcherData.current.set(key, fetcher.data);
          }
        });
        let isViewTransitionUnavailable = router.window == null || typeof router.window.document.startViewTransition !== "function";
        if (!viewTransitionOpts || isViewTransitionUnavailable) {
          if (flushSync) {
            flushSyncSafe(() => setStateImpl(newState));
          } else {
            optInStartTransition(() => setStateImpl(newState));
          }
          return;
        }
        if (flushSync) {
          flushSyncSafe(() => {
            if (transition) {
              renderDfd && renderDfd.resolve();
              transition.skipTransition();
            }
            setVtContext({
              isTransitioning: true,
              flushSync: true,
              currentLocation: viewTransitionOpts.currentLocation,
              nextLocation: viewTransitionOpts.nextLocation
            });
          });
          let t2 = router.window.document.startViewTransition(() => {
            flushSyncSafe(() => setStateImpl(newState));
          });
          t2.finished.finally(() => {
            flushSyncSafe(() => {
              setRenderDfd(void 0);
              setTransition(void 0);
              setPendingState(void 0);
              setVtContext({
                isTransitioning: false
              });
            });
          });
          flushSyncSafe(() => setTransition(t2));
          return;
        }
        if (transition) {
          renderDfd && renderDfd.resolve();
          transition.skipTransition();
          setInterruption({
            state: newState,
            currentLocation: viewTransitionOpts.currentLocation,
            nextLocation: viewTransitionOpts.nextLocation
          });
        } else {
          setPendingState(newState);
          setVtContext({
            isTransitioning: true,
            flushSync: false,
            currentLocation: viewTransitionOpts.currentLocation,
            nextLocation: viewTransitionOpts.nextLocation
          });
        }
      }, [router.window, transition, renderDfd, fetcherData, optInStartTransition]);
      reactExports.useLayoutEffect(() => router.subscribe(setState), [router, setState]);
      reactExports.useEffect(() => {
        if (vtContext.isTransitioning && !vtContext.flushSync) {
          setRenderDfd(new Deferred());
        }
      }, [vtContext]);
      reactExports.useEffect(() => {
        if (renderDfd && pendingState && router.window) {
          let newState = pendingState;
          let renderPromise = renderDfd.promise;
          let transition2 = router.window.document.startViewTransition(async () => {
            optInStartTransition(() => setStateImpl(newState));
            await renderPromise;
          });
          transition2.finished.finally(() => {
            setRenderDfd(void 0);
            setTransition(void 0);
            setPendingState(void 0);
            setVtContext({
              isTransitioning: false
            });
          });
          setTransition(transition2);
        }
      }, [optInStartTransition, pendingState, renderDfd, router.window]);
      reactExports.useEffect(() => {
        if (renderDfd && pendingState && state.location.key === pendingState.location.key) {
          renderDfd.resolve();
        }
      }, [renderDfd, transition, state.location, pendingState]);
      reactExports.useEffect(() => {
        if (!vtContext.isTransitioning && interruption) {
          setPendingState(interruption.state);
          setVtContext({
            isTransitioning: true,
            flushSync: false,
            currentLocation: interruption.currentLocation,
            nextLocation: interruption.nextLocation
          });
          setInterruption(void 0);
        }
      }, [vtContext.isTransitioning, interruption]);
      reactExports.useEffect(() => {
      }, []);
      let navigator2 = reactExports.useMemo(() => {
        return {
          createHref: router.createHref,
          encodeLocation: router.encodeLocation,
          go: (n2) => router.navigate(n2),
          push: (to, state2, opts) => router.navigate(to, {
            state: state2,
            preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
          }),
          replace: (to, state2, opts) => router.navigate(to, {
            replace: true,
            state: state2,
            preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
          })
        };
      }, [router]);
      let basename = router.basename || "/";
      let dataRouterContext = reactExports.useMemo(() => ({
        router,
        navigator: navigator2,
        static: false,
        basename
      }), [router, navigator2, basename]);
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(DataRouterContext.Provider, {
        value: dataRouterContext
      }, /* @__PURE__ */ reactExports.createElement(DataRouterStateContext.Provider, {
        value: state
      }, /* @__PURE__ */ reactExports.createElement(FetchersContext.Provider, {
        value: fetcherData.current
      }, /* @__PURE__ */ reactExports.createElement(ViewTransitionContext.Provider, {
        value: vtContext
      }, /* @__PURE__ */ reactExports.createElement(Router, {
        basename,
        location: state.location,
        navigationType: state.historyAction,
        navigator: navigator2,
        future: {
          v7_relativeSplatPath: router.future.v7_relativeSplatPath
        }
      }, state.initialized || router.future.v7_partialHydration ? /* @__PURE__ */ reactExports.createElement(DataRoutes, {
        routes: router.routes,
        future: router.future,
        state
      }) : fallbackElement))))), null);
    }
    function DataRoutes(_ref3) {
      let {
        routes,
        future,
        state
      } = _ref3;
      return useRoutesImpl(routes, void 0, state, future);
    }
    const isBrowser$2 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
    const Link = /* @__PURE__ */ reactExports.forwardRef(function LinkWithRef(_ref7, ref) {
      let {
        onClick,
        relative,
        reloadDocument,
        replace: replace2,
        state,
        target,
        to,
        preventScrollReset,
        unstable_viewTransition
      } = _ref7, rest = _objectWithoutPropertiesLoose$2(_ref7, _excluded$1e);
      let {
        basename
      } = reactExports.useContext(NavigationContext);
      let absoluteHref;
      let isExternal = false;
      if (typeof to === "string" && ABSOLUTE_URL_REGEX.test(to)) {
        absoluteHref = to;
        if (isBrowser$2) {
          try {
            let currentUrl = new URL(window.location.href);
            let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
            let path = stripBasename(targetUrl.pathname, basename);
            if (targetUrl.origin === currentUrl.origin && path != null) {
              to = path + targetUrl.search + targetUrl.hash;
            } else {
              isExternal = true;
            }
          } catch (e2) {
          }
        }
      }
      let href = useHref(to, {
        relative
      });
      let internalOnClick = useLinkClickHandler(to, {
        replace: replace2,
        state,
        target,
        preventScrollReset,
        relative,
        unstable_viewTransition
      });
      function handleClick(event) {
        if (onClick)
          onClick(event);
        if (!event.defaultPrevented) {
          internalOnClick(event);
        }
      }
      return (
        // eslint-disable-next-line jsx-a11y/anchor-has-content
        /* @__PURE__ */ reactExports.createElement("a", _extends$2({}, rest, {
          href: absoluteHref || href,
          onClick: isExternal || reloadDocument ? onClick : handleClick,
          ref,
          target
        }))
      );
    });
    var DataRouterHook;
    (function(DataRouterHook2) {
      DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
      DataRouterHook2["UseSubmit"] = "useSubmit";
      DataRouterHook2["UseSubmitFetcher"] = "useSubmitFetcher";
      DataRouterHook2["UseFetcher"] = "useFetcher";
      DataRouterHook2["useViewTransitionState"] = "useViewTransitionState";
    })(DataRouterHook || (DataRouterHook = {}));
    var DataRouterStateHook;
    (function(DataRouterStateHook2) {
      DataRouterStateHook2["UseFetcher"] = "useFetcher";
      DataRouterStateHook2["UseFetchers"] = "useFetchers";
      DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
    })(DataRouterStateHook || (DataRouterStateHook = {}));
    function useLinkClickHandler(to, _temp) {
      let {
        target,
        replace: replaceProp,
        state,
        preventScrollReset,
        relative,
        unstable_viewTransition
      } = _temp === void 0 ? {} : _temp;
      let navigate = useNavigate();
      let location = useLocation();
      let path = useResolvedPath(to, {
        relative
      });
      return reactExports.useCallback((event) => {
        if (shouldProcessLinkClick(event, target)) {
          event.preventDefault();
          let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
          navigate(to, {
            replace: replace2,
            state,
            preventScrollReset,
            relative,
            unstable_viewTransition
          });
        }
      }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative, unstable_viewTransition]);
    }
    const Image = "/assets/bmich_login_image-gENTBVJs.png";
    const Logo$1 = "/assets/Logo-5YV_IVr1.png";
    function Cache(maxSize) {
      this._maxSize = maxSize;
      this.clear();
    }
    Cache.prototype.clear = function() {
      this._size = 0;
      this._values = /* @__PURE__ */ Object.create(null);
    };
    Cache.prototype.get = function(key) {
      return this._values[key];
    };
    Cache.prototype.set = function(key, value) {
      this._size >= this._maxSize && this.clear();
      if (!(key in this._values))
        this._size++;
      return this._values[key] = value;
    };
    var SPLIT_REGEX = /[^.^\]^[]+|(?=\[\]|\.\.)/g, DIGIT_REGEX = /^\d+$/, LEAD_DIGIT_REGEX = /^\d/, SPEC_CHAR_REGEX = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g, CLEAN_QUOTES_REGEX = /^\s*(['"]?)(.*?)(\1)\s*$/, MAX_CACHE_SIZE = 512;
    var pathCache = new Cache(MAX_CACHE_SIZE), setCache = new Cache(MAX_CACHE_SIZE), getCache = new Cache(MAX_CACHE_SIZE);
    var propertyExpr = {
      Cache,
      split,
      normalizePath,
      setter: function(path) {
        var parts = normalizePath(path);
        return setCache.get(path) || setCache.set(path, function setter(obj, value) {
          var index = 0;
          var len = parts.length;
          var data = obj;
          while (index < len - 1) {
            var part = parts[index];
            if (part === "__proto__" || part === "constructor" || part === "prototype") {
              return obj;
            }
            data = data[parts[index++]];
          }
          data[parts[index]] = value;
        });
      },
      getter: function(path, safe) {
        var parts = normalizePath(path);
        return getCache.get(path) || getCache.set(path, function getter(data) {
          var index = 0, len = parts.length;
          while (index < len) {
            if (data != null || !safe)
              data = data[parts[index++]];
            else
              return;
          }
          return data;
        });
      },
      join: function(segments) {
        return segments.reduce(function(path, part) {
          return path + (isQuoted(part) || DIGIT_REGEX.test(part) ? "[" + part + "]" : (path ? "." : "") + part);
        }, "");
      },
      forEach: function(path, cb2, thisArg) {
        forEach$1(Array.isArray(path) ? path : split(path), cb2, thisArg);
      }
    };
    function normalizePath(path) {
      return pathCache.get(path) || pathCache.set(
        path,
        split(path).map(function(part) {
          return part.replace(CLEAN_QUOTES_REGEX, "$2");
        })
      );
    }
    function split(path) {
      return path.match(SPLIT_REGEX) || [""];
    }
    function forEach$1(parts, iter, thisArg) {
      var len = parts.length, part, idx, isArray2, isBracket;
      for (idx = 0; idx < len; idx++) {
        part = parts[idx];
        if (part) {
          if (shouldBeQuoted(part)) {
            part = '"' + part + '"';
          }
          isBracket = isQuoted(part);
          isArray2 = !isBracket && /^\d+$/.test(part);
          iter.call(thisArg, part, isBracket, isArray2, idx, parts);
        }
      }
    }
    function isQuoted(str) {
      return typeof str === "string" && str && ["'", '"'].indexOf(str.charAt(0)) !== -1;
    }
    function hasLeadingNumber(part) {
      return part.match(LEAD_DIGIT_REGEX) && !part.match(DIGIT_REGEX);
    }
    function hasSpecialChars(part) {
      return SPEC_CHAR_REGEX.test(part);
    }
    function shouldBeQuoted(part) {
      return !isQuoted(part) && (hasLeadingNumber(part) || hasSpecialChars(part));
    }
    const reWords = /[A-Z\xc0-\xd6\xd8-\xde]?[a-z\xdf-\xf6\xf8-\xff]+(?:['’](?:d|ll|m|re|s|t|ve))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde]|$)|(?:[A-Z\xc0-\xd6\xd8-\xde]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['’](?:D|LL|M|RE|S|T|VE))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde](?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])|$)|[A-Z\xc0-\xd6\xd8-\xde]?(?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['’](?:d|ll|m|re|s|t|ve))?|[A-Z\xc0-\xd6\xd8-\xde]+(?:['’](?:D|LL|M|RE|S|T|VE))?|\d*(?:1ST|2ND|3RD|(?![123])\dTH)(?=\b|[a-z_])|\d*(?:1st|2nd|3rd|(?![123])\dth)(?=\b|[A-Z_])|\d+|(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?(?:\u200d(?:[^\ud800-\udfff]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?)*/g;
    const words = (str) => str.match(reWords) || [];
    const upperFirst = (str) => str[0].toUpperCase() + str.slice(1);
    const join = (str, d2) => words(str).join(d2).toLowerCase();
    const camelCase = (str) => words(str).reduce(
      (acc, next2) => `${acc}${!acc ? next2.toLowerCase() : next2[0].toUpperCase() + next2.slice(1).toLowerCase()}`,
      ""
    );
    const pascalCase = (str) => upperFirst(camelCase(str));
    const snakeCase = (str) => join(str, "_");
    const kebabCase = (str) => join(str, "-");
    const sentenceCase = (str) => upperFirst(join(str, " "));
    const titleCase = (str) => words(str).map(upperFirst).join(" ");
    var tinyCase = {
      words,
      upperFirst,
      camelCase,
      pascalCase,
      snakeCase,
      kebabCase,
      sentenceCase,
      titleCase
    };
    var toposort$2 = { exports: {} };
    toposort$2.exports = function(edges) {
      return toposort(uniqueNodes(edges), edges);
    };
    toposort$2.exports.array = toposort;
    function toposort(nodes, edges) {
      var cursor2 = nodes.length, sorted = new Array(cursor2), visited = {}, i = cursor2, outgoingEdges = makeOutgoingEdges(edges), nodesHash = makeNodesHash(nodes);
      edges.forEach(function(edge) {
        if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {
          throw new Error("Unknown node. There is an unknown node in the supplied edges.");
        }
      });
      while (i--) {
        if (!visited[i])
          visit(nodes[i], i, /* @__PURE__ */ new Set());
      }
      return sorted;
      function visit(node2, i2, predecessors) {
        if (predecessors.has(node2)) {
          var nodeRep;
          try {
            nodeRep = ", node was:" + JSON.stringify(node2);
          } catch (e2) {
            nodeRep = "";
          }
          throw new Error("Cyclic dependency" + nodeRep);
        }
        if (!nodesHash.has(node2)) {
          throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(node2));
        }
        if (visited[i2])
          return;
        visited[i2] = true;
        var outgoing = outgoingEdges.get(node2) || /* @__PURE__ */ new Set();
        outgoing = Array.from(outgoing);
        if (i2 = outgoing.length) {
          predecessors.add(node2);
          do {
            var child = outgoing[--i2];
            visit(child, nodesHash.get(child), predecessors);
          } while (i2);
          predecessors.delete(node2);
        }
        sorted[--cursor2] = node2;
      }
    }
    function uniqueNodes(arr) {
      var res = /* @__PURE__ */ new Set();
      for (var i = 0, len = arr.length; i < len; i++) {
        var edge = arr[i];
        res.add(edge[0]);
        res.add(edge[1]);
      }
      return Array.from(res);
    }
    function makeOutgoingEdges(arr) {
      var edges = /* @__PURE__ */ new Map();
      for (var i = 0, len = arr.length; i < len; i++) {
        var edge = arr[i];
        if (!edges.has(edge[0]))
          edges.set(edge[0], /* @__PURE__ */ new Set());
        if (!edges.has(edge[1]))
          edges.set(edge[1], /* @__PURE__ */ new Set());
        edges.get(edge[0]).add(edge[1]);
      }
      return edges;
    }
    function makeNodesHash(arr) {
      var res = /* @__PURE__ */ new Map();
      for (var i = 0, len = arr.length; i < len; i++) {
        res.set(arr[i], i);
      }
      return res;
    }
    var toposortExports = toposort$2.exports;
    const toposort$1 = /* @__PURE__ */ getDefaultExportFromCjs(toposortExports);
    const toString$1 = Object.prototype.toString;
    const errorToString = Error.prototype.toString;
    const regExpToString = RegExp.prototype.toString;
    const symbolToString = typeof Symbol !== "undefined" ? Symbol.prototype.toString : () => "";
    const SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
    function printNumber(val) {
      if (val != +val)
        return "NaN";
      const isNegativeZero = val === 0 && 1 / val < 0;
      return isNegativeZero ? "-0" : "" + val;
    }
    function printSimpleValue(val, quoteStrings = false) {
      if (val == null || val === true || val === false)
        return "" + val;
      const typeOf = typeof val;
      if (typeOf === "number")
        return printNumber(val);
      if (typeOf === "string")
        return quoteStrings ? `"${val}"` : val;
      if (typeOf === "function")
        return "[Function " + (val.name || "anonymous") + "]";
      if (typeOf === "symbol")
        return symbolToString.call(val).replace(SYMBOL_REGEXP, "Symbol($1)");
      const tag = toString$1.call(val).slice(8, -1);
      if (tag === "Date")
        return isNaN(val.getTime()) ? "" + val : val.toISOString(val);
      if (tag === "Error" || val instanceof Error)
        return "[" + errorToString.call(val) + "]";
      if (tag === "RegExp")
        return regExpToString.call(val);
      return null;
    }
    function printValue(value, quoteStrings) {
      let result = printSimpleValue(value, quoteStrings);
      if (result !== null)
        return result;
      return JSON.stringify(value, function(key, value2) {
        let result2 = printSimpleValue(this[key], quoteStrings);
        if (result2 !== null)
          return result2;
        return value2;
      }, 2);
    }
    function toArray$1(value) {
      return value == null ? [] : [].concat(value);
    }
    let _Symbol$toStringTag, _Symbol$hasInstance, _Symbol$toStringTag2;
    let strReg = /\$\{\s*(\w+)\s*\}/g;
    _Symbol$toStringTag = Symbol.toStringTag;
    class ValidationErrorNoStack {
      constructor(errorOrErrors, value, field, type) {
        this.name = void 0;
        this.message = void 0;
        this.value = void 0;
        this.path = void 0;
        this.type = void 0;
        this.params = void 0;
        this.errors = void 0;
        this.inner = void 0;
        this[_Symbol$toStringTag] = "Error";
        this.name = "ValidationError";
        this.value = value;
        this.path = field;
        this.type = type;
        this.errors = [];
        this.inner = [];
        toArray$1(errorOrErrors).forEach((err) => {
          if (ValidationError.isError(err)) {
            this.errors.push(...err.errors);
            const innerErrors = err.inner.length ? err.inner : [err];
            this.inner.push(...innerErrors);
          } else {
            this.errors.push(err);
          }
        });
        this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0];
      }
    }
    _Symbol$hasInstance = Symbol.hasInstance;
    _Symbol$toStringTag2 = Symbol.toStringTag;
    class ValidationError extends Error {
      static formatError(message, params) {
        const path = params.label || params.path || "this";
        if (path !== params.path)
          params = Object.assign({}, params, {
            path
          });
        if (typeof message === "string")
          return message.replace(strReg, (_2, key) => printValue(params[key]));
        if (typeof message === "function")
          return message(params);
        return message;
      }
      static isError(err) {
        return err && err.name === "ValidationError";
      }
      constructor(errorOrErrors, value, field, type, disableStack) {
        const errorNoStack = new ValidationErrorNoStack(errorOrErrors, value, field, type);
        if (disableStack) {
          return errorNoStack;
        }
        super();
        this.value = void 0;
        this.path = void 0;
        this.type = void 0;
        this.params = void 0;
        this.errors = [];
        this.inner = [];
        this[_Symbol$toStringTag2] = "Error";
        this.name = errorNoStack.name;
        this.message = errorNoStack.message;
        this.type = errorNoStack.type;
        this.value = errorNoStack.value;
        this.path = errorNoStack.path;
        this.errors = errorNoStack.errors;
        this.inner = errorNoStack.inner;
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, ValidationError);
        }
      }
      static [_Symbol$hasInstance](inst) {
        return ValidationErrorNoStack[Symbol.hasInstance](inst) || super[Symbol.hasInstance](inst);
      }
    }
    let mixed = {
      default: "${path} is invalid",
      required: "${path} is a required field",
      defined: "${path} must be defined",
      notNull: "${path} cannot be null",
      oneOf: "${path} must be one of the following values: ${values}",
      notOneOf: "${path} must not be one of the following values: ${values}",
      notType: ({
        path,
        type,
        value,
        originalValue
      }) => {
        const castMsg = originalValue != null && originalValue !== value ? ` (cast from the value \`${printValue(originalValue, true)}\`).` : ".";
        return type !== "mixed" ? `${path} must be a \`${type}\` type, but the final value was: \`${printValue(value, true)}\`` + castMsg : `${path} must match the configured type. The validated value was: \`${printValue(value, true)}\`` + castMsg;
      }
    };
    let string = {
      length: "${path} must be exactly ${length} characters",
      min: "${path} must be at least ${min} characters",
      max: "${path} must be at most ${max} characters",
      matches: '${path} must match the following: "${regex}"',
      email: "${path} must be a valid email",
      url: "${path} must be a valid URL",
      uuid: "${path} must be a valid UUID",
      datetime: "${path} must be a valid ISO date-time",
      datetime_precision: "${path} must be a valid ISO date-time with a sub-second precision of exactly ${precision} digits",
      datetime_offset: '${path} must be a valid ISO date-time with UTC "Z" timezone',
      trim: "${path} must be a trimmed string",
      lowercase: "${path} must be a lowercase string",
      uppercase: "${path} must be a upper case string"
    };
    let number$1 = {
      min: "${path} must be greater than or equal to ${min}",
      max: "${path} must be less than or equal to ${max}",
      lessThan: "${path} must be less than ${less}",
      moreThan: "${path} must be greater than ${more}",
      positive: "${path} must be a positive number",
      negative: "${path} must be a negative number",
      integer: "${path} must be an integer"
    };
    let date = {
      min: "${path} field must be later than ${min}",
      max: "${path} field must be at earlier than ${max}"
    };
    let boolean = {
      isValue: "${path} field must be ${value}"
    };
    let object = {
      noUnknown: "${path} field has unspecified keys: ${unknown}"
    };
    let array = {
      min: "${path} field must have at least ${min} items",
      max: "${path} field must have less than or equal to ${max} items",
      length: "${path} must have ${length} items"
    };
    let tuple = {
      notType: (params) => {
        const {
          path,
          value,
          spec
        } = params;
        const typeLen = spec.types.length;
        if (Array.isArray(value)) {
          if (value.length < typeLen)
            return `${path} tuple value has too few items, expected a length of ${typeLen} but got ${value.length} for value: \`${printValue(value, true)}\``;
          if (value.length > typeLen)
            return `${path} tuple value has too many items, expected a length of ${typeLen} but got ${value.length} for value: \`${printValue(value, true)}\``;
        }
        return ValidationError.formatError(mixed.notType, params);
      }
    };
    Object.assign(/* @__PURE__ */ Object.create(null), {
      mixed,
      string,
      number: number$1,
      date,
      object,
      array,
      boolean,
      tuple
    });
    const isSchema = (obj) => obj && obj.__isYupSchema__;
    class Condition {
      static fromOptions(refs, config2) {
        if (!config2.then && !config2.otherwise)
          throw new TypeError("either `then:` or `otherwise:` is required for `when()` conditions");
        let {
          is,
          then,
          otherwise
        } = config2;
        let check = typeof is === "function" ? is : (...values2) => values2.every((value) => value === is);
        return new Condition(refs, (values2, schema) => {
          var _branch;
          let branch = check(...values2) ? then : otherwise;
          return (_branch = branch == null ? void 0 : branch(schema)) != null ? _branch : schema;
        });
      }
      constructor(refs, builder) {
        this.fn = void 0;
        this.refs = refs;
        this.refs = refs;
        this.fn = builder;
      }
      resolve(base, options) {
        let values2 = this.refs.map((ref) => (
          // TODO: ? operator here?
          ref.getValue(options == null ? void 0 : options.value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context)
        ));
        let schema = this.fn(values2, base, options);
        if (schema === void 0 || // @ts-ignore this can be base
        schema === base) {
          return base;
        }
        if (!isSchema(schema))
          throw new TypeError("conditions must return a schema object");
        return schema.resolve(options);
      }
    }
    const prefixes = {
      context: "$",
      value: "."
    };
    function create$9(key, options) {
      return new Reference(key, options);
    }
    class Reference {
      constructor(key, options = {}) {
        this.key = void 0;
        this.isContext = void 0;
        this.isValue = void 0;
        this.isSibling = void 0;
        this.path = void 0;
        this.getter = void 0;
        this.map = void 0;
        if (typeof key !== "string")
          throw new TypeError("ref must be a string, got: " + key);
        this.key = key.trim();
        if (key === "")
          throw new TypeError("ref must be a non-empty string");
        this.isContext = this.key[0] === prefixes.context;
        this.isValue = this.key[0] === prefixes.value;
        this.isSibling = !this.isContext && !this.isValue;
        let prefix2 = this.isContext ? prefixes.context : this.isValue ? prefixes.value : "";
        this.path = this.key.slice(prefix2.length);
        this.getter = this.path && propertyExpr.getter(this.path, true);
        this.map = options.map;
      }
      getValue(value, parent, context) {
        let result = this.isContext ? context : this.isValue ? value : parent;
        if (this.getter)
          result = this.getter(result || {});
        if (this.map)
          result = this.map(result);
        return result;
      }
      /**
       *
       * @param {*} value
       * @param {Object} options
       * @param {Object=} options.context
       * @param {Object=} options.parent
       */
      cast(value, options) {
        return this.getValue(value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context);
      }
      resolve() {
        return this;
      }
      describe() {
        return {
          type: "ref",
          key: this.key
        };
      }
      toString() {
        return `Ref(${this.key})`;
      }
      static isRef(value) {
        return value && value.__isYupRef;
      }
    }
    Reference.prototype.__isYupRef = true;
    const isAbsent = (value) => value == null;
    function createValidation(config2) {
      function validate({
        value,
        path = "",
        options,
        originalValue,
        schema
      }, panic, next2) {
        const {
          name,
          test: test2,
          params,
          message,
          skipAbsent
        } = config2;
        let {
          parent,
          context,
          abortEarly = schema.spec.abortEarly,
          disableStackTrace = schema.spec.disableStackTrace
        } = options;
        function resolve(item) {
          return Reference.isRef(item) ? item.getValue(value, parent, context) : item;
        }
        function createError(overrides = {}) {
          const nextParams = Object.assign({
            value,
            originalValue,
            label: schema.spec.label,
            path: overrides.path || path,
            spec: schema.spec,
            disableStackTrace: overrides.disableStackTrace || disableStackTrace
          }, params, overrides.params);
          for (const key of Object.keys(nextParams))
            nextParams[key] = resolve(nextParams[key]);
          const error = new ValidationError(ValidationError.formatError(overrides.message || message, nextParams), value, nextParams.path, overrides.type || name, nextParams.disableStackTrace);
          error.params = nextParams;
          return error;
        }
        const invalid = abortEarly ? panic : next2;
        let ctx = {
          path,
          parent,
          type: name,
          from: options.from,
          createError,
          resolve,
          options,
          originalValue,
          schema
        };
        const handleResult = (validOrError) => {
          if (ValidationError.isError(validOrError))
            invalid(validOrError);
          else if (!validOrError)
            invalid(createError());
          else
            next2(null);
        };
        const handleError = (err) => {
          if (ValidationError.isError(err))
            invalid(err);
          else
            panic(err);
        };
        const shouldSkip = skipAbsent && isAbsent(value);
        if (shouldSkip) {
          return handleResult(true);
        }
        let result;
        try {
          var _result;
          result = test2.call(ctx, value, ctx);
          if (typeof ((_result = result) == null ? void 0 : _result.then) === "function") {
            if (options.sync) {
              throw new Error(`Validation test of type: "${ctx.type}" returned a Promise during a synchronous validate. This test will finish after the validate call has returned`);
            }
            return Promise.resolve(result).then(handleResult, handleError);
          }
        } catch (err) {
          handleError(err);
          return;
        }
        handleResult(result);
      }
      validate.OPTIONS = config2;
      return validate;
    }
    function getIn(schema, path, value, context = value) {
      let parent, lastPart, lastPartDebug;
      if (!path)
        return {
          parent,
          parentPath: path,
          schema
        };
      propertyExpr.forEach(path, (_part, isBracket, isArray2) => {
        let part = isBracket ? _part.slice(1, _part.length - 1) : _part;
        schema = schema.resolve({
          context,
          parent,
          value
        });
        let isTuple = schema.type === "tuple";
        let idx = isArray2 ? parseInt(part, 10) : 0;
        if (schema.innerType || isTuple) {
          if (isTuple && !isArray2)
            throw new Error(`Yup.reach cannot implicitly index into a tuple type. the path part "${lastPartDebug}" must contain an index to the tuple element, e.g. "${lastPartDebug}[0]"`);
          if (value && idx >= value.length) {
            throw new Error(`Yup.reach cannot resolve an array item at index: ${_part}, in the path: ${path}. because there is no value at that index. `);
          }
          parent = value;
          value = value && value[idx];
          schema = isTuple ? schema.spec.types[idx] : schema.innerType;
        }
        if (!isArray2) {
          if (!schema.fields || !schema.fields[part])
            throw new Error(`The schema does not contain the path: ${path}. (failed at: ${lastPartDebug} which is a type: "${schema.type}")`);
          parent = value;
          value = value && value[part];
          schema = schema.fields[part];
        }
        lastPart = part;
        lastPartDebug = isBracket ? "[" + _part + "]" : "." + _part;
      });
      return {
        schema,
        parent,
        parentPath: lastPart
      };
    }
    class ReferenceSet extends Set {
      describe() {
        const description = [];
        for (const item of this.values()) {
          description.push(Reference.isRef(item) ? item.describe() : item);
        }
        return description;
      }
      resolveAll(resolve) {
        let result = [];
        for (const item of this.values()) {
          result.push(resolve(item));
        }
        return result;
      }
      clone() {
        return new ReferenceSet(this.values());
      }
      merge(newItems, removeItems) {
        const next2 = this.clone();
        newItems.forEach((value) => next2.add(value));
        removeItems.forEach((value) => next2.delete(value));
        return next2;
      }
    }
    function clone(src, seen = /* @__PURE__ */ new Map()) {
      if (isSchema(src) || !src || typeof src !== "object")
        return src;
      if (seen.has(src))
        return seen.get(src);
      let copy2;
      if (src instanceof Date) {
        copy2 = new Date(src.getTime());
        seen.set(src, copy2);
      } else if (src instanceof RegExp) {
        copy2 = new RegExp(src);
        seen.set(src, copy2);
      } else if (Array.isArray(src)) {
        copy2 = new Array(src.length);
        seen.set(src, copy2);
        for (let i = 0; i < src.length; i++)
          copy2[i] = clone(src[i], seen);
      } else if (src instanceof Map) {
        copy2 = /* @__PURE__ */ new Map();
        seen.set(src, copy2);
        for (const [k2, v2] of src.entries())
          copy2.set(k2, clone(v2, seen));
      } else if (src instanceof Set) {
        copy2 = /* @__PURE__ */ new Set();
        seen.set(src, copy2);
        for (const v2 of src)
          copy2.add(clone(v2, seen));
      } else if (src instanceof Object) {
        copy2 = {};
        seen.set(src, copy2);
        for (const [k2, v2] of Object.entries(src))
          copy2[k2] = clone(v2, seen);
      } else {
        throw Error(`Unable to clone ${src}`);
      }
      return copy2;
    }
    class Schema {
      constructor(options) {
        this.type = void 0;
        this.deps = [];
        this.tests = void 0;
        this.transforms = void 0;
        this.conditions = [];
        this._mutate = void 0;
        this.internalTests = {};
        this._whitelist = new ReferenceSet();
        this._blacklist = new ReferenceSet();
        this.exclusiveTests = /* @__PURE__ */ Object.create(null);
        this._typeCheck = void 0;
        this.spec = void 0;
        this.tests = [];
        this.transforms = [];
        this.withMutation(() => {
          this.typeError(mixed.notType);
        });
        this.type = options.type;
        this._typeCheck = options.check;
        this.spec = Object.assign({
          strip: false,
          strict: false,
          abortEarly: true,
          recursive: true,
          disableStackTrace: false,
          nullable: false,
          optional: true,
          coerce: true
        }, options == null ? void 0 : options.spec);
        this.withMutation((s) => {
          s.nonNullable();
        });
      }
      // TODO: remove
      get _type() {
        return this.type;
      }
      clone(spec) {
        if (this._mutate) {
          if (spec)
            Object.assign(this.spec, spec);
          return this;
        }
        const next2 = Object.create(Object.getPrototypeOf(this));
        next2.type = this.type;
        next2._typeCheck = this._typeCheck;
        next2._whitelist = this._whitelist.clone();
        next2._blacklist = this._blacklist.clone();
        next2.internalTests = Object.assign({}, this.internalTests);
        next2.exclusiveTests = Object.assign({}, this.exclusiveTests);
        next2.deps = [...this.deps];
        next2.conditions = [...this.conditions];
        next2.tests = [...this.tests];
        next2.transforms = [...this.transforms];
        next2.spec = clone(Object.assign({}, this.spec, spec));
        return next2;
      }
      label(label) {
        let next2 = this.clone();
        next2.spec.label = label;
        return next2;
      }
      meta(...args) {
        if (args.length === 0)
          return this.spec.meta;
        let next2 = this.clone();
        next2.spec.meta = Object.assign(next2.spec.meta || {}, args[0]);
        return next2;
      }
      withMutation(fn) {
        let before = this._mutate;
        this._mutate = true;
        let result = fn(this);
        this._mutate = before;
        return result;
      }
      concat(schema) {
        if (!schema || schema === this)
          return this;
        if (schema.type !== this.type && this.type !== "mixed")
          throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${schema.type}`);
        let base = this;
        let combined = schema.clone();
        const mergedSpec = Object.assign({}, base.spec, combined.spec);
        combined.spec = mergedSpec;
        combined.internalTests = Object.assign({}, base.internalTests, combined.internalTests);
        combined._whitelist = base._whitelist.merge(schema._whitelist, schema._blacklist);
        combined._blacklist = base._blacklist.merge(schema._blacklist, schema._whitelist);
        combined.tests = base.tests;
        combined.exclusiveTests = base.exclusiveTests;
        combined.withMutation((next2) => {
          schema.tests.forEach((fn) => {
            next2.test(fn.OPTIONS);
          });
        });
        combined.transforms = [...base.transforms, ...combined.transforms];
        return combined;
      }
      isType(v2) {
        if (v2 == null) {
          if (this.spec.nullable && v2 === null)
            return true;
          if (this.spec.optional && v2 === void 0)
            return true;
          return false;
        }
        return this._typeCheck(v2);
      }
      resolve(options) {
        let schema = this;
        if (schema.conditions.length) {
          let conditions = schema.conditions;
          schema = schema.clone();
          schema.conditions = [];
          schema = conditions.reduce((prevSchema, condition) => condition.resolve(prevSchema, options), schema);
          schema = schema.resolve(options);
        }
        return schema;
      }
      resolveOptions(options) {
        var _options$strict, _options$abortEarly, _options$recursive, _options$disableStack;
        return Object.assign({}, options, {
          from: options.from || [],
          strict: (_options$strict = options.strict) != null ? _options$strict : this.spec.strict,
          abortEarly: (_options$abortEarly = options.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly,
          recursive: (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive,
          disableStackTrace: (_options$disableStack = options.disableStackTrace) != null ? _options$disableStack : this.spec.disableStackTrace
        });
      }
      /**
       * Run the configured transform pipeline over an input value.
       */
      cast(value, options = {}) {
        let resolvedSchema = this.resolve(Object.assign({
          value
        }, options));
        let allowOptionality = options.assert === "ignore-optionality";
        let result = resolvedSchema._cast(value, options);
        if (options.assert !== false && !resolvedSchema.isType(result)) {
          if (allowOptionality && isAbsent(result)) {
            return result;
          }
          let formattedValue = printValue(value);
          let formattedResult = printValue(result);
          throw new TypeError(`The value of ${options.path || "field"} could not be cast to a value that satisfies the schema type: "${resolvedSchema.type}". 

attempted value: ${formattedValue} 
` + (formattedResult !== formattedValue ? `result of cast: ${formattedResult}` : ""));
        }
        return result;
      }
      _cast(rawValue, options) {
        let value = rawValue === void 0 ? rawValue : this.transforms.reduce((prevValue, fn) => fn.call(this, prevValue, rawValue, this), rawValue);
        if (value === void 0) {
          value = this.getDefault(options);
        }
        return value;
      }
      _validate(_value, options = {}, panic, next2) {
        let {
          path,
          originalValue = _value,
          strict = this.spec.strict
        } = options;
        let value = _value;
        if (!strict) {
          value = this._cast(value, Object.assign({
            assert: false
          }, options));
        }
        let initialTests = [];
        for (let test2 of Object.values(this.internalTests)) {
          if (test2)
            initialTests.push(test2);
        }
        this.runTests({
          path,
          value,
          originalValue,
          options,
          tests: initialTests
        }, panic, (initialErrors) => {
          if (initialErrors.length) {
            return next2(initialErrors, value);
          }
          this.runTests({
            path,
            value,
            originalValue,
            options,
            tests: this.tests
          }, panic, next2);
        });
      }
      /**
       * Executes a set of validations, either schema, produced Tests or a nested
       * schema validate result.
       */
      runTests(runOptions, panic, next2) {
        let fired = false;
        let {
          tests,
          value,
          originalValue,
          path,
          options
        } = runOptions;
        let panicOnce = (arg) => {
          if (fired)
            return;
          fired = true;
          panic(arg, value);
        };
        let nextOnce = (arg) => {
          if (fired)
            return;
          fired = true;
          next2(arg, value);
        };
        let count = tests.length;
        let nestedErrors = [];
        if (!count)
          return nextOnce([]);
        let args = {
          value,
          originalValue,
          path,
          options,
          schema: this
        };
        for (let i = 0; i < tests.length; i++) {
          const test2 = tests[i];
          test2(args, panicOnce, function finishTestRun(err) {
            if (err) {
              Array.isArray(err) ? nestedErrors.push(...err) : nestedErrors.push(err);
            }
            if (--count <= 0) {
              nextOnce(nestedErrors);
            }
          });
        }
      }
      asNestedTest({
        key,
        index,
        parent,
        parentPath,
        originalParent,
        options
      }) {
        const k2 = key != null ? key : index;
        if (k2 == null) {
          throw TypeError("Must include `key` or `index` for nested validations");
        }
        const isIndex2 = typeof k2 === "number";
        let value = parent[k2];
        const testOptions = Object.assign({}, options, {
          // Nested validations fields are always strict:
          //    1. parent isn't strict so the casting will also have cast inner values
          //    2. parent is strict in which case the nested values weren't cast either
          strict: true,
          parent,
          value,
          originalValue: originalParent[k2],
          // FIXME: tests depend on `index` being passed around deeply,
          //   we should not let the options.key/index bleed through
          key: void 0,
          // index: undefined,
          [isIndex2 ? "index" : "key"]: k2,
          path: isIndex2 || k2.includes(".") ? `${parentPath || ""}[${isIndex2 ? k2 : `"${k2}"`}]` : (parentPath ? `${parentPath}.` : "") + key
        });
        return (_2, panic, next2) => this.resolve(testOptions)._validate(value, testOptions, panic, next2);
      }
      validate(value, options) {
        var _options$disableStack2;
        let schema = this.resolve(Object.assign({}, options, {
          value
        }));
        let disableStackTrace = (_options$disableStack2 = options == null ? void 0 : options.disableStackTrace) != null ? _options$disableStack2 : schema.spec.disableStackTrace;
        return new Promise((resolve, reject) => schema._validate(value, options, (error, parsed) => {
          if (ValidationError.isError(error))
            error.value = parsed;
          reject(error);
        }, (errors, validated) => {
          if (errors.length)
            reject(new ValidationError(errors, validated, void 0, void 0, disableStackTrace));
          else
            resolve(validated);
        }));
      }
      validateSync(value, options) {
        var _options$disableStack3;
        let schema = this.resolve(Object.assign({}, options, {
          value
        }));
        let result;
        let disableStackTrace = (_options$disableStack3 = options == null ? void 0 : options.disableStackTrace) != null ? _options$disableStack3 : schema.spec.disableStackTrace;
        schema._validate(value, Object.assign({}, options, {
          sync: true
        }), (error, parsed) => {
          if (ValidationError.isError(error))
            error.value = parsed;
          throw error;
        }, (errors, validated) => {
          if (errors.length)
            throw new ValidationError(errors, value, void 0, void 0, disableStackTrace);
          result = validated;
        });
        return result;
      }
      isValid(value, options) {
        return this.validate(value, options).then(() => true, (err) => {
          if (ValidationError.isError(err))
            return false;
          throw err;
        });
      }
      isValidSync(value, options) {
        try {
          this.validateSync(value, options);
          return true;
        } catch (err) {
          if (ValidationError.isError(err))
            return false;
          throw err;
        }
      }
      _getDefault(options) {
        let defaultValue = this.spec.default;
        if (defaultValue == null) {
          return defaultValue;
        }
        return typeof defaultValue === "function" ? defaultValue.call(this, options) : clone(defaultValue);
      }
      getDefault(options) {
        let schema = this.resolve(options || {});
        return schema._getDefault(options);
      }
      default(def) {
        if (arguments.length === 0) {
          return this._getDefault();
        }
        let next2 = this.clone({
          default: def
        });
        return next2;
      }
      strict(isStrict = true) {
        return this.clone({
          strict: isStrict
        });
      }
      nullability(nullable, message) {
        const next2 = this.clone({
          nullable
        });
        next2.internalTests.nullable = createValidation({
          message,
          name: "nullable",
          test(value) {
            return value === null ? this.schema.spec.nullable : true;
          }
        });
        return next2;
      }
      optionality(optional, message) {
        const next2 = this.clone({
          optional
        });
        next2.internalTests.optionality = createValidation({
          message,
          name: "optionality",
          test(value) {
            return value === void 0 ? this.schema.spec.optional : true;
          }
        });
        return next2;
      }
      optional() {
        return this.optionality(true);
      }
      defined(message = mixed.defined) {
        return this.optionality(false, message);
      }
      nullable() {
        return this.nullability(true);
      }
      nonNullable(message = mixed.notNull) {
        return this.nullability(false, message);
      }
      required(message = mixed.required) {
        return this.clone().withMutation((next2) => next2.nonNullable(message).defined(message));
      }
      notRequired() {
        return this.clone().withMutation((next2) => next2.nullable().optional());
      }
      transform(fn) {
        let next2 = this.clone();
        next2.transforms.push(fn);
        return next2;
      }
      /**
       * Adds a test function to the schema's queue of tests.
       * tests can be exclusive or non-exclusive.
       *
       * - exclusive tests, will replace any existing tests of the same name.
       * - non-exclusive: can be stacked
       *
       * If a non-exclusive test is added to a schema with an exclusive test of the same name
       * the exclusive test is removed and further tests of the same name will be stacked.
       *
       * If an exclusive test is added to a schema with non-exclusive tests of the same name
       * the previous tests are removed and further tests of the same name will replace each other.
       */
      test(...args) {
        let opts;
        if (args.length === 1) {
          if (typeof args[0] === "function") {
            opts = {
              test: args[0]
            };
          } else {
            opts = args[0];
          }
        } else if (args.length === 2) {
          opts = {
            name: args[0],
            test: args[1]
          };
        } else {
          opts = {
            name: args[0],
            message: args[1],
            test: args[2]
          };
        }
        if (opts.message === void 0)
          opts.message = mixed.default;
        if (typeof opts.test !== "function")
          throw new TypeError("`test` is a required parameters");
        let next2 = this.clone();
        let validate = createValidation(opts);
        let isExclusive = opts.exclusive || opts.name && next2.exclusiveTests[opts.name] === true;
        if (opts.exclusive) {
          if (!opts.name)
            throw new TypeError("Exclusive tests must provide a unique `name` identifying the test");
        }
        if (opts.name)
          next2.exclusiveTests[opts.name] = !!opts.exclusive;
        next2.tests = next2.tests.filter((fn) => {
          if (fn.OPTIONS.name === opts.name) {
            if (isExclusive)
              return false;
            if (fn.OPTIONS.test === validate.OPTIONS.test)
              return false;
          }
          return true;
        });
        next2.tests.push(validate);
        return next2;
      }
      when(keys2, options) {
        if (!Array.isArray(keys2) && typeof keys2 !== "string") {
          options = keys2;
          keys2 = ".";
        }
        let next2 = this.clone();
        let deps = toArray$1(keys2).map((key) => new Reference(key));
        deps.forEach((dep) => {
          if (dep.isSibling)
            next2.deps.push(dep.key);
        });
        next2.conditions.push(typeof options === "function" ? new Condition(deps, options) : Condition.fromOptions(deps, options));
        return next2;
      }
      typeError(message) {
        let next2 = this.clone();
        next2.internalTests.typeError = createValidation({
          message,
          name: "typeError",
          skipAbsent: true,
          test(value) {
            if (!this.schema._typeCheck(value))
              return this.createError({
                params: {
                  type: this.schema.type
                }
              });
            return true;
          }
        });
        return next2;
      }
      oneOf(enums, message = mixed.oneOf) {
        let next2 = this.clone();
        enums.forEach((val) => {
          next2._whitelist.add(val);
          next2._blacklist.delete(val);
        });
        next2.internalTests.whiteList = createValidation({
          message,
          name: "oneOf",
          skipAbsent: true,
          test(value) {
            let valids = this.schema._whitelist;
            let resolved = valids.resolveAll(this.resolve);
            return resolved.includes(value) ? true : this.createError({
              params: {
                values: Array.from(valids).join(", "),
                resolved
              }
            });
          }
        });
        return next2;
      }
      notOneOf(enums, message = mixed.notOneOf) {
        let next2 = this.clone();
        enums.forEach((val) => {
          next2._blacklist.add(val);
          next2._whitelist.delete(val);
        });
        next2.internalTests.blacklist = createValidation({
          message,
          name: "notOneOf",
          test(value) {
            let invalids = this.schema._blacklist;
            let resolved = invalids.resolveAll(this.resolve);
            if (resolved.includes(value))
              return this.createError({
                params: {
                  values: Array.from(invalids).join(", "),
                  resolved
                }
              });
            return true;
          }
        });
        return next2;
      }
      strip(strip = true) {
        let next2 = this.clone();
        next2.spec.strip = strip;
        return next2;
      }
      /**
       * Return a serialized description of the schema including validations, flags, types etc.
       *
       * @param options Provide any needed context for resolving runtime schema alterations (lazy, when conditions, etc).
       */
      describe(options) {
        const next2 = (options ? this.resolve(options) : this).clone();
        const {
          label,
          meta,
          optional,
          nullable
        } = next2.spec;
        const description = {
          meta,
          label,
          optional,
          nullable,
          default: next2.getDefault(options),
          type: next2.type,
          oneOf: next2._whitelist.describe(),
          notOneOf: next2._blacklist.describe(),
          tests: next2.tests.map((fn) => ({
            name: fn.OPTIONS.name,
            params: fn.OPTIONS.params
          })).filter((n2, idx, list) => list.findIndex((c2) => c2.name === n2.name) === idx)
        };
        return description;
      }
    }
    Schema.prototype.__isYupSchema__ = true;
    for (const method of ["validate", "validateSync"])
      Schema.prototype[`${method}At`] = function(path, value, options = {}) {
        const {
          parent,
          parentPath,
          schema
        } = getIn(this, path, value, options.context);
        return schema[method](parent && parent[parentPath], Object.assign({}, options, {
          parent,
          path
        }));
      };
    for (const alias of ["equals", "is"])
      Schema.prototype[alias] = Schema.prototype.oneOf;
    for (const alias of ["not", "nope"])
      Schema.prototype[alias] = Schema.prototype.notOneOf;
    const returnsTrue = () => true;
    function create$8(spec) {
      return new MixedSchema(spec);
    }
    class MixedSchema extends Schema {
      constructor(spec) {
        super(typeof spec === "function" ? {
          type: "mixed",
          check: spec
        } : Object.assign({
          type: "mixed",
          check: returnsTrue
        }, spec));
      }
    }
    create$8.prototype = MixedSchema.prototype;
    function create$7() {
      return new BooleanSchema();
    }
    class BooleanSchema extends Schema {
      constructor() {
        super({
          type: "boolean",
          check(v2) {
            if (v2 instanceof Boolean)
              v2 = v2.valueOf();
            return typeof v2 === "boolean";
          }
        });
        this.withMutation(() => {
          this.transform((value, _raw, ctx) => {
            if (ctx.spec.coerce && !ctx.isType(value)) {
              if (/^(true|1)$/i.test(String(value)))
                return true;
              if (/^(false|0)$/i.test(String(value)))
                return false;
            }
            return value;
          });
        });
      }
      isTrue(message = boolean.isValue) {
        return this.test({
          message,
          name: "is-value",
          exclusive: true,
          params: {
            value: "true"
          },
          test(value) {
            return isAbsent(value) || value === true;
          }
        });
      }
      isFalse(message = boolean.isValue) {
        return this.test({
          message,
          name: "is-value",
          exclusive: true,
          params: {
            value: "false"
          },
          test(value) {
            return isAbsent(value) || value === false;
          }
        });
      }
      default(def) {
        return super.default(def);
      }
      defined(msg) {
        return super.defined(msg);
      }
      optional() {
        return super.optional();
      }
      required(msg) {
        return super.required(msg);
      }
      notRequired() {
        return super.notRequired();
      }
      nullable() {
        return super.nullable();
      }
      nonNullable(msg) {
        return super.nonNullable(msg);
      }
      strip(v2) {
        return super.strip(v2);
      }
    }
    create$7.prototype = BooleanSchema.prototype;
    const isoReg = /^(\d{4}|[+-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,.](\d{1,}))?)?(?:(Z)|([+-])(\d{2})(?::?(\d{2}))?)?)?$/;
    function parseIsoDate(date2) {
      const struct = parseDateStruct(date2);
      if (!struct)
        return Date.parse ? Date.parse(date2) : Number.NaN;
      if (struct.z === void 0 && struct.plusMinus === void 0) {
        return new Date(struct.year, struct.month, struct.day, struct.hour, struct.minute, struct.second, struct.millisecond).valueOf();
      }
      let totalMinutesOffset = 0;
      if (struct.z !== "Z" && struct.plusMinus !== void 0) {
        totalMinutesOffset = struct.hourOffset * 60 + struct.minuteOffset;
        if (struct.plusMinus === "+")
          totalMinutesOffset = 0 - totalMinutesOffset;
      }
      return Date.UTC(struct.year, struct.month, struct.day, struct.hour, struct.minute + totalMinutesOffset, struct.second, struct.millisecond);
    }
    function parseDateStruct(date2) {
      var _regexResult$7$length, _regexResult$;
      const regexResult = isoReg.exec(date2);
      if (!regexResult)
        return null;
      return {
        year: toNumber(regexResult[1]),
        month: toNumber(regexResult[2], 1) - 1,
        day: toNumber(regexResult[3], 1),
        hour: toNumber(regexResult[4]),
        minute: toNumber(regexResult[5]),
        second: toNumber(regexResult[6]),
        millisecond: regexResult[7] ? (
          // allow arbitrary sub-second precision beyond milliseconds
          toNumber(regexResult[7].substring(0, 3))
        ) : 0,
        precision: (_regexResult$7$length = (_regexResult$ = regexResult[7]) == null ? void 0 : _regexResult$.length) != null ? _regexResult$7$length : void 0,
        z: regexResult[8] || void 0,
        plusMinus: regexResult[9] || void 0,
        hourOffset: toNumber(regexResult[10]),
        minuteOffset: toNumber(regexResult[11])
      };
    }
    function toNumber(str, defaultValue = 0) {
      return Number(str) || defaultValue;
    }
    let rEmail = (
      // eslint-disable-next-line
      /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/
    );
    let rUrl = (
      // eslint-disable-next-line
      /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i
    );
    let rUUID = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    let yearMonthDay = "^\\d{4}-\\d{2}-\\d{2}";
    let hourMinuteSecond = "\\d{2}:\\d{2}:\\d{2}";
    let zOrOffset = "(([+-]\\d{2}(:?\\d{2})?)|Z)";
    let rIsoDateTime = new RegExp(`${yearMonthDay}T${hourMinuteSecond}(\\.\\d+)?${zOrOffset}$`);
    let isTrimmed = (value) => isAbsent(value) || value === value.trim();
    let objStringTag = {}.toString();
    function create$6() {
      return new StringSchema();
    }
    class StringSchema extends Schema {
      constructor() {
        super({
          type: "string",
          check(value) {
            if (value instanceof String)
              value = value.valueOf();
            return typeof value === "string";
          }
        });
        this.withMutation(() => {
          this.transform((value, _raw, ctx) => {
            if (!ctx.spec.coerce || ctx.isType(value))
              return value;
            if (Array.isArray(value))
              return value;
            const strValue = value != null && value.toString ? value.toString() : value;
            if (strValue === objStringTag)
              return value;
            return strValue;
          });
        });
      }
      required(message) {
        return super.required(message).withMutation((schema) => schema.test({
          message: message || mixed.required,
          name: "required",
          skipAbsent: true,
          test: (value) => !!value.length
        }));
      }
      notRequired() {
        return super.notRequired().withMutation((schema) => {
          schema.tests = schema.tests.filter((t2) => t2.OPTIONS.name !== "required");
          return schema;
        });
      }
      length(length2, message = string.length) {
        return this.test({
          message,
          name: "length",
          exclusive: true,
          params: {
            length: length2
          },
          skipAbsent: true,
          test(value) {
            return value.length === this.resolve(length2);
          }
        });
      }
      min(min2, message = string.min) {
        return this.test({
          message,
          name: "min",
          exclusive: true,
          params: {
            min: min2
          },
          skipAbsent: true,
          test(value) {
            return value.length >= this.resolve(min2);
          }
        });
      }
      max(max2, message = string.max) {
        return this.test({
          name: "max",
          exclusive: true,
          message,
          params: {
            max: max2
          },
          skipAbsent: true,
          test(value) {
            return value.length <= this.resolve(max2);
          }
        });
      }
      matches(regex, options) {
        let excludeEmptyString = false;
        let message;
        let name;
        if (options) {
          if (typeof options === "object") {
            ({
              excludeEmptyString = false,
              message,
              name
            } = options);
          } else {
            message = options;
          }
        }
        return this.test({
          name: name || "matches",
          message: message || string.matches,
          params: {
            regex
          },
          skipAbsent: true,
          test: (value) => value === "" && excludeEmptyString || value.search(regex) !== -1
        });
      }
      email(message = string.email) {
        return this.matches(rEmail, {
          name: "email",
          message,
          excludeEmptyString: true
        });
      }
      url(message = string.url) {
        return this.matches(rUrl, {
          name: "url",
          message,
          excludeEmptyString: true
        });
      }
      uuid(message = string.uuid) {
        return this.matches(rUUID, {
          name: "uuid",
          message,
          excludeEmptyString: false
        });
      }
      datetime(options) {
        let message = "";
        let allowOffset;
        let precision;
        if (options) {
          if (typeof options === "object") {
            ({
              message = "",
              allowOffset = false,
              precision = void 0
            } = options);
          } else {
            message = options;
          }
        }
        return this.matches(rIsoDateTime, {
          name: "datetime",
          message: message || string.datetime,
          excludeEmptyString: true
        }).test({
          name: "datetime_offset",
          message: message || string.datetime_offset,
          params: {
            allowOffset
          },
          skipAbsent: true,
          test: (value) => {
            if (!value || allowOffset)
              return true;
            const struct = parseDateStruct(value);
            if (!struct)
              return false;
            return !!struct.z;
          }
        }).test({
          name: "datetime_precision",
          message: message || string.datetime_precision,
          params: {
            precision
          },
          skipAbsent: true,
          test: (value) => {
            if (!value || precision == void 0)
              return true;
            const struct = parseDateStruct(value);
            if (!struct)
              return false;
            return struct.precision === precision;
          }
        });
      }
      //-- transforms --
      ensure() {
        return this.default("").transform((val) => val === null ? "" : val);
      }
      trim(message = string.trim) {
        return this.transform((val) => val != null ? val.trim() : val).test({
          message,
          name: "trim",
          test: isTrimmed
        });
      }
      lowercase(message = string.lowercase) {
        return this.transform((value) => !isAbsent(value) ? value.toLowerCase() : value).test({
          message,
          name: "string_case",
          exclusive: true,
          skipAbsent: true,
          test: (value) => isAbsent(value) || value === value.toLowerCase()
        });
      }
      uppercase(message = string.uppercase) {
        return this.transform((value) => !isAbsent(value) ? value.toUpperCase() : value).test({
          message,
          name: "string_case",
          exclusive: true,
          skipAbsent: true,
          test: (value) => isAbsent(value) || value === value.toUpperCase()
        });
      }
    }
    create$6.prototype = StringSchema.prototype;
    let isNaN$1 = (value) => value != +value;
    function create$5() {
      return new NumberSchema();
    }
    class NumberSchema extends Schema {
      constructor() {
        super({
          type: "number",
          check(value) {
            if (value instanceof Number)
              value = value.valueOf();
            return typeof value === "number" && !isNaN$1(value);
          }
        });
        this.withMutation(() => {
          this.transform((value, _raw, ctx) => {
            if (!ctx.spec.coerce)
              return value;
            let parsed = value;
            if (typeof parsed === "string") {
              parsed = parsed.replace(/\s/g, "");
              if (parsed === "")
                return NaN;
              parsed = +parsed;
            }
            if (ctx.isType(parsed) || parsed === null)
              return parsed;
            return parseFloat(parsed);
          });
        });
      }
      min(min2, message = number$1.min) {
        return this.test({
          message,
          name: "min",
          exclusive: true,
          params: {
            min: min2
          },
          skipAbsent: true,
          test(value) {
            return value >= this.resolve(min2);
          }
        });
      }
      max(max2, message = number$1.max) {
        return this.test({
          message,
          name: "max",
          exclusive: true,
          params: {
            max: max2
          },
          skipAbsent: true,
          test(value) {
            return value <= this.resolve(max2);
          }
        });
      }
      lessThan(less, message = number$1.lessThan) {
        return this.test({
          message,
          name: "max",
          exclusive: true,
          params: {
            less
          },
          skipAbsent: true,
          test(value) {
            return value < this.resolve(less);
          }
        });
      }
      moreThan(more, message = number$1.moreThan) {
        return this.test({
          message,
          name: "min",
          exclusive: true,
          params: {
            more
          },
          skipAbsent: true,
          test(value) {
            return value > this.resolve(more);
          }
        });
      }
      positive(msg = number$1.positive) {
        return this.moreThan(0, msg);
      }
      negative(msg = number$1.negative) {
        return this.lessThan(0, msg);
      }
      integer(message = number$1.integer) {
        return this.test({
          name: "integer",
          message,
          skipAbsent: true,
          test: (val) => Number.isInteger(val)
        });
      }
      truncate() {
        return this.transform((value) => !isAbsent(value) ? value | 0 : value);
      }
      round(method) {
        var _method;
        let avail = ["ceil", "floor", "round", "trunc"];
        method = ((_method = method) == null ? void 0 : _method.toLowerCase()) || "round";
        if (method === "trunc")
          return this.truncate();
        if (avail.indexOf(method.toLowerCase()) === -1)
          throw new TypeError("Only valid options for round() are: " + avail.join(", "));
        return this.transform((value) => !isAbsent(value) ? Math[method](value) : value);
      }
    }
    create$5.prototype = NumberSchema.prototype;
    let invalidDate = /* @__PURE__ */ new Date("");
    let isDate$1 = (obj) => Object.prototype.toString.call(obj) === "[object Date]";
    function create$4() {
      return new DateSchema();
    }
    class DateSchema extends Schema {
      constructor() {
        super({
          type: "date",
          check(v2) {
            return isDate$1(v2) && !isNaN(v2.getTime());
          }
        });
        this.withMutation(() => {
          this.transform((value, _raw, ctx) => {
            if (!ctx.spec.coerce || ctx.isType(value) || value === null)
              return value;
            value = parseIsoDate(value);
            return !isNaN(value) ? new Date(value) : DateSchema.INVALID_DATE;
          });
        });
      }
      prepareParam(ref, name) {
        let param;
        if (!Reference.isRef(ref)) {
          let cast = this.cast(ref);
          if (!this._typeCheck(cast))
            throw new TypeError(`\`${name}\` must be a Date or a value that can be \`cast()\` to a Date`);
          param = cast;
        } else {
          param = ref;
        }
        return param;
      }
      min(min2, message = date.min) {
        let limit = this.prepareParam(min2, "min");
        return this.test({
          message,
          name: "min",
          exclusive: true,
          params: {
            min: min2
          },
          skipAbsent: true,
          test(value) {
            return value >= this.resolve(limit);
          }
        });
      }
      max(max2, message = date.max) {
        let limit = this.prepareParam(max2, "max");
        return this.test({
          message,
          name: "max",
          exclusive: true,
          params: {
            max: max2
          },
          skipAbsent: true,
          test(value) {
            return value <= this.resolve(limit);
          }
        });
      }
    }
    DateSchema.INVALID_DATE = invalidDate;
    create$4.prototype = DateSchema.prototype;
    create$4.INVALID_DATE = invalidDate;
    function sortFields(fields, excludedEdges = []) {
      let edges = [];
      let nodes = /* @__PURE__ */ new Set();
      let excludes = new Set(excludedEdges.map(([a, b2]) => `${a}-${b2}`));
      function addNode(depPath, key) {
        let node2 = propertyExpr.split(depPath)[0];
        nodes.add(node2);
        if (!excludes.has(`${key}-${node2}`))
          edges.push([key, node2]);
      }
      for (const key of Object.keys(fields)) {
        let value = fields[key];
        nodes.add(key);
        if (Reference.isRef(value) && value.isSibling)
          addNode(value.path, key);
        else if (isSchema(value) && "deps" in value)
          value.deps.forEach((path) => addNode(path, key));
      }
      return toposort$1.array(Array.from(nodes), edges).reverse();
    }
    function findIndex(arr, err) {
      let idx = Infinity;
      arr.some((key, ii2) => {
        var _err$path;
        if ((_err$path = err.path) != null && _err$path.includes(key)) {
          idx = ii2;
          return true;
        }
      });
      return idx;
    }
    function sortByKeyOrder(keys2) {
      return (a, b2) => {
        return findIndex(keys2, a) - findIndex(keys2, b2);
      };
    }
    const parseJson = (value, _2, ctx) => {
      if (typeof value !== "string") {
        return value;
      }
      let parsed = value;
      try {
        parsed = JSON.parse(value);
      } catch (err) {
      }
      return ctx.isType(parsed) ? parsed : value;
    };
    function deepPartial(schema) {
      if ("fields" in schema) {
        const partial = {};
        for (const [key, fieldSchema] of Object.entries(schema.fields)) {
          partial[key] = deepPartial(fieldSchema);
        }
        return schema.setFields(partial);
      }
      if (schema.type === "array") {
        const nextArray = schema.optional();
        if (nextArray.innerType)
          nextArray.innerType = deepPartial(nextArray.innerType);
        return nextArray;
      }
      if (schema.type === "tuple") {
        return schema.optional().clone({
          types: schema.spec.types.map(deepPartial)
        });
      }
      if ("optional" in schema) {
        return schema.optional();
      }
      return schema;
    }
    const deepHas = (obj, p2) => {
      const path = [...propertyExpr.normalizePath(p2)];
      if (path.length === 1)
        return path[0] in obj;
      let last = path.pop();
      let parent = propertyExpr.getter(propertyExpr.join(path), true)(obj);
      return !!(parent && last in parent);
    };
    let isObject$1 = (obj) => Object.prototype.toString.call(obj) === "[object Object]";
    function unknown(ctx, value) {
      let known = Object.keys(ctx.fields);
      return Object.keys(value).filter((key) => known.indexOf(key) === -1);
    }
    const defaultSort = sortByKeyOrder([]);
    function create$3(spec) {
      return new ObjectSchema(spec);
    }
    class ObjectSchema extends Schema {
      constructor(spec) {
        super({
          type: "object",
          check(value) {
            return isObject$1(value) || typeof value === "function";
          }
        });
        this.fields = /* @__PURE__ */ Object.create(null);
        this._sortErrors = defaultSort;
        this._nodes = [];
        this._excludedEdges = [];
        this.withMutation(() => {
          if (spec) {
            this.shape(spec);
          }
        });
      }
      _cast(_value, options = {}) {
        var _options$stripUnknown;
        let value = super._cast(_value, options);
        if (value === void 0)
          return this.getDefault(options);
        if (!this._typeCheck(value))
          return value;
        let fields = this.fields;
        let strip = (_options$stripUnknown = options.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;
        let props = [].concat(this._nodes, Object.keys(value).filter((v2) => !this._nodes.includes(v2)));
        let intermediateValue = {};
        let innerOptions = Object.assign({}, options, {
          parent: intermediateValue,
          __validating: options.__validating || false
        });
        let isChanged = false;
        for (const prop of props) {
          let field = fields[prop];
          let exists = prop in value;
          if (field) {
            let fieldValue;
            let inputValue = value[prop];
            innerOptions.path = (options.path ? `${options.path}.` : "") + prop;
            field = field.resolve({
              value: inputValue,
              context: options.context,
              parent: intermediateValue
            });
            let fieldSpec = field instanceof Schema ? field.spec : void 0;
            let strict = fieldSpec == null ? void 0 : fieldSpec.strict;
            if (fieldSpec != null && fieldSpec.strip) {
              isChanged = isChanged || prop in value;
              continue;
            }
            fieldValue = !options.__validating || !strict ? (
              // TODO: use _cast, this is double resolving
              field.cast(value[prop], innerOptions)
            ) : value[prop];
            if (fieldValue !== void 0) {
              intermediateValue[prop] = fieldValue;
            }
          } else if (exists && !strip) {
            intermediateValue[prop] = value[prop];
          }
          if (exists !== prop in intermediateValue || intermediateValue[prop] !== value[prop]) {
            isChanged = true;
          }
        }
        return isChanged ? intermediateValue : value;
      }
      _validate(_value, options = {}, panic, next2) {
        let {
          from: from2 = [],
          originalValue = _value,
          recursive = this.spec.recursive
        } = options;
        options.from = [{
          schema: this,
          value: originalValue
        }, ...from2];
        options.__validating = true;
        options.originalValue = originalValue;
        super._validate(_value, options, panic, (objectErrors, value) => {
          if (!recursive || !isObject$1(value)) {
            next2(objectErrors, value);
            return;
          }
          originalValue = originalValue || value;
          let tests = [];
          for (let key of this._nodes) {
            let field = this.fields[key];
            if (!field || Reference.isRef(field)) {
              continue;
            }
            tests.push(field.asNestedTest({
              options,
              key,
              parent: value,
              parentPath: options.path,
              originalParent: originalValue
            }));
          }
          this.runTests({
            tests,
            value,
            originalValue,
            options
          }, panic, (fieldErrors) => {
            next2(fieldErrors.sort(this._sortErrors).concat(objectErrors), value);
          });
        });
      }
      clone(spec) {
        const next2 = super.clone(spec);
        next2.fields = Object.assign({}, this.fields);
        next2._nodes = this._nodes;
        next2._excludedEdges = this._excludedEdges;
        next2._sortErrors = this._sortErrors;
        return next2;
      }
      concat(schema) {
        let next2 = super.concat(schema);
        let nextFields = next2.fields;
        for (let [field, schemaOrRef] of Object.entries(this.fields)) {
          const target = nextFields[field];
          nextFields[field] = target === void 0 ? schemaOrRef : target;
        }
        return next2.withMutation((s) => (
          // XXX: excludes here is wrong
          s.setFields(nextFields, [...this._excludedEdges, ...schema._excludedEdges])
        ));
      }
      _getDefault(options) {
        if ("default" in this.spec) {
          return super._getDefault(options);
        }
        if (!this._nodes.length) {
          return void 0;
        }
        let dft = {};
        this._nodes.forEach((key) => {
          var _innerOptions;
          const field = this.fields[key];
          let innerOptions = options;
          if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
            innerOptions = Object.assign({}, innerOptions, {
              parent: innerOptions.value,
              value: innerOptions.value[key]
            });
          }
          dft[key] = field && "getDefault" in field ? field.getDefault(innerOptions) : void 0;
        });
        return dft;
      }
      setFields(shape2, excludedEdges) {
        let next2 = this.clone();
        next2.fields = shape2;
        next2._nodes = sortFields(shape2, excludedEdges);
        next2._sortErrors = sortByKeyOrder(Object.keys(shape2));
        if (excludedEdges)
          next2._excludedEdges = excludedEdges;
        return next2;
      }
      shape(additions, excludes = []) {
        return this.clone().withMutation((next2) => {
          let edges = next2._excludedEdges;
          if (excludes.length) {
            if (!Array.isArray(excludes[0]))
              excludes = [excludes];
            edges = [...next2._excludedEdges, ...excludes];
          }
          return next2.setFields(Object.assign(next2.fields, additions), edges);
        });
      }
      partial() {
        const partial = {};
        for (const [key, schema] of Object.entries(this.fields)) {
          partial[key] = "optional" in schema && schema.optional instanceof Function ? schema.optional() : schema;
        }
        return this.setFields(partial);
      }
      deepPartial() {
        const next2 = deepPartial(this);
        return next2;
      }
      pick(keys2) {
        const picked = {};
        for (const key of keys2) {
          if (this.fields[key])
            picked[key] = this.fields[key];
        }
        return this.setFields(picked, this._excludedEdges.filter(([a, b2]) => keys2.includes(a) && keys2.includes(b2)));
      }
      omit(keys2) {
        const remaining = [];
        for (const key of Object.keys(this.fields)) {
          if (keys2.includes(key))
            continue;
          remaining.push(key);
        }
        return this.pick(remaining);
      }
      from(from2, to, alias) {
        let fromGetter = propertyExpr.getter(from2, true);
        return this.transform((obj) => {
          if (!obj)
            return obj;
          let newObj = obj;
          if (deepHas(obj, from2)) {
            newObj = Object.assign({}, obj);
            if (!alias)
              delete newObj[from2];
            newObj[to] = fromGetter(obj);
          }
          return newObj;
        });
      }
      /** Parse an input JSON string to an object */
      json() {
        return this.transform(parseJson);
      }
      noUnknown(noAllow = true, message = object.noUnknown) {
        if (typeof noAllow !== "boolean") {
          message = noAllow;
          noAllow = true;
        }
        let next2 = this.test({
          name: "noUnknown",
          exclusive: true,
          message,
          test(value) {
            if (value == null)
              return true;
            const unknownKeys = unknown(this.schema, value);
            return !noAllow || unknownKeys.length === 0 || this.createError({
              params: {
                unknown: unknownKeys.join(", ")
              }
            });
          }
        });
        next2.spec.noUnknown = noAllow;
        return next2;
      }
      unknown(allow = true, message = object.noUnknown) {
        return this.noUnknown(!allow, message);
      }
      transformKeys(fn) {
        return this.transform((obj) => {
          if (!obj)
            return obj;
          const result = {};
          for (const key of Object.keys(obj))
            result[fn(key)] = obj[key];
          return result;
        });
      }
      camelCase() {
        return this.transformKeys(tinyCase.camelCase);
      }
      snakeCase() {
        return this.transformKeys(tinyCase.snakeCase);
      }
      constantCase() {
        return this.transformKeys((key) => tinyCase.snakeCase(key).toUpperCase());
      }
      describe(options) {
        const next2 = (options ? this.resolve(options) : this).clone();
        const base = super.describe(options);
        base.fields = {};
        for (const [key, value] of Object.entries(next2.fields)) {
          var _innerOptions2;
          let innerOptions = options;
          if ((_innerOptions2 = innerOptions) != null && _innerOptions2.value) {
            innerOptions = Object.assign({}, innerOptions, {
              parent: innerOptions.value,
              value: innerOptions.value[key]
            });
          }
          base.fields[key] = value.describe(innerOptions);
        }
        return base;
      }
    }
    create$3.prototype = ObjectSchema.prototype;
    function create$2(type) {
      return new ArraySchema(type);
    }
    class ArraySchema extends Schema {
      constructor(type) {
        super({
          type: "array",
          spec: {
            types: type
          },
          check(v2) {
            return Array.isArray(v2);
          }
        });
        this.innerType = void 0;
        this.innerType = type;
      }
      _cast(_value, _opts) {
        const value = super._cast(_value, _opts);
        if (!this._typeCheck(value) || !this.innerType) {
          return value;
        }
        let isChanged = false;
        const castArray = value.map((v2, idx) => {
          const castElement = this.innerType.cast(v2, Object.assign({}, _opts, {
            path: `${_opts.path || ""}[${idx}]`
          }));
          if (castElement !== v2) {
            isChanged = true;
          }
          return castElement;
        });
        return isChanged ? castArray : value;
      }
      _validate(_value, options = {}, panic, next2) {
        var _options$recursive;
        let innerType = this.innerType;
        let recursive = (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive;
        options.originalValue != null ? options.originalValue : _value;
        super._validate(_value, options, panic, (arrayErrors, value) => {
          var _options$originalValu2;
          if (!recursive || !innerType || !this._typeCheck(value)) {
            next2(arrayErrors, value);
            return;
          }
          let tests = new Array(value.length);
          for (let index = 0; index < value.length; index++) {
            var _options$originalValu;
            tests[index] = innerType.asNestedTest({
              options,
              index,
              parent: value,
              parentPath: options.path,
              originalParent: (_options$originalValu = options.originalValue) != null ? _options$originalValu : _value
            });
          }
          this.runTests({
            value,
            tests,
            originalValue: (_options$originalValu2 = options.originalValue) != null ? _options$originalValu2 : _value,
            options
          }, panic, (innerTypeErrors) => next2(innerTypeErrors.concat(arrayErrors), value));
        });
      }
      clone(spec) {
        const next2 = super.clone(spec);
        next2.innerType = this.innerType;
        return next2;
      }
      /** Parse an input JSON string to an object */
      json() {
        return this.transform(parseJson);
      }
      concat(schema) {
        let next2 = super.concat(schema);
        next2.innerType = this.innerType;
        if (schema.innerType)
          next2.innerType = next2.innerType ? (
            // @ts-expect-error Lazy doesn't have concat and will break
            next2.innerType.concat(schema.innerType)
          ) : schema.innerType;
        return next2;
      }
      of(schema) {
        let next2 = this.clone();
        if (!isSchema(schema))
          throw new TypeError("`array.of()` sub-schema must be a valid yup schema not: " + printValue(schema));
        next2.innerType = schema;
        next2.spec = Object.assign({}, next2.spec, {
          types: schema
        });
        return next2;
      }
      length(length2, message = array.length) {
        return this.test({
          message,
          name: "length",
          exclusive: true,
          params: {
            length: length2
          },
          skipAbsent: true,
          test(value) {
            return value.length === this.resolve(length2);
          }
        });
      }
      min(min2, message) {
        message = message || array.min;
        return this.test({
          message,
          name: "min",
          exclusive: true,
          params: {
            min: min2
          },
          skipAbsent: true,
          // FIXME(ts): Array<typeof T>
          test(value) {
            return value.length >= this.resolve(min2);
          }
        });
      }
      max(max2, message) {
        message = message || array.max;
        return this.test({
          message,
          name: "max",
          exclusive: true,
          params: {
            max: max2
          },
          skipAbsent: true,
          test(value) {
            return value.length <= this.resolve(max2);
          }
        });
      }
      ensure() {
        return this.default(() => []).transform((val, original) => {
          if (this._typeCheck(val))
            return val;
          return original == null ? [] : [].concat(original);
        });
      }
      compact(rejector) {
        let reject = !rejector ? (v2) => !!v2 : (v2, i, a) => !rejector(v2, i, a);
        return this.transform((values2) => values2 != null ? values2.filter(reject) : values2);
      }
      describe(options) {
        const next2 = (options ? this.resolve(options) : this).clone();
        const base = super.describe(options);
        if (next2.innerType) {
          var _innerOptions;
          let innerOptions = options;
          if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
            innerOptions = Object.assign({}, innerOptions, {
              parent: innerOptions.value,
              value: innerOptions.value[0]
            });
          }
          base.innerType = next2.innerType.describe(innerOptions);
        }
        return base;
      }
    }
    create$2.prototype = ArraySchema.prototype;
    const LoginFormValidation = create$3().shape({
      email: create$6().email("Invalid email").required("Email is required"),
      password: create$6().required("Password is required")
    });
    const RegisterFormValidation = create$3().shape({
      name: create$6().required("Name is required").min(3, "Name must be at least 3 characters").max(20, "Name must be at most 20 characters"),
      email: create$6().email("Invalid email").required("Email is required"),
      password: create$6().required("Password is required").min(6, "Password must be at least 6 characters").max(20, "Password must be at most 20 characters").matches(/(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+{}\[\]:;<>,.?~\\/-]).{8,}/, "Password must contain at least one uppercase letter, one lowercase letter, one number and one special character"),
      confirmPassword: create$6().required("Confirm password is required").oneOf([create$9("password"), null], "Passwords must match")
    });
    const PasswordUpdateFormValidation = create$3().shape({
      password: create$6().required("New password is required").min(6, "Password must be at least 6 characters").max(20, "Password must be at most 20 characters").matches(/(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+{}\[\]:;<>,.?~\\/-]).{8,}/, "Password must contain at least one uppercase letter, one lowercase letter, one number and one special character"),
      confirmPassword: create$6().required("Confirm password is required").oneOf([create$9("password"), null], "Passwords must match")
    });
    const WelcomePageFormValidation = create$3().shape({
      start_date: create$4().required("Start date is required").min(/* @__PURE__ */ new Date(), "Start date must be after today"),
      end_date: create$4().min(create$9("start_date"), "End date must be after start date"),
      venue_type: create$6().required("Venue type is required")
    });
    create$3().shape({
      max_qty: create$5().required("Maximum quantity is required"),
      qty: create$5().required("Quantity is required").min(1, "Quantity must be at least 1").max(create$9("max_qty"), `Quantity must be at most ${create$9("max_qty")}`)
    });
    const BookingFormValidation = create$3().shape({
      name_of_organization_individual: create$6().required("Name of organization/individual is required"),
      account_name: create$6().required("Account name is required"),
      account_number: create$6().required("Account number is required"),
      bank_name: create$6().required("Bank name is required"),
      bank_code: create$6().required("Bank code is required"),
      branch_name: create$6().required("Branch name is required"),
      branch_code: create$6().required("Branch code is required"),
      swift_code: create$6().matches(/^[A-Za-z]{4}[A-Za-z]{2}\w{2}(\w{3})?$/, "Invalid swift code"),
      contact_person: create$6().required("Contact person is required"),
      address: create$6().required("Address is required"),
      telephone_no: create$6().matches(/^[0]{1}[0-9]{9}$/, "Invalid telephone number"),
      mobile_no: create$6().matches(/^[0]{1}[7]{1}[01245678]{1}[0-9]{7}$/, "Invalid mobile number"),
      email: create$6().email("Invalid email").required("Email is required"),
      name_of_the_event: create$6(),
      venue_name: create$6(),
      date: create$4(),
      time: create$6(),
      event_type: create$2().min(1, "Event type is required").required("Event type is required"),
      setup: create$2(),
      public_performance_approval: create$7(),
      meal_plan: create$2().of(
        create$3().shape({
          meal: create$6().required("Meal is required"),
          time: create$6().when("selected", {
            is: true,
            then: create$6().required("Time is required")
          }),
          selected: create$7()
        })
      ),
      chief_guest: create$6(),
      expected: create$5().required("Expected number of guests is required").min(1, "Expected number of guests must be at least 1"),
      guaranteed: create$5().required("Guaranteed number of guests is required").min(0, "Guaranteed number of guests must be at least 0"),
      VAT_registration_no: create$6().matches(/^\d{9}$/, "Invalid VAT registration"),
      VAT_copy: create$8(),
      other: create$6()
    });
    function _objectWithoutPropertiesLoose$1(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function _extends$1() {
      _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends$1.apply(this, arguments);
    }
    var propTypes = { exports: {} };
    var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
    var ReactPropTypesSecret = ReactPropTypesSecret_1;
    function emptyFunction() {
    }
    function emptyFunctionWithReset() {
    }
    emptyFunctionWithReset.resetWarningCache = emptyFunction;
    var factoryWithThrowingShims = function() {
      function shim2(props, propName, componentName, location, propFullName, secret) {
        if (secret === ReactPropTypesSecret) {
          return;
        }
        var err = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        err.name = "Invariant Violation";
        throw err;
      }
      shim2.isRequired = shim2;
      function getShim() {
        return shim2;
      }
      var ReactPropTypes = {
        array: shim2,
        bigint: shim2,
        bool: shim2,
        func: shim2,
        number: shim2,
        object: shim2,
        string: shim2,
        symbol: shim2,
        any: shim2,
        arrayOf: getShim,
        element: shim2,
        elementType: shim2,
        instanceOf: getShim,
        node: shim2,
        objectOf: getShim,
        oneOf: getShim,
        oneOfType: getShim,
        shape: getShim,
        exact: getShim,
        checkPropTypes: emptyFunctionWithReset,
        resetWarningCache: emptyFunction
      };
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
    {
      propTypes.exports = factoryWithThrowingShims();
    }
    var propTypesExports = propTypes.exports;
    const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
    function r$2(e2) {
      var t2, f2, n2 = "";
      if ("string" == typeof e2 || "number" == typeof e2)
        n2 += e2;
      else if ("object" == typeof e2)
        if (Array.isArray(e2)) {
          var o = e2.length;
          for (t2 = 0; t2 < o; t2++)
            e2[t2] && (f2 = r$2(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
        } else
          for (f2 in e2)
            e2[f2] && (n2 && (n2 += " "), n2 += f2);
      return n2;
    }
    function clsx() {
      for (var e2, t2, f2 = 0, n2 = "", o = arguments.length; f2 < o; f2++)
        (e2 = arguments[f2]) && (t2 = r$2(e2)) && (n2 && (n2 += " "), n2 += t2);
      return n2;
    }
    function isPlainObject$1(item) {
      if (typeof item !== "object" || item === null) {
        return false;
      }
      const prototype2 = Object.getPrototypeOf(item);
      return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in item) && !(Symbol.iterator in item);
    }
    function deepClone(source) {
      if (!isPlainObject$1(source)) {
        return source;
      }
      const output = {};
      Object.keys(source).forEach((key) => {
        output[key] = deepClone(source[key]);
      });
      return output;
    }
    function deepmerge(target, source, options = {
      clone: true
    }) {
      const output = options.clone ? _extends$1({}, target) : target;
      if (isPlainObject$1(target) && isPlainObject$1(source)) {
        Object.keys(source).forEach((key) => {
          if (key === "__proto__") {
            return;
          }
          if (isPlainObject$1(source[key]) && key in target && isPlainObject$1(target[key])) {
            output[key] = deepmerge(target[key], source[key], options);
          } else if (options.clone) {
            output[key] = isPlainObject$1(source[key]) ? deepClone(source[key]) : source[key];
          } else {
            output[key] = source[key];
          }
        });
      }
      return output;
    }
    function formatMuiErrorMessage(code) {
      let url = "https://mui.com/production-error/?code=" + code;
      for (let i = 1; i < arguments.length; i += 1) {
        url += "&args[]=" + encodeURIComponent(arguments[i]);
      }
      return "Minified MUI error #" + code + "; visit " + url + " for the full message.";
    }
    var reactIs_production_min = {};
    /**
     * @license React
     * react-is.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var b = Symbol.for("react.element"), c = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), e$1 = Symbol.for("react.strict_mode"), f = Symbol.for("react.profiler"), g = Symbol.for("react.provider"), h$2 = Symbol.for("react.context"), k$1 = Symbol.for("react.server_context"), l$1 = Symbol.for("react.forward_ref"), m$1 = Symbol.for("react.suspense"), n$2 = Symbol.for("react.suspense_list"), p$2 = Symbol.for("react.memo"), q$2 = Symbol.for("react.lazy"), t$2 = Symbol.for("react.offscreen"), u$2;
    u$2 = Symbol.for("react.module.reference");
    function v$1(a) {
      if ("object" === typeof a && null !== a) {
        var r2 = a.$$typeof;
        switch (r2) {
          case b:
            switch (a = a.type, a) {
              case d:
              case f:
              case e$1:
              case m$1:
              case n$2:
                return a;
              default:
                switch (a = a && a.$$typeof, a) {
                  case k$1:
                  case h$2:
                  case l$1:
                  case q$2:
                  case p$2:
                  case g:
                    return a;
                  default:
                    return r2;
                }
            }
          case c:
            return r2;
        }
      }
    }
    reactIs_production_min.ContextConsumer = h$2;
    reactIs_production_min.ContextProvider = g;
    reactIs_production_min.Element = b;
    reactIs_production_min.ForwardRef = l$1;
    reactIs_production_min.Fragment = d;
    reactIs_production_min.Lazy = q$2;
    reactIs_production_min.Memo = p$2;
    reactIs_production_min.Portal = c;
    reactIs_production_min.Profiler = f;
    reactIs_production_min.StrictMode = e$1;
    reactIs_production_min.Suspense = m$1;
    reactIs_production_min.SuspenseList = n$2;
    reactIs_production_min.isAsyncMode = function() {
      return false;
    };
    reactIs_production_min.isConcurrentMode = function() {
      return false;
    };
    reactIs_production_min.isContextConsumer = function(a) {
      return v$1(a) === h$2;
    };
    reactIs_production_min.isContextProvider = function(a) {
      return v$1(a) === g;
    };
    reactIs_production_min.isElement = function(a) {
      return "object" === typeof a && null !== a && a.$$typeof === b;
    };
    reactIs_production_min.isForwardRef = function(a) {
      return v$1(a) === l$1;
    };
    reactIs_production_min.isFragment = function(a) {
      return v$1(a) === d;
    };
    reactIs_production_min.isLazy = function(a) {
      return v$1(a) === q$2;
    };
    reactIs_production_min.isMemo = function(a) {
      return v$1(a) === p$2;
    };
    reactIs_production_min.isPortal = function(a) {
      return v$1(a) === c;
    };
    reactIs_production_min.isProfiler = function(a) {
      return v$1(a) === f;
    };
    reactIs_production_min.isStrictMode = function(a) {
      return v$1(a) === e$1;
    };
    reactIs_production_min.isSuspense = function(a) {
      return v$1(a) === m$1;
    };
    reactIs_production_min.isSuspenseList = function(a) {
      return v$1(a) === n$2;
    };
    reactIs_production_min.isValidElementType = function(a) {
      return "string" === typeof a || "function" === typeof a || a === d || a === f || a === e$1 || a === m$1 || a === n$2 || a === t$2 || "object" === typeof a && null !== a && (a.$$typeof === q$2 || a.$$typeof === p$2 || a.$$typeof === g || a.$$typeof === h$2 || a.$$typeof === l$1 || a.$$typeof === u$2 || void 0 !== a.getModuleId) ? true : false;
    };
    reactIs_production_min.typeOf = v$1;
    const refType = PropTypes.oneOfType([PropTypes.func, PropTypes.object]);
    const refType$1 = refType;
    function capitalize(string2) {
      if (typeof string2 !== "string") {
        throw new Error(formatMuiErrorMessage(7));
      }
      return string2.charAt(0).toUpperCase() + string2.slice(1);
    }
    function createChainedFunction(...funcs) {
      return funcs.reduce((acc, func) => {
        if (func == null) {
          return acc;
        }
        return function chainedFunction(...args) {
          acc.apply(this, args);
          func.apply(this, args);
        };
      }, () => {
      });
    }
    function debounce$1(func, wait = 166) {
      let timeout;
      function debounced(...args) {
        const later = () => {
          func.apply(this, args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      }
      debounced.clear = () => {
        clearTimeout(timeout);
      };
      return debounced;
    }
    function deprecatedPropType(validator2, reason) {
      {
        return () => null;
      }
    }
    function isMuiElement(element, muiNames) {
      var _muiName, _element$type;
      return /* @__PURE__ */ reactExports.isValidElement(element) && muiNames.indexOf(
        // For server components `muiName` is avaialble in element.type._payload.value.muiName
        // relevant info - https://github.com/facebook/react/blob/2807d781a08db8e9873687fccc25c0f12b4fb3d4/packages/react/src/ReactLazy.js#L45
        // eslint-disable-next-line no-underscore-dangle
        (_muiName = element.type.muiName) != null ? _muiName : (_element$type = element.type) == null || (_element$type = _element$type._payload) == null || (_element$type = _element$type.value) == null ? void 0 : _element$type.muiName
      ) !== -1;
    }
    function ownerDocument(node2) {
      return node2 && node2.ownerDocument || document;
    }
    function ownerWindow(node2) {
      const doc = ownerDocument(node2);
      return doc.defaultView || window;
    }
    function requirePropFactory(componentNameInError, Component) {
      {
        return () => null;
      }
    }
    function setRef(ref, value) {
      if (typeof ref === "function") {
        ref(value);
      } else if (ref) {
        ref.current = value;
      }
    }
    const useEnhancedEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
    let globalId = 0;
    function useGlobalId(idOverride) {
      const [defaultId, setDefaultId] = reactExports.useState(idOverride);
      const id2 = idOverride || defaultId;
      reactExports.useEffect(() => {
        if (defaultId == null) {
          globalId += 1;
          setDefaultId(`mui-${globalId}`);
        }
      }, [defaultId]);
      return id2;
    }
    const maybeReactUseId = React$1["useId".toString()];
    function useId(idOverride) {
      if (maybeReactUseId !== void 0) {
        const reactId = maybeReactUseId();
        return idOverride != null ? idOverride : reactId;
      }
      return useGlobalId(idOverride);
    }
    function unsupportedProp(props, propName, componentName, location, propFullName) {
      {
        return null;
      }
    }
    function useControlled({
      controlled,
      default: defaultProp,
      name,
      state = "value"
    }) {
      const {
        current: isControlled
      } = reactExports.useRef(controlled !== void 0);
      const [valueState, setValue] = reactExports.useState(defaultProp);
      const value = isControlled ? controlled : valueState;
      const setValueIfUncontrolled = reactExports.useCallback((newValue) => {
        if (!isControlled) {
          setValue(newValue);
        }
      }, []);
      return [value, setValueIfUncontrolled];
    }
    function useEventCallback(fn) {
      const ref = reactExports.useRef(fn);
      useEnhancedEffect(() => {
        ref.current = fn;
      });
      return reactExports.useRef((...args) => (
        // @ts-expect-error hide `this`
        (0, ref.current)(...args)
      )).current;
    }
    function useForkRef(...refs) {
      return reactExports.useMemo(() => {
        if (refs.every((ref) => ref == null)) {
          return null;
        }
        return (instance2) => {
          refs.forEach((ref) => {
            setRef(ref, instance2);
          });
        };
      }, refs);
    }
    const UNINITIALIZED = {};
    function useLazyRef(init, initArg) {
      const ref = reactExports.useRef(UNINITIALIZED);
      if (ref.current === UNINITIALIZED) {
        ref.current = init(initArg);
      }
      return ref;
    }
    const EMPTY = [];
    function useOnMount(fn) {
      reactExports.useEffect(fn, EMPTY);
    }
    class Timeout {
      constructor() {
        this.currentId = 0;
        this.clear = () => {
          if (this.currentId !== 0) {
            clearTimeout(this.currentId);
            this.currentId = 0;
          }
        };
        this.disposeEffect = () => {
          return this.clear;
        };
      }
      static create() {
        return new Timeout();
      }
      /**
       * Executes `fn` after `delay`, clearing any previously scheduled call.
       */
      start(delay2, fn) {
        this.clear();
        this.currentId = setTimeout(() => {
          this.currentId = 0;
          fn();
        }, delay2);
      }
    }
    function useTimeout() {
      const timeout = useLazyRef(Timeout.create).current;
      useOnMount(timeout.disposeEffect);
      return timeout;
    }
    let hadKeyboardEvent = true;
    let hadFocusVisibleRecently = false;
    const hadFocusVisibleRecentlyTimeout = new Timeout();
    const inputTypesWhitelist = {
      text: true,
      search: true,
      url: true,
      tel: true,
      email: true,
      password: true,
      number: true,
      date: true,
      month: true,
      week: true,
      time: true,
      datetime: true,
      "datetime-local": true
    };
    function focusTriggersKeyboardModality(node2) {
      const {
        type,
        tagName
      } = node2;
      if (tagName === "INPUT" && inputTypesWhitelist[type] && !node2.readOnly) {
        return true;
      }
      if (tagName === "TEXTAREA" && !node2.readOnly) {
        return true;
      }
      if (node2.isContentEditable) {
        return true;
      }
      return false;
    }
    function handleKeyDown(event) {
      if (event.metaKey || event.altKey || event.ctrlKey) {
        return;
      }
      hadKeyboardEvent = true;
    }
    function handlePointerDown() {
      hadKeyboardEvent = false;
    }
    function handleVisibilityChange() {
      if (this.visibilityState === "hidden") {
        if (hadFocusVisibleRecently) {
          hadKeyboardEvent = true;
        }
      }
    }
    function prepare(doc) {
      doc.addEventListener("keydown", handleKeyDown, true);
      doc.addEventListener("mousedown", handlePointerDown, true);
      doc.addEventListener("pointerdown", handlePointerDown, true);
      doc.addEventListener("touchstart", handlePointerDown, true);
      doc.addEventListener("visibilitychange", handleVisibilityChange, true);
    }
    function isFocusVisible(event) {
      const {
        target
      } = event;
      try {
        return target.matches(":focus-visible");
      } catch (error) {
      }
      return hadKeyboardEvent || focusTriggersKeyboardModality(target);
    }
    function useIsFocusVisible() {
      const ref = reactExports.useCallback((node2) => {
        if (node2 != null) {
          prepare(node2.ownerDocument);
        }
      }, []);
      const isFocusVisibleRef = reactExports.useRef(false);
      function handleBlurVisible() {
        if (isFocusVisibleRef.current) {
          hadFocusVisibleRecently = true;
          hadFocusVisibleRecentlyTimeout.start(100, () => {
            hadFocusVisibleRecently = false;
          });
          isFocusVisibleRef.current = false;
          return true;
        }
        return false;
      }
      function handleFocusVisible(event) {
        if (isFocusVisible(event)) {
          isFocusVisibleRef.current = true;
          return true;
        }
        return false;
      }
      return {
        isFocusVisibleRef,
        onFocus: handleFocusVisible,
        onBlur: handleBlurVisible,
        ref
      };
    }
    function getScrollbarSize(doc) {
      const documentWidth = doc.documentElement.clientWidth;
      return Math.abs(window.innerWidth - documentWidth);
    }
    function resolveProps(defaultProps2, props) {
      const output = _extends$1({}, props);
      Object.keys(defaultProps2).forEach((propName) => {
        if (propName.toString().match(/^(components|slots)$/)) {
          output[propName] = _extends$1({}, defaultProps2[propName], output[propName]);
        } else if (propName.toString().match(/^(componentsProps|slotProps)$/)) {
          const defaultSlotProps = defaultProps2[propName] || {};
          const slotProps = props[propName];
          output[propName] = {};
          if (!slotProps || !Object.keys(slotProps)) {
            output[propName] = defaultSlotProps;
          } else if (!defaultSlotProps || !Object.keys(defaultSlotProps)) {
            output[propName] = slotProps;
          } else {
            output[propName] = _extends$1({}, slotProps);
            Object.keys(defaultSlotProps).forEach((slotPropName) => {
              output[propName][slotPropName] = resolveProps(defaultSlotProps[slotPropName], slotProps[slotPropName]);
            });
          }
        } else if (output[propName] === void 0) {
          output[propName] = defaultProps2[propName];
        }
      });
      return output;
    }
    function composeClasses(slots, getUtilityClass, classes = void 0) {
      const output = {};
      Object.keys(slots).forEach(
        // `Object.keys(slots)` can't be wider than `T` because we infer `T` from `slots`.
        // @ts-expect-error https://github.com/microsoft/TypeScript/pull/12253#issuecomment-263132208
        (slot) => {
          output[slot] = slots[slot].reduce((acc, key) => {
            if (key) {
              const utilityClass = getUtilityClass(key);
              if (utilityClass !== "") {
                acc.push(utilityClass);
              }
              if (classes && classes[key]) {
                acc.push(classes[key]);
              }
            }
            return acc;
          }, []).join(" ");
        }
      );
      return output;
    }
    const defaultGenerator = (componentName) => componentName;
    const createClassNameGenerator = () => {
      let generate = defaultGenerator;
      return {
        configure(generator) {
          generate = generator;
        },
        generate(componentName) {
          return generate(componentName);
        },
        reset() {
          generate = defaultGenerator;
        }
      };
    };
    const ClassNameGenerator = createClassNameGenerator();
    const globalStateClasses = {
      active: "active",
      checked: "checked",
      completed: "completed",
      disabled: "disabled",
      error: "error",
      expanded: "expanded",
      focused: "focused",
      focusVisible: "focusVisible",
      open: "open",
      readOnly: "readOnly",
      required: "required",
      selected: "selected"
    };
    function generateUtilityClass$1(componentName, slot, globalStatePrefix = "Mui") {
      const globalStateClass = globalStateClasses[slot];
      return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator.generate(componentName)}-${slot}`;
    }
    function generateUtilityClasses$1(componentName, slots, globalStatePrefix = "Mui") {
      const result = {};
      slots.forEach((slot) => {
        result[slot] = generateUtilityClass$1(componentName, slot, globalStatePrefix);
      });
      return result;
    }
    function clamp$1(val, min2 = Number.MIN_SAFE_INTEGER, max2 = Number.MAX_SAFE_INTEGER) {
      return Math.max(min2, Math.min(val, max2));
    }
    function memoize$1(fn) {
      var cache = /* @__PURE__ */ Object.create(null);
      return function(arg) {
        if (cache[arg] === void 0)
          cache[arg] = fn(arg);
        return cache[arg];
      };
    }
    var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
    var isPropValid = /* @__PURE__ */ memoize$1(
      function(prop) {
        return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
      }
      /* Z+1 */
    );
    function sheetForTag(tag) {
      if (tag.sheet) {
        return tag.sheet;
      }
      for (var i = 0; i < document.styleSheets.length; i++) {
        if (document.styleSheets[i].ownerNode === tag) {
          return document.styleSheets[i];
        }
      }
    }
    function createStyleElement(options) {
      var tag = document.createElement("style");
      tag.setAttribute("data-emotion", options.key);
      if (options.nonce !== void 0) {
        tag.setAttribute("nonce", options.nonce);
      }
      tag.appendChild(document.createTextNode(""));
      tag.setAttribute("data-s", "");
      return tag;
    }
    var StyleSheet = /* @__PURE__ */ function() {
      function StyleSheet2(options) {
        var _this = this;
        this._insertTag = function(tag) {
          var before;
          if (_this.tags.length === 0) {
            if (_this.insertionPoint) {
              before = _this.insertionPoint.nextSibling;
            } else if (_this.prepend) {
              before = _this.container.firstChild;
            } else {
              before = _this.before;
            }
          } else {
            before = _this.tags[_this.tags.length - 1].nextSibling;
          }
          _this.container.insertBefore(tag, before);
          _this.tags.push(tag);
        };
        this.isSpeedy = options.speedy === void 0 ? true : options.speedy;
        this.tags = [];
        this.ctr = 0;
        this.nonce = options.nonce;
        this.key = options.key;
        this.container = options.container;
        this.prepend = options.prepend;
        this.insertionPoint = options.insertionPoint;
        this.before = null;
      }
      var _proto = StyleSheet2.prototype;
      _proto.hydrate = function hydrate(nodes) {
        nodes.forEach(this._insertTag);
      };
      _proto.insert = function insert(rule) {
        if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
          this._insertTag(createStyleElement(this));
        }
        var tag = this.tags[this.tags.length - 1];
        if (this.isSpeedy) {
          var sheet = sheetForTag(tag);
          try {
            sheet.insertRule(rule, sheet.cssRules.length);
          } catch (e2) {
          }
        } else {
          tag.appendChild(document.createTextNode(rule));
        }
        this.ctr++;
      };
      _proto.flush = function flush() {
        this.tags.forEach(function(tag) {
          return tag.parentNode && tag.parentNode.removeChild(tag);
        });
        this.tags = [];
        this.ctr = 0;
      };
      return StyleSheet2;
    }();
    var MS = "-ms-";
    var MOZ = "-moz-";
    var WEBKIT = "-webkit-";
    var COMMENT = "comm";
    var RULESET = "rule";
    var DECLARATION = "decl";
    var IMPORT = "@import";
    var KEYFRAMES = "@keyframes";
    var LAYER = "@layer";
    var abs = Math.abs;
    var from = String.fromCharCode;
    var assign = Object.assign;
    function hash$2(value, length2) {
      return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
    }
    function trim$1(value) {
      return value.trim();
    }
    function match(value, pattern) {
      return (value = pattern.exec(value)) ? value[0] : value;
    }
    function replace(value, pattern, replacement) {
      return value.replace(pattern, replacement);
    }
    function indexof(value, search) {
      return value.indexOf(search);
    }
    function charat(value, index) {
      return value.charCodeAt(index) | 0;
    }
    function substr(value, begin, end2) {
      return value.slice(begin, end2);
    }
    function strlen(value) {
      return value.length;
    }
    function sizeof(value) {
      return value.length;
    }
    function append(value, array2) {
      return array2.push(value), value;
    }
    function combine(array2, callback) {
      return array2.map(callback).join("");
    }
    var line = 1;
    var column = 1;
    var length = 0;
    var position = 0;
    var character = 0;
    var characters = "";
    function node(value, root2, parent, type, props, children, length2) {
      return { value, root: root2, parent, type, props, children, line, column, length: length2, return: "" };
    }
    function copy(root2, props) {
      return assign(node("", null, null, "", null, null, 0), root2, { length: -root2.length }, props);
    }
    function char() {
      return character;
    }
    function prev() {
      character = position > 0 ? charat(characters, --position) : 0;
      if (column--, character === 10)
        column = 1, line--;
      return character;
    }
    function next() {
      character = position < length ? charat(characters, position++) : 0;
      if (column++, character === 10)
        column = 1, line++;
      return character;
    }
    function peek() {
      return charat(characters, position);
    }
    function caret() {
      return position;
    }
    function slice(begin, end2) {
      return substr(characters, begin, end2);
    }
    function token(type) {
      switch (type) {
        case 0:
        case 9:
        case 10:
        case 13:
        case 32:
          return 5;
        case 33:
        case 43:
        case 44:
        case 47:
        case 62:
        case 64:
        case 126:
        case 59:
        case 123:
        case 125:
          return 4;
        case 58:
          return 3;
        case 34:
        case 39:
        case 40:
        case 91:
          return 2;
        case 41:
        case 93:
          return 1;
      }
      return 0;
    }
    function alloc(value) {
      return line = column = 1, length = strlen(characters = value), position = 0, [];
    }
    function dealloc(value) {
      return characters = "", value;
    }
    function delimit(type) {
      return trim$1(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
    }
    function whitespace(type) {
      while (character = peek())
        if (character < 33)
          next();
        else
          break;
      return token(type) > 2 || token(character) > 3 ? "" : " ";
    }
    function escaping(index, count) {
      while (--count && next())
        if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
          break;
      return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
    }
    function delimiter(type) {
      while (next())
        switch (character) {
          case type:
            return position;
          case 34:
          case 39:
            if (type !== 34 && type !== 39)
              delimiter(character);
            break;
          case 40:
            if (type === 41)
              delimiter(type);
            break;
          case 92:
            next();
            break;
        }
      return position;
    }
    function commenter(type, index) {
      while (next())
        if (type + character === 47 + 10)
          break;
        else if (type + character === 42 + 42 && peek() === 47)
          break;
      return "/*" + slice(index, position - 1) + "*" + from(type === 47 ? type : next());
    }
    function identifier(index) {
      while (!token(peek()))
        next();
      return slice(index, position);
    }
    function compile(value) {
      return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
    }
    function parse(value, root2, parent, rule, rules, rulesets, pseudo, points, declarations) {
      var index = 0;
      var offset2 = 0;
      var length2 = pseudo;
      var atrule = 0;
      var property = 0;
      var previous = 0;
      var variable = 1;
      var scanning = 1;
      var ampersand = 1;
      var character2 = 0;
      var type = "";
      var props = rules;
      var children = rulesets;
      var reference2 = rule;
      var characters2 = type;
      while (scanning)
        switch (previous = character2, character2 = next()) {
          case 40:
            if (previous != 108 && charat(characters2, length2 - 1) == 58) {
              if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
                ampersand = -1;
              break;
            }
          case 34:
          case 39:
          case 91:
            characters2 += delimit(character2);
            break;
          case 9:
          case 10:
          case 13:
          case 32:
            characters2 += whitespace(previous);
            break;
          case 92:
            characters2 += escaping(caret() - 1, 7);
            continue;
          case 47:
            switch (peek()) {
              case 42:
              case 47:
                append(comment(commenter(next(), caret()), root2, parent), declarations);
                break;
              default:
                characters2 += "/";
            }
            break;
          case 123 * variable:
            points[index++] = strlen(characters2) * ampersand;
          case 125 * variable:
          case 59:
          case 0:
            switch (character2) {
              case 0:
              case 125:
                scanning = 0;
              case 59 + offset2:
                if (ampersand == -1)
                  characters2 = replace(characters2, /\f/g, "");
                if (property > 0 && strlen(characters2) - length2)
                  append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
                break;
              case 59:
                characters2 += ";";
              default:
                append(reference2 = ruleset(characters2, root2, parent, index, offset2, rules, points, type, props = [], children = [], length2), rulesets);
                if (character2 === 123)
                  if (offset2 === 0)
                    parse(characters2, root2, reference2, reference2, props, rulesets, length2, points, children);
                  else
                    switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                      case 100:
                      case 108:
                      case 109:
                      case 115:
                        parse(value, reference2, reference2, rule && append(ruleset(value, reference2, reference2, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                        break;
                      default:
                        parse(characters2, reference2, reference2, reference2, [""], children, 0, points, children);
                    }
            }
            index = offset2 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
            break;
          case 58:
            length2 = 1 + strlen(characters2), property = previous;
          default:
            if (variable < 1) {
              if (character2 == 123)
                --variable;
              else if (character2 == 125 && variable++ == 0 && prev() == 125)
                continue;
            }
            switch (characters2 += from(character2), character2 * variable) {
              case 38:
                ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
                break;
              case 44:
                points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
                break;
              case 64:
                if (peek() === 45)
                  characters2 += delimit(next());
                atrule = peek(), offset2 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
                break;
              case 45:
                if (previous === 45 && strlen(characters2) == 2)
                  variable = 0;
            }
        }
      return rulesets;
    }
    function ruleset(value, root2, parent, index, offset2, rules, points, type, props, children, length2) {
      var post = offset2 - 1;
      var rule = offset2 === 0 ? rules : [""];
      var size = sizeof(rule);
      for (var i = 0, j = 0, k2 = 0; i < index; ++i)
        for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j = points[i])), z2 = value; x2 < size; ++x2)
          if (z2 = trim$1(j > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
            props[k2++] = z2;
      return node(value, root2, parent, offset2 === 0 ? RULESET : type, props, children, length2);
    }
    function comment(value, root2, parent) {
      return node(value, root2, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
    }
    function declaration(value, root2, parent, length2) {
      return node(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
    }
    function serialize(children, callback) {
      var output = "";
      var length2 = sizeof(children);
      for (var i = 0; i < length2; i++)
        output += callback(children[i], i, children, callback) || "";
      return output;
    }
    function stringify(element, index, children, callback) {
      switch (element.type) {
        case LAYER:
          if (element.children.length)
            break;
        case IMPORT:
        case DECLARATION:
          return element.return = element.return || element.value;
        case COMMENT:
          return "";
        case KEYFRAMES:
          return element.return = element.value + "{" + serialize(element.children, callback) + "}";
        case RULESET:
          element.value = element.props.join(",");
      }
      return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
    }
    function middleware(collection) {
      var length2 = sizeof(collection);
      return function(element, index, children, callback) {
        var output = "";
        for (var i = 0; i < length2; i++)
          output += collection[i](element, index, children, callback) || "";
        return output;
      };
    }
    function rulesheet(callback) {
      return function(element) {
        if (!element.root) {
          if (element = element.return)
            callback(element);
        }
      };
    }
    var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index) {
      var previous = 0;
      var character2 = 0;
      while (true) {
        previous = character2;
        character2 = peek();
        if (previous === 38 && character2 === 12) {
          points[index] = 1;
        }
        if (token(character2)) {
          break;
        }
        next();
      }
      return slice(begin, position);
    };
    var toRules = function toRules2(parsed, points) {
      var index = -1;
      var character2 = 44;
      do {
        switch (token(character2)) {
          case 0:
            if (character2 === 38 && peek() === 12) {
              points[index] = 1;
            }
            parsed[index] += identifierWithPointTracking(position - 1, points, index);
            break;
          case 2:
            parsed[index] += delimit(character2);
            break;
          case 4:
            if (character2 === 44) {
              parsed[++index] = peek() === 58 ? "&\f" : "";
              points[index] = parsed[index].length;
              break;
            }
          default:
            parsed[index] += from(character2);
        }
      } while (character2 = next());
      return parsed;
    };
    var getRules = function getRules2(value, points) {
      return dealloc(toRules(alloc(value), points));
    };
    var fixedElements = /* @__PURE__ */ new WeakMap();
    var compat = function compat2(element) {
      if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
      // negative .length indicates that this rule has been already prefixed
      element.length < 1) {
        return;
      }
      var value = element.value, parent = element.parent;
      var isImplicitRule = element.column === parent.column && element.line === parent.line;
      while (parent.type !== "rule") {
        parent = parent.parent;
        if (!parent)
          return;
      }
      if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
        return;
      }
      if (isImplicitRule) {
        return;
      }
      fixedElements.set(element, true);
      var points = [];
      var rules = getRules(value, points);
      var parentRules = parent.props;
      for (var i = 0, k2 = 0; i < rules.length; i++) {
        for (var j = 0; j < parentRules.length; j++, k2++) {
          element.props[k2] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
        }
      }
    };
    var removeLabel = function removeLabel2(element) {
      if (element.type === "decl") {
        var value = element.value;
        if (
          // charcode for l
          value.charCodeAt(0) === 108 && // charcode for b
          value.charCodeAt(2) === 98
        ) {
          element["return"] = "";
          element.value = "";
        }
      }
    };
    function prefix(value, length2) {
      switch (hash$2(value, length2)) {
        case 5103:
          return WEBKIT + "print-" + value + value;
        case 5737:
        case 4201:
        case 3177:
        case 3433:
        case 1641:
        case 4457:
        case 2921:
        case 5572:
        case 6356:
        case 5844:
        case 3191:
        case 6645:
        case 3005:
        case 6391:
        case 5879:
        case 5623:
        case 6135:
        case 4599:
        case 4855:
        case 4215:
        case 6389:
        case 5109:
        case 5365:
        case 5621:
        case 3829:
          return WEBKIT + value + value;
        case 5349:
        case 4246:
        case 4810:
        case 6968:
        case 2756:
          return WEBKIT + value + MOZ + value + MS + value + value;
        case 6828:
        case 4268:
          return WEBKIT + value + MS + value + value;
        case 6165:
          return WEBKIT + value + MS + "flex-" + value + value;
        case 5187:
          return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
        case 5443:
          return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
        case 4675:
          return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
        case 5548:
          return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
        case 5292:
          return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
        case 6060:
          return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
        case 4554:
          return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
        case 6187:
          return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
        case 5495:
        case 3959:
          return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
        case 4968:
          return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
        case 4095:
        case 3583:
        case 4068:
        case 2532:
          return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
        case 8116:
        case 7059:
        case 5753:
        case 5535:
        case 5445:
        case 5701:
        case 4933:
        case 4677:
        case 5533:
        case 5789:
        case 5021:
        case 4765:
          if (strlen(value) - 1 - length2 > 6)
            switch (charat(value, length2 + 1)) {
              case 109:
                if (charat(value, length2 + 4) !== 45)
                  break;
              case 102:
                return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
              case 115:
                return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
            }
          break;
        case 4949:
          if (charat(value, length2 + 1) !== 115)
            break;
        case 6444:
          switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
            case 107:
              return replace(value, ":", ":" + WEBKIT) + value;
            case 101:
              return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
          }
          break;
        case 5936:
          switch (charat(value, length2 + 11)) {
            case 114:
              return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
            case 108:
              return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
            case 45:
              return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
          }
          return WEBKIT + value + MS + value + value;
      }
      return value;
    }
    var prefixer = function prefixer2(element, index, children, callback) {
      if (element.length > -1) {
        if (!element["return"])
          switch (element.type) {
            case DECLARATION:
              element["return"] = prefix(element.value, element.length);
              break;
            case KEYFRAMES:
              return serialize([copy(element, {
                value: replace(element.value, "@", "@" + WEBKIT)
              })], callback);
            case RULESET:
              if (element.length)
                return combine(element.props, function(value) {
                  switch (match(value, /(::plac\w+|:read-\w+)/)) {
                    case ":read-only":
                    case ":read-write":
                      return serialize([copy(element, {
                        props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                      })], callback);
                    case "::placeholder":
                      return serialize([copy(element, {
                        props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                      }), copy(element, {
                        props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                      }), copy(element, {
                        props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
                      })], callback);
                  }
                  return "";
                });
          }
      }
    };
    var defaultStylisPlugins = [prefixer];
    var createCache = function createCache2(options) {
      var key = options.key;
      if (key === "css") {
        var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
        Array.prototype.forEach.call(ssrStyles, function(node2) {
          var dataEmotionAttribute = node2.getAttribute("data-emotion");
          if (dataEmotionAttribute.indexOf(" ") === -1) {
            return;
          }
          document.head.appendChild(node2);
          node2.setAttribute("data-s", "");
        });
      }
      var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
      var inserted = {};
      var container;
      var nodesToHydrate = [];
      {
        container = options.container || document.head;
        Array.prototype.forEach.call(
          // this means we will ignore elements which don't have a space in them which
          // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
          document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
          function(node2) {
            var attrib = node2.getAttribute("data-emotion").split(" ");
            for (var i = 1; i < attrib.length; i++) {
              inserted[attrib[i]] = true;
            }
            nodesToHydrate.push(node2);
          }
        );
      }
      var _insert;
      var omnipresentPlugins = [compat, removeLabel];
      {
        var currentSheet;
        var finalizingPlugins = [stringify, rulesheet(function(rule) {
          currentSheet.insert(rule);
        })];
        var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
        var stylis = function stylis2(styles2) {
          return serialize(compile(styles2), serializer);
        };
        _insert = function insert(selector, serialized, sheet, shouldCache) {
          currentSheet = sheet;
          stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
          if (shouldCache) {
            cache.inserted[serialized.name] = true;
          }
        };
      }
      var cache = {
        key,
        sheet: new StyleSheet({
          key,
          container,
          nonce: options.nonce,
          speedy: options.speedy,
          prepend: options.prepend,
          insertionPoint: options.insertionPoint
        }),
        nonce: options.nonce,
        inserted,
        registered: {},
        insert: _insert
      };
      cache.sheet.hydrate(nodesToHydrate);
      return cache;
    };
    var isBrowser$1 = true;
    function getRegisteredStyles(registered, registeredStyles, classNames) {
      var rawClassName = "";
      classNames.split(" ").forEach(function(className) {
        if (registered[className] !== void 0) {
          registeredStyles.push(registered[className] + ";");
        } else {
          rawClassName += className + " ";
        }
      });
      return rawClassName;
    }
    var registerStyles = function registerStyles2(cache, serialized, isStringTag2) {
      var className = cache.key + "-" + serialized.name;
      if (
        // we only need to add the styles to the registered cache if the
        // class name could be used further down
        // the tree but if it's a string tag, we know it won't
        // so we don't have to add it to registered cache.
        // this improves memory usage since we can avoid storing the whole style string
        (isStringTag2 === false || // we need to always store it if we're in compat mode and
        // in node since emotion-server relies on whether a style is in
        // the registered cache to know whether a style is global or not
        // also, note that this check will be dead code eliminated in the browser
        isBrowser$1 === false) && cache.registered[className] === void 0
      ) {
        cache.registered[className] = serialized.styles;
      }
    };
    var insertStyles = function insertStyles2(cache, serialized, isStringTag2) {
      registerStyles(cache, serialized, isStringTag2);
      var className = cache.key + "-" + serialized.name;
      if (cache.inserted[serialized.name] === void 0) {
        var current = serialized;
        do {
          cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
          current = current.next;
        } while (current !== void 0);
      }
    };
    function murmur2(str) {
      var h2 = 0;
      var k2, i = 0, len = str.length;
      for (; len >= 4; ++i, len -= 4) {
        k2 = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
        k2 = /* Math.imul(k, m): */
        (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
        k2 ^= /* k >>> r: */
        k2 >>> 24;
        h2 = /* Math.imul(k, m): */
        (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
        (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      }
      switch (len) {
        case 3:
          h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
        case 2:
          h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
        case 1:
          h2 ^= str.charCodeAt(i) & 255;
          h2 = /* Math.imul(h, m): */
          (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      }
      h2 ^= h2 >>> 13;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
    }
    var unitlessKeys = {
      animationIterationCount: 1,
      aspectRatio: 1,
      borderImageOutset: 1,
      borderImageSlice: 1,
      borderImageWidth: 1,
      boxFlex: 1,
      boxFlexGroup: 1,
      boxOrdinalGroup: 1,
      columnCount: 1,
      columns: 1,
      flex: 1,
      flexGrow: 1,
      flexPositive: 1,
      flexShrink: 1,
      flexNegative: 1,
      flexOrder: 1,
      gridRow: 1,
      gridRowEnd: 1,
      gridRowSpan: 1,
      gridRowStart: 1,
      gridColumn: 1,
      gridColumnEnd: 1,
      gridColumnSpan: 1,
      gridColumnStart: 1,
      msGridRow: 1,
      msGridRowSpan: 1,
      msGridColumn: 1,
      msGridColumnSpan: 1,
      fontWeight: 1,
      lineHeight: 1,
      opacity: 1,
      order: 1,
      orphans: 1,
      tabSize: 1,
      widows: 1,
      zIndex: 1,
      zoom: 1,
      WebkitLineClamp: 1,
      // SVG-related properties
      fillOpacity: 1,
      floodOpacity: 1,
      stopOpacity: 1,
      strokeDasharray: 1,
      strokeDashoffset: 1,
      strokeMiterlimit: 1,
      strokeOpacity: 1,
      strokeWidth: 1
    };
    var hyphenateRegex = /[A-Z]|^ms/g;
    var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
    var isCustomProperty = function isCustomProperty2(property) {
      return property.charCodeAt(1) === 45;
    };
    var isProcessableValue = function isProcessableValue2(value) {
      return value != null && typeof value !== "boolean";
    };
    var processStyleName = /* @__PURE__ */ memoize$1(function(styleName) {
      return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
    });
    var processStyleValue = function processStyleValue2(key, value) {
      switch (key) {
        case "animation":
        case "animationName": {
          if (typeof value === "string") {
            return value.replace(animationRegex, function(match2, p1, p2) {
              cursor = {
                name: p1,
                styles: p2,
                next: cursor
              };
              return p1;
            });
          }
        }
      }
      if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
        return value + "px";
      }
      return value;
    };
    var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
    function handleInterpolation(mergedProps, registered, interpolation) {
      if (interpolation == null) {
        return "";
      }
      if (interpolation.__emotion_styles !== void 0) {
        return interpolation;
      }
      switch (typeof interpolation) {
        case "boolean": {
          return "";
        }
        case "object": {
          if (interpolation.anim === 1) {
            cursor = {
              name: interpolation.name,
              styles: interpolation.styles,
              next: cursor
            };
            return interpolation.name;
          }
          if (interpolation.styles !== void 0) {
            var next2 = interpolation.next;
            if (next2 !== void 0) {
              while (next2 !== void 0) {
                cursor = {
                  name: next2.name,
                  styles: next2.styles,
                  next: cursor
                };
                next2 = next2.next;
              }
            }
            var styles2 = interpolation.styles + ";";
            return styles2;
          }
          return createStringFromObject(mergedProps, registered, interpolation);
        }
        case "function": {
          if (mergedProps !== void 0) {
            var previousCursor = cursor;
            var result = interpolation(mergedProps);
            cursor = previousCursor;
            return handleInterpolation(mergedProps, registered, result);
          }
          break;
        }
      }
      if (registered == null) {
        return interpolation;
      }
      var cached = registered[interpolation];
      return cached !== void 0 ? cached : interpolation;
    }
    function createStringFromObject(mergedProps, registered, obj) {
      var string2 = "";
      if (Array.isArray(obj)) {
        for (var i = 0; i < obj.length; i++) {
          string2 += handleInterpolation(mergedProps, registered, obj[i]) + ";";
        }
      } else {
        for (var _key in obj) {
          var value = obj[_key];
          if (typeof value !== "object") {
            if (registered != null && registered[value] !== void 0) {
              string2 += _key + "{" + registered[value] + "}";
            } else if (isProcessableValue(value)) {
              string2 += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
            }
          } else {
            if (_key === "NO_COMPONENT_SELECTOR" && false) {
              throw new Error(noComponentSelectorMessage);
            }
            if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
              for (var _i = 0; _i < value.length; _i++) {
                if (isProcessableValue(value[_i])) {
                  string2 += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
                }
              }
            } else {
              var interpolated = handleInterpolation(mergedProps, registered, value);
              switch (_key) {
                case "animation":
                case "animationName": {
                  string2 += processStyleName(_key) + ":" + interpolated + ";";
                  break;
                }
                default: {
                  string2 += _key + "{" + interpolated + "}";
                }
              }
            }
          }
        }
      }
      return string2;
    }
    var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
    var cursor;
    var serializeStyles = function serializeStyles2(args, registered, mergedProps) {
      if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
        return args[0];
      }
      var stringMode = true;
      var styles2 = "";
      cursor = void 0;
      var strings = args[0];
      if (strings == null || strings.raw === void 0) {
        stringMode = false;
        styles2 += handleInterpolation(mergedProps, registered, strings);
      } else {
        styles2 += strings[0];
      }
      for (var i = 1; i < args.length; i++) {
        styles2 += handleInterpolation(mergedProps, registered, args[i]);
        if (stringMode) {
          styles2 += strings[i];
        }
      }
      labelPattern.lastIndex = 0;
      var identifierName = "";
      var match2;
      while ((match2 = labelPattern.exec(styles2)) !== null) {
        identifierName += "-" + // $FlowFixMe we know it's not null
        match2[1];
      }
      var name = murmur2(styles2) + identifierName;
      return {
        name,
        styles: styles2,
        next: cursor
      };
    };
    var syncFallback = function syncFallback2(create2) {
      return create2();
    };
    var useInsertionEffect = React$1["useInsertionEffect"] ? React$1["useInsertionEffect"] : false;
    var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
    var useInsertionEffectWithLayoutFallback = useInsertionEffect || reactExports.useLayoutEffect;
    var EmotionCacheContext = /* @__PURE__ */ reactExports.createContext(
      // we're doing this to avoid preconstruct's dead code elimination in this one case
      // because this module is primarily intended for the browser and node
      // but it's also required in react native and similar environments sometimes
      // and we could have a special build just for that
      // but this is much easier and the native packages
      // might use a different theme context in the future anyway
      typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
        key: "css"
      }) : null
    );
    EmotionCacheContext.Provider;
    var withEmotionCache = function withEmotionCache2(func) {
      return /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
        var cache = reactExports.useContext(EmotionCacheContext);
        return func(props, cache, ref);
      });
    };
    var ThemeContext = /* @__PURE__ */ reactExports.createContext({});
    var Global = /* @__PURE__ */ withEmotionCache(function(props, cache) {
      var styles2 = props.styles;
      var serialized = serializeStyles([styles2], void 0, reactExports.useContext(ThemeContext));
      var sheetRef = reactExports.useRef();
      useInsertionEffectWithLayoutFallback(function() {
        var key = cache.key + "-global";
        var sheet = new cache.sheet.constructor({
          key,
          nonce: cache.sheet.nonce,
          container: cache.sheet.container,
          speedy: cache.sheet.isSpeedy
        });
        var rehydrating = false;
        var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
        if (cache.sheet.tags.length) {
          sheet.before = cache.sheet.tags[0];
        }
        if (node2 !== null) {
          rehydrating = true;
          node2.setAttribute("data-emotion", key);
          sheet.hydrate([node2]);
        }
        sheetRef.current = [sheet, rehydrating];
        return function() {
          sheet.flush();
        };
      }, [cache]);
      useInsertionEffectWithLayoutFallback(function() {
        var sheetRefCurrent = sheetRef.current;
        var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
        if (rehydrating) {
          sheetRefCurrent[1] = false;
          return;
        }
        if (serialized.next !== void 0) {
          insertStyles(cache, serialized.next, true);
        }
        if (sheet.tags.length) {
          var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
          sheet.before = element;
          sheet.flush();
        }
        cache.insert("", serialized, sheet, false);
      }, [cache, serialized.name]);
      return null;
    });
    function css() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return serializeStyles(args);
    }
    var keyframes$1 = function keyframes2() {
      var insertable = css.apply(void 0, arguments);
      var name = "animation-" + insertable.name;
      return {
        name,
        styles: "@keyframes " + name + "{" + insertable.styles + "}",
        anim: 1,
        toString: function toString2() {
          return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
        }
      };
    };
    var testOmitPropsOnStringTag = isPropValid;
    var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
      return key !== "theme";
    };
    var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
      return typeof tag === "string" && // 96 is one less than the char code
      // for "a" so this is checking that
      // it's a lowercase character
      tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
    };
    var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
      var shouldForwardProp2;
      if (options) {
        var optionsShouldForwardProp = options.shouldForwardProp;
        shouldForwardProp2 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
          return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
        } : optionsShouldForwardProp;
      }
      if (typeof shouldForwardProp2 !== "function" && isReal) {
        shouldForwardProp2 = tag.__emotion_forwardProp;
      }
      return shouldForwardProp2;
    };
    var Insertion = function Insertion2(_ref) {
      var cache = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
      registerStyles(cache, serialized, isStringTag2);
      useInsertionEffectAlwaysWithSyncFallback(function() {
        return insertStyles(cache, serialized, isStringTag2);
      });
      return null;
    };
    var createStyled$1 = function createStyled2(tag, options) {
      var isReal = tag.__emotion_real === tag;
      var baseTag = isReal && tag.__emotion_base || tag;
      var identifierName;
      var targetClassName;
      if (options !== void 0) {
        identifierName = options.label;
        targetClassName = options.target;
      }
      var shouldForwardProp2 = composeShouldForwardProps(tag, options, isReal);
      var defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag);
      var shouldUseAs = !defaultShouldForwardProp("as");
      return function() {
        var args = arguments;
        var styles2 = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
        if (identifierName !== void 0) {
          styles2.push("label:" + identifierName + ";");
        }
        if (args[0] == null || args[0].raw === void 0) {
          styles2.push.apply(styles2, args);
        } else {
          styles2.push(args[0][0]);
          var len = args.length;
          var i = 1;
          for (; i < len; i++) {
            styles2.push(args[i], args[0][i]);
          }
        }
        var Styled = withEmotionCache(function(props, cache, ref) {
          var FinalTag = shouldUseAs && props.as || baseTag;
          var className = "";
          var classInterpolations = [];
          var mergedProps = props;
          if (props.theme == null) {
            mergedProps = {};
            for (var key in props) {
              mergedProps[key] = props[key];
            }
            mergedProps.theme = reactExports.useContext(ThemeContext);
          }
          if (typeof props.className === "string") {
            className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
          } else if (props.className != null) {
            className = props.className + " ";
          }
          var serialized = serializeStyles(styles2.concat(classInterpolations), cache.registered, mergedProps);
          className += cache.key + "-" + serialized.name;
          if (targetClassName !== void 0) {
            className += " " + targetClassName;
          }
          var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
          var newProps = {};
          for (var _key in props) {
            if (shouldUseAs && _key === "as")
              continue;
            if (
              // $FlowFixMe
              finalShouldForwardProp(_key)
            ) {
              newProps[_key] = props[_key];
            }
          }
          newProps.className = className;
          newProps.ref = ref;
          return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Insertion, {
            cache,
            serialized,
            isStringTag: typeof FinalTag === "string"
          }), /* @__PURE__ */ reactExports.createElement(FinalTag, newProps));
        });
        Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
        Styled.defaultProps = tag.defaultProps;
        Styled.__emotion_real = Styled;
        Styled.__emotion_base = baseTag;
        Styled.__emotion_styles = styles2;
        Styled.__emotion_forwardProp = shouldForwardProp2;
        Object.defineProperty(Styled, "toString", {
          value: function value() {
            if (targetClassName === void 0 && false) {
              return "NO_COMPONENT_SELECTOR";
            }
            return "." + targetClassName;
          }
        });
        Styled.withComponent = function(nextTag, nextOptions) {
          return createStyled2(nextTag, _extends$1({}, options, nextOptions, {
            shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
          })).apply(void 0, styles2);
        };
        return Styled;
      };
    };
    var tags = [
      "a",
      "abbr",
      "address",
      "area",
      "article",
      "aside",
      "audio",
      "b",
      "base",
      "bdi",
      "bdo",
      "big",
      "blockquote",
      "body",
      "br",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "col",
      "colgroup",
      "data",
      "datalist",
      "dd",
      "del",
      "details",
      "dfn",
      "dialog",
      "div",
      "dl",
      "dt",
      "em",
      "embed",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hgroup",
      "hr",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "keygen",
      "label",
      "legend",
      "li",
      "link",
      "main",
      "map",
      "mark",
      "marquee",
      "menu",
      "menuitem",
      "meta",
      "meter",
      "nav",
      "noscript",
      "object",
      "ol",
      "optgroup",
      "option",
      "output",
      "p",
      "param",
      "picture",
      "pre",
      "progress",
      "q",
      "rp",
      "rt",
      "ruby",
      "s",
      "samp",
      "script",
      "section",
      "select",
      "small",
      "source",
      "span",
      "strong",
      "style",
      "sub",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "title",
      "tr",
      "track",
      "u",
      "ul",
      "var",
      "video",
      "wbr",
      // SVG
      "circle",
      "clipPath",
      "defs",
      "ellipse",
      "foreignObject",
      "g",
      "image",
      "line",
      "linearGradient",
      "mask",
      "path",
      "pattern",
      "polygon",
      "polyline",
      "radialGradient",
      "rect",
      "stop",
      "svg",
      "text",
      "tspan"
    ];
    var newStyled = createStyled$1.bind();
    tags.forEach(function(tagName) {
      newStyled[tagName] = newStyled(tagName);
    });
    function isEmpty$3(obj) {
      return obj === void 0 || obj === null || Object.keys(obj).length === 0;
    }
    function GlobalStyles$2(props) {
      const {
        styles: styles2,
        defaultTheme: defaultTheme2 = {}
      } = props;
      const globalStyles = typeof styles2 === "function" ? (themeInput) => styles2(isEmpty$3(themeInput) ? defaultTheme2 : themeInput) : styles2;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Global, {
        styles: globalStyles
      });
    }
    function styled$1(tag, options) {
      const stylesFactory = newStyled(tag, options);
      return stylesFactory;
    }
    const internal_processStyles = (tag, processor) => {
      if (Array.isArray(tag.__emotion_styles)) {
        tag.__emotion_styles = processor(tag.__emotion_styles);
      }
    };
    const _excluded$1d = ["values", "unit", "step"];
    const sortBreakpointsValues = (values2) => {
      const breakpointsAsArray = Object.keys(values2).map((key) => ({
        key,
        val: values2[key]
      })) || [];
      breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
      return breakpointsAsArray.reduce((acc, obj) => {
        return _extends$1({}, acc, {
          [obj.key]: obj.val
        });
      }, {});
    };
    function createBreakpoints(breakpoints) {
      const {
        // The breakpoint **start** at this value.
        // For instance with the first breakpoint xs: [xs, sm).
        values: values2 = {
          xs: 0,
          // phone
          sm: 600,
          // tablet
          md: 900,
          // small laptop
          lg: 1200,
          // desktop
          xl: 1536
          // large screen
        },
        unit = "px",
        step = 5
      } = breakpoints, other = _objectWithoutPropertiesLoose$1(breakpoints, _excluded$1d);
      const sortedValues = sortBreakpointsValues(values2);
      const keys2 = Object.keys(sortedValues);
      function up(key) {
        const value = typeof values2[key] === "number" ? values2[key] : key;
        return `@media (min-width:${value}${unit})`;
      }
      function down(key) {
        const value = typeof values2[key] === "number" ? values2[key] : key;
        return `@media (max-width:${value - step / 100}${unit})`;
      }
      function between(start2, end2) {
        const endIndex = keys2.indexOf(end2);
        return `@media (min-width:${typeof values2[start2] === "number" ? values2[start2] : start2}${unit}) and (max-width:${(endIndex !== -1 && typeof values2[keys2[endIndex]] === "number" ? values2[keys2[endIndex]] : end2) - step / 100}${unit})`;
      }
      function only(key) {
        if (keys2.indexOf(key) + 1 < keys2.length) {
          return between(key, keys2[keys2.indexOf(key) + 1]);
        }
        return up(key);
      }
      function not(key) {
        const keyIndex = keys2.indexOf(key);
        if (keyIndex === 0) {
          return up(keys2[1]);
        }
        if (keyIndex === keys2.length - 1) {
          return down(keys2[keyIndex]);
        }
        return between(key, keys2[keys2.indexOf(key) + 1]).replace("@media", "@media not all and");
      }
      return _extends$1({
        keys: keys2,
        values: sortedValues,
        up,
        down,
        between,
        only,
        not,
        unit
      }, other);
    }
    const shape = {
      borderRadius: 4
    };
    const shape$1 = shape;
    function merge$1(acc, item) {
      if (!item) {
        return acc;
      }
      return deepmerge(acc, item, {
        clone: false
        // No need to clone deep, it's way faster.
      });
    }
    const values$1 = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    };
    const defaultBreakpoints = {
      // Sorted ASC by size. That's important.
      // It can't be configured as it's used statically for propTypes.
      keys: ["xs", "sm", "md", "lg", "xl"],
      up: (key) => `@media (min-width:${values$1[key]}px)`
    };
    function handleBreakpoints(props, propValue, styleFromPropValue) {
      const theme = props.theme || {};
      if (Array.isArray(propValue)) {
        const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
        return propValue.reduce((acc, item, index) => {
          acc[themeBreakpoints.up(themeBreakpoints.keys[index])] = styleFromPropValue(propValue[index]);
          return acc;
        }, {});
      }
      if (typeof propValue === "object") {
        const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
        return Object.keys(propValue).reduce((acc, breakpoint) => {
          if (Object.keys(themeBreakpoints.values || values$1).indexOf(breakpoint) !== -1) {
            const mediaKey = themeBreakpoints.up(breakpoint);
            acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
          } else {
            const cssKey = breakpoint;
            acc[cssKey] = propValue[cssKey];
          }
          return acc;
        }, {});
      }
      const output = styleFromPropValue(propValue);
      return output;
    }
    function createEmptyBreakpointObject(breakpointsInput = {}) {
      var _breakpointsInput$key;
      const breakpointsInOrder = (_breakpointsInput$key = breakpointsInput.keys) == null ? void 0 : _breakpointsInput$key.reduce((acc, key) => {
        const breakpointStyleKey = breakpointsInput.up(key);
        acc[breakpointStyleKey] = {};
        return acc;
      }, {});
      return breakpointsInOrder || {};
    }
    function removeUnusedBreakpoints(breakpointKeys, style2) {
      return breakpointKeys.reduce((acc, key) => {
        const breakpointOutput = acc[key];
        const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
        if (isBreakpointUnused) {
          delete acc[key];
        }
        return acc;
      }, style2);
    }
    function getPath(obj, path, checkVars = true) {
      if (!path || typeof path !== "string") {
        return null;
      }
      if (obj && obj.vars && checkVars) {
        const val = `vars.${path}`.split(".").reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
        if (val != null) {
          return val;
        }
      }
      return path.split(".").reduce((acc, item) => {
        if (acc && acc[item] != null) {
          return acc[item];
        }
        return null;
      }, obj);
    }
    function getStyleValue$1(themeMapping, transform, propValueFinal, userValue = propValueFinal) {
      let value;
      if (typeof themeMapping === "function") {
        value = themeMapping(propValueFinal);
      } else if (Array.isArray(themeMapping)) {
        value = themeMapping[propValueFinal] || userValue;
      } else {
        value = getPath(themeMapping, propValueFinal) || userValue;
      }
      if (transform) {
        value = transform(value, userValue, themeMapping);
      }
      return value;
    }
    function style$1(options) {
      const {
        prop,
        cssProperty = options.prop,
        themeKey,
        transform
      } = options;
      const fn = (props) => {
        if (props[prop] == null) {
          return null;
        }
        const propValue = props[prop];
        const theme = props.theme;
        const themeMapping = getPath(theme, themeKey) || {};
        const styleFromPropValue = (propValueFinal) => {
          let value = getStyleValue$1(themeMapping, transform, propValueFinal);
          if (propValueFinal === value && typeof propValueFinal === "string") {
            value = getStyleValue$1(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
          }
          if (cssProperty === false) {
            return value;
          }
          return {
            [cssProperty]: value
          };
        };
        return handleBreakpoints(props, propValue, styleFromPropValue);
      };
      fn.propTypes = {};
      fn.filterProps = [prop];
      return fn;
    }
    function memoize(fn) {
      const cache = {};
      return (arg) => {
        if (cache[arg] === void 0) {
          cache[arg] = fn(arg);
        }
        return cache[arg];
      };
    }
    const properties = {
      m: "margin",
      p: "padding"
    };
    const directions = {
      t: "Top",
      r: "Right",
      b: "Bottom",
      l: "Left",
      x: ["Left", "Right"],
      y: ["Top", "Bottom"]
    };
    const aliases = {
      marginX: "mx",
      marginY: "my",
      paddingX: "px",
      paddingY: "py"
    };
    const getCssProperties = memoize((prop) => {
      if (prop.length > 2) {
        if (aliases[prop]) {
          prop = aliases[prop];
        } else {
          return [prop];
        }
      }
      const [a, b2] = prop.split("");
      const property = properties[a];
      const direction = directions[b2] || "";
      return Array.isArray(direction) ? direction.map((dir) => property + dir) : [property + direction];
    });
    const marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"];
    const paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
    [...marginKeys, ...paddingKeys];
    function createUnaryUnit(theme, themeKey, defaultValue, propName) {
      var _getPath;
      const themeSpacing = (_getPath = getPath(theme, themeKey, false)) != null ? _getPath : defaultValue;
      if (typeof themeSpacing === "number") {
        return (abs2) => {
          if (typeof abs2 === "string") {
            return abs2;
          }
          return themeSpacing * abs2;
        };
      }
      if (Array.isArray(themeSpacing)) {
        return (abs2) => {
          if (typeof abs2 === "string") {
            return abs2;
          }
          return themeSpacing[abs2];
        };
      }
      if (typeof themeSpacing === "function") {
        return themeSpacing;
      }
      return () => void 0;
    }
    function createUnarySpacing(theme) {
      return createUnaryUnit(theme, "spacing", 8);
    }
    function getValue(transformer, propValue) {
      if (typeof propValue === "string" || propValue == null) {
        return propValue;
      }
      const abs2 = Math.abs(propValue);
      const transformed = transformer(abs2);
      if (propValue >= 0) {
        return transformed;
      }
      if (typeof transformed === "number") {
        return -transformed;
      }
      return `-${transformed}`;
    }
    function getStyleFromPropValue(cssProperties, transformer) {
      return (propValue) => cssProperties.reduce((acc, cssProperty) => {
        acc[cssProperty] = getValue(transformer, propValue);
        return acc;
      }, {});
    }
    function resolveCssProperty(props, keys2, prop, transformer) {
      if (keys2.indexOf(prop) === -1) {
        return null;
      }
      const cssProperties = getCssProperties(prop);
      const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
      const propValue = props[prop];
      return handleBreakpoints(props, propValue, styleFromPropValue);
    }
    function style(props, keys2) {
      const transformer = createUnarySpacing(props.theme);
      return Object.keys(props).map((prop) => resolveCssProperty(props, keys2, prop, transformer)).reduce(merge$1, {});
    }
    function margin(props) {
      return style(props, marginKeys);
    }
    margin.propTypes = {};
    margin.filterProps = marginKeys;
    function padding(props) {
      return style(props, paddingKeys);
    }
    padding.propTypes = {};
    padding.filterProps = paddingKeys;
    function createSpacing(spacingInput = 8) {
      if (spacingInput.mui) {
        return spacingInput;
      }
      const transform = createUnarySpacing({
        spacing: spacingInput
      });
      const spacing = (...argsInput) => {
        const args = argsInput.length === 0 ? [1] : argsInput;
        return args.map((argument) => {
          const output = transform(argument);
          return typeof output === "number" ? `${output}px` : output;
        }).join(" ");
      };
      spacing.mui = true;
      return spacing;
    }
    function compose(...styles2) {
      const handlers = styles2.reduce((acc, style2) => {
        style2.filterProps.forEach((prop) => {
          acc[prop] = style2;
        });
        return acc;
      }, {});
      const fn = (props) => {
        return Object.keys(props).reduce((acc, prop) => {
          if (handlers[prop]) {
            return merge$1(acc, handlers[prop](props));
          }
          return acc;
        }, {});
      };
      fn.propTypes = {};
      fn.filterProps = styles2.reduce((acc, style2) => acc.concat(style2.filterProps), []);
      return fn;
    }
    function borderTransform(value) {
      if (typeof value !== "number") {
        return value;
      }
      return `${value}px solid`;
    }
    function createBorderStyle(prop, transform) {
      return style$1({
        prop,
        themeKey: "borders",
        transform
      });
    }
    const border = createBorderStyle("border", borderTransform);
    const borderTop = createBorderStyle("borderTop", borderTransform);
    const borderRight = createBorderStyle("borderRight", borderTransform);
    const borderBottom = createBorderStyle("borderBottom", borderTransform);
    const borderLeft = createBorderStyle("borderLeft", borderTransform);
    const borderColor = createBorderStyle("borderColor");
    const borderTopColor = createBorderStyle("borderTopColor");
    const borderRightColor = createBorderStyle("borderRightColor");
    const borderBottomColor = createBorderStyle("borderBottomColor");
    const borderLeftColor = createBorderStyle("borderLeftColor");
    const outline = createBorderStyle("outline", borderTransform);
    const outlineColor = createBorderStyle("outlineColor");
    const borderRadius = (props) => {
      if (props.borderRadius !== void 0 && props.borderRadius !== null) {
        const transformer = createUnaryUnit(props.theme, "shape.borderRadius", 4);
        const styleFromPropValue = (propValue) => ({
          borderRadius: getValue(transformer, propValue)
        });
        return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
      }
      return null;
    };
    borderRadius.propTypes = {};
    borderRadius.filterProps = ["borderRadius"];
    compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius, outline, outlineColor);
    const gap = (props) => {
      if (props.gap !== void 0 && props.gap !== null) {
        const transformer = createUnaryUnit(props.theme, "spacing", 8);
        const styleFromPropValue = (propValue) => ({
          gap: getValue(transformer, propValue)
        });
        return handleBreakpoints(props, props.gap, styleFromPropValue);
      }
      return null;
    };
    gap.propTypes = {};
    gap.filterProps = ["gap"];
    const columnGap = (props) => {
      if (props.columnGap !== void 0 && props.columnGap !== null) {
        const transformer = createUnaryUnit(props.theme, "spacing", 8);
        const styleFromPropValue = (propValue) => ({
          columnGap: getValue(transformer, propValue)
        });
        return handleBreakpoints(props, props.columnGap, styleFromPropValue);
      }
      return null;
    };
    columnGap.propTypes = {};
    columnGap.filterProps = ["columnGap"];
    const rowGap = (props) => {
      if (props.rowGap !== void 0 && props.rowGap !== null) {
        const transformer = createUnaryUnit(props.theme, "spacing", 8);
        const styleFromPropValue = (propValue) => ({
          rowGap: getValue(transformer, propValue)
        });
        return handleBreakpoints(props, props.rowGap, styleFromPropValue);
      }
      return null;
    };
    rowGap.propTypes = {};
    rowGap.filterProps = ["rowGap"];
    const gridColumn = style$1({
      prop: "gridColumn"
    });
    const gridRow = style$1({
      prop: "gridRow"
    });
    const gridAutoFlow = style$1({
      prop: "gridAutoFlow"
    });
    const gridAutoColumns = style$1({
      prop: "gridAutoColumns"
    });
    const gridAutoRows = style$1({
      prop: "gridAutoRows"
    });
    const gridTemplateColumns = style$1({
      prop: "gridTemplateColumns"
    });
    const gridTemplateRows = style$1({
      prop: "gridTemplateRows"
    });
    const gridTemplateAreas = style$1({
      prop: "gridTemplateAreas"
    });
    const gridArea = style$1({
      prop: "gridArea"
    });
    compose(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
    function paletteTransform(value, userValue) {
      if (userValue === "grey") {
        return userValue;
      }
      return value;
    }
    const color$1 = style$1({
      prop: "color",
      themeKey: "palette",
      transform: paletteTransform
    });
    const bgcolor = style$1({
      prop: "bgcolor",
      cssProperty: "backgroundColor",
      themeKey: "palette",
      transform: paletteTransform
    });
    const backgroundColor = style$1({
      prop: "backgroundColor",
      themeKey: "palette",
      transform: paletteTransform
    });
    compose(color$1, bgcolor, backgroundColor);
    function sizingTransform(value) {
      return value <= 1 && value !== 0 ? `${value * 100}%` : value;
    }
    const width = style$1({
      prop: "width",
      transform: sizingTransform
    });
    const maxWidth = (props) => {
      if (props.maxWidth !== void 0 && props.maxWidth !== null) {
        const styleFromPropValue = (propValue) => {
          var _props$theme, _props$theme2;
          const breakpoint = ((_props$theme = props.theme) == null || (_props$theme = _props$theme.breakpoints) == null || (_props$theme = _props$theme.values) == null ? void 0 : _props$theme[propValue]) || values$1[propValue];
          if (!breakpoint) {
            return {
              maxWidth: sizingTransform(propValue)
            };
          }
          if (((_props$theme2 = props.theme) == null || (_props$theme2 = _props$theme2.breakpoints) == null ? void 0 : _props$theme2.unit) !== "px") {
            return {
              maxWidth: `${breakpoint}${props.theme.breakpoints.unit}`
            };
          }
          return {
            maxWidth: breakpoint
          };
        };
        return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
      }
      return null;
    };
    maxWidth.filterProps = ["maxWidth"];
    const minWidth = style$1({
      prop: "minWidth",
      transform: sizingTransform
    });
    const height = style$1({
      prop: "height",
      transform: sizingTransform
    });
    const maxHeight = style$1({
      prop: "maxHeight",
      transform: sizingTransform
    });
    const minHeight = style$1({
      prop: "minHeight",
      transform: sizingTransform
    });
    style$1({
      prop: "size",
      cssProperty: "width",
      transform: sizingTransform
    });
    style$1({
      prop: "size",
      cssProperty: "height",
      transform: sizingTransform
    });
    const boxSizing = style$1({
      prop: "boxSizing"
    });
    compose(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
    const defaultSxConfig = {
      // borders
      border: {
        themeKey: "borders",
        transform: borderTransform
      },
      borderTop: {
        themeKey: "borders",
        transform: borderTransform
      },
      borderRight: {
        themeKey: "borders",
        transform: borderTransform
      },
      borderBottom: {
        themeKey: "borders",
        transform: borderTransform
      },
      borderLeft: {
        themeKey: "borders",
        transform: borderTransform
      },
      borderColor: {
        themeKey: "palette"
      },
      borderTopColor: {
        themeKey: "palette"
      },
      borderRightColor: {
        themeKey: "palette"
      },
      borderBottomColor: {
        themeKey: "palette"
      },
      borderLeftColor: {
        themeKey: "palette"
      },
      outline: {
        themeKey: "borders",
        transform: borderTransform
      },
      outlineColor: {
        themeKey: "palette"
      },
      borderRadius: {
        themeKey: "shape.borderRadius",
        style: borderRadius
      },
      // palette
      color: {
        themeKey: "palette",
        transform: paletteTransform
      },
      bgcolor: {
        themeKey: "palette",
        cssProperty: "backgroundColor",
        transform: paletteTransform
      },
      backgroundColor: {
        themeKey: "palette",
        transform: paletteTransform
      },
      // spacing
      p: {
        style: padding
      },
      pt: {
        style: padding
      },
      pr: {
        style: padding
      },
      pb: {
        style: padding
      },
      pl: {
        style: padding
      },
      px: {
        style: padding
      },
      py: {
        style: padding
      },
      padding: {
        style: padding
      },
      paddingTop: {
        style: padding
      },
      paddingRight: {
        style: padding
      },
      paddingBottom: {
        style: padding
      },
      paddingLeft: {
        style: padding
      },
      paddingX: {
        style: padding
      },
      paddingY: {
        style: padding
      },
      paddingInline: {
        style: padding
      },
      paddingInlineStart: {
        style: padding
      },
      paddingInlineEnd: {
        style: padding
      },
      paddingBlock: {
        style: padding
      },
      paddingBlockStart: {
        style: padding
      },
      paddingBlockEnd: {
        style: padding
      },
      m: {
        style: margin
      },
      mt: {
        style: margin
      },
      mr: {
        style: margin
      },
      mb: {
        style: margin
      },
      ml: {
        style: margin
      },
      mx: {
        style: margin
      },
      my: {
        style: margin
      },
      margin: {
        style: margin
      },
      marginTop: {
        style: margin
      },
      marginRight: {
        style: margin
      },
      marginBottom: {
        style: margin
      },
      marginLeft: {
        style: margin
      },
      marginX: {
        style: margin
      },
      marginY: {
        style: margin
      },
      marginInline: {
        style: margin
      },
      marginInlineStart: {
        style: margin
      },
      marginInlineEnd: {
        style: margin
      },
      marginBlock: {
        style: margin
      },
      marginBlockStart: {
        style: margin
      },
      marginBlockEnd: {
        style: margin
      },
      // display
      displayPrint: {
        cssProperty: false,
        transform: (value) => ({
          "@media print": {
            display: value
          }
        })
      },
      display: {},
      overflow: {},
      textOverflow: {},
      visibility: {},
      whiteSpace: {},
      // flexbox
      flexBasis: {},
      flexDirection: {},
      flexWrap: {},
      justifyContent: {},
      alignItems: {},
      alignContent: {},
      order: {},
      flex: {},
      flexGrow: {},
      flexShrink: {},
      alignSelf: {},
      justifyItems: {},
      justifySelf: {},
      // grid
      gap: {
        style: gap
      },
      rowGap: {
        style: rowGap
      },
      columnGap: {
        style: columnGap
      },
      gridColumn: {},
      gridRow: {},
      gridAutoFlow: {},
      gridAutoColumns: {},
      gridAutoRows: {},
      gridTemplateColumns: {},
      gridTemplateRows: {},
      gridTemplateAreas: {},
      gridArea: {},
      // positions
      position: {},
      zIndex: {
        themeKey: "zIndex"
      },
      top: {},
      right: {},
      bottom: {},
      left: {},
      // shadows
      boxShadow: {
        themeKey: "shadows"
      },
      // sizing
      width: {
        transform: sizingTransform
      },
      maxWidth: {
        style: maxWidth
      },
      minWidth: {
        transform: sizingTransform
      },
      height: {
        transform: sizingTransform
      },
      maxHeight: {
        transform: sizingTransform
      },
      minHeight: {
        transform: sizingTransform
      },
      boxSizing: {},
      // typography
      fontFamily: {
        themeKey: "typography"
      },
      fontSize: {
        themeKey: "typography"
      },
      fontStyle: {
        themeKey: "typography"
      },
      fontWeight: {
        themeKey: "typography"
      },
      letterSpacing: {},
      textTransform: {},
      lineHeight: {},
      textAlign: {},
      typography: {
        cssProperty: false,
        themeKey: "typography"
      }
    };
    const defaultSxConfig$1 = defaultSxConfig;
    function objectsHaveSameKeys(...objects) {
      const allKeys = objects.reduce((keys2, object2) => keys2.concat(Object.keys(object2)), []);
      const union = new Set(allKeys);
      return objects.every((object2) => union.size === Object.keys(object2).length);
    }
    function callIfFn(maybeFn, arg) {
      return typeof maybeFn === "function" ? maybeFn(arg) : maybeFn;
    }
    function unstable_createStyleFunctionSx() {
      function getThemeValue(prop, val, theme, config2) {
        const props = {
          [prop]: val,
          theme
        };
        const options = config2[prop];
        if (!options) {
          return {
            [prop]: val
          };
        }
        const {
          cssProperty = prop,
          themeKey,
          transform,
          style: style2
        } = options;
        if (val == null) {
          return null;
        }
        if (themeKey === "typography" && val === "inherit") {
          return {
            [prop]: val
          };
        }
        const themeMapping = getPath(theme, themeKey) || {};
        if (style2) {
          return style2(props);
        }
        const styleFromPropValue = (propValueFinal) => {
          let value = getStyleValue$1(themeMapping, transform, propValueFinal);
          if (propValueFinal === value && typeof propValueFinal === "string") {
            value = getStyleValue$1(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
          }
          if (cssProperty === false) {
            return value;
          }
          return {
            [cssProperty]: value
          };
        };
        return handleBreakpoints(props, val, styleFromPropValue);
      }
      function styleFunctionSx2(props) {
        var _theme$unstable_sxCon;
        const {
          sx,
          theme = {}
        } = props || {};
        if (!sx) {
          return null;
        }
        const config2 = (_theme$unstable_sxCon = theme.unstable_sxConfig) != null ? _theme$unstable_sxCon : defaultSxConfig$1;
        function traverse(sxInput) {
          let sxObject = sxInput;
          if (typeof sxInput === "function") {
            sxObject = sxInput(theme);
          } else if (typeof sxInput !== "object") {
            return sxInput;
          }
          if (!sxObject) {
            return null;
          }
          const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);
          const breakpointsKeys = Object.keys(emptyBreakpoints);
          let css2 = emptyBreakpoints;
          Object.keys(sxObject).forEach((styleKey) => {
            const value = callIfFn(sxObject[styleKey], theme);
            if (value !== null && value !== void 0) {
              if (typeof value === "object") {
                if (config2[styleKey]) {
                  css2 = merge$1(css2, getThemeValue(styleKey, value, theme, config2));
                } else {
                  const breakpointsValues = handleBreakpoints({
                    theme
                  }, value, (x2) => ({
                    [styleKey]: x2
                  }));
                  if (objectsHaveSameKeys(breakpointsValues, value)) {
                    css2[styleKey] = styleFunctionSx2({
                      sx: value,
                      theme
                    });
                  } else {
                    css2 = merge$1(css2, breakpointsValues);
                  }
                }
              } else {
                css2 = merge$1(css2, getThemeValue(styleKey, value, theme, config2));
              }
            }
          });
          return removeUnusedBreakpoints(breakpointsKeys, css2);
        }
        return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
      }
      return styleFunctionSx2;
    }
    const styleFunctionSx = unstable_createStyleFunctionSx();
    styleFunctionSx.filterProps = ["sx"];
    const styleFunctionSx$1 = styleFunctionSx;
    function applyStyles$2(key, styles2) {
      const theme = this;
      if (theme.vars && typeof theme.getColorSchemeSelector === "function") {
        const selector = theme.getColorSchemeSelector(key).replace(/(\[[^\]]+\])/, "*:where($1)");
        return {
          [selector]: styles2
        };
      }
      if (theme.palette.mode === key) {
        return styles2;
      }
      return {};
    }
    const _excluded$1c = ["breakpoints", "palette", "spacing", "shape"];
    function createTheme$1(options = {}, ...args) {
      const {
        breakpoints: breakpointsInput = {},
        palette: paletteInput = {},
        spacing: spacingInput,
        shape: shapeInput = {}
      } = options, other = _objectWithoutPropertiesLoose$1(options, _excluded$1c);
      const breakpoints = createBreakpoints(breakpointsInput);
      const spacing = createSpacing(spacingInput);
      let muiTheme = deepmerge({
        breakpoints,
        direction: "ltr",
        components: {},
        // Inject component definitions.
        palette: _extends$1({
          mode: "light"
        }, paletteInput),
        spacing,
        shape: _extends$1({}, shape$1, shapeInput)
      }, other);
      muiTheme.applyStyles = applyStyles$2;
      muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
      muiTheme.unstable_sxConfig = _extends$1({}, defaultSxConfig$1, other == null ? void 0 : other.unstable_sxConfig);
      muiTheme.unstable_sx = function sx(props) {
        return styleFunctionSx$1({
          sx: props,
          theme: this
        });
      };
      return muiTheme;
    }
    function isObjectEmpty(obj) {
      return Object.keys(obj).length === 0;
    }
    function useTheme$2(defaultTheme2 = null) {
      const contextTheme = reactExports.useContext(ThemeContext);
      return !contextTheme || isObjectEmpty(contextTheme) ? defaultTheme2 : contextTheme;
    }
    const systemDefaultTheme$1 = createTheme$1();
    function useTheme$1(defaultTheme2 = systemDefaultTheme$1) {
      return useTheme$2(defaultTheme2);
    }
    function GlobalStyles$1({
      styles: styles2,
      themeId,
      defaultTheme: defaultTheme2 = {}
    }) {
      const upperTheme = useTheme$1(defaultTheme2);
      const globalStyles = typeof styles2 === "function" ? styles2(themeId ? upperTheme[themeId] || upperTheme : upperTheme) : styles2;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$2, {
        styles: globalStyles
      });
    }
    const _excluded$1b = ["sx"];
    const splitProps = (props) => {
      var _props$theme$unstable, _props$theme;
      const result = {
        systemProps: {},
        otherProps: {}
      };
      const config2 = (_props$theme$unstable = props == null || (_props$theme = props.theme) == null ? void 0 : _props$theme.unstable_sxConfig) != null ? _props$theme$unstable : defaultSxConfig$1;
      Object.keys(props).forEach((prop) => {
        if (config2[prop]) {
          result.systemProps[prop] = props[prop];
        } else {
          result.otherProps[prop] = props[prop];
        }
      });
      return result;
    };
    function extendSxProp(props) {
      const {
        sx: inSx
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1b);
      const {
        systemProps,
        otherProps
      } = splitProps(other);
      let finalSx;
      if (Array.isArray(inSx)) {
        finalSx = [systemProps, ...inSx];
      } else if (typeof inSx === "function") {
        finalSx = (...args) => {
          const result = inSx(...args);
          if (!isPlainObject$1(result)) {
            return systemProps;
          }
          return _extends$1({}, systemProps, result);
        };
      } else {
        finalSx = _extends$1({}, systemProps, inSx);
      }
      return _extends$1({}, otherProps, {
        sx: finalSx
      });
    }
    const _excluded$1a = ["className", "component"];
    function createBox$1(options = {}) {
      const {
        themeId,
        defaultTheme: defaultTheme2,
        defaultClassName = "MuiBox-root",
        generateClassName
      } = options;
      const BoxRoot = styled$1("div", {
        shouldForwardProp: (prop) => prop !== "theme" && prop !== "sx" && prop !== "as"
      })(styleFunctionSx$1);
      const Box2 = /* @__PURE__ */ reactExports.forwardRef(function Box3(inProps, ref) {
        const theme = useTheme$1(defaultTheme2);
        const _extendSxProp = extendSxProp(inProps), {
          className,
          component = "div"
        } = _extendSxProp, other = _objectWithoutPropertiesLoose$1(_extendSxProp, _excluded$1a);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(BoxRoot, _extends$1({
          as: component,
          ref,
          className: clsx(className, generateClassName ? generateClassName(defaultClassName) : defaultClassName),
          theme: themeId ? theme[themeId] || theme : theme
        }, other));
      });
      return Box2;
    }
    const _excluded$19 = ["ownerState"], _excluded2$a = ["variants"], _excluded3$4 = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
    function isEmpty$2(obj) {
      return Object.keys(obj).length === 0;
    }
    function isStringTag(tag) {
      return typeof tag === "string" && // 96 is one less than the char code
      // for "a" so this is checking that
      // it's a lowercase character
      tag.charCodeAt(0) > 96;
    }
    function shouldForwardProp(prop) {
      return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
    }
    const systemDefaultTheme = createTheme$1();
    const lowercaseFirstLetter = (string2) => {
      if (!string2) {
        return string2;
      }
      return string2.charAt(0).toLowerCase() + string2.slice(1);
    };
    function resolveTheme({
      defaultTheme: defaultTheme2,
      theme,
      themeId
    }) {
      return isEmpty$2(theme) ? defaultTheme2 : theme[themeId] || theme;
    }
    function defaultOverridesResolver(slot) {
      if (!slot) {
        return null;
      }
      return (props, styles2) => styles2[slot];
    }
    function processStyleArg(callableStyle, _ref) {
      let {
        ownerState
      } = _ref, props = _objectWithoutPropertiesLoose$1(_ref, _excluded$19);
      const resolvedStylesArg = typeof callableStyle === "function" ? callableStyle(_extends$1({
        ownerState
      }, props)) : callableStyle;
      if (Array.isArray(resolvedStylesArg)) {
        return resolvedStylesArg.flatMap((resolvedStyle) => processStyleArg(resolvedStyle, _extends$1({
          ownerState
        }, props)));
      }
      if (!!resolvedStylesArg && typeof resolvedStylesArg === "object" && Array.isArray(resolvedStylesArg.variants)) {
        const {
          variants = []
        } = resolvedStylesArg, otherStyles = _objectWithoutPropertiesLoose$1(resolvedStylesArg, _excluded2$a);
        let result = otherStyles;
        variants.forEach((variant) => {
          let isMatch = true;
          if (typeof variant.props === "function") {
            isMatch = variant.props(_extends$1({
              ownerState
            }, props));
          } else {
            Object.keys(variant.props).forEach((key) => {
              if ((ownerState == null ? void 0 : ownerState[key]) !== variant.props[key] && props[key] !== variant.props[key]) {
                isMatch = false;
              }
            });
          }
          if (isMatch) {
            if (!Array.isArray(result)) {
              result = [result];
            }
            result.push(typeof variant.style === "function" ? variant.style(_extends$1({
              ownerState
            }, props)) : variant.style);
          }
        });
        return result;
      }
      return resolvedStylesArg;
    }
    function createStyled(input = {}) {
      const {
        themeId,
        defaultTheme: defaultTheme2 = systemDefaultTheme,
        rootShouldForwardProp: rootShouldForwardProp2 = shouldForwardProp,
        slotShouldForwardProp: slotShouldForwardProp2 = shouldForwardProp
      } = input;
      const systemSx = (props) => {
        return styleFunctionSx$1(_extends$1({}, props, {
          theme: resolveTheme(_extends$1({}, props, {
            defaultTheme: defaultTheme2,
            themeId
          }))
        }));
      };
      systemSx.__mui_systemSx = true;
      return (tag, inputOptions = {}) => {
        internal_processStyles(tag, (styles2) => styles2.filter((style2) => !(style2 != null && style2.__mui_systemSx)));
        const {
          name: componentName,
          slot: componentSlot,
          skipVariantsResolver: inputSkipVariantsResolver,
          skipSx: inputSkipSx,
          // TODO v6: remove `lowercaseFirstLetter()` in the next major release
          // For more details: https://github.com/mui/material-ui/pull/37908
          overridesResolver: overridesResolver2 = defaultOverridesResolver(lowercaseFirstLetter(componentSlot))
        } = inputOptions, options = _objectWithoutPropertiesLoose$1(inputOptions, _excluded3$4);
        const skipVariantsResolver = inputSkipVariantsResolver !== void 0 ? inputSkipVariantsResolver : (
          // TODO v6: remove `Root` in the next major release
          // For more details: https://github.com/mui/material-ui/pull/37908
          componentSlot && componentSlot !== "Root" && componentSlot !== "root" || false
        );
        const skipSx = inputSkipSx || false;
        let label;
        let shouldForwardPropOption = shouldForwardProp;
        if (componentSlot === "Root" || componentSlot === "root") {
          shouldForwardPropOption = rootShouldForwardProp2;
        } else if (componentSlot) {
          shouldForwardPropOption = slotShouldForwardProp2;
        } else if (isStringTag(tag)) {
          shouldForwardPropOption = void 0;
        }
        const defaultStyledResolver = styled$1(tag, _extends$1({
          shouldForwardProp: shouldForwardPropOption,
          label
        }, options));
        const transformStyleArg = (stylesArg) => {
          if (typeof stylesArg === "function" && stylesArg.__emotion_real !== stylesArg || isPlainObject$1(stylesArg)) {
            return (props) => processStyleArg(stylesArg, _extends$1({}, props, {
              theme: resolveTheme({
                theme: props.theme,
                defaultTheme: defaultTheme2,
                themeId
              })
            }));
          }
          return stylesArg;
        };
        const muiStyledResolver = (styleArg, ...expressions) => {
          let transformedStyleArg = transformStyleArg(styleArg);
          const expressionsWithDefaultTheme = expressions ? expressions.map(transformStyleArg) : [];
          if (componentName && overridesResolver2) {
            expressionsWithDefaultTheme.push((props) => {
              const theme = resolveTheme(_extends$1({}, props, {
                defaultTheme: defaultTheme2,
                themeId
              }));
              if (!theme.components || !theme.components[componentName] || !theme.components[componentName].styleOverrides) {
                return null;
              }
              const styleOverrides = theme.components[componentName].styleOverrides;
              const resolvedStyleOverrides = {};
              Object.entries(styleOverrides).forEach(([slotKey, slotStyle]) => {
                resolvedStyleOverrides[slotKey] = processStyleArg(slotStyle, _extends$1({}, props, {
                  theme
                }));
              });
              return overridesResolver2(props, resolvedStyleOverrides);
            });
          }
          if (componentName && !skipVariantsResolver) {
            expressionsWithDefaultTheme.push((props) => {
              var _theme$components;
              const theme = resolveTheme(_extends$1({}, props, {
                defaultTheme: defaultTheme2,
                themeId
              }));
              const themeVariants = theme == null || (_theme$components = theme.components) == null || (_theme$components = _theme$components[componentName]) == null ? void 0 : _theme$components.variants;
              return processStyleArg({
                variants: themeVariants
              }, _extends$1({}, props, {
                theme
              }));
            });
          }
          if (!skipSx) {
            expressionsWithDefaultTheme.push(systemSx);
          }
          const numOfCustomFnsApplied = expressionsWithDefaultTheme.length - expressions.length;
          if (Array.isArray(styleArg) && numOfCustomFnsApplied > 0) {
            const placeholders = new Array(numOfCustomFnsApplied).fill("");
            transformedStyleArg = [...styleArg, ...placeholders];
            transformedStyleArg.raw = [...styleArg.raw, ...placeholders];
          }
          const Component = defaultStyledResolver(transformedStyleArg, ...expressionsWithDefaultTheme);
          if (tag.muiName) {
            Component.muiName = tag.muiName;
          }
          return Component;
        };
        if (defaultStyledResolver.withConfig) {
          muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
        }
        return muiStyledResolver;
      };
    }
    function getThemeProps(params) {
      const {
        theme,
        name,
        props
      } = params;
      if (!theme || !theme.components || !theme.components[name] || !theme.components[name].defaultProps) {
        return props;
      }
      return resolveProps(theme.components[name].defaultProps, props);
    }
    function useThemeProps$1({
      props,
      name,
      defaultTheme: defaultTheme2,
      themeId
    }) {
      let theme = useTheme$1(defaultTheme2);
      if (themeId) {
        theme = theme[themeId] || theme;
      }
      const mergedProps = getThemeProps({
        theme,
        name,
        props
      });
      return mergedProps;
    }
    function clampWrapper(value, min2 = 0, max2 = 1) {
      return clamp$1(value, min2, max2);
    }
    function hexToRgb(color2) {
      color2 = color2.slice(1);
      const re2 = new RegExp(`.{1,${color2.length >= 6 ? 2 : 1}}`, "g");
      let colors = color2.match(re2);
      if (colors && colors[0].length === 1) {
        colors = colors.map((n2) => n2 + n2);
      }
      return colors ? `rgb${colors.length === 4 ? "a" : ""}(${colors.map((n2, index) => {
        return index < 3 ? parseInt(n2, 16) : Math.round(parseInt(n2, 16) / 255 * 1e3) / 1e3;
      }).join(", ")})` : "";
    }
    function decomposeColor(color2) {
      if (color2.type) {
        return color2;
      }
      if (color2.charAt(0) === "#") {
        return decomposeColor(hexToRgb(color2));
      }
      const marker = color2.indexOf("(");
      const type = color2.substring(0, marker);
      if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(type) === -1) {
        throw new Error(formatMuiErrorMessage(9, color2));
      }
      let values2 = color2.substring(marker + 1, color2.length - 1);
      let colorSpace;
      if (type === "color") {
        values2 = values2.split(" ");
        colorSpace = values2.shift();
        if (values2.length === 4 && values2[3].charAt(0) === "/") {
          values2[3] = values2[3].slice(1);
        }
        if (["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(colorSpace) === -1) {
          throw new Error(formatMuiErrorMessage(10, colorSpace));
        }
      } else {
        values2 = values2.split(",");
      }
      values2 = values2.map((value) => parseFloat(value));
      return {
        type,
        values: values2,
        colorSpace
      };
    }
    function recomposeColor(color2) {
      const {
        type,
        colorSpace
      } = color2;
      let {
        values: values2
      } = color2;
      if (type.indexOf("rgb") !== -1) {
        values2 = values2.map((n2, i) => i < 3 ? parseInt(n2, 10) : n2);
      } else if (type.indexOf("hsl") !== -1) {
        values2[1] = `${values2[1]}%`;
        values2[2] = `${values2[2]}%`;
      }
      if (type.indexOf("color") !== -1) {
        values2 = `${colorSpace} ${values2.join(" ")}`;
      } else {
        values2 = `${values2.join(", ")}`;
      }
      return `${type}(${values2})`;
    }
    function hslToRgb(color2) {
      color2 = decomposeColor(color2);
      const {
        values: values2
      } = color2;
      const h2 = values2[0];
      const s = values2[1] / 100;
      const l2 = values2[2] / 100;
      const a = s * Math.min(l2, 1 - l2);
      const f2 = (n2, k2 = (n2 + h2 / 30) % 12) => l2 - a * Math.max(Math.min(k2 - 3, 9 - k2, 1), -1);
      let type = "rgb";
      const rgb = [Math.round(f2(0) * 255), Math.round(f2(8) * 255), Math.round(f2(4) * 255)];
      if (color2.type === "hsla") {
        type += "a";
        rgb.push(values2[3]);
      }
      return recomposeColor({
        type,
        values: rgb
      });
    }
    function getLuminance(color2) {
      color2 = decomposeColor(color2);
      let rgb = color2.type === "hsl" || color2.type === "hsla" ? decomposeColor(hslToRgb(color2)).values : color2.values;
      rgb = rgb.map((val) => {
        if (color2.type !== "color") {
          val /= 255;
        }
        return val <= 0.03928 ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4;
      });
      return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
    }
    function getContrastRatio(foreground, background) {
      const lumA = getLuminance(foreground);
      const lumB = getLuminance(background);
      return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
    }
    function alpha$1(color2, value) {
      color2 = decomposeColor(color2);
      value = clampWrapper(value);
      if (color2.type === "rgb" || color2.type === "hsl") {
        color2.type += "a";
      }
      if (color2.type === "color") {
        color2.values[3] = `/${value}`;
      } else {
        color2.values[3] = value;
      }
      return recomposeColor(color2);
    }
    function darken(color2, coefficient) {
      color2 = decomposeColor(color2);
      coefficient = clampWrapper(coefficient);
      if (color2.type.indexOf("hsl") !== -1) {
        color2.values[2] *= 1 - coefficient;
      } else if (color2.type.indexOf("rgb") !== -1 || color2.type.indexOf("color") !== -1) {
        for (let i = 0; i < 3; i += 1) {
          color2.values[i] *= 1 - coefficient;
        }
      }
      return recomposeColor(color2);
    }
    function lighten(color2, coefficient) {
      color2 = decomposeColor(color2);
      coefficient = clampWrapper(coefficient);
      if (color2.type.indexOf("hsl") !== -1) {
        color2.values[2] += (100 - color2.values[2]) * coefficient;
      } else if (color2.type.indexOf("rgb") !== -1) {
        for (let i = 0; i < 3; i += 1) {
          color2.values[i] += (255 - color2.values[i]) * coefficient;
        }
      } else if (color2.type.indexOf("color") !== -1) {
        for (let i = 0; i < 3; i += 1) {
          color2.values[i] += (1 - color2.values[i]) * coefficient;
        }
      }
      return recomposeColor(color2);
    }
    function emphasize(color2, coefficient = 0.15) {
      return getLuminance(color2) > 0.5 ? darken(color2, coefficient) : lighten(color2, coefficient);
    }
    function createMixins(breakpoints, mixins) {
      return _extends$1({
        toolbar: {
          minHeight: 56,
          [breakpoints.up("xs")]: {
            "@media (orientation: landscape)": {
              minHeight: 48
            }
          },
          [breakpoints.up("sm")]: {
            minHeight: 64
          }
        }
      }, mixins);
    }
    const common = {
      black: "#000",
      white: "#fff"
    };
    const common$1 = common;
    const grey = {
      50: "#fafafa",
      100: "#f5f5f5",
      200: "#eeeeee",
      300: "#e0e0e0",
      400: "#bdbdbd",
      500: "#9e9e9e",
      600: "#757575",
      700: "#616161",
      800: "#424242",
      900: "#212121",
      A100: "#f5f5f5",
      A200: "#eeeeee",
      A400: "#bdbdbd",
      A700: "#616161"
    };
    const grey$1 = grey;
    const purple = {
      50: "#f3e5f5",
      100: "#e1bee7",
      200: "#ce93d8",
      300: "#ba68c8",
      400: "#ab47bc",
      500: "#9c27b0",
      600: "#8e24aa",
      700: "#7b1fa2",
      800: "#6a1b9a",
      900: "#4a148c",
      A100: "#ea80fc",
      A200: "#e040fb",
      A400: "#d500f9",
      A700: "#aa00ff"
    };
    const purple$1 = purple;
    const red = {
      50: "#ffebee",
      100: "#ffcdd2",
      200: "#ef9a9a",
      300: "#e57373",
      400: "#ef5350",
      500: "#f44336",
      600: "#e53935",
      700: "#d32f2f",
      800: "#c62828",
      900: "#b71c1c",
      A100: "#ff8a80",
      A200: "#ff5252",
      A400: "#ff1744",
      A700: "#d50000"
    };
    const red$1 = red;
    const orange = {
      50: "#fff3e0",
      100: "#ffe0b2",
      200: "#ffcc80",
      300: "#ffb74d",
      400: "#ffa726",
      500: "#ff9800",
      600: "#fb8c00",
      700: "#f57c00",
      800: "#ef6c00",
      900: "#e65100",
      A100: "#ffd180",
      A200: "#ffab40",
      A400: "#ff9100",
      A700: "#ff6d00"
    };
    const orange$1 = orange;
    const blue = {
      50: "#e3f2fd",
      100: "#bbdefb",
      200: "#90caf9",
      300: "#64b5f6",
      400: "#42a5f5",
      500: "#2196f3",
      600: "#1e88e5",
      700: "#1976d2",
      800: "#1565c0",
      900: "#0d47a1",
      A100: "#82b1ff",
      A200: "#448aff",
      A400: "#2979ff",
      A700: "#2962ff"
    };
    const blue$1 = blue;
    const lightBlue = {
      50: "#e1f5fe",
      100: "#b3e5fc",
      200: "#81d4fa",
      300: "#4fc3f7",
      400: "#29b6f6",
      500: "#03a9f4",
      600: "#039be5",
      700: "#0288d1",
      800: "#0277bd",
      900: "#01579b",
      A100: "#80d8ff",
      A200: "#40c4ff",
      A400: "#00b0ff",
      A700: "#0091ea"
    };
    const lightBlue$1 = lightBlue;
    const green = {
      50: "#e8f5e9",
      100: "#c8e6c9",
      200: "#a5d6a7",
      300: "#81c784",
      400: "#66bb6a",
      500: "#4caf50",
      600: "#43a047",
      700: "#388e3c",
      800: "#2e7d32",
      900: "#1b5e20",
      A100: "#b9f6ca",
      A200: "#69f0ae",
      A400: "#00e676",
      A700: "#00c853"
    };
    const green$1 = green;
    const _excluded$18 = ["mode", "contrastThreshold", "tonalOffset"];
    const light = {
      // The colors used to style the text.
      text: {
        // The most important text.
        primary: "rgba(0, 0, 0, 0.87)",
        // Secondary text.
        secondary: "rgba(0, 0, 0, 0.6)",
        // Disabled text have even lower visual prominence.
        disabled: "rgba(0, 0, 0, 0.38)"
      },
      // The color used to divide different elements.
      divider: "rgba(0, 0, 0, 0.12)",
      // The background colors used to style the surfaces.
      // Consistency between these values is important.
      background: {
        paper: common$1.white,
        default: common$1.white
      },
      // The colors used to style the action elements.
      action: {
        // The color of an active action like an icon button.
        active: "rgba(0, 0, 0, 0.54)",
        // The color of an hovered action.
        hover: "rgba(0, 0, 0, 0.04)",
        hoverOpacity: 0.04,
        // The color of a selected action.
        selected: "rgba(0, 0, 0, 0.08)",
        selectedOpacity: 0.08,
        // The color of a disabled action.
        disabled: "rgba(0, 0, 0, 0.26)",
        // The background color of a disabled action.
        disabledBackground: "rgba(0, 0, 0, 0.12)",
        disabledOpacity: 0.38,
        focus: "rgba(0, 0, 0, 0.12)",
        focusOpacity: 0.12,
        activatedOpacity: 0.12
      }
    };
    const dark = {
      text: {
        primary: common$1.white,
        secondary: "rgba(255, 255, 255, 0.7)",
        disabled: "rgba(255, 255, 255, 0.5)",
        icon: "rgba(255, 255, 255, 0.5)"
      },
      divider: "rgba(255, 255, 255, 0.12)",
      background: {
        paper: "#121212",
        default: "#121212"
      },
      action: {
        active: common$1.white,
        hover: "rgba(255, 255, 255, 0.08)",
        hoverOpacity: 0.08,
        selected: "rgba(255, 255, 255, 0.16)",
        selectedOpacity: 0.16,
        disabled: "rgba(255, 255, 255, 0.3)",
        disabledBackground: "rgba(255, 255, 255, 0.12)",
        disabledOpacity: 0.38,
        focus: "rgba(255, 255, 255, 0.12)",
        focusOpacity: 0.12,
        activatedOpacity: 0.24
      }
    };
    function addLightOrDark(intent, direction, shade, tonalOffset) {
      const tonalOffsetLight = tonalOffset.light || tonalOffset;
      const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
      if (!intent[direction]) {
        if (intent.hasOwnProperty(shade)) {
          intent[direction] = intent[shade];
        } else if (direction === "light") {
          intent.light = lighten(intent.main, tonalOffsetLight);
        } else if (direction === "dark") {
          intent.dark = darken(intent.main, tonalOffsetDark);
        }
      }
    }
    function getDefaultPrimary(mode = "light") {
      if (mode === "dark") {
        return {
          main: blue$1[200],
          light: blue$1[50],
          dark: blue$1[400]
        };
      }
      return {
        main: blue$1[700],
        light: blue$1[400],
        dark: blue$1[800]
      };
    }
    function getDefaultSecondary(mode = "light") {
      if (mode === "dark") {
        return {
          main: purple$1[200],
          light: purple$1[50],
          dark: purple$1[400]
        };
      }
      return {
        main: purple$1[500],
        light: purple$1[300],
        dark: purple$1[700]
      };
    }
    function getDefaultError(mode = "light") {
      if (mode === "dark") {
        return {
          main: red$1[500],
          light: red$1[300],
          dark: red$1[700]
        };
      }
      return {
        main: red$1[700],
        light: red$1[400],
        dark: red$1[800]
      };
    }
    function getDefaultInfo(mode = "light") {
      if (mode === "dark") {
        return {
          main: lightBlue$1[400],
          light: lightBlue$1[300],
          dark: lightBlue$1[700]
        };
      }
      return {
        main: lightBlue$1[700],
        light: lightBlue$1[500],
        dark: lightBlue$1[900]
      };
    }
    function getDefaultSuccess(mode = "light") {
      if (mode === "dark") {
        return {
          main: green$1[400],
          light: green$1[300],
          dark: green$1[700]
        };
      }
      return {
        main: green$1[800],
        light: green$1[500],
        dark: green$1[900]
      };
    }
    function getDefaultWarning(mode = "light") {
      if (mode === "dark") {
        return {
          main: orange$1[400],
          light: orange$1[300],
          dark: orange$1[700]
        };
      }
      return {
        main: "#ed6c02",
        // closest to orange[800] that pass 3:1.
        light: orange$1[500],
        dark: orange$1[900]
      };
    }
    function createPalette(palette) {
      const {
        mode = "light",
        contrastThreshold = 3,
        tonalOffset = 0.2
      } = palette, other = _objectWithoutPropertiesLoose$1(palette, _excluded$18);
      const primary = palette.primary || getDefaultPrimary(mode);
      const secondary = palette.secondary || getDefaultSecondary(mode);
      const error = palette.error || getDefaultError(mode);
      const info = palette.info || getDefaultInfo(mode);
      const success = palette.success || getDefaultSuccess(mode);
      const warning2 = palette.warning || getDefaultWarning(mode);
      function getContrastText(background) {
        const contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
        return contrastText;
      }
      const augmentColor = ({
        color: color2,
        name,
        mainShade = 500,
        lightShade = 300,
        darkShade = 700
      }) => {
        color2 = _extends$1({}, color2);
        if (!color2.main && color2[mainShade]) {
          color2.main = color2[mainShade];
        }
        if (!color2.hasOwnProperty("main")) {
          throw new Error(formatMuiErrorMessage(11, name ? ` (${name})` : "", mainShade));
        }
        if (typeof color2.main !== "string") {
          throw new Error(formatMuiErrorMessage(12, name ? ` (${name})` : "", JSON.stringify(color2.main)));
        }
        addLightOrDark(color2, "light", lightShade, tonalOffset);
        addLightOrDark(color2, "dark", darkShade, tonalOffset);
        if (!color2.contrastText) {
          color2.contrastText = getContrastText(color2.main);
        }
        return color2;
      };
      const modes = {
        dark,
        light
      };
      const paletteOutput = deepmerge(_extends$1({
        // A collection of common colors.
        common: _extends$1({}, common$1),
        // prevent mutable object.
        // The palette mode, can be light or dark.
        mode,
        // The colors used to represent primary interface elements for a user.
        primary: augmentColor({
          color: primary,
          name: "primary"
        }),
        // The colors used to represent secondary interface elements for a user.
        secondary: augmentColor({
          color: secondary,
          name: "secondary",
          mainShade: "A400",
          lightShade: "A200",
          darkShade: "A700"
        }),
        // The colors used to represent interface elements that the user should be made aware of.
        error: augmentColor({
          color: error,
          name: "error"
        }),
        // The colors used to represent potentially dangerous actions or important messages.
        warning: augmentColor({
          color: warning2,
          name: "warning"
        }),
        // The colors used to present information to the user that is neutral and not necessarily important.
        info: augmentColor({
          color: info,
          name: "info"
        }),
        // The colors used to indicate the successful completion of an action that user triggered.
        success: augmentColor({
          color: success,
          name: "success"
        }),
        // The grey colors.
        grey: grey$1,
        // Used by `getContrastText()` to maximize the contrast between
        // the background and the text.
        contrastThreshold,
        // Takes a background color and returns the text color that maximizes the contrast.
        getContrastText,
        // Generate a rich color object.
        augmentColor,
        // Used by the functions below to shift a color's luminance by approximately
        // two indexes within its tonal palette.
        // E.g., shift from Red 500 to Red 300 or Red 700.
        tonalOffset
      }, modes[mode]), other);
      return paletteOutput;
    }
    const _excluded$17 = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];
    function round$1(value) {
      return Math.round(value * 1e5) / 1e5;
    }
    const caseAllCaps = {
      textTransform: "uppercase"
    };
    const defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
    function createTypography(palette, typography) {
      const _ref = typeof typography === "function" ? typography(palette) : typography, {
        fontFamily = defaultFontFamily,
        // The default font size of the Material Specification.
        fontSize = 14,
        // px
        fontWeightLight = 300,
        fontWeightRegular = 400,
        fontWeightMedium = 500,
        fontWeightBold = 700,
        // Tell MUI what's the font-size on the html element.
        // 16px is the default font-size used by browsers.
        htmlFontSize = 16,
        // Apply the CSS properties to all the variants.
        allVariants,
        pxToRem: pxToRem2
      } = _ref, other = _objectWithoutPropertiesLoose$1(_ref, _excluded$17);
      const coef = fontSize / 14;
      const pxToRem = pxToRem2 || ((size) => `${size / htmlFontSize * coef}rem`);
      const buildVariant = (fontWeight, size, lineHeight, letterSpacing, casing) => _extends$1({
        fontFamily,
        fontWeight,
        fontSize: pxToRem(size),
        // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
        lineHeight
      }, fontFamily === defaultFontFamily ? {
        letterSpacing: `${round$1(letterSpacing / size)}em`
      } : {}, casing, allVariants);
      const variants = {
        h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
        h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
        h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
        h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
        h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
        h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
        subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
        subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
        body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
        body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
        button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
        caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
        overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps),
        // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
        inherit: {
          fontFamily: "inherit",
          fontWeight: "inherit",
          fontSize: "inherit",
          lineHeight: "inherit",
          letterSpacing: "inherit"
        }
      };
      return deepmerge(_extends$1({
        htmlFontSize,
        pxToRem,
        fontFamily,
        fontSize,
        fontWeightLight,
        fontWeightRegular,
        fontWeightMedium,
        fontWeightBold
      }, variants), other, {
        clone: false
        // No need to clone deep
      });
    }
    const shadowKeyUmbraOpacity = 0.2;
    const shadowKeyPenumbraOpacity = 0.14;
    const shadowAmbientShadowOpacity = 0.12;
    function createShadow(...px2) {
      return [`${px2[0]}px ${px2[1]}px ${px2[2]}px ${px2[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px2[4]}px ${px2[5]}px ${px2[6]}px ${px2[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px2[8]}px ${px2[9]}px ${px2[10]}px ${px2[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",");
    }
    const shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
    const _excluded$16 = ["duration", "easing", "delay"];
    const easing = {
      // This is the most common easing curve.
      easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
      // Objects enter the screen at full velocity from off-screen and
      // slowly decelerate to a resting point.
      easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
      // Objects leave the screen at full velocity. They do not decelerate when off-screen.
      easeIn: "cubic-bezier(0.4, 0, 1, 1)",
      // The sharp curve is used by objects that may return to the screen at any time.
      sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
    };
    const duration = {
      shortest: 150,
      shorter: 200,
      short: 250,
      // most basic recommended timing
      standard: 300,
      // this is to be used in complex animations
      complex: 375,
      // recommended when something is entering screen
      enteringScreen: 225,
      // recommended when something is leaving screen
      leavingScreen: 195
    };
    function formatMs(milliseconds) {
      return `${Math.round(milliseconds)}ms`;
    }
    function getAutoHeightDuration(height2) {
      if (!height2) {
        return 0;
      }
      const constant = height2 / 36;
      return Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10);
    }
    function createTransitions(inputTransitions) {
      const mergedEasing = _extends$1({}, easing, inputTransitions.easing);
      const mergedDuration = _extends$1({}, duration, inputTransitions.duration);
      const create2 = (props = ["all"], options = {}) => {
        const {
          duration: durationOption = mergedDuration.standard,
          easing: easingOption = mergedEasing.easeInOut,
          delay: delay2 = 0
        } = options;
        _objectWithoutPropertiesLoose$1(options, _excluded$16);
        return (Array.isArray(props) ? props : [props]).map((animatedProp) => `${animatedProp} ${typeof durationOption === "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay2 === "string" ? delay2 : formatMs(delay2)}`).join(",");
      };
      return _extends$1({
        getAutoHeightDuration,
        create: create2
      }, inputTransitions, {
        easing: mergedEasing,
        duration: mergedDuration
      });
    }
    const zIndex = {
      mobileStepper: 1e3,
      fab: 1050,
      speedDial: 1050,
      appBar: 1100,
      drawer: 1200,
      modal: 1300,
      snackbar: 1400,
      tooltip: 1500
    };
    const zIndex$1 = zIndex;
    const _excluded$15 = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];
    function createTheme(options = {}, ...args) {
      const {
        mixins: mixinsInput = {},
        palette: paletteInput = {},
        transitions: transitionsInput = {},
        typography: typographyInput = {}
      } = options, other = _objectWithoutPropertiesLoose$1(options, _excluded$15);
      if (options.vars) {
        throw new Error(formatMuiErrorMessage(18));
      }
      const palette = createPalette(paletteInput);
      const systemTheme = createTheme$1(options);
      let muiTheme = deepmerge(systemTheme, {
        mixins: createMixins(systemTheme.breakpoints, mixinsInput),
        palette,
        // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
        shadows: shadows.slice(),
        typography: createTypography(palette, typographyInput),
        transitions: createTransitions(transitionsInput),
        zIndex: _extends$1({}, zIndex$1)
      });
      muiTheme = deepmerge(muiTheme, other);
      muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
      muiTheme.unstable_sxConfig = _extends$1({}, defaultSxConfig$1, other == null ? void 0 : other.unstable_sxConfig);
      muiTheme.unstable_sx = function sx(props) {
        return styleFunctionSx$1({
          sx: props,
          theme: this
        });
      };
      return muiTheme;
    }
    const defaultTheme$1 = createTheme();
    const defaultTheme$2 = defaultTheme$1;
    const THEME_ID = "$$material";
    const rootShouldForwardProp = (prop) => shouldForwardProp(prop) && prop !== "classes";
    const slotShouldForwardProp = shouldForwardProp;
    const styled = createStyled({
      themeId: THEME_ID,
      defaultTheme: defaultTheme$2,
      rootShouldForwardProp
    });
    function useThemeProps({
      props,
      name
    }) {
      return useThemeProps$1({
        props,
        name,
        defaultTheme: defaultTheme$2,
        themeId: THEME_ID
      });
    }
    function _setPrototypeOf(o, p2) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
        o2.__proto__ = p3;
        return o2;
      };
      return _setPrototypeOf(o, p2);
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    const config = {
      disabled: false
    };
    const TransitionGroupContext = React.createContext(null);
    var forceReflow = function forceReflow2(node2) {
      return node2.scrollTop;
    };
    var UNMOUNTED = "unmounted";
    var EXITED = "exited";
    var ENTERING = "entering";
    var ENTERED = "entered";
    var EXITING = "exiting";
    var Transition = /* @__PURE__ */ function(_React$Component) {
      _inheritsLoose(Transition2, _React$Component);
      function Transition2(props, context) {
        var _this;
        _this = _React$Component.call(this, props, context) || this;
        var parentGroup = context;
        var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
        var initialStatus;
        _this.appearStatus = null;
        if (props.in) {
          if (appear) {
            initialStatus = EXITED;
            _this.appearStatus = ENTERING;
          } else {
            initialStatus = ENTERED;
          }
        } else {
          if (props.unmountOnExit || props.mountOnEnter) {
            initialStatus = UNMOUNTED;
          } else {
            initialStatus = EXITED;
          }
        }
        _this.state = {
          status: initialStatus
        };
        _this.nextCallback = null;
        return _this;
      }
      Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
        var nextIn = _ref.in;
        if (nextIn && prevState.status === UNMOUNTED) {
          return {
            status: EXITED
          };
        }
        return null;
      };
      var _proto = Transition2.prototype;
      _proto.componentDidMount = function componentDidMount() {
        this.updateStatus(true, this.appearStatus);
      };
      _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
        var nextStatus = null;
        if (prevProps !== this.props) {
          var status = this.state.status;
          if (this.props.in) {
            if (status !== ENTERING && status !== ENTERED) {
              nextStatus = ENTERING;
            }
          } else {
            if (status === ENTERING || status === ENTERED) {
              nextStatus = EXITING;
            }
          }
        }
        this.updateStatus(false, nextStatus);
      };
      _proto.componentWillUnmount = function componentWillUnmount() {
        this.cancelNextCallback();
      };
      _proto.getTimeouts = function getTimeouts() {
        var timeout2 = this.props.timeout;
        var exit, enter, appear;
        exit = enter = appear = timeout2;
        if (timeout2 != null && typeof timeout2 !== "number") {
          exit = timeout2.exit;
          enter = timeout2.enter;
          appear = timeout2.appear !== void 0 ? timeout2.appear : enter;
        }
        return {
          exit,
          enter,
          appear
        };
      };
      _proto.updateStatus = function updateStatus(mounting, nextStatus) {
        if (mounting === void 0) {
          mounting = false;
        }
        if (nextStatus !== null) {
          this.cancelNextCallback();
          if (nextStatus === ENTERING) {
            if (this.props.unmountOnExit || this.props.mountOnEnter) {
              var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
              if (node2)
                forceReflow(node2);
            }
            this.performEnter(mounting);
          } else {
            this.performExit();
          }
        } else if (this.props.unmountOnExit && this.state.status === EXITED) {
          this.setState({
            status: UNMOUNTED
          });
        }
      };
      _proto.performEnter = function performEnter(mounting) {
        var _this2 = this;
        var enter = this.props.enter;
        var appearing = this.context ? this.context.isMounting : mounting;
        var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
        var timeouts = this.getTimeouts();
        var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
        if (!mounting && !enter || config.disabled) {
          this.safeSetState({
            status: ENTERED
          }, function() {
            _this2.props.onEntered(maybeNode);
          });
          return;
        }
        this.props.onEnter(maybeNode, maybeAppearing);
        this.safeSetState({
          status: ENTERING
        }, function() {
          _this2.props.onEntering(maybeNode, maybeAppearing);
          _this2.onTransitionEnd(enterTimeout, function() {
            _this2.safeSetState({
              status: ENTERED
            }, function() {
              _this2.props.onEntered(maybeNode, maybeAppearing);
            });
          });
        });
      };
      _proto.performExit = function performExit() {
        var _this3 = this;
        var exit = this.props.exit;
        var timeouts = this.getTimeouts();
        var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
        if (!exit || config.disabled) {
          this.safeSetState({
            status: EXITED
          }, function() {
            _this3.props.onExited(maybeNode);
          });
          return;
        }
        this.props.onExit(maybeNode);
        this.safeSetState({
          status: EXITING
        }, function() {
          _this3.props.onExiting(maybeNode);
          _this3.onTransitionEnd(timeouts.exit, function() {
            _this3.safeSetState({
              status: EXITED
            }, function() {
              _this3.props.onExited(maybeNode);
            });
          });
        });
      };
      _proto.cancelNextCallback = function cancelNextCallback() {
        if (this.nextCallback !== null) {
          this.nextCallback.cancel();
          this.nextCallback = null;
        }
      };
      _proto.safeSetState = function safeSetState(nextState, callback) {
        callback = this.setNextCallback(callback);
        this.setState(nextState, callback);
      };
      _proto.setNextCallback = function setNextCallback(callback) {
        var _this4 = this;
        var active = true;
        this.nextCallback = function(event) {
          if (active) {
            active = false;
            _this4.nextCallback = null;
            callback(event);
          }
        };
        this.nextCallback.cancel = function() {
          active = false;
        };
        return this.nextCallback;
      };
      _proto.onTransitionEnd = function onTransitionEnd(timeout2, handler) {
        this.setNextCallback(handler);
        var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
        var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
        if (!node2 || doesNotHaveTimeoutOrListener) {
          setTimeout(this.nextCallback, 0);
          return;
        }
        if (this.props.addEndListener) {
          var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node2, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
          this.props.addEndListener(maybeNode, maybeNextCallback);
        }
        if (timeout2 != null) {
          setTimeout(this.nextCallback, timeout2);
        }
      };
      _proto.render = function render() {
        var status = this.state.status;
        if (status === UNMOUNTED) {
          return null;
        }
        var _this$props = this.props, children = _this$props.children;
        _this$props.in;
        _this$props.mountOnEnter;
        _this$props.unmountOnExit;
        _this$props.appear;
        _this$props.enter;
        _this$props.exit;
        _this$props.timeout;
        _this$props.addEndListener;
        _this$props.onEnter;
        _this$props.onEntering;
        _this$props.onEntered;
        _this$props.onExit;
        _this$props.onExiting;
        _this$props.onExited;
        _this$props.nodeRef;
        var childProps = _objectWithoutPropertiesLoose$1(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
        return (
          // allows for nested Transitions
          /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
            value: null
          }, typeof children === "function" ? children(status, childProps) : React.cloneElement(React.Children.only(children), childProps))
        );
      };
      return Transition2;
    }(React.Component);
    Transition.contextType = TransitionGroupContext;
    Transition.propTypes = {};
    function noop$2() {
    }
    Transition.defaultProps = {
      in: false,
      mountOnEnter: false,
      unmountOnExit: false,
      appear: false,
      enter: true,
      exit: true,
      onEnter: noop$2,
      onEntering: noop$2,
      onEntered: noop$2,
      onExit: noop$2,
      onExiting: noop$2,
      onExited: noop$2
    };
    Transition.UNMOUNTED = UNMOUNTED;
    Transition.EXITED = EXITED;
    Transition.ENTERING = ENTERING;
    Transition.ENTERED = ENTERED;
    Transition.EXITING = EXITING;
    const Transition$1 = Transition;
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function getChildMapping(children, mapFn) {
      var mapper = function mapper2(child) {
        return mapFn && reactExports.isValidElement(child) ? mapFn(child) : child;
      };
      var result = /* @__PURE__ */ Object.create(null);
      if (children)
        reactExports.Children.map(children, function(c2) {
          return c2;
        }).forEach(function(child) {
          result[child.key] = mapper(child);
        });
      return result;
    }
    function mergeChildMappings(prev2, next2) {
      prev2 = prev2 || {};
      next2 = next2 || {};
      function getValueForKey(key) {
        return key in next2 ? next2[key] : prev2[key];
      }
      var nextKeysPending = /* @__PURE__ */ Object.create(null);
      var pendingKeys = [];
      for (var prevKey in prev2) {
        if (prevKey in next2) {
          if (pendingKeys.length) {
            nextKeysPending[prevKey] = pendingKeys;
            pendingKeys = [];
          }
        } else {
          pendingKeys.push(prevKey);
        }
      }
      var i;
      var childMapping = {};
      for (var nextKey in next2) {
        if (nextKeysPending[nextKey]) {
          for (i = 0; i < nextKeysPending[nextKey].length; i++) {
            var pendingNextKey = nextKeysPending[nextKey][i];
            childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
          }
        }
        childMapping[nextKey] = getValueForKey(nextKey);
      }
      for (i = 0; i < pendingKeys.length; i++) {
        childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
      }
      return childMapping;
    }
    function getProp(child, prop, props) {
      return props[prop] != null ? props[prop] : child.props[prop];
    }
    function getInitialChildMapping(props, onExited) {
      return getChildMapping(props.children, function(child) {
        return reactExports.cloneElement(child, {
          onExited: onExited.bind(null, child),
          in: true,
          appear: getProp(child, "appear", props),
          enter: getProp(child, "enter", props),
          exit: getProp(child, "exit", props)
        });
      });
    }
    function getNextChildMapping(nextProps, prevChildMapping, onExited) {
      var nextChildMapping = getChildMapping(nextProps.children);
      var children = mergeChildMappings(prevChildMapping, nextChildMapping);
      Object.keys(children).forEach(function(key) {
        var child = children[key];
        if (!reactExports.isValidElement(child))
          return;
        var hasPrev = key in prevChildMapping;
        var hasNext = key in nextChildMapping;
        var prevChild = prevChildMapping[key];
        var isLeaving = reactExports.isValidElement(prevChild) && !prevChild.props.in;
        if (hasNext && (!hasPrev || isLeaving)) {
          children[key] = reactExports.cloneElement(child, {
            onExited: onExited.bind(null, child),
            in: true,
            exit: getProp(child, "exit", nextProps),
            enter: getProp(child, "enter", nextProps)
          });
        } else if (!hasNext && hasPrev && !isLeaving) {
          children[key] = reactExports.cloneElement(child, {
            in: false
          });
        } else if (hasNext && hasPrev && reactExports.isValidElement(prevChild)) {
          children[key] = reactExports.cloneElement(child, {
            onExited: onExited.bind(null, child),
            in: prevChild.props.in,
            exit: getProp(child, "exit", nextProps),
            enter: getProp(child, "enter", nextProps)
          });
        }
      });
      return children;
    }
    var values = Object.values || function(obj) {
      return Object.keys(obj).map(function(k2) {
        return obj[k2];
      });
    };
    var defaultProps = {
      component: "div",
      childFactory: function childFactory(child) {
        return child;
      }
    };
    var TransitionGroup = /* @__PURE__ */ function(_React$Component) {
      _inheritsLoose(TransitionGroup2, _React$Component);
      function TransitionGroup2(props, context) {
        var _this;
        _this = _React$Component.call(this, props, context) || this;
        var handleExited = _this.handleExited.bind(_assertThisInitialized(_this));
        _this.state = {
          contextValue: {
            isMounting: true
          },
          handleExited,
          firstRender: true
        };
        return _this;
      }
      var _proto = TransitionGroup2.prototype;
      _proto.componentDidMount = function componentDidMount() {
        this.mounted = true;
        this.setState({
          contextValue: {
            isMounting: false
          }
        });
      };
      _proto.componentWillUnmount = function componentWillUnmount() {
        this.mounted = false;
      };
      TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
        var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
        return {
          children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
          firstRender: false
        };
      };
      _proto.handleExited = function handleExited(child, node2) {
        var currentChildMapping = getChildMapping(this.props.children);
        if (child.key in currentChildMapping)
          return;
        if (child.props.onExited) {
          child.props.onExited(node2);
        }
        if (this.mounted) {
          this.setState(function(state) {
            var children = _extends$1({}, state.children);
            delete children[child.key];
            return {
              children
            };
          });
        }
      };
      _proto.render = function render() {
        var _this$props = this.props, Component = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose$1(_this$props, ["component", "childFactory"]);
        var contextValue = this.state.contextValue;
        var children = values(this.state.children).map(childFactory2);
        delete props.appear;
        delete props.enter;
        delete props.exit;
        if (Component === null) {
          return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
            value: contextValue
          }, children);
        }
        return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
          value: contextValue
        }, /* @__PURE__ */ React.createElement(Component, props, children));
      };
      return TransitionGroup2;
    }(React.Component);
    TransitionGroup.propTypes = {};
    TransitionGroup.defaultProps = defaultProps;
    const TransitionGroup$1 = TransitionGroup;
    function Ripple(props) {
      const {
        className,
        classes,
        pulsate = false,
        rippleX,
        rippleY,
        rippleSize,
        in: inProp,
        onExited,
        timeout
      } = props;
      const [leaving, setLeaving] = reactExports.useState(false);
      const rippleClassName = clsx(className, classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);
      const rippleStyles = {
        width: rippleSize,
        height: rippleSize,
        top: -(rippleSize / 2) + rippleY,
        left: -(rippleSize / 2) + rippleX
      };
      const childClassName = clsx(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
      if (!inProp && !leaving) {
        setLeaving(true);
      }
      reactExports.useEffect(() => {
        if (!inProp && onExited != null) {
          const timeoutId = setTimeout(onExited, timeout);
          return () => {
            clearTimeout(timeoutId);
          };
        }
        return void 0;
      }, [onExited, inProp, timeout]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        className: rippleClassName,
        style: rippleStyles,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
          className: childClassName
        })
      });
    }
    const touchRippleClasses = generateUtilityClasses$1("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]);
    const _excluded$14 = ["center", "classes", "className"];
    let _$1 = (t2) => t2, _t$1, _t2$1, _t3$1, _t4$1;
    const DURATION = 550;
    const DELAY_RIPPLE = 80;
    const enterKeyframe = keyframes$1(_t$1 || (_t$1 = _$1`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`));
    const exitKeyframe = keyframes$1(_t2$1 || (_t2$1 = _$1`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`));
    const pulsateKeyframe = keyframes$1(_t3$1 || (_t3$1 = _$1`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`));
    const TouchRippleRoot = styled("span", {
      name: "MuiTouchRipple",
      slot: "Root"
    })({
      overflow: "hidden",
      pointerEvents: "none",
      position: "absolute",
      zIndex: 0,
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      borderRadius: "inherit"
    });
    const TouchRippleRipple = styled(Ripple, {
      name: "MuiTouchRipple",
      slot: "Ripple"
    })(_t4$1 || (_t4$1 = _$1`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`), touchRippleClasses.rippleVisible, enterKeyframe, DURATION, ({
      theme
    }) => theme.transitions.easing.easeInOut, touchRippleClasses.ripplePulsate, ({
      theme
    }) => theme.transitions.duration.shorter, touchRippleClasses.child, touchRippleClasses.childLeaving, exitKeyframe, DURATION, ({
      theme
    }) => theme.transitions.easing.easeInOut, touchRippleClasses.childPulsate, pulsateKeyframe, ({
      theme
    }) => theme.transitions.easing.easeInOut);
    const TouchRipple = /* @__PURE__ */ reactExports.forwardRef(function TouchRipple2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiTouchRipple"
      });
      const {
        center: centerProp = false,
        classes = {},
        className
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$14);
      const [ripples, setRipples] = reactExports.useState([]);
      const nextKey = reactExports.useRef(0);
      const rippleCallback = reactExports.useRef(null);
      reactExports.useEffect(() => {
        if (rippleCallback.current) {
          rippleCallback.current();
          rippleCallback.current = null;
        }
      }, [ripples]);
      const ignoringMouseDown = reactExports.useRef(false);
      const startTimer = useTimeout();
      const startTimerCommit = reactExports.useRef(null);
      const container = reactExports.useRef(null);
      const startCommit = reactExports.useCallback((params) => {
        const {
          pulsate: pulsate2,
          rippleX,
          rippleY,
          rippleSize,
          cb: cb2
        } = params;
        setRipples((oldRipples) => [...oldRipples, /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRipple, {
          classes: {
            ripple: clsx(classes.ripple, touchRippleClasses.ripple),
            rippleVisible: clsx(classes.rippleVisible, touchRippleClasses.rippleVisible),
            ripplePulsate: clsx(classes.ripplePulsate, touchRippleClasses.ripplePulsate),
            child: clsx(classes.child, touchRippleClasses.child),
            childLeaving: clsx(classes.childLeaving, touchRippleClasses.childLeaving),
            childPulsate: clsx(classes.childPulsate, touchRippleClasses.childPulsate)
          },
          timeout: DURATION,
          pulsate: pulsate2,
          rippleX,
          rippleY,
          rippleSize
        }, nextKey.current)]);
        nextKey.current += 1;
        rippleCallback.current = cb2;
      }, [classes]);
      const start2 = reactExports.useCallback((event = {}, options = {}, cb2 = () => {
      }) => {
        const {
          pulsate: pulsate2 = false,
          center = centerProp || options.pulsate,
          fakeElement = false
          // For test purposes
        } = options;
        if ((event == null ? void 0 : event.type) === "mousedown" && ignoringMouseDown.current) {
          ignoringMouseDown.current = false;
          return;
        }
        if ((event == null ? void 0 : event.type) === "touchstart") {
          ignoringMouseDown.current = true;
        }
        const element = fakeElement ? null : container.current;
        const rect = element ? element.getBoundingClientRect() : {
          width: 0,
          height: 0,
          left: 0,
          top: 0
        };
        let rippleX;
        let rippleY;
        let rippleSize;
        if (center || event === void 0 || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
          rippleX = Math.round(rect.width / 2);
          rippleY = Math.round(rect.height / 2);
        } else {
          const {
            clientX,
            clientY
          } = event.touches && event.touches.length > 0 ? event.touches[0] : event;
          rippleX = Math.round(clientX - rect.left);
          rippleY = Math.round(clientY - rect.top);
        }
        if (center) {
          rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3);
          if (rippleSize % 2 === 0) {
            rippleSize += 1;
          }
        } else {
          const sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
          const sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
          rippleSize = Math.sqrt(sizeX ** 2 + sizeY ** 2);
        }
        if (event != null && event.touches) {
          if (startTimerCommit.current === null) {
            startTimerCommit.current = () => {
              startCommit({
                pulsate: pulsate2,
                rippleX,
                rippleY,
                rippleSize,
                cb: cb2
              });
            };
            startTimer.start(DELAY_RIPPLE, () => {
              if (startTimerCommit.current) {
                startTimerCommit.current();
                startTimerCommit.current = null;
              }
            });
          }
        } else {
          startCommit({
            pulsate: pulsate2,
            rippleX,
            rippleY,
            rippleSize,
            cb: cb2
          });
        }
      }, [centerProp, startCommit, startTimer]);
      const pulsate = reactExports.useCallback(() => {
        start2({}, {
          pulsate: true
        });
      }, [start2]);
      const stop = reactExports.useCallback((event, cb2) => {
        startTimer.clear();
        if ((event == null ? void 0 : event.type) === "touchend" && startTimerCommit.current) {
          startTimerCommit.current();
          startTimerCommit.current = null;
          startTimer.start(0, () => {
            stop(event, cb2);
          });
          return;
        }
        startTimerCommit.current = null;
        setRipples((oldRipples) => {
          if (oldRipples.length > 0) {
            return oldRipples.slice(1);
          }
          return oldRipples;
        });
        rippleCallback.current = cb2;
      }, [startTimer]);
      reactExports.useImperativeHandle(ref, () => ({
        pulsate,
        start: start2,
        stop
      }), [pulsate, start2, stop]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRoot, _extends$1({
        className: clsx(touchRippleClasses.root, classes.root, className),
        ref: container
      }, other, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionGroup$1, {
          component: null,
          exit: true,
          children: ripples
        })
      }));
    });
    const TouchRipple$1 = TouchRipple;
    function getButtonBaseUtilityClass(slot) {
      return generateUtilityClass$1("MuiButtonBase", slot);
    }
    const buttonBaseClasses = generateUtilityClasses$1("MuiButtonBase", ["root", "disabled", "focusVisible"]);
    const _excluded$13 = ["action", "centerRipple", "children", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "LinkComponent", "onBlur", "onClick", "onContextMenu", "onDragLeave", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "tabIndex", "TouchRippleProps", "touchRippleRef", "type"];
    const useUtilityClasses$Q = (ownerState) => {
      const {
        disabled,
        focusVisible,
        focusVisibleClassName,
        classes
      } = ownerState;
      const slots = {
        root: ["root", disabled && "disabled", focusVisible && "focusVisible"]
      };
      const composedClasses = composeClasses(slots, getButtonBaseUtilityClass, classes);
      if (focusVisible && focusVisibleClassName) {
        composedClasses.root += ` ${focusVisibleClassName}`;
      }
      return composedClasses;
    };
    const ButtonBaseRoot = styled("button", {
      name: "MuiButtonBase",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })({
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      position: "relative",
      boxSizing: "border-box",
      WebkitTapHighlightColor: "transparent",
      backgroundColor: "transparent",
      // Reset default value
      // We disable the focus ring for mouse, touch and keyboard users.
      outline: 0,
      border: 0,
      margin: 0,
      // Remove the margin in Safari
      borderRadius: 0,
      padding: 0,
      // Remove the padding in Firefox
      cursor: "pointer",
      userSelect: "none",
      verticalAlign: "middle",
      MozAppearance: "none",
      // Reset
      WebkitAppearance: "none",
      // Reset
      textDecoration: "none",
      // So we take precedent over the style of a native <a /> element.
      color: "inherit",
      "&::-moz-focus-inner": {
        borderStyle: "none"
        // Remove Firefox dotted outline.
      },
      [`&.${buttonBaseClasses.disabled}`]: {
        pointerEvents: "none",
        // Disable link interactions
        cursor: "default"
      },
      "@media print": {
        colorAdjust: "exact"
      }
    });
    const ButtonBase = /* @__PURE__ */ reactExports.forwardRef(function ButtonBase2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiButtonBase"
      });
      const {
        action,
        centerRipple = false,
        children,
        className,
        component = "button",
        disabled = false,
        disableRipple = false,
        disableTouchRipple = false,
        focusRipple = false,
        LinkComponent = "a",
        onBlur,
        onClick,
        onContextMenu,
        onDragLeave,
        onFocus,
        onFocusVisible,
        onKeyDown,
        onKeyUp,
        onMouseDown,
        onMouseLeave,
        onMouseUp,
        onTouchEnd,
        onTouchMove,
        onTouchStart,
        tabIndex = 0,
        TouchRippleProps,
        touchRippleRef,
        type
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$13);
      const buttonRef = reactExports.useRef(null);
      const rippleRef = reactExports.useRef(null);
      const handleRippleRef = useForkRef(rippleRef, touchRippleRef);
      const {
        isFocusVisibleRef,
        onFocus: handleFocusVisible,
        onBlur: handleBlurVisible,
        ref: focusVisibleRef
      } = useIsFocusVisible();
      const [focusVisible, setFocusVisible] = reactExports.useState(false);
      if (disabled && focusVisible) {
        setFocusVisible(false);
      }
      reactExports.useImperativeHandle(action, () => ({
        focusVisible: () => {
          setFocusVisible(true);
          buttonRef.current.focus();
        }
      }), []);
      const [mountedState, setMountedState] = reactExports.useState(false);
      reactExports.useEffect(() => {
        setMountedState(true);
      }, []);
      const enableTouchRipple = mountedState && !disableRipple && !disabled;
      reactExports.useEffect(() => {
        if (focusVisible && focusRipple && !disableRipple && mountedState) {
          rippleRef.current.pulsate();
        }
      }, [disableRipple, focusRipple, focusVisible, mountedState]);
      function useRippleHandler(rippleAction, eventCallback, skipRippleAction = disableTouchRipple) {
        return useEventCallback((event) => {
          if (eventCallback) {
            eventCallback(event);
          }
          const ignore = skipRippleAction;
          if (!ignore && rippleRef.current) {
            rippleRef.current[rippleAction](event);
          }
          return true;
        });
      }
      const handleMouseDown = useRippleHandler("start", onMouseDown);
      const handleContextMenu = useRippleHandler("stop", onContextMenu);
      const handleDragLeave = useRippleHandler("stop", onDragLeave);
      const handleMouseUp = useRippleHandler("stop", onMouseUp);
      const handleMouseLeave = useRippleHandler("stop", (event) => {
        if (focusVisible) {
          event.preventDefault();
        }
        if (onMouseLeave) {
          onMouseLeave(event);
        }
      });
      const handleTouchStart = useRippleHandler("start", onTouchStart);
      const handleTouchEnd = useRippleHandler("stop", onTouchEnd);
      const handleTouchMove = useRippleHandler("stop", onTouchMove);
      const handleBlur = useRippleHandler("stop", (event) => {
        handleBlurVisible(event);
        if (isFocusVisibleRef.current === false) {
          setFocusVisible(false);
        }
        if (onBlur) {
          onBlur(event);
        }
      }, false);
      const handleFocus = useEventCallback((event) => {
        if (!buttonRef.current) {
          buttonRef.current = event.currentTarget;
        }
        handleFocusVisible(event);
        if (isFocusVisibleRef.current === true) {
          setFocusVisible(true);
          if (onFocusVisible) {
            onFocusVisible(event);
          }
        }
        if (onFocus) {
          onFocus(event);
        }
      });
      const isNonNativeButton = () => {
        const button = buttonRef.current;
        return component && component !== "button" && !(button.tagName === "A" && button.href);
      };
      const keydownRef = reactExports.useRef(false);
      const handleKeyDown2 = useEventCallback((event) => {
        if (focusRipple && !keydownRef.current && focusVisible && rippleRef.current && event.key === " ") {
          keydownRef.current = true;
          rippleRef.current.stop(event, () => {
            rippleRef.current.start(event);
          });
        }
        if (event.target === event.currentTarget && isNonNativeButton() && event.key === " ") {
          event.preventDefault();
        }
        if (onKeyDown) {
          onKeyDown(event);
        }
        if (event.target === event.currentTarget && isNonNativeButton() && event.key === "Enter" && !disabled) {
          event.preventDefault();
          if (onClick) {
            onClick(event);
          }
        }
      });
      const handleKeyUp = useEventCallback((event) => {
        if (focusRipple && event.key === " " && rippleRef.current && focusVisible && !event.defaultPrevented) {
          keydownRef.current = false;
          rippleRef.current.stop(event, () => {
            rippleRef.current.pulsate(event);
          });
        }
        if (onKeyUp) {
          onKeyUp(event);
        }
        if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === " " && !event.defaultPrevented) {
          onClick(event);
        }
      });
      let ComponentProp = component;
      if (ComponentProp === "button" && (other.href || other.to)) {
        ComponentProp = LinkComponent;
      }
      const buttonProps = {};
      if (ComponentProp === "button") {
        buttonProps.type = type === void 0 ? "button" : type;
        buttonProps.disabled = disabled;
      } else {
        if (!other.href && !other.to) {
          buttonProps.role = "button";
        }
        if (disabled) {
          buttonProps["aria-disabled"] = disabled;
        }
      }
      const handleRef = useForkRef(ref, focusVisibleRef, buttonRef);
      const ownerState = _extends$1({}, props, {
        centerRipple,
        component,
        disabled,
        disableRipple,
        disableTouchRipple,
        focusRipple,
        tabIndex,
        focusVisible
      });
      const classes = useUtilityClasses$Q(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonBaseRoot, _extends$1({
        as: ComponentProp,
        className: clsx(classes.root, className),
        ownerState,
        onBlur: handleBlur,
        onClick,
        onContextMenu: handleContextMenu,
        onFocus: handleFocus,
        onKeyDown: handleKeyDown2,
        onKeyUp: handleKeyUp,
        onMouseDown: handleMouseDown,
        onMouseLeave: handleMouseLeave,
        onMouseUp: handleMouseUp,
        onDragLeave: handleDragLeave,
        onTouchEnd: handleTouchEnd,
        onTouchMove: handleTouchMove,
        onTouchStart: handleTouchStart,
        ref: handleRef,
        tabIndex: disabled ? -1 : tabIndex,
        type
      }, buttonProps, other, {
        children: [children, enableTouchRipple ? (
          /* TouchRipple is only needed client-side, x2 boost on the server. */
          /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRipple$1, _extends$1({
            ref: handleRippleRef,
            center: centerRipple
          }, TouchRippleProps))
        ) : null]
      }));
    });
    const ButtonBase$1 = ButtonBase;
    function getButtonUtilityClass(slot) {
      return generateUtilityClass$1("MuiButton", slot);
    }
    const buttonClasses = generateUtilityClasses$1("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge"]);
    const buttonClasses$1 = buttonClasses;
    const ButtonGroupContext = /* @__PURE__ */ reactExports.createContext({});
    const ButtonGroupContext$1 = ButtonGroupContext;
    const ButtonGroupButtonContext = /* @__PURE__ */ reactExports.createContext(void 0);
    const ButtonGroupButtonContext$1 = ButtonGroupButtonContext;
    const _excluded$12 = ["children", "color", "component", "className", "disabled", "disableElevation", "disableFocusRipple", "endIcon", "focusVisibleClassName", "fullWidth", "size", "startIcon", "type", "variant"];
    const useUtilityClasses$P = (ownerState) => {
      const {
        color: color2,
        disableElevation,
        fullWidth,
        size,
        variant,
        classes
      } = ownerState;
      const slots = {
        root: ["root", variant, `${variant}${capitalize(color2)}`, `size${capitalize(size)}`, `${variant}Size${capitalize(size)}`, color2 === "inherit" && "colorInherit", disableElevation && "disableElevation", fullWidth && "fullWidth"],
        label: ["label"],
        startIcon: ["startIcon", `iconSize${capitalize(size)}`],
        endIcon: ["endIcon", `iconSize${capitalize(size)}`]
      };
      const composedClasses = composeClasses(slots, getButtonUtilityClass, classes);
      return _extends$1({}, classes, composedClasses);
    };
    const commonIconStyles = (ownerState) => _extends$1({}, ownerState.size === "small" && {
      "& > *:nth-of-type(1)": {
        fontSize: 18
      }
    }, ownerState.size === "medium" && {
      "& > *:nth-of-type(1)": {
        fontSize: 20
      }
    }, ownerState.size === "large" && {
      "& > *:nth-of-type(1)": {
        fontSize: 22
      }
    });
    const ButtonRoot = styled(ButtonBase$1, {
      shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
      name: "MuiButton",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, styles2[ownerState.variant], styles2[`${ownerState.variant}${capitalize(ownerState.color)}`], styles2[`size${capitalize(ownerState.size)}`], styles2[`${ownerState.variant}Size${capitalize(ownerState.size)}`], ownerState.color === "inherit" && styles2.colorInherit, ownerState.disableElevation && styles2.disableElevation, ownerState.fullWidth && styles2.fullWidth];
      }
    })(({
      theme,
      ownerState
    }) => {
      var _theme$palette$getCon, _theme$palette;
      const inheritContainedBackgroundColor = theme.palette.mode === "light" ? theme.palette.grey[300] : theme.palette.grey[800];
      const inheritContainedHoverBackgroundColor = theme.palette.mode === "light" ? theme.palette.grey.A100 : theme.palette.grey[700];
      return _extends$1({}, theme.typography.button, {
        minWidth: 64,
        padding: "6px 16px",
        borderRadius: (theme.vars || theme).shape.borderRadius,
        transition: theme.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
          duration: theme.transitions.duration.short
        }),
        "&:hover": _extends$1({
          textDecoration: "none",
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha$1(theme.palette.text.primary, theme.palette.action.hoverOpacity),
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        }, ownerState.variant === "text" && ownerState.color !== "inherit" && {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha$1(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        }, ownerState.variant === "outlined" && ownerState.color !== "inherit" && {
          border: `1px solid ${(theme.vars || theme).palette[ownerState.color].main}`,
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha$1(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        }, ownerState.variant === "contained" && {
          backgroundColor: theme.vars ? theme.vars.palette.Button.inheritContainedHoverBg : inheritContainedHoverBackgroundColor,
          boxShadow: (theme.vars || theme).shadows[4],
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            boxShadow: (theme.vars || theme).shadows[2],
            backgroundColor: (theme.vars || theme).palette.grey[300]
          }
        }, ownerState.variant === "contained" && ownerState.color !== "inherit" && {
          backgroundColor: (theme.vars || theme).palette[ownerState.color].dark,
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            backgroundColor: (theme.vars || theme).palette[ownerState.color].main
          }
        }),
        "&:active": _extends$1({}, ownerState.variant === "contained" && {
          boxShadow: (theme.vars || theme).shadows[8]
        }),
        [`&.${buttonClasses$1.focusVisible}`]: _extends$1({}, ownerState.variant === "contained" && {
          boxShadow: (theme.vars || theme).shadows[6]
        }),
        [`&.${buttonClasses$1.disabled}`]: _extends$1({
          color: (theme.vars || theme).palette.action.disabled
        }, ownerState.variant === "outlined" && {
          border: `1px solid ${(theme.vars || theme).palette.action.disabledBackground}`
        }, ownerState.variant === "contained" && {
          color: (theme.vars || theme).palette.action.disabled,
          boxShadow: (theme.vars || theme).shadows[0],
          backgroundColor: (theme.vars || theme).palette.action.disabledBackground
        })
      }, ownerState.variant === "text" && {
        padding: "6px 8px"
      }, ownerState.variant === "text" && ownerState.color !== "inherit" && {
        color: (theme.vars || theme).palette[ownerState.color].main
      }, ownerState.variant === "outlined" && {
        padding: "5px 15px",
        border: "1px solid currentColor"
      }, ownerState.variant === "outlined" && ownerState.color !== "inherit" && {
        color: (theme.vars || theme).palette[ownerState.color].main,
        border: theme.vars ? `1px solid rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.5)` : `1px solid ${alpha$1(theme.palette[ownerState.color].main, 0.5)}`
      }, ownerState.variant === "contained" && {
        color: theme.vars ? (
          // this is safe because grey does not change between default light/dark mode
          theme.vars.palette.text.primary
        ) : (_theme$palette$getCon = (_theme$palette = theme.palette).getContrastText) == null ? void 0 : _theme$palette$getCon.call(_theme$palette, theme.palette.grey[300]),
        backgroundColor: theme.vars ? theme.vars.palette.Button.inheritContainedBg : inheritContainedBackgroundColor,
        boxShadow: (theme.vars || theme).shadows[2]
      }, ownerState.variant === "contained" && ownerState.color !== "inherit" && {
        color: (theme.vars || theme).palette[ownerState.color].contrastText,
        backgroundColor: (theme.vars || theme).palette[ownerState.color].main
      }, ownerState.color === "inherit" && {
        color: "inherit",
        borderColor: "currentColor"
      }, ownerState.size === "small" && ownerState.variant === "text" && {
        padding: "4px 5px",
        fontSize: theme.typography.pxToRem(13)
      }, ownerState.size === "large" && ownerState.variant === "text" && {
        padding: "8px 11px",
        fontSize: theme.typography.pxToRem(15)
      }, ownerState.size === "small" && ownerState.variant === "outlined" && {
        padding: "3px 9px",
        fontSize: theme.typography.pxToRem(13)
      }, ownerState.size === "large" && ownerState.variant === "outlined" && {
        padding: "7px 21px",
        fontSize: theme.typography.pxToRem(15)
      }, ownerState.size === "small" && ownerState.variant === "contained" && {
        padding: "4px 10px",
        fontSize: theme.typography.pxToRem(13)
      }, ownerState.size === "large" && ownerState.variant === "contained" && {
        padding: "8px 22px",
        fontSize: theme.typography.pxToRem(15)
      }, ownerState.fullWidth && {
        width: "100%"
      });
    }, ({
      ownerState
    }) => ownerState.disableElevation && {
      boxShadow: "none",
      "&:hover": {
        boxShadow: "none"
      },
      [`&.${buttonClasses$1.focusVisible}`]: {
        boxShadow: "none"
      },
      "&:active": {
        boxShadow: "none"
      },
      [`&.${buttonClasses$1.disabled}`]: {
        boxShadow: "none"
      }
    });
    const ButtonStartIcon = styled("span", {
      name: "MuiButton",
      slot: "StartIcon",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.startIcon, styles2[`iconSize${capitalize(ownerState.size)}`]];
      }
    })(({
      ownerState
    }) => _extends$1({
      display: "inherit",
      marginRight: 8,
      marginLeft: -4
    }, ownerState.size === "small" && {
      marginLeft: -2
    }, commonIconStyles(ownerState)));
    const ButtonEndIcon = styled("span", {
      name: "MuiButton",
      slot: "EndIcon",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.endIcon, styles2[`iconSize${capitalize(ownerState.size)}`]];
      }
    })(({
      ownerState
    }) => _extends$1({
      display: "inherit",
      marginRight: -4,
      marginLeft: 8
    }, ownerState.size === "small" && {
      marginRight: -2
    }, commonIconStyles(ownerState)));
    const Button = /* @__PURE__ */ reactExports.forwardRef(function Button2(inProps, ref) {
      const contextProps = reactExports.useContext(ButtonGroupContext$1);
      const buttonGroupButtonContextPositionClassName = reactExports.useContext(ButtonGroupButtonContext$1);
      const resolvedProps = resolveProps(contextProps, inProps);
      const props = useThemeProps({
        props: resolvedProps,
        name: "MuiButton"
      });
      const {
        children,
        color: color2 = "primary",
        component = "button",
        className,
        disabled = false,
        disableElevation = false,
        disableFocusRipple = false,
        endIcon: endIconProp,
        focusVisibleClassName,
        fullWidth = false,
        size = "medium",
        startIcon: startIconProp,
        type,
        variant = "text"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$12);
      const ownerState = _extends$1({}, props, {
        color: color2,
        component,
        disabled,
        disableElevation,
        disableFocusRipple,
        fullWidth,
        size,
        type,
        variant
      });
      const classes = useUtilityClasses$P(ownerState);
      const startIcon = startIconProp && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonStartIcon, {
        className: classes.startIcon,
        ownerState,
        children: startIconProp
      });
      const endIcon = endIconProp && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonEndIcon, {
        className: classes.endIcon,
        ownerState,
        children: endIconProp
      });
      const positionClassName = buttonGroupButtonContextPositionClassName || "";
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonRoot, _extends$1({
        ownerState,
        className: clsx(contextProps.className, classes.root, className, positionClassName),
        component,
        disabled,
        focusRipple: !disableFocusRipple,
        focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
        ref,
        type
      }, other, {
        classes,
        children: [startIcon, children, endIcon]
      }));
    });
    const Button$1 = Button;
    function isHostComponent(element) {
      return typeof element === "string";
    }
    function appendOwnerState(elementType, otherProps, ownerState) {
      if (elementType === void 0 || isHostComponent(elementType)) {
        return otherProps;
      }
      return _extends$1({}, otherProps, {
        ownerState: _extends$1({}, otherProps.ownerState, ownerState)
      });
    }
    const defaultContextValue = {
      disableDefaultClasses: false
    };
    const ClassNameConfiguratorContext = /* @__PURE__ */ reactExports.createContext(defaultContextValue);
    function useClassNamesOverride(generateUtilityClass2) {
      const {
        disableDefaultClasses
      } = reactExports.useContext(ClassNameConfiguratorContext);
      return (slot) => {
        if (disableDefaultClasses) {
          return "";
        }
        return generateUtilityClass2(slot);
      };
    }
    function extractEventHandlers(object2, excludeKeys = []) {
      if (object2 === void 0) {
        return {};
      }
      const result = {};
      Object.keys(object2).filter((prop) => prop.match(/^on[A-Z]/) && typeof object2[prop] === "function" && !excludeKeys.includes(prop)).forEach((prop) => {
        result[prop] = object2[prop];
      });
      return result;
    }
    function resolveComponentProps(componentProps, ownerState, slotState) {
      if (typeof componentProps === "function") {
        return componentProps(ownerState, slotState);
      }
      return componentProps;
    }
    function omitEventHandlers(object2) {
      if (object2 === void 0) {
        return {};
      }
      const result = {};
      Object.keys(object2).filter((prop) => !(prop.match(/^on[A-Z]/) && typeof object2[prop] === "function")).forEach((prop) => {
        result[prop] = object2[prop];
      });
      return result;
    }
    function mergeSlotProps(parameters) {
      const {
        getSlotProps,
        additionalProps,
        externalSlotProps,
        externalForwardedProps,
        className
      } = parameters;
      if (!getSlotProps) {
        const joinedClasses2 = clsx(additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
        const mergedStyle2 = _extends$1({}, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
        const props2 = _extends$1({}, additionalProps, externalForwardedProps, externalSlotProps);
        if (joinedClasses2.length > 0) {
          props2.className = joinedClasses2;
        }
        if (Object.keys(mergedStyle2).length > 0) {
          props2.style = mergedStyle2;
        }
        return {
          props: props2,
          internalRef: void 0
        };
      }
      const eventHandlers = extractEventHandlers(_extends$1({}, externalForwardedProps, externalSlotProps));
      const componentsPropsWithoutEventHandlers = omitEventHandlers(externalSlotProps);
      const otherPropsWithoutEventHandlers = omitEventHandlers(externalForwardedProps);
      const internalSlotProps = getSlotProps(eventHandlers);
      const joinedClasses = clsx(internalSlotProps == null ? void 0 : internalSlotProps.className, additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
      const mergedStyle = _extends$1({}, internalSlotProps == null ? void 0 : internalSlotProps.style, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
      const props = _extends$1({}, internalSlotProps, additionalProps, otherPropsWithoutEventHandlers, componentsPropsWithoutEventHandlers);
      if (joinedClasses.length > 0) {
        props.className = joinedClasses;
      }
      if (Object.keys(mergedStyle).length > 0) {
        props.style = mergedStyle;
      }
      return {
        props,
        internalRef: internalSlotProps.ref
      };
    }
    const _excluded$11 = ["elementType", "externalSlotProps", "ownerState", "skipResolvingSlotProps"];
    function useSlotProps(parameters) {
      var _parameters$additiona;
      const {
        elementType,
        externalSlotProps,
        ownerState,
        skipResolvingSlotProps = false
      } = parameters, rest = _objectWithoutPropertiesLoose$1(parameters, _excluded$11);
      const resolvedComponentsProps = skipResolvingSlotProps ? {} : resolveComponentProps(externalSlotProps, ownerState);
      const {
        props: mergedProps,
        internalRef
      } = mergeSlotProps(_extends$1({}, rest, {
        externalSlotProps: resolvedComponentsProps
      }));
      const ref = useForkRef(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, (_parameters$additiona = parameters.additionalProps) == null ? void 0 : _parameters$additiona.ref);
      const props = appendOwnerState(elementType, _extends$1({}, mergedProps, {
        ref
      }), ownerState);
      return props;
    }
    const GLOBAL_CLASS_PREFIX = "base";
    function buildStateClass(state) {
      return `${GLOBAL_CLASS_PREFIX}--${state}`;
    }
    function buildSlotClass(componentName, slot) {
      return `${GLOBAL_CLASS_PREFIX}-${componentName}-${slot}`;
    }
    function generateUtilityClass(componentName, slot) {
      const globalStateClass = globalStateClasses[slot];
      return globalStateClass ? buildStateClass(globalStateClass) : buildSlotClass(componentName, slot);
    }
    function generateUtilityClasses(componentName, slots) {
      const result = {};
      slots.forEach((slot) => {
        result[slot] = generateUtilityClass(componentName, slot);
      });
      return result;
    }
    function mapEventPropToEvent(eventProp) {
      return eventProp.substring(2).toLowerCase();
    }
    function clickedRootScrollbar$1(event, doc) {
      return doc.documentElement.clientWidth < event.clientX || doc.documentElement.clientHeight < event.clientY;
    }
    function ClickAwayListener(props) {
      const {
        children,
        disableReactTree = false,
        mouseEvent = "onClick",
        onClickAway,
        touchEvent = "onTouchEnd"
      } = props;
      const movedRef = reactExports.useRef(false);
      const nodeRef = reactExports.useRef(null);
      const activatedRef = reactExports.useRef(false);
      const syntheticEventRef = reactExports.useRef(false);
      reactExports.useEffect(() => {
        setTimeout(() => {
          activatedRef.current = true;
        }, 0);
        return () => {
          activatedRef.current = false;
        };
      }, []);
      const handleRef = useForkRef(
        // @ts-expect-error TODO upstream fix
        children.ref,
        nodeRef
      );
      const handleClickAway = useEventCallback((event) => {
        const insideReactTree = syntheticEventRef.current;
        syntheticEventRef.current = false;
        const doc = ownerDocument(nodeRef.current);
        if (!activatedRef.current || !nodeRef.current || "clientX" in event && clickedRootScrollbar$1(event, doc)) {
          return;
        }
        if (movedRef.current) {
          movedRef.current = false;
          return;
        }
        let insideDOM;
        if (event.composedPath) {
          insideDOM = event.composedPath().indexOf(nodeRef.current) > -1;
        } else {
          insideDOM = !doc.documentElement.contains(
            // @ts-expect-error returns `false` as intended when not dispatched from a Node
            event.target
          ) || nodeRef.current.contains(
            // @ts-expect-error returns `false` as intended when not dispatched from a Node
            event.target
          );
        }
        if (!insideDOM && (disableReactTree || !insideReactTree)) {
          onClickAway(event);
        }
      });
      const createHandleSynthetic = (handlerName) => (event) => {
        syntheticEventRef.current = true;
        const childrenPropsHandler = children.props[handlerName];
        if (childrenPropsHandler) {
          childrenPropsHandler(event);
        }
      };
      const childrenProps = {
        ref: handleRef
      };
      if (touchEvent !== false) {
        childrenProps[touchEvent] = createHandleSynthetic(touchEvent);
      }
      reactExports.useEffect(() => {
        if (touchEvent !== false) {
          const mappedTouchEvent = mapEventPropToEvent(touchEvent);
          const doc = ownerDocument(nodeRef.current);
          const handleTouchMove = () => {
            movedRef.current = true;
          };
          doc.addEventListener(mappedTouchEvent, handleClickAway);
          doc.addEventListener("touchmove", handleTouchMove);
          return () => {
            doc.removeEventListener(mappedTouchEvent, handleClickAway);
            doc.removeEventListener("touchmove", handleTouchMove);
          };
        }
        return void 0;
      }, [handleClickAway, touchEvent]);
      if (mouseEvent !== false) {
        childrenProps[mouseEvent] = createHandleSynthetic(mouseEvent);
      }
      reactExports.useEffect(() => {
        if (mouseEvent !== false) {
          const mappedMouseEvent = mapEventPropToEvent(mouseEvent);
          const doc = ownerDocument(nodeRef.current);
          doc.addEventListener(mappedMouseEvent, handleClickAway);
          return () => {
            doc.removeEventListener(mappedMouseEvent, handleClickAway);
          };
        }
        return void 0;
      }, [handleClickAway, mouseEvent]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
        children: /* @__PURE__ */ reactExports.cloneElement(children, childrenProps)
      });
    }
    const candidatesSelector = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
    function getTabIndex(node2) {
      const tabindexAttr = parseInt(node2.getAttribute("tabindex") || "", 10);
      if (!Number.isNaN(tabindexAttr)) {
        return tabindexAttr;
      }
      if (node2.contentEditable === "true" || (node2.nodeName === "AUDIO" || node2.nodeName === "VIDEO" || node2.nodeName === "DETAILS") && node2.getAttribute("tabindex") === null) {
        return 0;
      }
      return node2.tabIndex;
    }
    function isNonTabbableRadio(node2) {
      if (node2.tagName !== "INPUT" || node2.type !== "radio") {
        return false;
      }
      if (!node2.name) {
        return false;
      }
      const getRadio = (selector) => node2.ownerDocument.querySelector(`input[type="radio"]${selector}`);
      let roving = getRadio(`[name="${node2.name}"]:checked`);
      if (!roving) {
        roving = getRadio(`[name="${node2.name}"]`);
      }
      return roving !== node2;
    }
    function isNodeMatchingSelectorFocusable(node2) {
      if (node2.disabled || node2.tagName === "INPUT" && node2.type === "hidden" || isNonTabbableRadio(node2)) {
        return false;
      }
      return true;
    }
    function defaultGetTabbable(root2) {
      const regularTabNodes = [];
      const orderedTabNodes = [];
      Array.from(root2.querySelectorAll(candidatesSelector)).forEach((node2, i) => {
        const nodeTabIndex = getTabIndex(node2);
        if (nodeTabIndex === -1 || !isNodeMatchingSelectorFocusable(node2)) {
          return;
        }
        if (nodeTabIndex === 0) {
          regularTabNodes.push(node2);
        } else {
          orderedTabNodes.push({
            documentOrder: i,
            tabIndex: nodeTabIndex,
            node: node2
          });
        }
      });
      return orderedTabNodes.sort((a, b2) => a.tabIndex === b2.tabIndex ? a.documentOrder - b2.documentOrder : a.tabIndex - b2.tabIndex).map((a) => a.node).concat(regularTabNodes);
    }
    function defaultIsEnabled() {
      return true;
    }
    function FocusTrap(props) {
      const {
        children,
        disableAutoFocus = false,
        disableEnforceFocus = false,
        disableRestoreFocus = false,
        getTabbable = defaultGetTabbable,
        isEnabled = defaultIsEnabled,
        open
      } = props;
      const ignoreNextEnforceFocus = reactExports.useRef(false);
      const sentinelStart = reactExports.useRef(null);
      const sentinelEnd = reactExports.useRef(null);
      const nodeToRestore = reactExports.useRef(null);
      const reactFocusEventTarget = reactExports.useRef(null);
      const activated = reactExports.useRef(false);
      const rootRef = reactExports.useRef(null);
      const handleRef = useForkRef(children.ref, rootRef);
      const lastKeydown = reactExports.useRef(null);
      reactExports.useEffect(() => {
        if (!open || !rootRef.current) {
          return;
        }
        activated.current = !disableAutoFocus;
      }, [disableAutoFocus, open]);
      reactExports.useEffect(() => {
        if (!open || !rootRef.current) {
          return;
        }
        const doc = ownerDocument(rootRef.current);
        if (!rootRef.current.contains(doc.activeElement)) {
          if (!rootRef.current.hasAttribute("tabIndex")) {
            rootRef.current.setAttribute("tabIndex", "-1");
          }
          if (activated.current) {
            rootRef.current.focus();
          }
        }
        return () => {
          if (!disableRestoreFocus) {
            if (nodeToRestore.current && nodeToRestore.current.focus) {
              ignoreNextEnforceFocus.current = true;
              nodeToRestore.current.focus();
            }
            nodeToRestore.current = null;
          }
        };
      }, [open]);
      reactExports.useEffect(() => {
        if (!open || !rootRef.current) {
          return;
        }
        const doc = ownerDocument(rootRef.current);
        const loopFocus = (nativeEvent) => {
          lastKeydown.current = nativeEvent;
          if (disableEnforceFocus || !isEnabled() || nativeEvent.key !== "Tab") {
            return;
          }
          if (doc.activeElement === rootRef.current && nativeEvent.shiftKey) {
            ignoreNextEnforceFocus.current = true;
            if (sentinelEnd.current) {
              sentinelEnd.current.focus();
            }
          }
        };
        const contain = () => {
          const rootElement = rootRef.current;
          if (rootElement === null) {
            return;
          }
          if (!doc.hasFocus() || !isEnabled() || ignoreNextEnforceFocus.current) {
            ignoreNextEnforceFocus.current = false;
            return;
          }
          if (rootElement.contains(doc.activeElement)) {
            return;
          }
          if (disableEnforceFocus && doc.activeElement !== sentinelStart.current && doc.activeElement !== sentinelEnd.current) {
            return;
          }
          if (doc.activeElement !== reactFocusEventTarget.current) {
            reactFocusEventTarget.current = null;
          } else if (reactFocusEventTarget.current !== null) {
            return;
          }
          if (!activated.current) {
            return;
          }
          let tabbable = [];
          if (doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) {
            tabbable = getTabbable(rootRef.current);
          }
          if (tabbable.length > 0) {
            var _lastKeydown$current, _lastKeydown$current2;
            const isShiftTab = Boolean(((_lastKeydown$current = lastKeydown.current) == null ? void 0 : _lastKeydown$current.shiftKey) && ((_lastKeydown$current2 = lastKeydown.current) == null ? void 0 : _lastKeydown$current2.key) === "Tab");
            const focusNext = tabbable[0];
            const focusPrevious = tabbable[tabbable.length - 1];
            if (typeof focusNext !== "string" && typeof focusPrevious !== "string") {
              if (isShiftTab) {
                focusPrevious.focus();
              } else {
                focusNext.focus();
              }
            }
          } else {
            rootElement.focus();
          }
        };
        doc.addEventListener("focusin", contain);
        doc.addEventListener("keydown", loopFocus, true);
        const interval = setInterval(() => {
          if (doc.activeElement && doc.activeElement.tagName === "BODY") {
            contain();
          }
        }, 50);
        return () => {
          clearInterval(interval);
          doc.removeEventListener("focusin", contain);
          doc.removeEventListener("keydown", loopFocus, true);
        };
      }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open, getTabbable]);
      const onFocus = (event) => {
        if (nodeToRestore.current === null) {
          nodeToRestore.current = event.relatedTarget;
        }
        activated.current = true;
        reactFocusEventTarget.current = event.target;
        const childrenPropsHandler = children.props.onFocus;
        if (childrenPropsHandler) {
          childrenPropsHandler(event);
        }
      };
      const handleFocusSentinel = (event) => {
        if (nodeToRestore.current === null) {
          nodeToRestore.current = event.relatedTarget;
        }
        activated.current = true;
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx("div", {
          tabIndex: open ? 0 : -1,
          onFocus: handleFocusSentinel,
          ref: sentinelStart,
          "data-testid": "sentinelStart"
        }), /* @__PURE__ */ reactExports.cloneElement(children, {
          ref: handleRef,
          onFocus
        }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
          tabIndex: open ? 0 : -1,
          onFocus: handleFocusSentinel,
          ref: sentinelEnd,
          "data-testid": "sentinelEnd"
        })]
      });
    }
    var top = "top";
    var bottom = "bottom";
    var right = "right";
    var left = "left";
    var auto$1 = "auto";
    var basePlacements = [top, bottom, right, left];
    var start = "start";
    var end = "end";
    var clippingParents = "clippingParents";
    var viewport = "viewport";
    var popper = "popper";
    var reference = "reference";
    var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
      return acc.concat([placement + "-" + start, placement + "-" + end]);
    }, []);
    var placements = /* @__PURE__ */ [].concat(basePlacements, [auto$1]).reduce(function(acc, placement) {
      return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
    }, []);
    var beforeRead = "beforeRead";
    var read = "read";
    var afterRead = "afterRead";
    var beforeMain = "beforeMain";
    var main = "main";
    var afterMain = "afterMain";
    var beforeWrite = "beforeWrite";
    var write = "write";
    var afterWrite = "afterWrite";
    var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
    function getNodeName(element) {
      return element ? (element.nodeName || "").toLowerCase() : null;
    }
    function getWindow(node2) {
      if (node2 == null) {
        return window;
      }
      if (node2.toString() !== "[object Window]") {
        var ownerDocument2 = node2.ownerDocument;
        return ownerDocument2 ? ownerDocument2.defaultView || window : window;
      }
      return node2;
    }
    function isElement(node2) {
      var OwnElement = getWindow(node2).Element;
      return node2 instanceof OwnElement || node2 instanceof Element;
    }
    function isHTMLElement$1(node2) {
      var OwnElement = getWindow(node2).HTMLElement;
      return node2 instanceof OwnElement || node2 instanceof HTMLElement;
    }
    function isShadowRoot(node2) {
      if (typeof ShadowRoot === "undefined") {
        return false;
      }
      var OwnElement = getWindow(node2).ShadowRoot;
      return node2 instanceof OwnElement || node2 instanceof ShadowRoot;
    }
    function applyStyles(_ref) {
      var state = _ref.state;
      Object.keys(state.elements).forEach(function(name) {
        var style2 = state.styles[name] || {};
        var attributes = state.attributes[name] || {};
        var element = state.elements[name];
        if (!isHTMLElement$1(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style2);
        Object.keys(attributes).forEach(function(name2) {
          var value = attributes[name2];
          if (value === false) {
            element.removeAttribute(name2);
          } else {
            element.setAttribute(name2, value === true ? "" : value);
          }
        });
      });
    }
    function effect$2(_ref2) {
      var state = _ref2.state;
      var initialStyles = {
        popper: {
          position: state.options.strategy,
          left: "0",
          top: "0",
          margin: "0"
        },
        arrow: {
          position: "absolute"
        },
        reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);
      state.styles = initialStyles;
      if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
      }
      return function() {
        Object.keys(state.elements).forEach(function(name) {
          var element = state.elements[name];
          var attributes = state.attributes[name] || {};
          var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
          var style2 = styleProperties.reduce(function(style3, property) {
            style3[property] = "";
            return style3;
          }, {});
          if (!isHTMLElement$1(element) || !getNodeName(element)) {
            return;
          }
          Object.assign(element.style, style2);
          Object.keys(attributes).forEach(function(attribute) {
            element.removeAttribute(attribute);
          });
        });
      };
    }
    const applyStyles$1 = {
      name: "applyStyles",
      enabled: true,
      phase: "write",
      fn: applyStyles,
      effect: effect$2,
      requires: ["computeStyles"]
    };
    function getBasePlacement(placement) {
      return placement.split("-")[0];
    }
    var max = Math.max;
    var min = Math.min;
    var round = Math.round;
    function getUAString() {
      var uaData = navigator.userAgentData;
      if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
        return uaData.brands.map(function(item) {
          return item.brand + "/" + item.version;
        }).join(" ");
      }
      return navigator.userAgent;
    }
    function isLayoutViewport() {
      return !/^((?!chrome|android).)*safari/i.test(getUAString());
    }
    function getBoundingClientRect(element, includeScale, isFixedStrategy) {
      if (includeScale === void 0) {
        includeScale = false;
      }
      if (isFixedStrategy === void 0) {
        isFixedStrategy = false;
      }
      var clientRect = element.getBoundingClientRect();
      var scaleX = 1;
      var scaleY = 1;
      if (includeScale && isHTMLElement$1(element)) {
        scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
        scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
      }
      var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
      var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
      var x2 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
      var y2 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
      var width2 = clientRect.width / scaleX;
      var height2 = clientRect.height / scaleY;
      return {
        width: width2,
        height: height2,
        top: y2,
        right: x2 + width2,
        bottom: y2 + height2,
        left: x2,
        x: x2,
        y: y2
      };
    }
    function getLayoutRect(element) {
      var clientRect = getBoundingClientRect(element);
      var width2 = element.offsetWidth;
      var height2 = element.offsetHeight;
      if (Math.abs(clientRect.width - width2) <= 1) {
        width2 = clientRect.width;
      }
      if (Math.abs(clientRect.height - height2) <= 1) {
        height2 = clientRect.height;
      }
      return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width: width2,
        height: height2
      };
    }
    function contains(parent, child) {
      var rootNode = child.getRootNode && child.getRootNode();
      if (parent.contains(child)) {
        return true;
      } else if (rootNode && isShadowRoot(rootNode)) {
        var next2 = child;
        do {
          if (next2 && parent.isSameNode(next2)) {
            return true;
          }
          next2 = next2.parentNode || next2.host;
        } while (next2);
      }
      return false;
    }
    function getComputedStyle$2(element) {
      return getWindow(element).getComputedStyle(element);
    }
    function isTableElement(element) {
      return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
    }
    function getDocumentElement(element) {
      return ((isElement(element) ? element.ownerDocument : (
        // $FlowFixMe[prop-missing]
        element.document
      )) || window.document).documentElement;
    }
    function getParentNode(element) {
      if (getNodeName(element) === "html") {
        return element;
      }
      return (
        // this is a quicker (but less type safe) way to save quite some bytes from the bundle
        // $FlowFixMe[incompatible-return]
        // $FlowFixMe[prop-missing]
        element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
        element.parentNode || // DOM Element detected
        (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
        // $FlowFixMe[incompatible-call]: HTMLElement is a Node
        getDocumentElement(element)
      );
    }
    function getTrueOffsetParent(element) {
      if (!isHTMLElement$1(element) || // https://github.com/popperjs/popper-core/issues/837
      getComputedStyle$2(element).position === "fixed") {
        return null;
      }
      return element.offsetParent;
    }
    function getContainingBlock(element) {
      var isFirefox = /firefox/i.test(getUAString());
      var isIE = /Trident/i.test(getUAString());
      if (isIE && isHTMLElement$1(element)) {
        var elementCss = getComputedStyle$2(element);
        if (elementCss.position === "fixed") {
          return null;
        }
      }
      var currentNode = getParentNode(element);
      if (isShadowRoot(currentNode)) {
        currentNode = currentNode.host;
      }
      while (isHTMLElement$1(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
        var css2 = getComputedStyle$2(currentNode);
        if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].indexOf(css2.willChange) !== -1 || isFirefox && css2.willChange === "filter" || isFirefox && css2.filter && css2.filter !== "none") {
          return currentNode;
        } else {
          currentNode = currentNode.parentNode;
        }
      }
      return null;
    }
    function getOffsetParent(element) {
      var window2 = getWindow(element);
      var offsetParent = getTrueOffsetParent(element);
      while (offsetParent && isTableElement(offsetParent) && getComputedStyle$2(offsetParent).position === "static") {
        offsetParent = getTrueOffsetParent(offsetParent);
      }
      if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$2(offsetParent).position === "static")) {
        return window2;
      }
      return offsetParent || getContainingBlock(element) || window2;
    }
    function getMainAxisFromPlacement(placement) {
      return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
    }
    function within(min$1, value, max$1) {
      return max(min$1, min(value, max$1));
    }
    function withinMaxClamp(min2, value, max2) {
      var v2 = within(min2, value, max2);
      return v2 > max2 ? max2 : v2;
    }
    function getFreshSideObject() {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    }
    function mergePaddingObject(paddingObject) {
      return Object.assign({}, getFreshSideObject(), paddingObject);
    }
    function expandToHashMap(value, keys2) {
      return keys2.reduce(function(hashMap, key) {
        hashMap[key] = value;
        return hashMap;
      }, {});
    }
    var toPaddingObject = function toPaddingObject2(padding2, state) {
      padding2 = typeof padding2 === "function" ? padding2(Object.assign({}, state.rects, {
        placement: state.placement
      })) : padding2;
      return mergePaddingObject(typeof padding2 !== "number" ? padding2 : expandToHashMap(padding2, basePlacements));
    };
    function arrow(_ref) {
      var _state$modifiersData$;
      var state = _ref.state, name = _ref.name, options = _ref.options;
      var arrowElement = state.elements.arrow;
      var popperOffsets2 = state.modifiersData.popperOffsets;
      var basePlacement = getBasePlacement(state.placement);
      var axis = getMainAxisFromPlacement(basePlacement);
      var isVertical = [left, right].indexOf(basePlacement) >= 0;
      var len = isVertical ? "height" : "width";
      if (!arrowElement || !popperOffsets2) {
        return;
      }
      var paddingObject = toPaddingObject(options.padding, state);
      var arrowRect = getLayoutRect(arrowElement);
      var minProp = axis === "y" ? top : left;
      var maxProp = axis === "y" ? bottom : right;
      var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
      var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
      var arrowOffsetParent = getOffsetParent(arrowElement);
      var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
      var centerToReference = endDiff / 2 - startDiff / 2;
      var min2 = paddingObject[minProp];
      var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
      var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
      var offset2 = within(min2, center, max2);
      var axisProp = axis;
      state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
    }
    function effect$1(_ref2) {
      var state = _ref2.state, options = _ref2.options;
      var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
      if (arrowElement == null) {
        return;
      }
      if (typeof arrowElement === "string") {
        arrowElement = state.elements.popper.querySelector(arrowElement);
        if (!arrowElement) {
          return;
        }
      }
      if (!contains(state.elements.popper, arrowElement)) {
        return;
      }
      state.elements.arrow = arrowElement;
    }
    const arrow$1 = {
      name: "arrow",
      enabled: true,
      phase: "main",
      fn: arrow,
      effect: effect$1,
      requires: ["popperOffsets"],
      requiresIfExists: ["preventOverflow"]
    };
    function getVariation(placement) {
      return placement.split("-")[1];
    }
    var unsetSides = {
      top: "auto",
      right: "auto",
      bottom: "auto",
      left: "auto"
    };
    function roundOffsetsByDPR(_ref, win) {
      var x2 = _ref.x, y2 = _ref.y;
      var dpr = win.devicePixelRatio || 1;
      return {
        x: round(x2 * dpr) / dpr || 0,
        y: round(y2 * dpr) / dpr || 0
      };
    }
    function mapToStyles(_ref2) {
      var _Object$assign2;
      var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position2 = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
      var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y2 = _offsets$y === void 0 ? 0 : _offsets$y;
      var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
        x: x2,
        y: y2
      }) : {
        x: x2,
        y: y2
      };
      x2 = _ref3.x;
      y2 = _ref3.y;
      var hasX = offsets.hasOwnProperty("x");
      var hasY = offsets.hasOwnProperty("y");
      var sideX = left;
      var sideY = top;
      var win = window;
      if (adaptive) {
        var offsetParent = getOffsetParent(popper2);
        var heightProp = "clientHeight";
        var widthProp = "clientWidth";
        if (offsetParent === getWindow(popper2)) {
          offsetParent = getDocumentElement(popper2);
          if (getComputedStyle$2(offsetParent).position !== "static" && position2 === "absolute") {
            heightProp = "scrollHeight";
            widthProp = "scrollWidth";
          }
        }
        offsetParent = offsetParent;
        if (placement === top || (placement === left || placement === right) && variation === end) {
          sideY = bottom;
          var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
            // $FlowFixMe[prop-missing]
            offsetParent[heightProp]
          );
          y2 -= offsetY - popperRect.height;
          y2 *= gpuAcceleration ? 1 : -1;
        }
        if (placement === left || (placement === top || placement === bottom) && variation === end) {
          sideX = right;
          var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
            // $FlowFixMe[prop-missing]
            offsetParent[widthProp]
          );
          x2 -= offsetX - popperRect.width;
          x2 *= gpuAcceleration ? 1 : -1;
        }
      }
      var commonStyles = Object.assign({
        position: position2
      }, adaptive && unsetSides);
      var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
        x: x2,
        y: y2
      }, getWindow(popper2)) : {
        x: x2,
        y: y2
      };
      x2 = _ref4.x;
      y2 = _ref4.y;
      if (gpuAcceleration) {
        var _Object$assign;
        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
      }
      return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
    }
    function computeStyles(_ref5) {
      var state = _ref5.state, options = _ref5.options;
      var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
      var commonStyles = {
        placement: getBasePlacement(state.placement),
        variation: getVariation(state.placement),
        popper: state.elements.popper,
        popperRect: state.rects.popper,
        gpuAcceleration,
        isFixed: state.options.strategy === "fixed"
      };
      if (state.modifiersData.popperOffsets != null) {
        state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.popperOffsets,
          position: state.options.strategy,
          adaptive,
          roundOffsets
        })));
      }
      if (state.modifiersData.arrow != null) {
        state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.arrow,
          position: "absolute",
          adaptive: false,
          roundOffsets
        })));
      }
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        "data-popper-placement": state.placement
      });
    }
    const computeStyles$1 = {
      name: "computeStyles",
      enabled: true,
      phase: "beforeWrite",
      fn: computeStyles,
      data: {}
    };
    var passive = {
      passive: true
    };
    function effect(_ref) {
      var state = _ref.state, instance2 = _ref.instance, options = _ref.options;
      var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
      var window2 = getWindow(state.elements.popper);
      var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.addEventListener("scroll", instance2.update, passive);
        });
      }
      if (resize) {
        window2.addEventListener("resize", instance2.update, passive);
      }
      return function() {
        if (scroll) {
          scrollParents.forEach(function(scrollParent) {
            scrollParent.removeEventListener("scroll", instance2.update, passive);
          });
        }
        if (resize) {
          window2.removeEventListener("resize", instance2.update, passive);
        }
      };
    }
    const eventListeners = {
      name: "eventListeners",
      enabled: true,
      phase: "write",
      fn: function fn() {
      },
      effect,
      data: {}
    };
    var hash$1 = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    };
    function getOppositePlacement(placement) {
      return placement.replace(/left|right|bottom|top/g, function(matched) {
        return hash$1[matched];
      });
    }
    var hash = {
      start: "end",
      end: "start"
    };
    function getOppositeVariationPlacement(placement) {
      return placement.replace(/start|end/g, function(matched) {
        return hash[matched];
      });
    }
    function getWindowScroll(node2) {
      var win = getWindow(node2);
      var scrollLeft = win.pageXOffset;
      var scrollTop = win.pageYOffset;
      return {
        scrollLeft,
        scrollTop
      };
    }
    function getWindowScrollBarX(element) {
      return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
    }
    function getViewportRect(element, strategy) {
      var win = getWindow(element);
      var html = getDocumentElement(element);
      var visualViewport = win.visualViewport;
      var width2 = html.clientWidth;
      var height2 = html.clientHeight;
      var x2 = 0;
      var y2 = 0;
      if (visualViewport) {
        width2 = visualViewport.width;
        height2 = visualViewport.height;
        var layoutViewport = isLayoutViewport();
        if (layoutViewport || !layoutViewport && strategy === "fixed") {
          x2 = visualViewport.offsetLeft;
          y2 = visualViewport.offsetTop;
        }
      }
      return {
        width: width2,
        height: height2,
        x: x2 + getWindowScrollBarX(element),
        y: y2
      };
    }
    function getDocumentRect(element) {
      var _element$ownerDocumen;
      var html = getDocumentElement(element);
      var winScroll = getWindowScroll(element);
      var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
      var width2 = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
      var height2 = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
      var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);
      var y2 = -winScroll.scrollTop;
      if (getComputedStyle$2(body || html).direction === "rtl") {
        x2 += max(html.clientWidth, body ? body.clientWidth : 0) - width2;
      }
      return {
        width: width2,
        height: height2,
        x: x2,
        y: y2
      };
    }
    function isScrollParent(element) {
      var _getComputedStyle = getComputedStyle$2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
      return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
    }
    function getScrollParent(node2) {
      if (["html", "body", "#document"].indexOf(getNodeName(node2)) >= 0) {
        return node2.ownerDocument.body;
      }
      if (isHTMLElement$1(node2) && isScrollParent(node2)) {
        return node2;
      }
      return getScrollParent(getParentNode(node2));
    }
    function listScrollParents(element, list) {
      var _element$ownerDocumen;
      if (list === void 0) {
        list = [];
      }
      var scrollParent = getScrollParent(element);
      var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
      var win = getWindow(scrollParent);
      var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
      var updatedList = list.concat(target);
      return isBody ? updatedList : (
        // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
        updatedList.concat(listScrollParents(getParentNode(target)))
      );
    }
    function rectToClientRect(rect) {
      return Object.assign({}, rect, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
      });
    }
    function getInnerBoundingClientRect(element, strategy) {
      var rect = getBoundingClientRect(element, false, strategy === "fixed");
      rect.top = rect.top + element.clientTop;
      rect.left = rect.left + element.clientLeft;
      rect.bottom = rect.top + element.clientHeight;
      rect.right = rect.left + element.clientWidth;
      rect.width = element.clientWidth;
      rect.height = element.clientHeight;
      rect.x = rect.left;
      rect.y = rect.top;
      return rect;
    }
    function getClientRectFromMixedType(element, clippingParent, strategy) {
      return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
    }
    function getClippingParents(element) {
      var clippingParents2 = listScrollParents(getParentNode(element));
      var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$2(element).position) >= 0;
      var clipperElement = canEscapeClipping && isHTMLElement$1(element) ? getOffsetParent(element) : element;
      if (!isElement(clipperElement)) {
        return [];
      }
      return clippingParents2.filter(function(clippingParent) {
        return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
      });
    }
    function getClippingRect(element, boundary, rootBoundary, strategy) {
      var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
      var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
      var firstClippingParent = clippingParents2[0];
      var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
        var rect = getClientRectFromMixedType(element, clippingParent, strategy);
        accRect.top = max(rect.top, accRect.top);
        accRect.right = min(rect.right, accRect.right);
        accRect.bottom = min(rect.bottom, accRect.bottom);
        accRect.left = max(rect.left, accRect.left);
        return accRect;
      }, getClientRectFromMixedType(element, firstClippingParent, strategy));
      clippingRect.width = clippingRect.right - clippingRect.left;
      clippingRect.height = clippingRect.bottom - clippingRect.top;
      clippingRect.x = clippingRect.left;
      clippingRect.y = clippingRect.top;
      return clippingRect;
    }
    function computeOffsets(_ref) {
      var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
      var basePlacement = placement ? getBasePlacement(placement) : null;
      var variation = placement ? getVariation(placement) : null;
      var commonX = reference2.x + reference2.width / 2 - element.width / 2;
      var commonY = reference2.y + reference2.height / 2 - element.height / 2;
      var offsets;
      switch (basePlacement) {
        case top:
          offsets = {
            x: commonX,
            y: reference2.y - element.height
          };
          break;
        case bottom:
          offsets = {
            x: commonX,
            y: reference2.y + reference2.height
          };
          break;
        case right:
          offsets = {
            x: reference2.x + reference2.width,
            y: commonY
          };
          break;
        case left:
          offsets = {
            x: reference2.x - element.width,
            y: commonY
          };
          break;
        default:
          offsets = {
            x: reference2.x,
            y: reference2.y
          };
      }
      var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
      if (mainAxis != null) {
        var len = mainAxis === "y" ? "height" : "width";
        switch (variation) {
          case start:
            offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
            break;
          case end:
            offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
            break;
        }
      }
      return offsets;
    }
    function detectOverflow(state, options) {
      if (options === void 0) {
        options = {};
      }
      var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding2 = _options$padding === void 0 ? 0 : _options$padding;
      var paddingObject = mergePaddingObject(typeof padding2 !== "number" ? padding2 : expandToHashMap(padding2, basePlacements));
      var altContext = elementContext === popper ? reference : popper;
      var popperRect = state.rects.popper;
      var element = state.elements[altBoundary ? altContext : elementContext];
      var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
      var referenceClientRect = getBoundingClientRect(state.elements.reference);
      var popperOffsets2 = computeOffsets({
        reference: referenceClientRect,
        element: popperRect,
        strategy: "absolute",
        placement
      });
      var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
      var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
      var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
      };
      var offsetData = state.modifiersData.offset;
      if (elementContext === popper && offsetData) {
        var offset2 = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function(key) {
          var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
          var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
          overflowOffsets[key] += offset2[axis] * multiply;
        });
      }
      return overflowOffsets;
    }
    function computeAutoPlacement(state, options) {
      if (options === void 0) {
        options = {};
      }
      var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding2 = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
      var variation = getVariation(placement);
      var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
        return getVariation(placement2) === variation;
      }) : basePlacements;
      var allowedPlacements = placements$1.filter(function(placement2) {
        return allowedAutoPlacements.indexOf(placement2) >= 0;
      });
      if (allowedPlacements.length === 0) {
        allowedPlacements = placements$1;
      }
      var overflows = allowedPlacements.reduce(function(acc, placement2) {
        acc[placement2] = detectOverflow(state, {
          placement: placement2,
          boundary,
          rootBoundary,
          padding: padding2
        })[getBasePlacement(placement2)];
        return acc;
      }, {});
      return Object.keys(overflows).sort(function(a, b2) {
        return overflows[a] - overflows[b2];
      });
    }
    function getExpandedFallbackPlacements(placement) {
      if (getBasePlacement(placement) === auto$1) {
        return [];
      }
      var oppositePlacement = getOppositePlacement(placement);
      return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
    }
    function flip(_ref) {
      var state = _ref.state, options = _ref.options, name = _ref.name;
      if (state.modifiersData[name]._skip) {
        return;
      }
      var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding2 = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
      var preferredPlacement = state.options.placement;
      var basePlacement = getBasePlacement(preferredPlacement);
      var isBasePlacement = basePlacement === preferredPlacement;
      var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
      var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
        return acc.concat(getBasePlacement(placement2) === auto$1 ? computeAutoPlacement(state, {
          placement: placement2,
          boundary,
          rootBoundary,
          padding: padding2,
          flipVariations,
          allowedAutoPlacements
        }) : placement2);
      }, []);
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var checksMap = /* @__PURE__ */ new Map();
      var makeFallbackChecks = true;
      var firstFittingPlacement = placements2[0];
      for (var i = 0; i < placements2.length; i++) {
        var placement = placements2[i];
        var _basePlacement = getBasePlacement(placement);
        var isStartVariation = getVariation(placement) === start;
        var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
        var len = isVertical ? "width" : "height";
        var overflow = detectOverflow(state, {
          placement,
          boundary,
          rootBoundary,
          altBoundary,
          padding: padding2
        });
        var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
        if (referenceRect[len] > popperRect[len]) {
          mainVariationSide = getOppositePlacement(mainVariationSide);
        }
        var altVariationSide = getOppositePlacement(mainVariationSide);
        var checks = [];
        if (checkMainAxis) {
          checks.push(overflow[_basePlacement] <= 0);
        }
        if (checkAltAxis) {
          checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
        }
        if (checks.every(function(check) {
          return check;
        })) {
          firstFittingPlacement = placement;
          makeFallbackChecks = false;
          break;
        }
        checksMap.set(placement, checks);
      }
      if (makeFallbackChecks) {
        var numberOfChecks = flipVariations ? 3 : 1;
        var _loop = function _loop2(_i2) {
          var fittingPlacement = placements2.find(function(placement2) {
            var checks2 = checksMap.get(placement2);
            if (checks2) {
              return checks2.slice(0, _i2).every(function(check) {
                return check;
              });
            }
          });
          if (fittingPlacement) {
            firstFittingPlacement = fittingPlacement;
            return "break";
          }
        };
        for (var _i = numberOfChecks; _i > 0; _i--) {
          var _ret = _loop(_i);
          if (_ret === "break")
            break;
        }
      }
      if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
      }
    }
    const flip$1 = {
      name: "flip",
      enabled: true,
      phase: "main",
      fn: flip,
      requiresIfExists: ["offset"],
      data: {
        _skip: false
      }
    };
    function getSideOffsets(overflow, rect, preventedOffsets) {
      if (preventedOffsets === void 0) {
        preventedOffsets = {
          x: 0,
          y: 0
        };
      }
      return {
        top: overflow.top - rect.height - preventedOffsets.y,
        right: overflow.right - rect.width + preventedOffsets.x,
        bottom: overflow.bottom - rect.height + preventedOffsets.y,
        left: overflow.left - rect.width - preventedOffsets.x
      };
    }
    function isAnySideFullyClipped(overflow) {
      return [top, right, bottom, left].some(function(side) {
        return overflow[side] >= 0;
      });
    }
    function hide(_ref) {
      var state = _ref.state, name = _ref.name;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var preventedOffsets = state.modifiersData.preventOverflow;
      var referenceOverflow = detectOverflow(state, {
        elementContext: "reference"
      });
      var popperAltOverflow = detectOverflow(state, {
        altBoundary: true
      });
      var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
      var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
      var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
      var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
      state.modifiersData[name] = {
        referenceClippingOffsets,
        popperEscapeOffsets,
        isReferenceHidden,
        hasPopperEscaped
      };
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        "data-popper-reference-hidden": isReferenceHidden,
        "data-popper-escaped": hasPopperEscaped
      });
    }
    const hide$1 = {
      name: "hide",
      enabled: true,
      phase: "main",
      requiresIfExists: ["preventOverflow"],
      fn: hide
    };
    function distanceAndSkiddingToXY(placement, rects, offset2) {
      var basePlacement = getBasePlacement(placement);
      var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
      var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
        placement
      })) : offset2, skidding = _ref[0], distance2 = _ref[1];
      skidding = skidding || 0;
      distance2 = (distance2 || 0) * invertDistance;
      return [left, right].indexOf(basePlacement) >= 0 ? {
        x: distance2,
        y: skidding
      } : {
        x: skidding,
        y: distance2
      };
    }
    function offset(_ref2) {
      var state = _ref2.state, options = _ref2.options, name = _ref2.name;
      var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
      var data = placements.reduce(function(acc, placement) {
        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
        return acc;
      }, {});
      var _data$state$placement = data[state.placement], x2 = _data$state$placement.x, y2 = _data$state$placement.y;
      if (state.modifiersData.popperOffsets != null) {
        state.modifiersData.popperOffsets.x += x2;
        state.modifiersData.popperOffsets.y += y2;
      }
      state.modifiersData[name] = data;
    }
    const offset$1 = {
      name: "offset",
      enabled: true,
      phase: "main",
      requires: ["popperOffsets"],
      fn: offset
    };
    function popperOffsets(_ref) {
      var state = _ref.state, name = _ref.name;
      state.modifiersData[name] = computeOffsets({
        reference: state.rects.reference,
        element: state.rects.popper,
        strategy: "absolute",
        placement: state.placement
      });
    }
    const popperOffsets$1 = {
      name: "popperOffsets",
      enabled: true,
      phase: "read",
      fn: popperOffsets,
      data: {}
    };
    function getAltAxis(axis) {
      return axis === "x" ? "y" : "x";
    }
    function preventOverflow(_ref) {
      var state = _ref.state, options = _ref.options, name = _ref.name;
      var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding2 = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
      var overflow = detectOverflow(state, {
        boundary,
        rootBoundary,
        padding: padding2,
        altBoundary
      });
      var basePlacement = getBasePlacement(state.placement);
      var variation = getVariation(state.placement);
      var isBasePlacement = !variation;
      var mainAxis = getMainAxisFromPlacement(basePlacement);
      var altAxis = getAltAxis(mainAxis);
      var popperOffsets2 = state.modifiersData.popperOffsets;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
        placement: state.placement
      })) : tetherOffset;
      var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
        mainAxis: tetherOffsetValue,
        altAxis: tetherOffsetValue
      } : Object.assign({
        mainAxis: 0,
        altAxis: 0
      }, tetherOffsetValue);
      var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
      var data = {
        x: 0,
        y: 0
      };
      if (!popperOffsets2) {
        return;
      }
      if (checkMainAxis) {
        var _offsetModifierState$;
        var mainSide = mainAxis === "y" ? top : left;
        var altSide = mainAxis === "y" ? bottom : right;
        var len = mainAxis === "y" ? "height" : "width";
        var offset2 = popperOffsets2[mainAxis];
        var min$1 = offset2 + overflow[mainSide];
        var max$1 = offset2 - overflow[altSide];
        var additive = tether ? -popperRect[len] / 2 : 0;
        var minLen = variation === start ? referenceRect[len] : popperRect[len];
        var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
        var arrowElement = state.elements.arrow;
        var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
          width: 0,
          height: 0
        };
        var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide];
        var arrowLen = within(0, referenceRect[len], arrowRect[len]);
        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
        var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
        var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
        var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
        var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = offset2 + maxOffset - offsetModifierValue;
        var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset2, tether ? max(max$1, tetherMax) : max$1);
        popperOffsets2[mainAxis] = preventedOffset;
        data[mainAxis] = preventedOffset - offset2;
      }
      if (checkAltAxis) {
        var _offsetModifierState$2;
        var _mainSide = mainAxis === "x" ? top : left;
        var _altSide = mainAxis === "x" ? bottom : right;
        var _offset = popperOffsets2[altAxis];
        var _len = altAxis === "y" ? "height" : "width";
        var _min = _offset + overflow[_mainSide];
        var _max = _offset - overflow[_altSide];
        var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
        var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
        var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
        var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
        var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
        popperOffsets2[altAxis] = _preventedOffset;
        data[altAxis] = _preventedOffset - _offset;
      }
      state.modifiersData[name] = data;
    }
    const preventOverflow$1 = {
      name: "preventOverflow",
      enabled: true,
      phase: "main",
      fn: preventOverflow,
      requiresIfExists: ["offset"]
    };
    function getHTMLElementScroll(element) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }
    function getNodeScroll(node2) {
      if (node2 === getWindow(node2) || !isHTMLElement$1(node2)) {
        return getWindowScroll(node2);
      } else {
        return getHTMLElementScroll(node2);
      }
    }
    function isElementScaled(element) {
      var rect = element.getBoundingClientRect();
      var scaleX = round(rect.width) / element.offsetWidth || 1;
      var scaleY = round(rect.height) / element.offsetHeight || 1;
      return scaleX !== 1 || scaleY !== 1;
    }
    function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
      if (isFixed === void 0) {
        isFixed = false;
      }
      var isOffsetParentAnElement = isHTMLElement$1(offsetParent);
      var offsetParentIsScaled = isHTMLElement$1(offsetParent) && isElementScaled(offsetParent);
      var documentElement = getDocumentElement(offsetParent);
      var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
      var scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      var offsets = {
        x: 0,
        y: 0
      };
      if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
        isScrollParent(documentElement)) {
          scroll = getNodeScroll(offsetParent);
        }
        if (isHTMLElement$1(offsetParent)) {
          offsets = getBoundingClientRect(offsetParent, true);
          offsets.x += offsetParent.clientLeft;
          offsets.y += offsetParent.clientTop;
        } else if (documentElement) {
          offsets.x = getWindowScrollBarX(documentElement);
        }
      }
      return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
      };
    }
    function order(modifiers) {
      var map = /* @__PURE__ */ new Map();
      var visited = /* @__PURE__ */ new Set();
      var result = [];
      modifiers.forEach(function(modifier) {
        map.set(modifier.name, modifier);
      });
      function sort(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function(dep) {
          if (!visited.has(dep)) {
            var depModifier = map.get(dep);
            if (depModifier) {
              sort(depModifier);
            }
          }
        });
        result.push(modifier);
      }
      modifiers.forEach(function(modifier) {
        if (!visited.has(modifier.name)) {
          sort(modifier);
        }
      });
      return result;
    }
    function orderModifiers(modifiers) {
      var orderedModifiers = order(modifiers);
      return modifierPhases.reduce(function(acc, phase) {
        return acc.concat(orderedModifiers.filter(function(modifier) {
          return modifier.phase === phase;
        }));
      }, []);
    }
    function debounce(fn) {
      var pending;
      return function() {
        if (!pending) {
          pending = new Promise(function(resolve) {
            Promise.resolve().then(function() {
              pending = void 0;
              resolve(fn());
            });
          });
        }
        return pending;
      };
    }
    function mergeByName(modifiers) {
      var merged = modifiers.reduce(function(merged2, current) {
        var existing = merged2[current.name];
        merged2[current.name] = existing ? Object.assign({}, existing, current, {
          options: Object.assign({}, existing.options, current.options),
          data: Object.assign({}, existing.data, current.data)
        }) : current;
        return merged2;
      }, {});
      return Object.keys(merged).map(function(key) {
        return merged[key];
      });
    }
    var DEFAULT_OPTIONS = {
      placement: "bottom",
      modifiers: [],
      strategy: "absolute"
    };
    function areValidElements() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return !args.some(function(element) {
        return !(element && typeof element.getBoundingClientRect === "function");
      });
    }
    function popperGenerator(generatorOptions) {
      if (generatorOptions === void 0) {
        generatorOptions = {};
      }
      var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
      return function createPopper2(reference2, popper2, options) {
        if (options === void 0) {
          options = defaultOptions;
        }
        var state = {
          placement: "bottom",
          orderedModifiers: [],
          options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
          modifiersData: {},
          elements: {
            reference: reference2,
            popper: popper2
          },
          attributes: {},
          styles: {}
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance2 = {
          state,
          setOptions: function setOptions(setOptionsAction) {
            var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
            cleanupModifierEffects();
            state.options = Object.assign({}, defaultOptions, state.options, options2);
            state.scrollParents = {
              reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
              popper: listScrollParents(popper2)
            };
            var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
            state.orderedModifiers = orderedModifiers.filter(function(m2) {
              return m2.enabled;
            });
            runModifierEffects();
            return instance2.update();
          },
          // Sync update – it will always be executed, even if not necessary. This
          // is useful for low frequency updates where sync behavior simplifies the
          // logic.
          // For high frequency updates (e.g. `resize` and `scroll` events), always
          // prefer the async Popper#update method
          forceUpdate: function forceUpdate() {
            if (isDestroyed) {
              return;
            }
            var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
            if (!areValidElements(reference3, popper3)) {
              return;
            }
            state.rects = {
              reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
              popper: getLayoutRect(popper3)
            };
            state.reset = false;
            state.placement = state.options.placement;
            state.orderedModifiers.forEach(function(modifier) {
              return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
            });
            for (var index = 0; index < state.orderedModifiers.length; index++) {
              if (state.reset === true) {
                state.reset = false;
                index = -1;
                continue;
              }
              var _state$orderedModifie = state.orderedModifiers[index], fn = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
              if (typeof fn === "function") {
                state = fn({
                  state,
                  options: _options,
                  name,
                  instance: instance2
                }) || state;
              }
            }
          },
          // Async and optimistically optimized update – it will not be executed if
          // not necessary (debounced to run at most once-per-tick)
          update: debounce(function() {
            return new Promise(function(resolve) {
              instance2.forceUpdate();
              resolve(state);
            });
          }),
          destroy: function destroy() {
            cleanupModifierEffects();
            isDestroyed = true;
          }
        };
        if (!areValidElements(reference2, popper2)) {
          return instance2;
        }
        instance2.setOptions(options).then(function(state2) {
          if (!isDestroyed && options.onFirstUpdate) {
            options.onFirstUpdate(state2);
          }
        });
        function runModifierEffects() {
          state.orderedModifiers.forEach(function(_ref) {
            var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect2 = _ref.effect;
            if (typeof effect2 === "function") {
              var cleanupFn = effect2({
                state,
                name,
                instance: instance2,
                options: options2
              });
              var noopFn = function noopFn2() {
              };
              effectCleanupFns.push(cleanupFn || noopFn);
            }
          });
        }
        function cleanupModifierEffects() {
          effectCleanupFns.forEach(function(fn) {
            return fn();
          });
          effectCleanupFns = [];
        }
        return instance2;
      };
    }
    var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
    var createPopper = /* @__PURE__ */ popperGenerator({
      defaultModifiers
    });
    function getContainer$1(container) {
      return typeof container === "function" ? container() : container;
    }
    const Portal = /* @__PURE__ */ reactExports.forwardRef(function Portal2(props, forwardedRef) {
      const {
        children,
        container,
        disablePortal = false
      } = props;
      const [mountNode, setMountNode] = reactExports.useState(null);
      const handleRef = useForkRef(/* @__PURE__ */ reactExports.isValidElement(children) ? children.ref : null, forwardedRef);
      useEnhancedEffect(() => {
        if (!disablePortal) {
          setMountNode(getContainer$1(container) || document.body);
        }
      }, [container, disablePortal]);
      useEnhancedEffect(() => {
        if (mountNode && !disablePortal) {
          setRef(forwardedRef, mountNode);
          return () => {
            setRef(forwardedRef, null);
          };
        }
        return void 0;
      }, [forwardedRef, mountNode, disablePortal]);
      if (disablePortal) {
        if (/* @__PURE__ */ reactExports.isValidElement(children)) {
          const newProps = {
            ref: handleRef
          };
          return /* @__PURE__ */ reactExports.cloneElement(children, newProps);
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
          children
        });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
        children: mountNode ? /* @__PURE__ */ reactDomExports.createPortal(children, mountNode) : mountNode
      });
    });
    const COMPONENT_NAME = "Popper";
    function getPopperUtilityClass(slot) {
      return generateUtilityClass(COMPONENT_NAME, slot);
    }
    generateUtilityClasses(COMPONENT_NAME, ["root"]);
    const _excluded$10 = ["anchorEl", "children", "direction", "disablePortal", "modifiers", "open", "placement", "popperOptions", "popperRef", "slotProps", "slots", "TransitionProps", "ownerState"], _excluded2$9 = ["anchorEl", "children", "container", "direction", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "style", "transition", "slotProps", "slots"];
    function flipPlacement(placement, direction) {
      if (direction === "ltr") {
        return placement;
      }
      switch (placement) {
        case "bottom-end":
          return "bottom-start";
        case "bottom-start":
          return "bottom-end";
        case "top-end":
          return "top-start";
        case "top-start":
          return "top-end";
        default:
          return placement;
      }
    }
    function resolveAnchorEl$1(anchorEl) {
      return typeof anchorEl === "function" ? anchorEl() : anchorEl;
    }
    function isHTMLElement(element) {
      return element.nodeType !== void 0;
    }
    const useUtilityClasses$O = () => {
      const slots = {
        root: ["root"]
      };
      return composeClasses(slots, useClassNamesOverride(getPopperUtilityClass));
    };
    const defaultPopperOptions = {};
    const PopperTooltip = /* @__PURE__ */ reactExports.forwardRef(function PopperTooltip2(props, forwardedRef) {
      var _slots$root;
      const {
        anchorEl,
        children,
        direction,
        disablePortal,
        modifiers,
        open,
        placement: initialPlacement,
        popperOptions,
        popperRef: popperRefProp,
        slotProps = {},
        slots = {},
        TransitionProps
        // @ts-ignore internal logic
        // prevent from spreading to DOM, it can come from the parent component e.g. Select.
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$10);
      const tooltipRef = reactExports.useRef(null);
      const ownRef = useForkRef(tooltipRef, forwardedRef);
      const popperRef = reactExports.useRef(null);
      const handlePopperRef = useForkRef(popperRef, popperRefProp);
      const handlePopperRefRef = reactExports.useRef(handlePopperRef);
      useEnhancedEffect(() => {
        handlePopperRefRef.current = handlePopperRef;
      }, [handlePopperRef]);
      reactExports.useImperativeHandle(popperRefProp, () => popperRef.current, []);
      const rtlPlacement = flipPlacement(initialPlacement, direction);
      const [placement, setPlacement] = reactExports.useState(rtlPlacement);
      const [resolvedAnchorElement, setResolvedAnchorElement] = reactExports.useState(resolveAnchorEl$1(anchorEl));
      reactExports.useEffect(() => {
        if (popperRef.current) {
          popperRef.current.forceUpdate();
        }
      });
      reactExports.useEffect(() => {
        if (anchorEl) {
          setResolvedAnchorElement(resolveAnchorEl$1(anchorEl));
        }
      }, [anchorEl]);
      useEnhancedEffect(() => {
        if (!resolvedAnchorElement || !open) {
          return void 0;
        }
        const handlePopperUpdate = (data) => {
          setPlacement(data.placement);
        };
        let popperModifiers = [{
          name: "preventOverflow",
          options: {
            altBoundary: disablePortal
          }
        }, {
          name: "flip",
          options: {
            altBoundary: disablePortal
          }
        }, {
          name: "onUpdate",
          enabled: true,
          phase: "afterWrite",
          fn: ({
            state
          }) => {
            handlePopperUpdate(state);
          }
        }];
        if (modifiers != null) {
          popperModifiers = popperModifiers.concat(modifiers);
        }
        if (popperOptions && popperOptions.modifiers != null) {
          popperModifiers = popperModifiers.concat(popperOptions.modifiers);
        }
        const popper2 = createPopper(resolvedAnchorElement, tooltipRef.current, _extends$1({
          placement: rtlPlacement
        }, popperOptions, {
          modifiers: popperModifiers
        }));
        handlePopperRefRef.current(popper2);
        return () => {
          popper2.destroy();
          handlePopperRefRef.current(null);
        };
      }, [resolvedAnchorElement, disablePortal, modifiers, open, popperOptions, rtlPlacement]);
      const childProps = {
        placement
      };
      if (TransitionProps !== null) {
        childProps.TransitionProps = TransitionProps;
      }
      const classes = useUtilityClasses$O();
      const Root = (_slots$root = slots.root) != null ? _slots$root : "div";
      const rootProps = useSlotProps({
        elementType: Root,
        externalSlotProps: slotProps.root,
        externalForwardedProps: other,
        additionalProps: {
          role: "tooltip",
          ref: ownRef
        },
        ownerState: props,
        className: classes.root
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Root, _extends$1({}, rootProps, {
        children: typeof children === "function" ? children(childProps) : children
      }));
    });
    const Popper$2 = /* @__PURE__ */ reactExports.forwardRef(function Popper2(props, forwardedRef) {
      const {
        anchorEl,
        children,
        container: containerProp,
        direction = "ltr",
        disablePortal = false,
        keepMounted = false,
        modifiers,
        open,
        placement = "bottom",
        popperOptions = defaultPopperOptions,
        popperRef,
        style: style2,
        transition = false,
        slotProps = {},
        slots = {}
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded2$9);
      const [exited, setExited] = reactExports.useState(true);
      const handleEnter = () => {
        setExited(false);
      };
      const handleExited = () => {
        setExited(true);
      };
      if (!keepMounted && !open && (!transition || exited)) {
        return null;
      }
      let container;
      if (containerProp) {
        container = containerProp;
      } else if (anchorEl) {
        const resolvedAnchorEl = resolveAnchorEl$1(anchorEl);
        container = resolvedAnchorEl && isHTMLElement(resolvedAnchorEl) ? ownerDocument(resolvedAnchorEl).body : ownerDocument(null).body;
      }
      const display = !open && keepMounted && (!transition || exited) ? "none" : void 0;
      const transitionProps = transition ? {
        in: open,
        onEnter: handleEnter,
        onExited: handleExited
      } : void 0;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, {
        disablePortal,
        container,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopperTooltip, _extends$1({
          anchorEl,
          direction,
          disablePortal,
          modifiers,
          ref: forwardedRef,
          open: transition ? !exited : open,
          placement,
          popperOptions,
          popperRef,
          slotProps,
          slots
        }, other, {
          style: _extends$1({
            // Prevents scroll issue, waiting for Popper.js to add this style once initiated.
            position: "fixed",
            // Fix Popper.js display issue
            top: 0,
            left: 0,
            display
          }, style2),
          TransitionProps: transitionProps,
          children
        }))
      });
    });
    function isOverflowing(container) {
      const doc = ownerDocument(container);
      if (doc.body === container) {
        return ownerWindow(container).innerWidth > doc.documentElement.clientWidth;
      }
      return container.scrollHeight > container.clientHeight;
    }
    function ariaHidden(element, show) {
      if (show) {
        element.setAttribute("aria-hidden", "true");
      } else {
        element.removeAttribute("aria-hidden");
      }
    }
    function getPaddingRight(element) {
      return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;
    }
    function isAriaHiddenForbiddenOnElement(element) {
      const forbiddenTagNames = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"];
      const isForbiddenTagName = forbiddenTagNames.indexOf(element.tagName) !== -1;
      const isInputHidden = element.tagName === "INPUT" && element.getAttribute("type") === "hidden";
      return isForbiddenTagName || isInputHidden;
    }
    function ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude, show) {
      const blacklist = [mountElement, currentElement, ...elementsToExclude];
      [].forEach.call(container.children, (element) => {
        const isNotExcludedElement = blacklist.indexOf(element) === -1;
        const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);
        if (isNotExcludedElement && isNotForbiddenElement) {
          ariaHidden(element, show);
        }
      });
    }
    function findIndexOf(items, callback) {
      let idx = -1;
      items.some((item, index) => {
        if (callback(item)) {
          idx = index;
          return true;
        }
        return false;
      });
      return idx;
    }
    function handleContainer(containerInfo, props) {
      const restoreStyle = [];
      const container = containerInfo.container;
      if (!props.disableScrollLock) {
        if (isOverflowing(container)) {
          const scrollbarSize = getScrollbarSize(ownerDocument(container));
          restoreStyle.push({
            value: container.style.paddingRight,
            property: "padding-right",
            el: container
          });
          container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`;
          const fixedElements2 = ownerDocument(container).querySelectorAll(".mui-fixed");
          [].forEach.call(fixedElements2, (element) => {
            restoreStyle.push({
              value: element.style.paddingRight,
              property: "padding-right",
              el: element
            });
            element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;
          });
        }
        let scrollContainer;
        if (container.parentNode instanceof DocumentFragment) {
          scrollContainer = ownerDocument(container).body;
        } else {
          const parent = container.parentElement;
          const containerWindow = ownerWindow(container);
          scrollContainer = (parent == null ? void 0 : parent.nodeName) === "HTML" && containerWindow.getComputedStyle(parent).overflowY === "scroll" ? parent : container;
        }
        restoreStyle.push({
          value: scrollContainer.style.overflow,
          property: "overflow",
          el: scrollContainer
        }, {
          value: scrollContainer.style.overflowX,
          property: "overflow-x",
          el: scrollContainer
        }, {
          value: scrollContainer.style.overflowY,
          property: "overflow-y",
          el: scrollContainer
        });
        scrollContainer.style.overflow = "hidden";
      }
      const restore = () => {
        restoreStyle.forEach(({
          value,
          el: el2,
          property
        }) => {
          if (value) {
            el2.style.setProperty(property, value);
          } else {
            el2.style.removeProperty(property);
          }
        });
      };
      return restore;
    }
    function getHiddenSiblings(container) {
      const hiddenSiblings = [];
      [].forEach.call(container.children, (element) => {
        if (element.getAttribute("aria-hidden") === "true") {
          hiddenSiblings.push(element);
        }
      });
      return hiddenSiblings;
    }
    class ModalManager {
      constructor() {
        this.containers = void 0;
        this.modals = void 0;
        this.modals = [];
        this.containers = [];
      }
      add(modal, container) {
        let modalIndex = this.modals.indexOf(modal);
        if (modalIndex !== -1) {
          return modalIndex;
        }
        modalIndex = this.modals.length;
        this.modals.push(modal);
        if (modal.modalRef) {
          ariaHidden(modal.modalRef, false);
        }
        const hiddenSiblings = getHiddenSiblings(container);
        ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);
        const containerIndex = findIndexOf(this.containers, (item) => item.container === container);
        if (containerIndex !== -1) {
          this.containers[containerIndex].modals.push(modal);
          return modalIndex;
        }
        this.containers.push({
          modals: [modal],
          container,
          restore: null,
          hiddenSiblings
        });
        return modalIndex;
      }
      mount(modal, props) {
        const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1);
        const containerInfo = this.containers[containerIndex];
        if (!containerInfo.restore) {
          containerInfo.restore = handleContainer(containerInfo, props);
        }
      }
      remove(modal, ariaHiddenState = true) {
        const modalIndex = this.modals.indexOf(modal);
        if (modalIndex === -1) {
          return modalIndex;
        }
        const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1);
        const containerInfo = this.containers[containerIndex];
        containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
        this.modals.splice(modalIndex, 1);
        if (containerInfo.modals.length === 0) {
          if (containerInfo.restore) {
            containerInfo.restore();
          }
          if (modal.modalRef) {
            ariaHidden(modal.modalRef, ariaHiddenState);
          }
          ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);
          this.containers.splice(containerIndex, 1);
        } else {
          const nextTop = containerInfo.modals[containerInfo.modals.length - 1];
          if (nextTop.modalRef) {
            ariaHidden(nextTop.modalRef, false);
          }
        }
        return modalIndex;
      }
      isTopModal(modal) {
        return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
      }
    }
    function getContainer(container) {
      return typeof container === "function" ? container() : container;
    }
    function getHasTransition(children) {
      return children ? children.props.hasOwnProperty("in") : false;
    }
    const defaultManager = new ModalManager();
    function useModal(parameters) {
      const {
        container,
        disableEscapeKeyDown = false,
        disableScrollLock = false,
        // @ts-ignore internal logic - Base UI supports the manager as a prop too
        manager = defaultManager,
        closeAfterTransition = false,
        onTransitionEnter,
        onTransitionExited,
        children,
        onClose,
        open,
        rootRef
      } = parameters;
      const modal = reactExports.useRef({});
      const mountNodeRef = reactExports.useRef(null);
      const modalRef = reactExports.useRef(null);
      const handleRef = useForkRef(modalRef, rootRef);
      const [exited, setExited] = reactExports.useState(!open);
      const hasTransition = getHasTransition(children);
      let ariaHiddenProp = true;
      if (parameters["aria-hidden"] === "false" || parameters["aria-hidden"] === false) {
        ariaHiddenProp = false;
      }
      const getDoc = () => ownerDocument(mountNodeRef.current);
      const getModal = () => {
        modal.current.modalRef = modalRef.current;
        modal.current.mount = mountNodeRef.current;
        return modal.current;
      };
      const handleMounted = () => {
        manager.mount(getModal(), {
          disableScrollLock
        });
        if (modalRef.current) {
          modalRef.current.scrollTop = 0;
        }
      };
      const handleOpen = useEventCallback(() => {
        const resolvedContainer = getContainer(container) || getDoc().body;
        manager.add(getModal(), resolvedContainer);
        if (modalRef.current) {
          handleMounted();
        }
      });
      const isTopModal = reactExports.useCallback(() => manager.isTopModal(getModal()), [manager]);
      const handlePortalRef = useEventCallback((node2) => {
        mountNodeRef.current = node2;
        if (!node2) {
          return;
        }
        if (open && isTopModal()) {
          handleMounted();
        } else if (modalRef.current) {
          ariaHidden(modalRef.current, ariaHiddenProp);
        }
      });
      const handleClose = reactExports.useCallback(() => {
        manager.remove(getModal(), ariaHiddenProp);
      }, [ariaHiddenProp, manager]);
      reactExports.useEffect(() => {
        return () => {
          handleClose();
        };
      }, [handleClose]);
      reactExports.useEffect(() => {
        if (open) {
          handleOpen();
        } else if (!hasTransition || !closeAfterTransition) {
          handleClose();
        }
      }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);
      const createHandleKeyDown = (otherHandlers) => (event) => {
        var _otherHandlers$onKeyD;
        (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null || _otherHandlers$onKeyD.call(otherHandlers, event);
        if (event.key !== "Escape" || event.which === 229 || // Wait until IME is settled.
        !isTopModal()) {
          return;
        }
        if (!disableEscapeKeyDown) {
          event.stopPropagation();
          if (onClose) {
            onClose(event, "escapeKeyDown");
          }
        }
      };
      const createHandleBackdropClick = (otherHandlers) => (event) => {
        var _otherHandlers$onClic;
        (_otherHandlers$onClic = otherHandlers.onClick) == null || _otherHandlers$onClic.call(otherHandlers, event);
        if (event.target !== event.currentTarget) {
          return;
        }
        if (onClose) {
          onClose(event, "backdropClick");
        }
      };
      const getRootProps = (otherHandlers = {}) => {
        const propsEventHandlers = extractEventHandlers(parameters);
        delete propsEventHandlers.onTransitionEnter;
        delete propsEventHandlers.onTransitionExited;
        const externalEventHandlers = _extends$1({}, propsEventHandlers, otherHandlers);
        return _extends$1({
          role: "presentation"
        }, externalEventHandlers, {
          onKeyDown: createHandleKeyDown(externalEventHandlers),
          ref: handleRef
        });
      };
      const getBackdropProps = (otherHandlers = {}) => {
        const externalEventHandlers = otherHandlers;
        return _extends$1({
          "aria-hidden": true
        }, externalEventHandlers, {
          onClick: createHandleBackdropClick(externalEventHandlers),
          open
        });
      };
      const getTransitionProps2 = () => {
        const handleEnter = () => {
          setExited(false);
          if (onTransitionEnter) {
            onTransitionEnter();
          }
        };
        const handleExited = () => {
          setExited(true);
          if (onTransitionExited) {
            onTransitionExited();
          }
          if (closeAfterTransition) {
            handleClose();
          }
        };
        return {
          onEnter: createChainedFunction(handleEnter, children == null ? void 0 : children.props.onEnter),
          onExited: createChainedFunction(handleExited, children == null ? void 0 : children.props.onExited)
        };
      };
      return {
        getRootProps,
        getBackdropProps,
        getTransitionProps: getTransitionProps2,
        rootRef: handleRef,
        portalRef: handlePortalRef,
        isTopModal,
        exited,
        hasTransition
      };
    }
    function useSnackbar(parameters = {}) {
      const {
        autoHideDuration = null,
        disableWindowBlurListener = false,
        onClose,
        open,
        resumeHideDuration
      } = parameters;
      const timerAutoHide = useTimeout();
      reactExports.useEffect(() => {
        if (!open) {
          return void 0;
        }
        function handleKeyDown2(nativeEvent) {
          if (!nativeEvent.defaultPrevented) {
            if (nativeEvent.key === "Escape" || nativeEvent.key === "Esc") {
              onClose == null || onClose(nativeEvent, "escapeKeyDown");
            }
          }
        }
        document.addEventListener("keydown", handleKeyDown2);
        return () => {
          document.removeEventListener("keydown", handleKeyDown2);
        };
      }, [open, onClose]);
      const handleClose = useEventCallback((event, reason) => {
        onClose == null || onClose(event, reason);
      });
      const setAutoHideTimer = useEventCallback((autoHideDurationParam) => {
        if (!onClose || autoHideDurationParam == null) {
          return;
        }
        timerAutoHide.start(autoHideDurationParam, () => {
          handleClose(null, "timeout");
        });
      });
      reactExports.useEffect(() => {
        if (open) {
          setAutoHideTimer(autoHideDuration);
        }
        return timerAutoHide.clear;
      }, [open, autoHideDuration, setAutoHideTimer, timerAutoHide]);
      const handleClickAway = (event) => {
        onClose == null || onClose(event, "clickaway");
      };
      const handlePause = timerAutoHide.clear;
      const handleResume = reactExports.useCallback(() => {
        if (autoHideDuration != null) {
          setAutoHideTimer(resumeHideDuration != null ? resumeHideDuration : autoHideDuration * 0.5);
        }
      }, [autoHideDuration, resumeHideDuration, setAutoHideTimer]);
      const createHandleBlur = (otherHandlers) => (event) => {
        const onBlurCallback = otherHandlers.onBlur;
        onBlurCallback == null || onBlurCallback(event);
        handleResume();
      };
      const createHandleFocus = (otherHandlers) => (event) => {
        const onFocusCallback = otherHandlers.onFocus;
        onFocusCallback == null || onFocusCallback(event);
        handlePause();
      };
      const createMouseEnter = (otherHandlers) => (event) => {
        const onMouseEnterCallback = otherHandlers.onMouseEnter;
        onMouseEnterCallback == null || onMouseEnterCallback(event);
        handlePause();
      };
      const createMouseLeave = (otherHandlers) => (event) => {
        const onMouseLeaveCallback = otherHandlers.onMouseLeave;
        onMouseLeaveCallback == null || onMouseLeaveCallback(event);
        handleResume();
      };
      reactExports.useEffect(() => {
        if (!disableWindowBlurListener && open) {
          window.addEventListener("focus", handleResume);
          window.addEventListener("blur", handlePause);
          return () => {
            window.removeEventListener("focus", handleResume);
            window.removeEventListener("blur", handlePause);
          };
        }
        return void 0;
      }, [disableWindowBlurListener, open, handleResume, handlePause]);
      const getRootProps = (externalProps = {}) => {
        const externalEventHandlers = _extends$1({}, extractEventHandlers(parameters), extractEventHandlers(externalProps));
        return _extends$1({
          // ClickAwayListener adds an `onClick` prop which results in the alert not being announced.
          // See https://github.com/mui/material-ui/issues/29080
          role: "presentation"
        }, externalProps, externalEventHandlers, {
          onBlur: createHandleBlur(externalEventHandlers),
          onFocus: createHandleFocus(externalEventHandlers),
          onMouseEnter: createMouseEnter(externalEventHandlers),
          onMouseLeave: createMouseLeave(externalEventHandlers)
        });
      };
      return {
        getRootProps,
        onClickAway: handleClickAway
      };
    }
    const _excluded$$ = ["onChange", "maxRows", "minRows", "style", "value"];
    function getStyleValue(value) {
      return parseInt(value, 10) || 0;
    }
    const styles$2 = {
      shadow: {
        // Visibility needed to hide the extra text area on iPads
        visibility: "hidden",
        // Remove from the content flow
        position: "absolute",
        // Ignore the scrollbar width
        overflow: "hidden",
        height: 0,
        top: 0,
        left: 0,
        // Create a new layer, increase the isolation of the computed values
        transform: "translateZ(0)"
      }
    };
    function isEmpty$1(obj) {
      return obj === void 0 || obj === null || Object.keys(obj).length === 0 || obj.outerHeightStyle === 0 && !obj.overflow;
    }
    const TextareaAutosize = /* @__PURE__ */ reactExports.forwardRef(function TextareaAutosize2(props, forwardedRef) {
      const {
        onChange,
        maxRows,
        minRows = 1,
        style: style2,
        value
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$$);
      const {
        current: isControlled
      } = reactExports.useRef(value != null);
      const inputRef = reactExports.useRef(null);
      const handleRef = useForkRef(forwardedRef, inputRef);
      const shadowRef = reactExports.useRef(null);
      const renders = reactExports.useRef(0);
      const [state, setState] = reactExports.useState({
        outerHeightStyle: 0
      });
      const getUpdatedState = reactExports.useCallback(() => {
        const input = inputRef.current;
        const containerWindow = ownerWindow(input);
        const computedStyle = containerWindow.getComputedStyle(input);
        if (computedStyle.width === "0px") {
          return {
            outerHeightStyle: 0
          };
        }
        const inputShallow = shadowRef.current;
        inputShallow.style.width = computedStyle.width;
        inputShallow.value = input.value || props.placeholder || "x";
        if (inputShallow.value.slice(-1) === "\n") {
          inputShallow.value += " ";
        }
        const boxSizing2 = computedStyle.boxSizing;
        const padding2 = getStyleValue(computedStyle.paddingBottom) + getStyleValue(computedStyle.paddingTop);
        const border2 = getStyleValue(computedStyle.borderBottomWidth) + getStyleValue(computedStyle.borderTopWidth);
        const innerHeight = inputShallow.scrollHeight;
        inputShallow.value = "x";
        const singleRowHeight = inputShallow.scrollHeight;
        let outerHeight = innerHeight;
        if (minRows) {
          outerHeight = Math.max(Number(minRows) * singleRowHeight, outerHeight);
        }
        if (maxRows) {
          outerHeight = Math.min(Number(maxRows) * singleRowHeight, outerHeight);
        }
        outerHeight = Math.max(outerHeight, singleRowHeight);
        const outerHeightStyle = outerHeight + (boxSizing2 === "border-box" ? padding2 + border2 : 0);
        const overflow = Math.abs(outerHeight - innerHeight) <= 1;
        return {
          outerHeightStyle,
          overflow
        };
      }, [maxRows, minRows, props.placeholder]);
      const updateState = (prevState, newState) => {
        const {
          outerHeightStyle,
          overflow
        } = newState;
        if (renders.current < 20 && (outerHeightStyle > 0 && Math.abs((prevState.outerHeightStyle || 0) - outerHeightStyle) > 1 || prevState.overflow !== overflow)) {
          renders.current += 1;
          return {
            overflow,
            outerHeightStyle
          };
        }
        return prevState;
      };
      const syncHeight = reactExports.useCallback(() => {
        const newState = getUpdatedState();
        if (isEmpty$1(newState)) {
          return;
        }
        setState((prevState) => updateState(prevState, newState));
      }, [getUpdatedState]);
      useEnhancedEffect(() => {
        const syncHeightWithFlushSync = () => {
          const newState = getUpdatedState();
          if (isEmpty$1(newState)) {
            return;
          }
          reactDomExports.flushSync(() => {
            setState((prevState) => updateState(prevState, newState));
          });
        };
        const handleResize = () => {
          renders.current = 0;
          syncHeightWithFlushSync();
        };
        let rAF;
        const debounceHandleResize = debounce$1(handleResize);
        const input = inputRef.current;
        const containerWindow = ownerWindow(input);
        containerWindow.addEventListener("resize", debounceHandleResize);
        let resizeObserver;
        if (typeof ResizeObserver !== "undefined") {
          resizeObserver = new ResizeObserver(handleResize);
          resizeObserver.observe(input);
        }
        return () => {
          debounceHandleResize.clear();
          cancelAnimationFrame(rAF);
          containerWindow.removeEventListener("resize", debounceHandleResize);
          if (resizeObserver) {
            resizeObserver.disconnect();
          }
        };
      }, [getUpdatedState]);
      useEnhancedEffect(() => {
        syncHeight();
      });
      reactExports.useEffect(() => {
        renders.current = 0;
      }, [value]);
      const handleChange = (event) => {
        renders.current = 0;
        if (!isControlled) {
          syncHeight();
        }
        if (onChange) {
          onChange(event);
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx("textarea", _extends$1({
          value,
          onChange: handleChange,
          ref: handleRef,
          rows: minRows,
          style: _extends$1({
            height: state.outerHeightStyle,
            // Need a large enough difference to allow scrolling.
            // This prevents infinite rendering loop.
            overflow: state.overflow ? "hidden" : void 0
          }, style2)
        }, other)), /* @__PURE__ */ jsxRuntimeExports.jsx("textarea", {
          "aria-hidden": true,
          className: props.className,
          readOnly: true,
          ref: shadowRef,
          tabIndex: -1,
          style: _extends$1({}, styles$2.shadow, style2, {
            paddingTop: 0,
            paddingBottom: 0
          })
        })]
      });
    });
    function useTheme() {
      const theme = useTheme$1(defaultTheme$2);
      return theme[THEME_ID] || theme;
    }
    const reflow = (node2) => node2.scrollTop;
    function getTransitionProps(props, options) {
      var _style$transitionDura, _style$transitionTimi;
      const {
        timeout,
        easing: easing2,
        style: style2 = {}
      } = props;
      return {
        duration: (_style$transitionDura = style2.transitionDuration) != null ? _style$transitionDura : typeof timeout === "number" ? timeout : timeout[options.mode] || 0,
        easing: (_style$transitionTimi = style2.transitionTimingFunction) != null ? _style$transitionTimi : typeof easing2 === "object" ? easing2[options.mode] : easing2,
        delay: style2.transitionDelay
      };
    }
    const _excluded$_ = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
    function getScale(value) {
      return `scale(${value}, ${value ** 2})`;
    }
    const styles$1 = {
      entering: {
        opacity: 1,
        transform: getScale(1)
      },
      entered: {
        opacity: 1,
        transform: "none"
      }
    };
    const isWebKit154 = typeof navigator !== "undefined" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent);
    const Grow = /* @__PURE__ */ reactExports.forwardRef(function Grow2(props, ref) {
      const {
        addEndListener,
        appear = true,
        children,
        easing: easing2,
        in: inProp,
        onEnter,
        onEntered,
        onEntering,
        onExit,
        onExited,
        onExiting,
        style: style2,
        timeout = "auto",
        // eslint-disable-next-line react/prop-types
        TransitionComponent = Transition$1
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$_);
      const timer = useTimeout();
      const autoTimeout = reactExports.useRef();
      const theme = useTheme();
      const nodeRef = reactExports.useRef(null);
      const handleRef = useForkRef(nodeRef, children.ref, ref);
      const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
        if (callback) {
          const node2 = nodeRef.current;
          if (maybeIsAppearing === void 0) {
            callback(node2);
          } else {
            callback(node2, maybeIsAppearing);
          }
        }
      };
      const handleEntering = normalizedTransitionCallback(onEntering);
      const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
        reflow(node2);
        const {
          duration: transitionDuration,
          delay: delay2,
          easing: transitionTimingFunction
        } = getTransitionProps({
          style: style2,
          timeout,
          easing: easing2
        }, {
          mode: "enter"
        });
        let duration2;
        if (timeout === "auto") {
          duration2 = theme.transitions.getAutoHeightDuration(node2.clientHeight);
          autoTimeout.current = duration2;
        } else {
          duration2 = transitionDuration;
        }
        node2.style.transition = [theme.transitions.create("opacity", {
          duration: duration2,
          delay: delay2
        }), theme.transitions.create("transform", {
          duration: isWebKit154 ? duration2 : duration2 * 0.666,
          delay: delay2,
          easing: transitionTimingFunction
        })].join(",");
        if (onEnter) {
          onEnter(node2, isAppearing);
        }
      });
      const handleEntered = normalizedTransitionCallback(onEntered);
      const handleExiting = normalizedTransitionCallback(onExiting);
      const handleExit = normalizedTransitionCallback((node2) => {
        const {
          duration: transitionDuration,
          delay: delay2,
          easing: transitionTimingFunction
        } = getTransitionProps({
          style: style2,
          timeout,
          easing: easing2
        }, {
          mode: "exit"
        });
        let duration2;
        if (timeout === "auto") {
          duration2 = theme.transitions.getAutoHeightDuration(node2.clientHeight);
          autoTimeout.current = duration2;
        } else {
          duration2 = transitionDuration;
        }
        node2.style.transition = [theme.transitions.create("opacity", {
          duration: duration2,
          delay: delay2
        }), theme.transitions.create("transform", {
          duration: isWebKit154 ? duration2 : duration2 * 0.666,
          delay: isWebKit154 ? delay2 : delay2 || duration2 * 0.333,
          easing: transitionTimingFunction
        })].join(",");
        node2.style.opacity = 0;
        node2.style.transform = getScale(0.75);
        if (onExit) {
          onExit(node2);
        }
      });
      const handleExited = normalizedTransitionCallback(onExited);
      const handleAddEndListener = (next2) => {
        if (timeout === "auto") {
          timer.start(autoTimeout.current || 0, next2);
        }
        if (addEndListener) {
          addEndListener(nodeRef.current, next2);
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$1({
        appear,
        in: inProp,
        nodeRef,
        onEnter: handleEnter,
        onEntered: handleEntered,
        onEntering: handleEntering,
        onExit: handleExit,
        onExited: handleExited,
        onExiting: handleExiting,
        addEndListener: handleAddEndListener,
        timeout: timeout === "auto" ? null : timeout
      }, other, {
        children: (state, childProps) => {
          return /* @__PURE__ */ reactExports.cloneElement(children, _extends$1({
            style: _extends$1({
              opacity: 0,
              transform: getScale(0.75),
              visibility: state === "exited" && !inProp ? "hidden" : void 0
            }, styles$1[state], style2, children.props.style),
            ref: handleRef
          }, childProps));
        }
      }));
    });
    Grow.muiSupportAuto = true;
    const Grow$1 = Grow;
    const getOverlayAlpha = (elevation) => {
      let alphaValue;
      if (elevation < 1) {
        alphaValue = 5.11916 * elevation ** 2;
      } else {
        alphaValue = 4.5 * Math.log(elevation + 1) + 2;
      }
      return (alphaValue / 100).toFixed(2);
    };
    function getPaperUtilityClass(slot) {
      return generateUtilityClass$1("MuiPaper", slot);
    }
    generateUtilityClasses$1("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
    const _excluded$Z = ["className", "component", "elevation", "square", "variant"];
    const useUtilityClasses$N = (ownerState) => {
      const {
        square,
        elevation,
        variant,
        classes
      } = ownerState;
      const slots = {
        root: ["root", variant, !square && "rounded", variant === "elevation" && `elevation${elevation}`]
      };
      return composeClasses(slots, getPaperUtilityClass, classes);
    };
    const PaperRoot = styled("div", {
      name: "MuiPaper",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, styles2[ownerState.variant], !ownerState.square && styles2.rounded, ownerState.variant === "elevation" && styles2[`elevation${ownerState.elevation}`]];
      }
    })(({
      theme,
      ownerState
    }) => {
      var _theme$vars$overlays;
      return _extends$1({
        backgroundColor: (theme.vars || theme).palette.background.paper,
        color: (theme.vars || theme).palette.text.primary,
        transition: theme.transitions.create("box-shadow")
      }, !ownerState.square && {
        borderRadius: theme.shape.borderRadius
      }, ownerState.variant === "outlined" && {
        border: `1px solid ${(theme.vars || theme).palette.divider}`
      }, ownerState.variant === "elevation" && _extends$1({
        boxShadow: (theme.vars || theme).shadows[ownerState.elevation]
      }, !theme.vars && theme.palette.mode === "dark" && {
        backgroundImage: `linear-gradient(${alpha$1("#fff", getOverlayAlpha(ownerState.elevation))}, ${alpha$1("#fff", getOverlayAlpha(ownerState.elevation))})`
      }, theme.vars && {
        backgroundImage: (_theme$vars$overlays = theme.vars.overlays) == null ? void 0 : _theme$vars$overlays[ownerState.elevation]
      }));
    });
    const Paper = /* @__PURE__ */ reactExports.forwardRef(function Paper2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiPaper"
      });
      const {
        className,
        component = "div",
        elevation = 1,
        square = false,
        variant = "elevation"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$Z);
      const ownerState = _extends$1({}, props, {
        component,
        elevation,
        square,
        variant
      });
      const classes = useUtilityClasses$N(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PaperRoot, _extends$1({
        as: component,
        ownerState,
        className: clsx(classes.root, className),
        ref
      }, other));
    });
    const Paper$1 = Paper;
    function getSnackbarContentUtilityClass(slot) {
      return generateUtilityClass$1("MuiSnackbarContent", slot);
    }
    generateUtilityClasses$1("MuiSnackbarContent", ["root", "message", "action"]);
    const _excluded$Y = ["action", "className", "message", "role"];
    const useUtilityClasses$M = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        action: ["action"],
        message: ["message"]
      };
      return composeClasses(slots, getSnackbarContentUtilityClass, classes);
    };
    const SnackbarContentRoot = styled(Paper$1, {
      name: "MuiSnackbarContent",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })(({
      theme
    }) => {
      const emphasis = theme.palette.mode === "light" ? 0.8 : 0.98;
      const backgroundColor2 = emphasize(theme.palette.background.default, emphasis);
      return _extends$1({}, theme.typography.body2, {
        color: theme.vars ? theme.vars.palette.SnackbarContent.color : theme.palette.getContrastText(backgroundColor2),
        backgroundColor: theme.vars ? theme.vars.palette.SnackbarContent.bg : backgroundColor2,
        display: "flex",
        alignItems: "center",
        flexWrap: "wrap",
        padding: "6px 16px",
        borderRadius: (theme.vars || theme).shape.borderRadius,
        flexGrow: 1,
        [theme.breakpoints.up("sm")]: {
          flexGrow: "initial",
          minWidth: 288
        }
      });
    });
    const SnackbarContentMessage = styled("div", {
      name: "MuiSnackbarContent",
      slot: "Message",
      overridesResolver: (props, styles2) => styles2.message
    })({
      padding: "8px 0"
    });
    const SnackbarContentAction = styled("div", {
      name: "MuiSnackbarContent",
      slot: "Action",
      overridesResolver: (props, styles2) => styles2.action
    })({
      display: "flex",
      alignItems: "center",
      marginLeft: "auto",
      paddingLeft: 16,
      marginRight: -8
    });
    const SnackbarContent = /* @__PURE__ */ reactExports.forwardRef(function SnackbarContent2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiSnackbarContent"
      });
      const {
        action,
        className,
        message,
        role = "alert"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$Y);
      const ownerState = props;
      const classes = useUtilityClasses$M(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(SnackbarContentRoot, _extends$1({
        role,
        square: true,
        elevation: 6,
        className: clsx(classes.root, className),
        ownerState,
        ref
      }, other, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SnackbarContentMessage, {
          className: classes.message,
          ownerState,
          children: message
        }), action ? /* @__PURE__ */ jsxRuntimeExports.jsx(SnackbarContentAction, {
          className: classes.action,
          ownerState,
          children: action
        }) : null]
      }));
    });
    const SnackbarContent$1 = SnackbarContent;
    function getSnackbarUtilityClass(slot) {
      return generateUtilityClass$1("MuiSnackbar", slot);
    }
    generateUtilityClasses$1("MuiSnackbar", ["root", "anchorOriginTopCenter", "anchorOriginBottomCenter", "anchorOriginTopRight", "anchorOriginBottomRight", "anchorOriginTopLeft", "anchorOriginBottomLeft"]);
    const _excluded$X = ["onEnter", "onExited"], _excluded2$8 = ["action", "anchorOrigin", "autoHideDuration", "children", "className", "ClickAwayListenerProps", "ContentProps", "disableWindowBlurListener", "message", "onBlur", "onClose", "onFocus", "onMouseEnter", "onMouseLeave", "open", "resumeHideDuration", "TransitionComponent", "transitionDuration", "TransitionProps"];
    const useUtilityClasses$L = (ownerState) => {
      const {
        classes,
        anchorOrigin
      } = ownerState;
      const slots = {
        root: ["root", `anchorOrigin${capitalize(anchorOrigin.vertical)}${capitalize(anchorOrigin.horizontal)}`]
      };
      return composeClasses(slots, getSnackbarUtilityClass, classes);
    };
    const SnackbarRoot = styled("div", {
      name: "MuiSnackbar",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, styles2[`anchorOrigin${capitalize(ownerState.anchorOrigin.vertical)}${capitalize(ownerState.anchorOrigin.horizontal)}`]];
      }
    })(({
      theme,
      ownerState
    }) => {
      const center = {
        left: "50%",
        right: "auto",
        transform: "translateX(-50%)"
      };
      return _extends$1({
        zIndex: (theme.vars || theme).zIndex.snackbar,
        position: "fixed",
        display: "flex",
        left: 8,
        right: 8,
        justifyContent: "center",
        alignItems: "center"
      }, ownerState.anchorOrigin.vertical === "top" ? {
        top: 8
      } : {
        bottom: 8
      }, ownerState.anchorOrigin.horizontal === "left" && {
        justifyContent: "flex-start"
      }, ownerState.anchorOrigin.horizontal === "right" && {
        justifyContent: "flex-end"
      }, {
        [theme.breakpoints.up("sm")]: _extends$1({}, ownerState.anchorOrigin.vertical === "top" ? {
          top: 24
        } : {
          bottom: 24
        }, ownerState.anchorOrigin.horizontal === "center" && center, ownerState.anchorOrigin.horizontal === "left" && {
          left: 24,
          right: "auto"
        }, ownerState.anchorOrigin.horizontal === "right" && {
          right: 24,
          left: "auto"
        })
      });
    });
    const Snackbar = /* @__PURE__ */ reactExports.forwardRef(function Snackbar2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiSnackbar"
      });
      const theme = useTheme();
      const defaultTransitionDuration = {
        enter: theme.transitions.duration.enteringScreen,
        exit: theme.transitions.duration.leavingScreen
      };
      const {
        action,
        anchorOrigin: {
          vertical,
          horizontal
        } = {
          vertical: "bottom",
          horizontal: "left"
        },
        autoHideDuration = null,
        children,
        className,
        ClickAwayListenerProps,
        ContentProps,
        disableWindowBlurListener = false,
        message,
        open,
        TransitionComponent = Grow$1,
        transitionDuration = defaultTransitionDuration,
        TransitionProps: {
          onEnter,
          onExited
        } = {}
      } = props, TransitionProps = _objectWithoutPropertiesLoose$1(props.TransitionProps, _excluded$X), other = _objectWithoutPropertiesLoose$1(props, _excluded2$8);
      const ownerState = _extends$1({}, props, {
        anchorOrigin: {
          vertical,
          horizontal
        },
        autoHideDuration,
        disableWindowBlurListener,
        TransitionComponent,
        transitionDuration
      });
      const classes = useUtilityClasses$L(ownerState);
      const {
        getRootProps,
        onClickAway
      } = useSnackbar(_extends$1({}, ownerState));
      const [exited, setExited] = reactExports.useState(true);
      const rootProps = useSlotProps({
        elementType: SnackbarRoot,
        getSlotProps: getRootProps,
        externalForwardedProps: other,
        ownerState,
        additionalProps: {
          ref
        },
        className: [classes.root, className]
      });
      const handleExited = (node2) => {
        setExited(true);
        if (onExited) {
          onExited(node2);
        }
      };
      const handleEnter = (node2, isAppearing) => {
        setExited(false);
        if (onEnter) {
          onEnter(node2, isAppearing);
        }
      };
      if (!open && exited) {
        return null;
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ClickAwayListener, _extends$1({
        onClickAway
      }, ClickAwayListenerProps, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(SnackbarRoot, _extends$1({}, rootProps, {
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$1({
            appear: true,
            in: open,
            timeout: transitionDuration,
            direction: vertical === "top" ? "down" : "up",
            onEnter: handleEnter,
            onExited: handleExited
          }, TransitionProps, {
            children: children || /* @__PURE__ */ jsxRuntimeExports.jsx(SnackbarContent$1, _extends$1({
              message,
              action
            }, ContentProps))
          }))
        }))
      }));
    });
    const Snackbar$1 = Snackbar;
    function getAlertUtilityClass(slot) {
      return generateUtilityClass$1("MuiAlert", slot);
    }
    const alertClasses = generateUtilityClasses$1("MuiAlert", ["root", "action", "icon", "message", "filled", "filledSuccess", "filledInfo", "filledWarning", "filledError", "outlined", "outlinedSuccess", "outlinedInfo", "outlinedWarning", "outlinedError", "standard", "standardSuccess", "standardInfo", "standardWarning", "standardError"]);
    const alertClasses$1 = alertClasses;
    function getIconButtonUtilityClass(slot) {
      return generateUtilityClass$1("MuiIconButton", slot);
    }
    const iconButtonClasses = generateUtilityClasses$1("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge"]);
    const _excluded$W = ["edge", "children", "className", "color", "disabled", "disableFocusRipple", "size"];
    const useUtilityClasses$K = (ownerState) => {
      const {
        classes,
        disabled,
        color: color2,
        edge,
        size
      } = ownerState;
      const slots = {
        root: ["root", disabled && "disabled", color2 !== "default" && `color${capitalize(color2)}`, edge && `edge${capitalize(edge)}`, `size${capitalize(size)}`]
      };
      return composeClasses(slots, getIconButtonUtilityClass, classes);
    };
    const IconButtonRoot = styled(ButtonBase$1, {
      name: "MuiIconButton",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, ownerState.color !== "default" && styles2[`color${capitalize(ownerState.color)}`], ownerState.edge && styles2[`edge${capitalize(ownerState.edge)}`], styles2[`size${capitalize(ownerState.size)}`]];
      }
    })(({
      theme,
      ownerState
    }) => _extends$1({
      textAlign: "center",
      flex: "0 0 auto",
      fontSize: theme.typography.pxToRem(24),
      padding: 8,
      borderRadius: "50%",
      overflow: "visible",
      // Explicitly set the default value to solve a bug on IE11.
      color: (theme.vars || theme).palette.action.active,
      transition: theme.transitions.create("background-color", {
        duration: theme.transitions.duration.shortest
      })
    }, !ownerState.disableRipple && {
      "&:hover": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha$1(theme.palette.action.active, theme.palette.action.hoverOpacity),
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }, ownerState.edge === "start" && {
      marginLeft: ownerState.size === "small" ? -3 : -12
    }, ownerState.edge === "end" && {
      marginRight: ownerState.size === "small" ? -3 : -12
    }), ({
      theme,
      ownerState
    }) => {
      var _palette;
      const palette = (_palette = (theme.vars || theme).palette) == null ? void 0 : _palette[ownerState.color];
      return _extends$1({}, ownerState.color === "inherit" && {
        color: "inherit"
      }, ownerState.color !== "inherit" && ownerState.color !== "default" && _extends$1({
        color: palette == null ? void 0 : palette.main
      }, !ownerState.disableRipple && {
        "&:hover": _extends$1({}, palette && {
          backgroundColor: theme.vars ? `rgba(${palette.mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha$1(palette.main, theme.palette.action.hoverOpacity)
        }, {
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        })
      }), ownerState.size === "small" && {
        padding: 5,
        fontSize: theme.typography.pxToRem(18)
      }, ownerState.size === "large" && {
        padding: 12,
        fontSize: theme.typography.pxToRem(28)
      }, {
        [`&.${iconButtonClasses.disabled}`]: {
          backgroundColor: "transparent",
          color: (theme.vars || theme).palette.action.disabled
        }
      });
    });
    const IconButton = /* @__PURE__ */ reactExports.forwardRef(function IconButton2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiIconButton"
      });
      const {
        edge = false,
        children,
        className,
        color: color2 = "default",
        disabled = false,
        disableFocusRipple = false,
        size = "medium"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$W);
      const ownerState = _extends$1({}, props, {
        edge,
        color: color2,
        disabled,
        disableFocusRipple,
        size
      });
      const classes = useUtilityClasses$K(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(IconButtonRoot, _extends$1({
        className: clsx(classes.root, className),
        centerRipple: true,
        focusRipple: !disableFocusRipple,
        disabled,
        ref,
        ownerState
      }, other, {
        children
      }));
    });
    const IconButton$1 = IconButton;
    function getSvgIconUtilityClass(slot) {
      return generateUtilityClass$1("MuiSvgIcon", slot);
    }
    generateUtilityClasses$1("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
    const _excluded$V = ["children", "className", "color", "component", "fontSize", "htmlColor", "inheritViewBox", "titleAccess", "viewBox"];
    const useUtilityClasses$J = (ownerState) => {
      const {
        color: color2,
        fontSize,
        classes
      } = ownerState;
      const slots = {
        root: ["root", color2 !== "inherit" && `color${capitalize(color2)}`, `fontSize${capitalize(fontSize)}`]
      };
      return composeClasses(slots, getSvgIconUtilityClass, classes);
    };
    const SvgIconRoot = styled("svg", {
      name: "MuiSvgIcon",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, ownerState.color !== "inherit" && styles2[`color${capitalize(ownerState.color)}`], styles2[`fontSize${capitalize(ownerState.fontSize)}`]];
      }
    })(({
      theme,
      ownerState
    }) => {
      var _theme$transitions, _theme$transitions$cr, _theme$transitions2, _theme$typography, _theme$typography$pxT, _theme$typography2, _theme$typography2$px, _theme$typography3, _theme$typography3$px, _palette$ownerState$c, _palette, _palette2, _palette3;
      return {
        userSelect: "none",
        width: "1em",
        height: "1em",
        display: "inline-block",
        // the <svg> will define the property that has `currentColor`
        // e.g. heroicons uses fill="none" and stroke="currentColor"
        fill: ownerState.hasSvgAsChild ? void 0 : "currentColor",
        flexShrink: 0,
        transition: (_theme$transitions = theme.transitions) == null || (_theme$transitions$cr = _theme$transitions.create) == null ? void 0 : _theme$transitions$cr.call(_theme$transitions, "fill", {
          duration: (_theme$transitions2 = theme.transitions) == null || (_theme$transitions2 = _theme$transitions2.duration) == null ? void 0 : _theme$transitions2.shorter
        }),
        fontSize: {
          inherit: "inherit",
          small: ((_theme$typography = theme.typography) == null || (_theme$typography$pxT = _theme$typography.pxToRem) == null ? void 0 : _theme$typography$pxT.call(_theme$typography, 20)) || "1.25rem",
          medium: ((_theme$typography2 = theme.typography) == null || (_theme$typography2$px = _theme$typography2.pxToRem) == null ? void 0 : _theme$typography2$px.call(_theme$typography2, 24)) || "1.5rem",
          large: ((_theme$typography3 = theme.typography) == null || (_theme$typography3$px = _theme$typography3.pxToRem) == null ? void 0 : _theme$typography3$px.call(_theme$typography3, 35)) || "2.1875rem"
        }[ownerState.fontSize],
        // TODO v5 deprecate, v6 remove for sx
        color: (_palette$ownerState$c = (_palette = (theme.vars || theme).palette) == null || (_palette = _palette[ownerState.color]) == null ? void 0 : _palette.main) != null ? _palette$ownerState$c : {
          action: (_palette2 = (theme.vars || theme).palette) == null || (_palette2 = _palette2.action) == null ? void 0 : _palette2.active,
          disabled: (_palette3 = (theme.vars || theme).palette) == null || (_palette3 = _palette3.action) == null ? void 0 : _palette3.disabled,
          inherit: void 0
        }[ownerState.color]
      };
    });
    const SvgIcon = /* @__PURE__ */ reactExports.forwardRef(function SvgIcon2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiSvgIcon"
      });
      const {
        children,
        className,
        color: color2 = "inherit",
        component = "svg",
        fontSize = "medium",
        htmlColor,
        inheritViewBox = false,
        titleAccess,
        viewBox = "0 0 24 24"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$V);
      const hasSvgAsChild = /* @__PURE__ */ reactExports.isValidElement(children) && children.type === "svg";
      const ownerState = _extends$1({}, props, {
        color: color2,
        component,
        fontSize,
        instanceFontSize: inProps.fontSize,
        inheritViewBox,
        viewBox,
        hasSvgAsChild
      });
      const more = {};
      if (!inheritViewBox) {
        more.viewBox = viewBox;
      }
      const classes = useUtilityClasses$J(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(SvgIconRoot, _extends$1({
        as: component,
        className: clsx(classes.root, className),
        focusable: "false",
        color: htmlColor,
        "aria-hidden": titleAccess ? void 0 : true,
        role: titleAccess ? "img" : void 0,
        ref
      }, more, other, hasSvgAsChild && children.props, {
        ownerState,
        children: [hasSvgAsChild ? children.props.children : children, titleAccess ? /* @__PURE__ */ jsxRuntimeExports.jsx("title", {
          children: titleAccess
        }) : null]
      }));
    });
    SvgIcon.muiName = "SvgIcon";
    function createSvgIcon$1(path, displayName) {
      function Component(props, ref) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(SvgIcon, _extends$1({
          "data-testid": `${displayName}Icon`,
          ref
        }, props, {
          children: path
        }));
      }
      Component.muiName = SvgIcon.muiName;
      return /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(Component));
    }
    const SuccessOutlinedIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      d: "M20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4C12.76,4 13.5,4.11 14.2, 4.31L15.77,2.74C14.61,2.26 13.34,2 12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0, 0 22,12M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z"
    }), "SuccessOutlined");
    const ReportProblemOutlinedIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      d: "M12 5.99L19.53 19H4.47L12 5.99M12 2L1 21h22L12 2zm1 14h-2v2h2v-2zm0-6h-2v4h2v-4z"
    }), "ReportProblemOutlined");
    const ErrorOutlineIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      d: "M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
    }), "ErrorOutline");
    const InfoOutlinedIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      d: "M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20, 12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10, 10 0 0,0 12,2M11,17H13V11H11V17Z"
    }), "InfoOutlined");
    const ClearIcon$1 = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
    }), "Close");
    const _excluded$U = ["action", "children", "className", "closeText", "color", "components", "componentsProps", "icon", "iconMapping", "onClose", "role", "severity", "slotProps", "slots", "variant"];
    const useUtilityClasses$I = (ownerState) => {
      const {
        variant,
        color: color2,
        severity,
        classes
      } = ownerState;
      const slots = {
        root: ["root", `${variant}${capitalize(color2 || severity)}`, `${variant}`],
        icon: ["icon"],
        message: ["message"],
        action: ["action"]
      };
      return composeClasses(slots, getAlertUtilityClass, classes);
    };
    const AlertRoot = styled(Paper$1, {
      name: "MuiAlert",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, styles2[ownerState.variant], styles2[`${ownerState.variant}${capitalize(ownerState.color || ownerState.severity)}`]];
      }
    })(({
      theme,
      ownerState
    }) => {
      const getColor = theme.palette.mode === "light" ? darken : lighten;
      const getBackgroundColor = theme.palette.mode === "light" ? lighten : darken;
      const color2 = ownerState.color || ownerState.severity;
      return _extends$1({}, theme.typography.body2, {
        backgroundColor: "transparent",
        display: "flex",
        padding: "6px 16px"
      }, color2 && ownerState.variant === "standard" && {
        color: theme.vars ? theme.vars.palette.Alert[`${color2}Color`] : getColor(theme.palette[color2].light, 0.6),
        backgroundColor: theme.vars ? theme.vars.palette.Alert[`${color2}StandardBg`] : getBackgroundColor(theme.palette[color2].light, 0.9),
        [`& .${alertClasses$1.icon}`]: theme.vars ? {
          color: theme.vars.palette.Alert[`${color2}IconColor`]
        } : {
          color: theme.palette[color2].main
        }
      }, color2 && ownerState.variant === "outlined" && {
        color: theme.vars ? theme.vars.palette.Alert[`${color2}Color`] : getColor(theme.palette[color2].light, 0.6),
        border: `1px solid ${(theme.vars || theme).palette[color2].light}`,
        [`& .${alertClasses$1.icon}`]: theme.vars ? {
          color: theme.vars.palette.Alert[`${color2}IconColor`]
        } : {
          color: theme.palette[color2].main
        }
      }, color2 && ownerState.variant === "filled" && _extends$1({
        fontWeight: theme.typography.fontWeightMedium
      }, theme.vars ? {
        color: theme.vars.palette.Alert[`${color2}FilledColor`],
        backgroundColor: theme.vars.palette.Alert[`${color2}FilledBg`]
      } : {
        backgroundColor: theme.palette.mode === "dark" ? theme.palette[color2].dark : theme.palette[color2].main,
        color: theme.palette.getContrastText(theme.palette[color2].main)
      }));
    });
    const AlertIcon = styled("div", {
      name: "MuiAlert",
      slot: "Icon",
      overridesResolver: (props, styles2) => styles2.icon
    })({
      marginRight: 12,
      padding: "7px 0",
      display: "flex",
      fontSize: 22,
      opacity: 0.9
    });
    const AlertMessage = styled("div", {
      name: "MuiAlert",
      slot: "Message",
      overridesResolver: (props, styles2) => styles2.message
    })({
      padding: "8px 0",
      minWidth: 0,
      overflow: "auto"
    });
    const AlertAction = styled("div", {
      name: "MuiAlert",
      slot: "Action",
      overridesResolver: (props, styles2) => styles2.action
    })({
      display: "flex",
      alignItems: "flex-start",
      padding: "4px 0 0 16px",
      marginLeft: "auto",
      marginRight: -8
    });
    const defaultIconMapping = {
      success: /* @__PURE__ */ jsxRuntimeExports.jsx(SuccessOutlinedIcon, {
        fontSize: "inherit"
      }),
      warning: /* @__PURE__ */ jsxRuntimeExports.jsx(ReportProblemOutlinedIcon, {
        fontSize: "inherit"
      }),
      error: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorOutlineIcon, {
        fontSize: "inherit"
      }),
      info: /* @__PURE__ */ jsxRuntimeExports.jsx(InfoOutlinedIcon, {
        fontSize: "inherit"
      })
    };
    const Alert = /* @__PURE__ */ reactExports.forwardRef(function Alert2(inProps, ref) {
      var _ref, _slots$closeButton, _ref2, _slots$closeIcon, _slotProps$closeButto, _slotProps$closeIcon;
      const props = useThemeProps({
        props: inProps,
        name: "MuiAlert"
      });
      const {
        action,
        children,
        className,
        closeText = "Close",
        color: color2,
        components = {},
        componentsProps = {},
        icon,
        iconMapping = defaultIconMapping,
        onClose,
        role = "alert",
        severity = "success",
        slotProps = {},
        slots = {},
        variant = "standard"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$U);
      const ownerState = _extends$1({}, props, {
        color: color2,
        severity,
        variant
      });
      const classes = useUtilityClasses$I(ownerState);
      const AlertCloseButton = (_ref = (_slots$closeButton = slots.closeButton) != null ? _slots$closeButton : components.CloseButton) != null ? _ref : IconButton$1;
      const AlertCloseIcon = (_ref2 = (_slots$closeIcon = slots.closeIcon) != null ? _slots$closeIcon : components.CloseIcon) != null ? _ref2 : ClearIcon$1;
      const closeButtonProps = (_slotProps$closeButto = slotProps.closeButton) != null ? _slotProps$closeButto : componentsProps.closeButton;
      const closeIconProps = (_slotProps$closeIcon = slotProps.closeIcon) != null ? _slotProps$closeIcon : componentsProps.closeIcon;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(AlertRoot, _extends$1({
        role,
        elevation: 0,
        ownerState,
        className: clsx(classes.root, className),
        ref
      }, other, {
        children: [icon !== false ? /* @__PURE__ */ jsxRuntimeExports.jsx(AlertIcon, {
          ownerState,
          className: classes.icon,
          children: icon || iconMapping[severity] || defaultIconMapping[severity]
        }) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(AlertMessage, {
          ownerState,
          className: classes.message,
          children
        }), action != null ? /* @__PURE__ */ jsxRuntimeExports.jsx(AlertAction, {
          ownerState,
          className: classes.action,
          children: action
        }) : null, action == null && onClose ? /* @__PURE__ */ jsxRuntimeExports.jsx(AlertAction, {
          ownerState,
          className: classes.action,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(AlertCloseButton, _extends$1({
            size: "small",
            "aria-label": closeText,
            title: closeText,
            color: "inherit",
            onClick: onClose
          }, closeButtonProps, {
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(AlertCloseIcon, _extends$1({
              fontSize: "small"
            }, closeIconProps))
          }))
        }) : null]
      }));
    });
    const Alert$1 = Alert;
    function SnackbarAlert({ msg, type, variant }) {
      const [open, setOpen] = reactExports.useState(false);
      reactExports.useEffect(() => {
        setOpen(true);
      }, []);
      const handleClose = (event, reason) => {
        if (reason === "clickaway") {
          return;
        }
        setOpen(false);
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Snackbar$1, { open, autoHideDuration: 6e3, onClose: handleClose, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Alert$1,
        {
          onClose: handleClose,
          severity: type,
          variant,
          sx: { width: "100%" },
          children: msg
        }
      ) }) });
    }
    function bind(fn, thisArg) {
      return function wrap() {
        return fn.apply(thisArg, arguments);
      };
    }
    const { toString } = Object.prototype;
    const { getPrototypeOf } = Object;
    const kindOf = /* @__PURE__ */ ((cache) => (thing) => {
      const str = toString.call(thing);
      return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    const kindOfTest = (type) => {
      type = type.toLowerCase();
      return (thing) => kindOf(thing) === type;
    };
    const typeOfTest = (type) => (thing) => typeof thing === type;
    const { isArray } = Array;
    const isUndefined = typeOfTest("undefined");
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
    }
    const isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      let result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    const isString$1 = typeOfTest("string");
    const isFunction = typeOfTest("function");
    const isNumber = typeOfTest("number");
    const isObject = (thing) => thing !== null && typeof thing === "object";
    const isBoolean = (thing) => thing === true || thing === false;
    const isPlainObject = (val) => {
      if (kindOf(val) !== "object") {
        return false;
      }
      const prototype2 = getPrototypeOf(val);
      return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
    };
    const isDate = kindOfTest("Date");
    const isFile = kindOfTest("File");
    const isBlob = kindOfTest("Blob");
    const isFileList = kindOfTest("FileList");
    const isStream = (val) => isObject(val) && isFunction(val.pipe);
    const isFormData = (thing) => {
      let kind;
      return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
      kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
    };
    const isURLSearchParams = kindOfTest("URLSearchParams");
    const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    function forEach(obj, fn, { allOwnKeys = false } = {}) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      let i;
      let l2;
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (i = 0, l2 = obj.length; i < l2; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys2.length;
        let key;
        for (i = 0; i < len; i++) {
          key = keys2[i];
          fn.call(null, obj[key], key, obj);
        }
      }
    }
    function findKey(obj, key) {
      key = key.toLowerCase();
      const keys2 = Object.keys(obj);
      let i = keys2.length;
      let _key;
      while (i-- > 0) {
        _key = keys2[i];
        if (key === _key.toLowerCase()) {
          return _key;
        }
      }
      return null;
    }
    const _global = (() => {
      if (typeof globalThis !== "undefined")
        return globalThis;
      return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
    })();
    const isContextDefined = (context) => !isUndefined(context) && context !== _global;
    function merge() {
      const { caseless } = isContextDefined(this) && this || {};
      const result = {};
      const assignValue2 = (val, key) => {
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
          result[targetKey] = merge(result[targetKey], val);
        } else if (isPlainObject(val)) {
          result[targetKey] = merge({}, val);
        } else if (isArray(val)) {
          result[targetKey] = val.slice();
        } else {
          result[targetKey] = val;
        }
      };
      for (let i = 0, l2 = arguments.length; i < l2; i++) {
        arguments[i] && forEach(arguments[i], assignValue2);
      }
      return result;
    }
    const extend = (a, b2, thisArg, { allOwnKeys } = {}) => {
      forEach(b2, (val, key) => {
        if (thisArg && isFunction(val)) {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      }, { allOwnKeys });
      return a;
    };
    const stripBOM = (content) => {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    };
    const inherits = (constructor, superConstructor, props, descriptors2) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };
    const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
      let props;
      let i;
      let prop;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null)
        return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    };
    const endsWith = (str, searchString, position2) => {
      str = String(str);
      if (position2 === void 0 || position2 > str.length) {
        position2 = str.length;
      }
      position2 -= searchString.length;
      const lastIndex = str.indexOf(searchString, position2);
      return lastIndex !== -1 && lastIndex === position2;
    };
    const toArray = (thing) => {
      if (!thing)
        return null;
      if (isArray(thing))
        return thing;
      let i = thing.length;
      if (!isNumber(i))
        return null;
      const arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    };
    const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
      return (thing) => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
    const forEachEntry = (obj, fn) => {
      const generator = obj && obj[Symbol.iterator];
      const iterator = generator.call(obj);
      let result;
      while ((result = iterator.next()) && !result.done) {
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
      }
    };
    const matchAll = (regExp, str) => {
      let matches;
      const arr = [];
      while ((matches = regExp.exec(str)) !== null) {
        arr.push(matches);
      }
      return arr;
    };
    const isHTMLForm = kindOfTest("HTMLFormElement");
    const toCamelCase = (str) => {
      return str.toLowerCase().replace(
        /[-_\s]([a-z\d])(\w*)/g,
        function replacer(m2, p1, p2) {
          return p1.toUpperCase() + p2;
        }
      );
    };
    const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
    const isRegExp = kindOfTest("RegExp");
    const reduceDescriptors = (obj, reducer) => {
      const descriptors2 = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};
      forEach(descriptors2, (descriptor, name) => {
        let ret;
        if ((ret = reducer(descriptor, name, obj)) !== false) {
          reducedDescriptors[name] = ret || descriptor;
        }
      });
      Object.defineProperties(obj, reducedDescriptors);
    };
    const freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name) => {
        if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
          return false;
        }
        const value = obj[name];
        if (!isFunction(value))
          return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not rewrite read-only method '" + name + "'");
          };
        }
      });
    };
    const toObjectSet = (arrayOrString, delimiter2) => {
      const obj = {};
      const define = (arr) => {
        arr.forEach((value) => {
          obj[value] = true;
        });
      };
      isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter2));
      return obj;
    };
    const noop$1 = () => {
    };
    const toFiniteNumber = (value, defaultValue) => {
      value = +value;
      return Number.isFinite(value) ? value : defaultValue;
    };
    const ALPHA = "abcdefghijklmnopqrstuvwxyz";
    const DIGIT = "0123456789";
    const ALPHABET = {
      DIGIT,
      ALPHA,
      ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
    };
    const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
      let str = "";
      const { length: length2 } = alphabet;
      while (size--) {
        str += alphabet[Math.random() * length2 | 0];
      }
      return str;
    };
    function isSpecCompliantForm(thing) {
      return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
    }
    const toJSONObject = (obj) => {
      const stack = new Array(10);
      const visit = (source, i) => {
        if (isObject(source)) {
          if (stack.indexOf(source) >= 0) {
            return;
          }
          if (!("toJSON" in source)) {
            stack[i] = source;
            const target = isArray(source) ? [] : {};
            forEach(source, (value, key) => {
              const reducedValue = visit(value, i + 1);
              !isUndefined(reducedValue) && (target[key] = reducedValue);
            });
            stack[i] = void 0;
            return target;
          }
        }
        return source;
      };
      return visit(obj, 0);
    };
    const isAsyncFn = kindOfTest("AsyncFunction");
    const isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
    const utils$2 = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString: isString$1,
      isNumber,
      isBoolean,
      isObject,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isRegExp,
      isFunction,
      isStream,
      isURLSearchParams,
      isTypedArray,
      isFileList,
      forEach,
      merge,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty,
      hasOwnProp: hasOwnProperty,
      // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop: noop$1,
      toFiniteNumber,
      findKey,
      global: _global,
      isContextDefined,
      ALPHABET,
      generateString,
      isSpecCompliantForm,
      toJSONObject,
      isAsyncFn,
      isThenable
    };
    function AxiosError(message, code, config2, request, response) {
      Error.call(this);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack;
      }
      this.message = message;
      this.name = "AxiosError";
      code && (this.code = code);
      config2 && (this.config = config2);
      request && (this.request = request);
      response && (this.response = response);
    }
    utils$2.inherits(AxiosError, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: utils$2.toJSONObject(this.config),
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    const prototype$1 = AxiosError.prototype;
    const descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
      // eslint-disable-next-line func-names
    ].forEach((code) => {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype$1, "isAxiosError", { value: true });
    AxiosError.from = (error, code, config2, request, response, customProps) => {
      const axiosError = Object.create(prototype$1);
      utils$2.toFlatObject(error, axiosError, function filter2(obj) {
        return obj !== Error.prototype;
      }, (prop) => {
        return prop !== "isAxiosError";
      });
      AxiosError.call(axiosError, error.message, code, config2, request, response);
      axiosError.cause = error;
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    const httpAdapter = null;
    function isVisitable(thing) {
      return utils$2.isPlainObject(thing) || utils$2.isArray(thing);
    }
    function removeBrackets(key) {
      return utils$2.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path, key, dots) {
      if (!path)
        return key;
      return path.concat(key).map(function each(token2, i) {
        token2 = removeBrackets(token2);
        return !dots && i ? "[" + token2 + "]" : token2;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr) {
      return utils$2.isArray(arr) && !arr.some(isVisitable);
    }
    const predicates = utils$2.toFlatObject(utils$2, {}, null, function filter2(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function toFormData(obj, formData, options) {
      if (!utils$2.isObject(obj)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new FormData();
      options = utils$2.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        return !utils$2.isUndefined(source[option]);
      });
      const metaTokens = options.metaTokens;
      const visitor = options.visitor || defaultVisitor;
      const dots = options.dots;
      const indexes = options.indexes;
      const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      const useBlob = _Blob && utils$2.isSpecCompliantForm(formData);
      if (!utils$2.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value) {
        if (value === null)
          return "";
        if (utils$2.isDate(value)) {
          return value.toISOString();
        }
        if (!useBlob && utils$2.isBlob(value)) {
          throw new AxiosError("Blob is not supported. Use a Buffer instead.");
        }
        if (utils$2.isArrayBuffer(value) || utils$2.isTypedArray(value)) {
          return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function defaultVisitor(value, key, path) {
        let arr = value;
        if (value && !path && typeof value === "object") {
          if (utils$2.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value = JSON.stringify(value);
          } else if (utils$2.isArray(value) && isFlatArray(value) || (utils$2.isFileList(value) || utils$2.endsWith(key, "[]")) && (arr = utils$2.toArray(value))) {
            key = removeBrackets(key);
            arr.forEach(function each(el2, index) {
              !(utils$2.isUndefined(el2) || el2 === null) && formData.append(
                // eslint-disable-next-line no-nested-ternary
                indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
                convertValue(el2)
              );
            });
            return false;
          }
        }
        if (isVisitable(value)) {
          return true;
        }
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
      }
      const stack = [];
      const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build(value, path) {
        if (utils$2.isUndefined(value))
          return;
        if (stack.indexOf(value) !== -1) {
          throw Error("Circular reference detected in " + path.join("."));
        }
        stack.push(value);
        utils$2.forEach(value, function each(el2, key) {
          const result = !(utils$2.isUndefined(el2) || el2 === null) && visitor.call(
            formData,
            el2,
            utils$2.isString(key) ? key.trim() : key,
            path,
            exposedHelpers
          );
          if (result === true) {
            build(el2, path ? path.concat(key) : [key]);
          }
        });
        stack.pop();
      }
      if (!utils$2.isObject(obj)) {
        throw new TypeError("data must be an object");
      }
      build(obj);
      return formData;
    }
    function encode$1(str) {
      const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match2) {
        return charMap[match2];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData(params, this, options);
    }
    const prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append2(name, value) {
      this._pairs.push([name, value]);
    };
    prototype.toString = function toString2(encoder) {
      const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode$1);
      } : encode$1;
      return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "").join("&");
    };
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    function buildURL(url, params, options) {
      if (!params) {
        return url;
      }
      const _encode = options && options.encode || encode;
      const serializeFn = options && options.serialize;
      let serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils$2.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
      }
      if (serializedParams) {
        const hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    }
    class InterceptorManager {
      constructor() {
        this.handlers = [];
      }
      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }
      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
       */
      eject(id2) {
        if (this.handlers[id2]) {
          this.handlers[id2] = null;
        }
      }
      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn) {
        utils$2.forEach(this.handlers, function forEachHandler(h2) {
          if (h2 !== null) {
            fn(h2);
          }
        });
      }
    }
    const transitionalDefaults = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
    const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
    const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
    const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
    const platform$1 = {
      isBrowser: true,
      classes: {
        URLSearchParams: URLSearchParams$1,
        FormData: FormData$1,
        Blob: Blob$1
      },
      protocols: ["http", "https", "file", "blob", "url", "data"]
    };
    const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
    const hasStandardBrowserEnv = ((product) => {
      return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
    })(typeof navigator !== "undefined" && navigator.product);
    const hasStandardBrowserWebWorkerEnv = (() => {
      return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
      self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
    })();
    const utils$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      hasBrowserEnv,
      hasStandardBrowserEnv,
      hasStandardBrowserWebWorkerEnv
    }, Symbol.toStringTag, { value: "Module" }));
    const platform = {
      ...utils$1,
      ...platform$1
    };
    function toURLEncodedForm(data, options) {
      return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
        visitor: function(value, key, path, helpers) {
          if (platform.isNode && utils$2.isBuffer(value)) {
            this.append(key, value.toString("base64"));
            return false;
          }
          return helpers.defaultVisitor.apply(this, arguments);
        }
      }, options));
    }
    function parsePropPath(name) {
      return utils$2.matchAll(/\w+|\[(\w*)]/g, name).map((match2) => {
        return match2[0] === "[]" ? "" : match2[1] || match2[0];
      });
    }
    function arrayToObject(arr) {
      const obj = {};
      const keys2 = Object.keys(arr);
      let i;
      const len = keys2.length;
      let key;
      for (i = 0; i < len; i++) {
        key = keys2[i];
        obj[key] = arr[key];
      }
      return obj;
    }
    function formDataToJSON(formData) {
      function buildPath(path, value, target, index) {
        let name = path[index++];
        if (name === "__proto__")
          return true;
        const isNumericKey = Number.isFinite(+name);
        const isLast = index >= path.length;
        name = !name && utils$2.isArray(target) ? target.length : name;
        if (isLast) {
          if (utils$2.hasOwnProp(target, name)) {
            target[name] = [target[name], value];
          } else {
            target[name] = value;
          }
          return !isNumericKey;
        }
        if (!target[name] || !utils$2.isObject(target[name])) {
          target[name] = [];
        }
        const result = buildPath(path, value, target[name], index);
        if (result && utils$2.isArray(target[name])) {
          target[name] = arrayToObject(target[name]);
        }
        return !isNumericKey;
      }
      if (utils$2.isFormData(formData) && utils$2.isFunction(formData.entries)) {
        const obj = {};
        utils$2.forEachEntry(formData, (name, value) => {
          buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
      }
      return null;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils$2.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils$2.trim(rawValue);
        } catch (e2) {
          if (e2.name !== "SyntaxError") {
            throw e2;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    const defaults = {
      transitional: transitionalDefaults,
      adapter: ["xhr", "http"],
      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils$2.isObject(data);
        if (isObjectPayload && utils$2.isHTMLForm(data)) {
          data = new FormData(data);
        }
        const isFormData2 = utils$2.isFormData(data);
        if (isFormData2) {
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
        }
        if (utils$2.isArrayBuffer(data) || utils$2.isBuffer(data) || utils$2.isStream(data) || utils$2.isFile(data) || utils$2.isBlob(data)) {
          return data;
        }
        if (utils$2.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils$2.isURLSearchParams(data)) {
          headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
          return data.toString();
        }
        let isFileList2;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }
          if ((isFileList2 = utils$2.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
            const _FormData = this.env && this.env.FormData;
            return toFormData(
              isFileList2 ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        const transitional = this.transitional || defaults.transitional;
        const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";
        if (data && utils$2.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          const silentJSONParsing = transitional && transitional.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data);
          } catch (e2) {
            if (strictJSONParsing) {
              if (e2.name === "SyntaxError") {
                throw AxiosError.from(e2, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e2;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*",
          "Content-Type": void 0
        }
      }
    };
    utils$2.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
      defaults.headers[method] = {};
    });
    const defaults$1 = defaults;
    const ignoreDuplicateOf = utils$2.toObjectSet([
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]);
    const parseHeaders = (rawHeaders) => {
      const parsed = {};
      let key;
      let val;
      let i;
      rawHeaders && rawHeaders.split("\n").forEach(function parser(line2) {
        i = line2.indexOf(":");
        key = line2.substring(0, i).trim().toLowerCase();
        val = line2.substring(i + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
          return;
        }
        if (key === "set-cookie") {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      });
      return parsed;
    };
    const $internals = Symbol("internals");
    function normalizeHeader(header) {
      return header && String(header).trim().toLowerCase();
    }
    function normalizeValue(value) {
      if (value === false || value == null) {
        return value;
      }
      return utils$2.isArray(value) ? value.map(normalizeValue) : String(value);
    }
    function parseTokens(str) {
      const tokens = /* @__PURE__ */ Object.create(null);
      const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
      let match2;
      while (match2 = tokensRE.exec(str)) {
        tokens[match2[1]] = match2[2];
      }
      return tokens;
    }
    const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
    function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
      if (utils$2.isFunction(filter2)) {
        return filter2.call(this, value, header);
      }
      if (isHeaderNameFilter) {
        value = header;
      }
      if (!utils$2.isString(value))
        return;
      if (utils$2.isString(filter2)) {
        return value.indexOf(filter2) !== -1;
      }
      if (utils$2.isRegExp(filter2)) {
        return filter2.test(value);
      }
    }
    function formatHeader(header) {
      return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char2, str) => {
        return char2.toUpperCase() + str;
      });
    }
    function buildAccessors(obj, header) {
      const accessorName = utils$2.toCamelCase(" " + header);
      ["get", "set", "has"].forEach((methodName) => {
        Object.defineProperty(obj, methodName + accessorName, {
          value: function(arg1, arg2, arg3) {
            return this[methodName].call(this, header, arg1, arg2, arg3);
          },
          configurable: true
        });
      });
    }
    class AxiosHeaders {
      constructor(headers) {
        headers && this.set(headers);
      }
      set(header, valueOrRewrite, rewrite) {
        const self2 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error("header name must be a non-empty string");
          }
          const key = utils$2.findKey(self2, lHeader);
          if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
            self2[key || _header] = normalizeValue(_value);
          }
        }
        const setHeaders = (headers, _rewrite) => utils$2.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
        if (utils$2.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if (utils$2.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders(header), valueOrRewrite);
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      }
      get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$2.findKey(this, header);
          if (key) {
            const value = this[key];
            if (!parser) {
              return value;
            }
            if (parser === true) {
              return parseTokens(value);
            }
            if (utils$2.isFunction(parser)) {
              return parser.call(this, value, key);
            }
            if (utils$2.isRegExp(parser)) {
              return parser.exec(value);
            }
            throw new TypeError("parser must be boolean|regexp|function");
          }
        }
      }
      has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$2.findKey(this, header);
          return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
      }
      delete(header, matcher) {
        const self2 = this;
        let deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            const key = utils$2.findKey(self2, _header);
            if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
              delete self2[key];
              deleted = true;
            }
          }
        }
        if (utils$2.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }
        return deleted;
      }
      clear(matcher) {
        const keys2 = Object.keys(this);
        let i = keys2.length;
        let deleted = false;
        while (i--) {
          const key = keys2[i];
          if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
            delete this[key];
            deleted = true;
          }
        }
        return deleted;
      }
      normalize(format) {
        const self2 = this;
        const headers = {};
        utils$2.forEach(this, (value, header) => {
          const key = utils$2.findKey(headers, header);
          if (key) {
            self2[key] = normalizeValue(value);
            delete self2[header];
            return;
          }
          const normalized = format ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self2[header];
          }
          self2[normalized] = normalizeValue(value);
          headers[normalized] = true;
        });
        return this;
      }
      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }
      toJSON(asStrings) {
        const obj = /* @__PURE__ */ Object.create(null);
        utils$2.forEach(this, (value, header) => {
          value != null && value !== false && (obj[header] = asStrings && utils$2.isArray(value) ? value.join(", ") : value);
        });
        return obj;
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
      }
      get [Symbol.toStringTag]() {
        return "AxiosHeaders";
      }
      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
      static concat(first, ...targets) {
        const computed = new this(first);
        targets.forEach((target) => computed.set(target));
        return computed;
      }
      static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        const accessors = internals.accessors;
        const prototype2 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype2, _header);
            accessors[lHeader] = true;
          }
        }
        utils$2.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    }
    AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
    utils$2.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
      let mapped = key[0].toUpperCase() + key.slice(1);
      return {
        get: () => value,
        set(headerValue) {
          this[mapped] = headerValue;
        }
      };
    });
    utils$2.freezeMethods(AxiosHeaders);
    const AxiosHeaders$1 = AxiosHeaders;
    function transformData(fns, response) {
      const config2 = this || defaults$1;
      const context = response || config2;
      const headers = AxiosHeaders$1.from(context.headers);
      let data = context.data;
      utils$2.forEach(fns, function transform(fn) {
        data = fn.call(config2, data, headers.normalize(), response ? response.status : void 0);
      });
      headers.normalize();
      return data;
    }
    function isCancel(value) {
      return !!(value && value.__CANCEL__);
    }
    function CanceledError(message, config2, request) {
      AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config2, request);
      this.name = "CanceledError";
    }
    utils$2.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    function settle(resolve, reject, response) {
      const validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    }
    const cookies = platform.hasStandardBrowserEnv ? (
      // Standard browser envs support document.cookie
      {
        write(name, value, expires, path, domain, secure) {
          const cookie = [name + "=" + encodeURIComponent(value)];
          utils$2.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
          utils$2.isString(path) && cookie.push("path=" + path);
          utils$2.isString(domain) && cookie.push("domain=" + domain);
          secure === true && cookie.push("secure");
          document.cookie = cookie.join("; ");
        },
        read(name) {
          const match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match2 ? decodeURIComponent(match2[3]) : null;
        },
        remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      }
    ) : (
      // Non-standard browser env (web workers, react-native) lack needed support.
      {
        write() {
        },
        read() {
          return null;
        },
        remove() {
        }
      }
    );
    function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    }
    function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    }
    function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    }
    const isURLSameOrigin = platform.hasStandardBrowserEnv ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        const msie = /(msie|trident)/i.test(navigator.userAgent);
        const urlParsingNode = document.createElement("a");
        let originURL;
        function resolveURL(url) {
          let href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin2(requestURL) {
          const parsed = utils$2.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      /* @__PURE__ */ function nonStandardBrowserEnv() {
        return function isURLSameOrigin2() {
          return true;
        };
      }()
    );
    function parseProtocol(url) {
      const match2 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
      return match2 && match2[1] || "";
    }
    function speedometer(samplesCount, min2) {
      samplesCount = samplesCount || 10;
      const bytes = new Array(samplesCount);
      const timestamps = new Array(samplesCount);
      let head = 0;
      let tail = 0;
      let firstSampleTS;
      min2 = min2 !== void 0 ? min2 : 1e3;
      return function push(chunkLength) {
        const now2 = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) {
          firstSampleTS = now2;
        }
        bytes[head] = chunkLength;
        timestamps[head] = now2;
        let i = tail;
        let bytesCount = 0;
        while (i !== head) {
          bytesCount += bytes[i++];
          i = i % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) {
          tail = (tail + 1) % samplesCount;
        }
        if (now2 - firstSampleTS < min2) {
          return;
        }
        const passed = startedAt && now2 - startedAt;
        return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
      };
    }
    function progressEventReducer(listener, isDownloadStream) {
      let bytesNotified = 0;
      const _speedometer = speedometer(50, 250);
      return (e2) => {
        const loaded = e2.loaded;
        const total = e2.lengthComputable ? e2.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
          loaded,
          total,
          progress: total ? loaded / total : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
          event: e2
        };
        data[isDownloadStream ? "download" : "upload"] = true;
        listener(data);
      };
    }
    const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
    const xhrAdapter = isXHRAdapterSupported && function(config2) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        let requestData = config2.data;
        const requestHeaders = AxiosHeaders$1.from(config2.headers).normalize();
        let { responseType, withXSRFToken } = config2;
        let onCanceled;
        function done() {
          if (config2.cancelToken) {
            config2.cancelToken.unsubscribe(onCanceled);
          }
          if (config2.signal) {
            config2.signal.removeEventListener("abort", onCanceled);
          }
        }
        let contentType;
        if (utils$2.isFormData(requestData)) {
          if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
            requestHeaders.setContentType(false);
          } else if ((contentType = requestHeaders.getContentType()) !== false) {
            const [type, ...tokens] = contentType ? contentType.split(";").map((token2) => token2.trim()).filter(Boolean) : [];
            requestHeaders.setContentType([type || "multipart/form-data", ...tokens].join("; "));
          }
        }
        let request = new XMLHttpRequest();
        if (config2.auth) {
          const username = config2.auth.username || "";
          const password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
          requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
        }
        const fullPath = buildFullPath(config2.baseURL, config2.url);
        request.open(config2.method.toUpperCase(), buildURL(fullPath, config2.params, config2.paramsSerializer), true);
        request.timeout = config2.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          const responseHeaders = AxiosHeaders$1.from(
            "getAllResponseHeaders" in request && request.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config: config2,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config2, request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config2, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
          const transitional = config2.transitional || transitionalDefaults;
          if (config2.timeoutErrorMessage) {
            timeoutErrorMessage = config2.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config2,
            request
          ));
          request = null;
        };
        if (platform.hasStandardBrowserEnv) {
          withXSRFToken && utils$2.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config2));
          if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(fullPath)) {
            const xsrfValue = config2.xsrfHeaderName && config2.xsrfCookieName && cookies.read(config2.xsrfCookieName);
            if (xsrfValue) {
              requestHeaders.set(config2.xsrfHeaderName, xsrfValue);
            }
          }
        }
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request) {
          utils$2.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
          });
        }
        if (!utils$2.isUndefined(config2.withCredentials)) {
          request.withCredentials = !!config2.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config2.responseType;
        }
        if (typeof config2.onDownloadProgress === "function") {
          request.addEventListener("progress", progressEventReducer(config2.onDownloadProgress, true));
        }
        if (typeof config2.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", progressEventReducer(config2.onUploadProgress));
        }
        if (config2.cancelToken || config2.signal) {
          onCanceled = (cancel) => {
            if (!request) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError(null, config2, request) : cancel);
            request.abort();
            request = null;
          };
          config2.cancelToken && config2.cancelToken.subscribe(onCanceled);
          if (config2.signal) {
            config2.signal.aborted ? onCanceled() : config2.signal.addEventListener("abort", onCanceled);
          }
        }
        const protocol = parseProtocol(fullPath);
        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config2));
          return;
        }
        request.send(requestData || null);
      });
    };
    const knownAdapters = {
      http: httpAdapter,
      xhr: xhrAdapter
    };
    utils$2.forEach(knownAdapters, (fn, value) => {
      if (fn) {
        try {
          Object.defineProperty(fn, "name", { value });
        } catch (e2) {
        }
        Object.defineProperty(fn, "adapterName", { value });
      }
    });
    const renderReason = (reason) => `- ${reason}`;
    const isResolvedHandle = (adapter) => utils$2.isFunction(adapter) || adapter === null || adapter === false;
    const adapters = {
      getAdapter: (adapters2) => {
        adapters2 = utils$2.isArray(adapters2) ? adapters2 : [adapters2];
        const { length: length2 } = adapters2;
        let nameOrAdapter;
        let adapter;
        const rejectedReasons = {};
        for (let i = 0; i < length2; i++) {
          nameOrAdapter = adapters2[i];
          let id2;
          adapter = nameOrAdapter;
          if (!isResolvedHandle(nameOrAdapter)) {
            adapter = knownAdapters[(id2 = String(nameOrAdapter)).toLowerCase()];
            if (adapter === void 0) {
              throw new AxiosError(`Unknown adapter '${id2}'`);
            }
          }
          if (adapter) {
            break;
          }
          rejectedReasons[id2 || "#" + i] = adapter;
        }
        if (!adapter) {
          const reasons = Object.entries(rejectedReasons).map(
            ([id2, state]) => `adapter ${id2} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
          );
          let s = length2 ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
          throw new AxiosError(
            `There is no suitable adapter to dispatch the request ` + s,
            "ERR_NOT_SUPPORT"
          );
        }
        return adapter;
      },
      adapters: knownAdapters
    };
    function throwIfCancellationRequested(config2) {
      if (config2.cancelToken) {
        config2.cancelToken.throwIfRequested();
      }
      if (config2.signal && config2.signal.aborted) {
        throw new CanceledError(null, config2);
      }
    }
    function dispatchRequest(config2) {
      throwIfCancellationRequested(config2);
      config2.headers = AxiosHeaders$1.from(config2.headers);
      config2.data = transformData.call(
        config2,
        config2.transformRequest
      );
      if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
        config2.headers.setContentType("application/x-www-form-urlencoded", false);
      }
      const adapter = adapters.getAdapter(config2.adapter || defaults$1.adapter);
      return adapter(config2).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config2);
        response.data = transformData.call(
          config2,
          config2.transformResponse,
          response
        );
        response.headers = AxiosHeaders$1.from(response.headers);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config2);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config2,
              config2.transformResponse,
              reason.response
            );
            reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
          }
        }
        return Promise.reject(reason);
      });
    }
    const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
    function mergeConfig(config1, config2) {
      config2 = config2 || {};
      const config3 = {};
      function getMergedValue(target, source, caseless) {
        if (utils$2.isPlainObject(target) && utils$2.isPlainObject(source)) {
          return utils$2.merge.call({ caseless }, target, source);
        } else if (utils$2.isPlainObject(source)) {
          return utils$2.merge({}, source);
        } else if (utils$2.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(a, b2, caseless) {
        if (!utils$2.isUndefined(b2)) {
          return getMergedValue(a, b2, caseless);
        } else if (!utils$2.isUndefined(a)) {
          return getMergedValue(void 0, a, caseless);
        }
      }
      function valueFromConfig2(a, b2) {
        if (!utils$2.isUndefined(b2)) {
          return getMergedValue(void 0, b2);
        }
      }
      function defaultToConfig2(a, b2) {
        if (!utils$2.isUndefined(b2)) {
          return getMergedValue(void 0, b2);
        } else if (!utils$2.isUndefined(a)) {
          return getMergedValue(void 0, a);
        }
      }
      function mergeDirectKeys(a, b2, prop) {
        if (prop in config2) {
          return getMergedValue(a, b2);
        } else if (prop in config1) {
          return getMergedValue(void 0, a);
        }
      }
      const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        withXSRFToken: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a, b2) => mergeDeepProperties(headersToObject(a), headersToObject(b2), true)
      };
      utils$2.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
        const merge2 = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge2(config1[prop], config2[prop], prop);
        utils$2.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
      });
      return config3;
    }
    const VERSION = "1.6.7";
    const validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
      validators$1[type] = function validator2(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    const deprecatedWarnings = {};
    validators$1.transitional = function transitional(validator2, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return (value, opt, opts) => {
        if (validator2 === false) {
          throw new AxiosError(
            formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      const keys2 = Object.keys(options);
      let i = keys2.length;
      while (i-- > 0) {
        const opt = keys2[i];
        const validator2 = schema[opt];
        if (validator2) {
          const value = options[opt];
          const result = value === void 0 || validator2(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    const validator = {
      assertOptions,
      validators: validators$1
    };
    const validators = validator.validators;
    class Axios {
      constructor(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager(),
          response: new InterceptorManager()
        };
      }
      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      async request(configOrUrl, config2) {
        try {
          return await this._request(configOrUrl, config2);
        } catch (err) {
          if (err instanceof Error) {
            let dummy;
            Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
            const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
            if (!err.stack) {
              err.stack = stack;
            } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
              err.stack += "\n" + stack;
            }
          }
          throw err;
        }
      }
      _request(configOrUrl, config2) {
        if (typeof configOrUrl === "string") {
          config2 = config2 || {};
          config2.url = configOrUrl;
        } else {
          config2 = configOrUrl || {};
        }
        config2 = mergeConfig(this.defaults, config2);
        const { transitional, paramsSerializer, headers } = config2;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        if (paramsSerializer != null) {
          if (utils$2.isFunction(paramsSerializer)) {
            config2.paramsSerializer = {
              serialize: paramsSerializer
            };
          } else {
            validator.assertOptions(paramsSerializer, {
              encode: validators.function,
              serialize: validators.function
            }, true);
          }
        }
        config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
        let contextHeaders = headers && utils$2.merge(
          headers.common,
          headers[config2.method]
        );
        headers && utils$2.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (method) => {
            delete headers[method];
          }
        );
        config2.headers = AxiosHeaders$1.concat(contextHeaders, headers);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest.bind(this), void 0];
          chain.unshift.apply(chain, requestInterceptorChain);
          chain.push.apply(chain, responseInterceptorChain);
          len = chain.length;
          promise = Promise.resolve(config2);
          while (i < len) {
            promise = promise.then(chain[i++], chain[i++]);
          }
          return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config2;
        i = 0;
        while (i < len) {
          const onFulfilled = requestInterceptorChain[i++];
          const onRejected = requestInterceptorChain[i++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }
        try {
          promise = dispatchRequest.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while (i < len) {
          promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        }
        return promise;
      }
      getUri(config2) {
        config2 = mergeConfig(this.defaults, config2);
        const fullPath = buildFullPath(config2.baseURL, config2.url);
        return buildURL(fullPath, config2.params, config2.paramsSerializer);
      }
    }
    utils$2.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config2) {
        return this.request(mergeConfig(config2 || {}, {
          method,
          url,
          data: (config2 || {}).data
        }));
      };
    });
    utils$2.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config2) {
          return this.request(mergeConfig(config2 || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    const Axios$1 = Axios;
    class CancelToken {
      constructor(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        const token2 = this;
        this.promise.then((cancel) => {
          if (!token2._listeners)
            return;
          let i = token2._listeners.length;
          while (i-- > 0) {
            token2._listeners[i](cancel);
          }
          token2._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve;
          const promise = new Promise((resolve) => {
            token2.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token2.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message, config2, request) {
          if (token2.reason) {
            return;
          }
          token2.reason = new CanceledError(message, config2, request);
          resolvePromise(token2.reason);
        });
      }
      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      /**
       * Subscribe to the cancel signal
       */
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      /**
       * Unsubscribe from the cancel signal
       */
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index = this._listeners.indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      }
      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel;
        const token2 = new CancelToken(function executor(c2) {
          cancel = c2;
        });
        return {
          token: token2,
          cancel
        };
      }
    }
    const CancelToken$1 = CancelToken;
    function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    }
    function isAxiosError(payload) {
      return utils$2.isObject(payload) && payload.isAxiosError === true;
    }
    const HttpStatusCode = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511
    };
    Object.entries(HttpStatusCode).forEach(([key, value]) => {
      HttpStatusCode[value] = key;
    });
    const HttpStatusCode$1 = HttpStatusCode;
    function createInstance(defaultConfig) {
      const context = new Axios$1(defaultConfig);
      const instance2 = bind(Axios$1.prototype.request, context);
      utils$2.extend(instance2, Axios$1.prototype, context, { allOwnKeys: true });
      utils$2.extend(instance2, context, null, { allOwnKeys: true });
      instance2.create = function create2(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance2;
    }
    const axios = createInstance(defaults$1);
    axios.Axios = Axios$1;
    axios.CanceledError = CanceledError;
    axios.CancelToken = CancelToken$1;
    axios.isCancel = isCancel;
    axios.VERSION = VERSION;
    axios.toFormData = toFormData;
    axios.AxiosError = AxiosError;
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;
    axios.isAxiosError = isAxiosError;
    axios.mergeConfig = mergeConfig;
    axios.AxiosHeaders = AxiosHeaders$1;
    axios.formToJSON = (thing) => formDataToJSON(utils$2.isHTMLForm(thing) ? new FormData(thing) : thing);
    axios.getAdapter = adapters.getAdapter;
    axios.HttpStatusCode = HttpStatusCode$1;
    axios.default = axios;
    const base_url = "https://booking.bmich.com/api/";
    const instance = axios.create({
      baseURL: base_url,
      timeout: 1e5,
      withCredentials: true
    });
    const Copyright = () => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: "copyright", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
        "© Copyright ",
        (/* @__PURE__ */ new Date()).getFullYear(),
        ". BMICH. All Rights Reserved | ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "https://visionarydv.com/", target: "_blank", style: { color: "inherit" }, children: "VDV" })
      ] }) });
    };
    const Login = () => {
      const navigation = useNavigate();
      const [err, setErr] = reactExports.useState({ open: false, msg: "" });
      const [success, setSuccess] = reactExports.useState(false);
      const [loading, setLoading] = reactExports.useState(false);
      const login = async (values22) => {
        setErr({ open: false, msg: "" });
        setLoading(true);
        try {
          const data = {
            email: values22.email,
            password: values22.password
          };
          const res = await instance.post("/customer/login", data);
          if (res.status === 200) {
            navigation("/?login=success");
            setLoading(false);
          }
          setLoading(false);
        } catch (err2) {
          console.log(err2);
          if (err2.response.status === 400 && err2.response.data.message === "Invalid email or password") {
            setErr({ open: true, msg: "Login failed" });
            setFieldError("email", "Invalid email or password");
            setLoading(false);
            return;
          }
          setErr({ open: true, msg: "Login failed" });
          setLoading(false);
        }
      };
      const { values: values2, errors, handleChange, touched, handleBlur, handleSubmit, setFieldValue, resetForm, setFieldError } = useFormik({
        initialValues: {
          email: "",
          password: ""
        },
        onSubmit: (values22) => login(values22),
        validationSchema: LoginFormValidation
      });
      reactExports.useEffect(() => {
        setSuccess(false);
        const url = window.location.href;
        if (url.includes("registered=success")) {
          setSuccess(true);
        }
      }, []);
      const fields = [
        {
          _id: 1,
          label: "Email",
          type: "email",
          name: "email",
          value: values2.email,
          error: errors.email,
          touched: touched.email,
          required: true,
          onChange: handleChange,
          onBlur: handleBlur
        },
        {
          _id: 2,
          label: "Password",
          type: "password",
          name: "password",
          value: values2.password,
          error: errors.password,
          touched: touched.password,
          required: true,
          onChange: handleChange,
          onBlur: handleBlur
        }
      ];
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { id: "login", children: [
        err.open && /* @__PURE__ */ jsxRuntimeExports.jsx(SnackbarAlert, { msg: err.msg, type: "error", variant: "filled" }),
        success && /* @__PURE__ */ jsxRuntimeExports.jsx(SnackbarAlert, { msg: "Registration Success", type: "success", variant: "filled" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "book-venue-btn", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => navigation("/"), children: "Book a Venue" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card-container", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "left column", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: Image, alt: "image" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "right column", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "head", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "logo", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: Logo$1, alt: "logo" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "LOGIN TO YOUR ACCOUNT" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "form-container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, children: [
              fields.map((field, index) => {
                return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { width: "100%" }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { htmlFor: field.name, className: "col-3  mb-1", children: [
                    field.label,
                    " ",
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "require", children: "*" })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: field.type,
                      className: `form-control ${field.error && field.touched ? "is-invalid" : "custom-input"}`,
                      id: field.name,
                      name: field.name,
                      value: field.value,
                      onChange: field.onChange,
                      onBlur: field.onBlur
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: field.touched && field.error ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "red" }, children: field.error }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { height: "20px" } }) })
                ] }, index);
              }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/forgot-password", className: "for-passwd", children: "Forgot your password?" }),
              loading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { class: "submit-button", type: "button", disabled: true, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { class: "spinner-border spinner-border-sm mx-1", role: "status", "aria-hidden": "true" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { class: "sr-only", children: "Login..." })
              ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "submit", className: "submit-button", children: "Login" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Link, { to: "/register", className: "for-sign-up-link", children: [
                "Don't have an account? ",
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Register here" })
              ] })
            ] }) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Copyright, {})
      ] });
    };
    const Register = () => {
      const navigation = useNavigate();
      const [error, setError] = reactExports.useState(false);
      const [registrationSuccess, setRegistrationSuccess] = reactExports.useState(false);
      const [loading, setLoading] = reactExports.useState(false);
      const register = async (values22) => {
        setError(false);
        setLoading(true);
        try {
          const data = {
            name: values22.name,
            email: values22.email,
            password: values22.password,
            confirmPassword: values22.confirmPassword
          };
          const res = await instance.post("/customer/register", data);
          if (res.status === 200) {
            try {
              const res2 = await instance.post(`/customer/activation-link/${data.email}`);
              if (res2.status === 200) {
                setRegistrationSuccess(true);
              }
            } catch (err) {
              console.log(err);
            }
          }
          setLoading(false);
        } catch (err) {
          console.log(err);
          if (err.response.status === 400 && err.response.data.message === "Email address already exists") {
            setFieldError("email", "Email address already exists");
            setLoading(false);
          }
          setError(true);
          setLoading(false);
        }
      };
      const { values: values2, errors, handleChange, touched, handleBlur, handleSubmit, setFieldValue, resetForm, setFieldError } = useFormik({
        initialValues: {
          name: "",
          email: "",
          password: "",
          confirmPassword: ""
        },
        validationSchema: RegisterFormValidation,
        onSubmit: (values22) => register(values22)
      });
      const fields = [
        {
          _id: 1,
          label: "Name",
          type: "name",
          name: "name",
          value: values2.name,
          error: errors.name,
          touched: touched.name,
          onChange: handleChange,
          onBlur: handleBlur
        },
        {
          _id: 2,
          label: "Email",
          type: "email",
          name: "email",
          value: values2.email,
          error: errors.email,
          touched: touched.email,
          onChange: handleChange,
          onBlur: handleBlur
        },
        {
          _id: 3,
          label: "Password",
          type: "password",
          name: "password",
          value: values2.password,
          error: errors.password,
          touched: touched.password,
          onChange: handleChange,
          onBlur: handleBlur
        },
        {
          _id: 4,
          label: "Confirm Password",
          type: "password",
          name: "confirmPassword",
          value: values2.confirmPassword,
          error: errors.confirmPassword,
          touched: touched.confirmPassword,
          onChange: handleChange,
          onBlur: handleBlur
        }
      ];
      if (registrationSuccess) {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { id: "registrationSuccess", style: {
          display: "flex",
          flexDirection: "column",
          justifyContent: "center",
          alignItems: "center",
          height: "100vh"
        }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Thanks for your registration. Please check you emails for the confirmation email." }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/", style: { color: "#000" }, children: "Home" })
        ] });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { id: "register", children: [
        error && /* @__PURE__ */ jsxRuntimeExports.jsx(SnackbarAlert, { msg: "Registration failed", type: "error", variant: "filled" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "book-venue-btn", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => navigation("/"), children: "Book a Venue" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card-container", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "left column", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: Image, alt: "image" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "right column", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "head", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "logo", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: Logo$1, alt: "logo" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "CREATE YOUR ACCOUNT" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "form-container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, children: [
              fields.map((field, index) => {
                return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { width: "100%" }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { htmlFor: field.name, className: "col-3  mb-1", style: { width: "200px" }, children: [
                    field.label,
                    " ",
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "require", children: "*" })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: field.type,
                      className: `form-control ${field.error && field.touched ? "is-invalid" : "custom-input"}`,
                      id: field.name,
                      name: field.name,
                      value: field.value,
                      onChange: field.onChange,
                      onBlur: field.onBlur
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: field.touched && field.error ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "red" }, children: field.error }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { height: "20px" } }) })
                ] }, index);
              }),
              loading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { class: "submit-button", type: "button", disabled: true, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { class: "spinner-border spinner-border-sm mx-1", role: "status", "aria-hidden": "true" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { class: "sr-only", children: "Registering..." })
              ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "submit", className: "submit-button", children: "Register" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Link, { to: "/login", className: "for-sign-up-link", children: [
                "Do you have an account? ",
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Login here" })
              ] })
            ] }) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Copyright, {})
      ] });
    };
    const venue_type = [
      { value: "graduations", label: "Graduations" },
      { value: "music_concerts", label: "Music Concerts" },
      { value: "awards_ceremonies", label: "Awards Ceremonies" },
      { value: "conventions", label: "Conventions" },
      { value: "dramas", label: "Dramas" },
      { value: "beauty_pageants", label: "Beauty Pageants" },
      { value: "cocktails", label: "Cocktails" },
      { value: "lunch_dinner", label: "Lunch/Dinner" },
      { value: "exhibitions", label: "Exhibitions" },
      { value: "fairs", label: "Fairs" },
      { value: "launching_ceremonies", label: "Launching Ceremonies" },
      { value: "sing_alongs", label: "Sing Alongs" },
      { value: "wedding_receptions", label: "Wedding Receptions" },
      { value: "parties", label: "Parties" },
      { value: "alms_givings", label: "Alms Givings" },
      { value: "seminars", label: "Seminars" },
      { value: "conferences", label: "Conferences" },
      { value: "annual_general_meetings", label: "Annual General meetings" },
      { value: "workshops", label: "Workshops" },
      { value: "vip_refreshments", label: "VIP Refreshments" },
      { value: "examinations", label: "Examinations" },
      { value: "cinemas", label: "Cinemas" },
      { value: "dressing", label: "Dressing" },
      { value: "meeting", label: "Meeting" },
      { value: "auction", label: "Auction" }
    ];
    const Video = "/assets/BMICH-video-wDwr4HSa.mp4";
    const Welcome = () => {
      const navigation = useNavigate();
      const [msg, setMsg] = reactExports.useState({ open: false, msg: "", type: "" });
      const submit = ({ venue_type: venue_type2, start_date, end_date }) => {
        navigation(`/venues?check=abc&venue_type=${venue_type2}&start_date=${start_date}&end_date=${end_date}`);
      };
      const { values: values2, errors, handleChange, touched, handleBlur, handleSubmit, setFieldValue, resetForm, setFieldError } = useFormik({
        initialValues: {
          venue_type: "all",
          start_date: "",
          end_date: ""
        },
        onSubmit: (values22) => submit(values22),
        validationSchema: WelcomePageFormValidation
      });
      reactExports.useEffect(() => {
        const url = window.location.href;
        if (url.includes("login=success")) {
          setMsg({ open: true, text: "Login Success", type: "success" });
        }
      }, []);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { id: "welcome", children: [
        msg.open && /* @__PURE__ */ jsxRuntimeExports.jsx(SnackbarAlert, { msg: msg.text, type: msg.type, variant: "filled" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "top-margin" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content-new", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("video", { autoPlay: true, loop: true, muted: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx("source", { src: Video, type: "video/mp4" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: "Book a Venue" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { className: "inputs", onSubmit: handleSubmit, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "row", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "type-of-event", children: "Type of Event" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "select",
                  {
                    className: "form-select",
                    "aria-label": "type-of-event",
                    id: "type-of-event",
                    name: "venue_type",
                    onChange: handleChange,
                    onBlur: handleBlur,
                    value: values2.venue_type,
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "all", children: " All " }),
                      venue_type.map((option, index) => {
                        return /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: option.value, children: option.label }, index);
                      })
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: touched.venue_type && errors.venue_type ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "red" }, children: errors.venue_type }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { height: "20px" } }) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "row", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "startDate", children: "Start Date" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    id: "startDate",
                    className: "form-control",
                    type: "date",
                    name: "start_date",
                    value: values2.start_date,
                    onChange: handleChange,
                    onBlur: handleBlur
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: touched.start_date && errors.start_date ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "red" }, children: errors.start_date }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { height: "20px" } }) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "row", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "endDate", children: "End Date" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    id: "endDate",
                    className: "form-control",
                    type: "date",
                    name: "end_date",
                    value: values2.end_date,
                    onChange: handleChange,
                    onBlur: handleBlur
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: touched.end_date && errors.end_date ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "red" }, children: errors.end_date }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { height: "20px" } }) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "submit", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "submit", className: "btn btn-primary", children: "Submit" }) })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "copyright", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Copyright, {}) })
      ] });
    };
    const Logo = "/assets/Logo-5YV_IVr1.png";
    var DefaultContext = {
      color: void 0,
      size: void 0,
      className: void 0,
      style: void 0,
      attr: void 0
    };
    var IconContext = React.createContext && /* @__PURE__ */ React.createContext(DefaultContext);
    var _excluded$T = ["attr", "size", "title"];
    function _objectWithoutProperties(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose(source, excluded);
      var key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function ownKeys(e2, r2) {
      var t2 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e2);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread(e2) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
          _defineProperty(e2, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e2;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function Tree2Element(tree) {
      return tree && tree.map((node2, i) => /* @__PURE__ */ React.createElement(node2.tag, _objectSpread({
        key: i
      }, node2.attr), Tree2Element(node2.child)));
    }
    function GenIcon(data) {
      return (props) => /* @__PURE__ */ React.createElement(IconBase, _extends({
        attr: _objectSpread({}, data.attr)
      }, props), Tree2Element(data.child));
    }
    function IconBase(props) {
      var elem = (conf) => {
        var {
          attr,
          size,
          title
        } = props, svgProps = _objectWithoutProperties(props, _excluded$T);
        var computedSize = size || conf.size || "1em";
        var className;
        if (conf.className)
          className = conf.className;
        if (props.className)
          className = (className ? className + " " : "") + props.className;
        return /* @__PURE__ */ React.createElement("svg", _extends({
          stroke: "currentColor",
          fill: "currentColor",
          strokeWidth: "0"
        }, conf.attr, attr, svgProps, {
          className,
          style: _objectSpread(_objectSpread({
            color: props.color || conf.color
          }, conf.style), props.style),
          height: computedSize,
          width: computedSize,
          xmlns: "http://www.w3.org/2000/svg"
        }), title && /* @__PURE__ */ React.createElement("title", null, title), props.children);
      };
      return IconContext !== void 0 ? /* @__PURE__ */ React.createElement(IconContext.Consumer, null, (conf) => elem(conf)) : elem(DefaultContext);
    }
    function RxAvatar(props) {
      return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 15 15", "fill": "none" }, "child": [{ "tag": "path", "attr": { "fillRule": "evenodd", "clipRule": "evenodd", "d": "M0.877014 7.49988C0.877014 3.84219 3.84216 0.877045 7.49985 0.877045C11.1575 0.877045 14.1227 3.84219 14.1227 7.49988C14.1227 11.1575 11.1575 14.1227 7.49985 14.1227C3.84216 14.1227 0.877014 11.1575 0.877014 7.49988ZM7.49985 1.82704C4.36683 1.82704 1.82701 4.36686 1.82701 7.49988C1.82701 8.97196 2.38774 10.3131 3.30727 11.3213C4.19074 9.94119 5.73818 9.02499 7.50023 9.02499C9.26206 9.02499 10.8093 9.94097 11.6929 11.3208C12.6121 10.3127 13.1727 8.97172 13.1727 7.49988C13.1727 4.36686 10.6328 1.82704 7.49985 1.82704ZM10.9818 11.9787C10.2839 10.7795 8.9857 9.97499 7.50023 9.97499C6.01458 9.97499 4.71624 10.7797 4.01845 11.9791C4.97952 12.7272 6.18765 13.1727 7.49985 13.1727C8.81227 13.1727 10.0206 12.727 10.9818 11.9787ZM5.14999 6.50487C5.14999 5.207 6.20212 4.15487 7.49999 4.15487C8.79786 4.15487 9.84999 5.207 9.84999 6.50487C9.84999 7.80274 8.79786 8.85487 7.49999 8.85487C6.20212 8.85487 5.14999 7.80274 5.14999 6.50487ZM7.49999 5.10487C6.72679 5.10487 6.09999 5.73167 6.09999 6.50487C6.09999 7.27807 6.72679 7.90487 7.49999 7.90487C8.27319 7.90487 8.89999 7.27807 8.89999 6.50487C8.89999 5.73167 8.27319 5.10487 7.49999 5.10487Z", "fill": "currentColor" }, "child": [] }] })(props);
    }
    var define_import_meta_env_default$1 = { BASE_URL: "/", MODE: "production", DEV: false, PROD: true, SSR: false };
    const createStoreImpl = (createState2) => {
      let state;
      const listeners = /* @__PURE__ */ new Set();
      const setState = (partial, replace2) => {
        const nextState = typeof partial === "function" ? partial(state) : partial;
        if (!Object.is(nextState, state)) {
          const previousState = state;
          state = (replace2 != null ? replace2 : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
          listeners.forEach((listener) => listener(state, previousState));
        }
      };
      const getState = () => state;
      const getInitialState = () => initialState;
      const subscribe = (listener) => {
        listeners.add(listener);
        return () => listeners.delete(listener);
      };
      const destroy = () => {
        if ((define_import_meta_env_default$1 ? "production" : void 0) !== "production") {
          console.warn(
            "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
          );
        }
        listeners.clear();
      };
      const api = { setState, getState, getInitialState, subscribe, destroy };
      const initialState = state = createState2(setState, getState, api);
      return api;
    };
    const createStore = (createState2) => createState2 ? createStoreImpl(createState2) : createStoreImpl;
    var withSelector = { exports: {} };
    var withSelector_production_min = {};
    var shim = { exports: {} };
    var useSyncExternalStoreShim_production_min = {};
    /**
     * @license React
     * use-sync-external-store-shim.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var e = reactExports;
    function h$1(a, b2) {
      return a === b2 && (0 !== a || 1 / a === 1 / b2) || a !== a && b2 !== b2;
    }
    var k = "function" === typeof Object.is ? Object.is : h$1, l = e.useState, m = e.useEffect, n$1 = e.useLayoutEffect, p$1 = e.useDebugValue;
    function q$1(a, b2) {
      var d2 = b2(), f2 = l({ inst: { value: d2, getSnapshot: b2 } }), c2 = f2[0].inst, g2 = f2[1];
      n$1(function() {
        c2.value = d2;
        c2.getSnapshot = b2;
        r$1(c2) && g2({ inst: c2 });
      }, [a, d2, b2]);
      m(function() {
        r$1(c2) && g2({ inst: c2 });
        return a(function() {
          r$1(c2) && g2({ inst: c2 });
        });
      }, [a]);
      p$1(d2);
      return d2;
    }
    function r$1(a) {
      var b2 = a.getSnapshot;
      a = a.value;
      try {
        var d2 = b2();
        return !k(a, d2);
      } catch (f2) {
        return true;
      }
    }
    function t$1(a, b2) {
      return b2();
    }
    var u$1 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? t$1 : q$1;
    useSyncExternalStoreShim_production_min.useSyncExternalStore = void 0 !== e.useSyncExternalStore ? e.useSyncExternalStore : u$1;
    {
      shim.exports = useSyncExternalStoreShim_production_min;
    }
    var shimExports = shim.exports;
    /**
     * @license React
     * use-sync-external-store-shim/with-selector.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var h = reactExports, n = shimExports;
    function p(a, b2) {
      return a === b2 && (0 !== a || 1 / a === 1 / b2) || a !== a && b2 !== b2;
    }
    var q = "function" === typeof Object.is ? Object.is : p, r = n.useSyncExternalStore, t = h.useRef, u = h.useEffect, v = h.useMemo, w = h.useDebugValue;
    withSelector_production_min.useSyncExternalStoreWithSelector = function(a, b2, e2, l2, g2) {
      var c2 = t(null);
      if (null === c2.current) {
        var f2 = { hasValue: false, value: null };
        c2.current = f2;
      } else
        f2 = c2.current;
      c2 = v(function() {
        function a2(a3) {
          if (!c3) {
            c3 = true;
            d3 = a3;
            a3 = l2(a3);
            if (void 0 !== g2 && f2.hasValue) {
              var b3 = f2.value;
              if (g2(b3, a3))
                return k2 = b3;
            }
            return k2 = a3;
          }
          b3 = k2;
          if (q(d3, a3))
            return b3;
          var e3 = l2(a3);
          if (void 0 !== g2 && g2(b3, e3))
            return b3;
          d3 = a3;
          return k2 = e3;
        }
        var c3 = false, d3, k2, m2 = void 0 === e2 ? null : e2;
        return [function() {
          return a2(b2());
        }, null === m2 ? void 0 : function() {
          return a2(m2());
        }];
      }, [b2, e2, l2, g2]);
      var d2 = r(a, c2[0], c2[1]);
      u(function() {
        f2.hasValue = true;
        f2.value = d2;
      }, [d2]);
      w(d2);
      return d2;
    };
    {
      withSelector.exports = withSelector_production_min;
    }
    var withSelectorExports = withSelector.exports;
    const useSyncExternalStoreExports = /* @__PURE__ */ getDefaultExportFromCjs(withSelectorExports);
    var define_import_meta_env_default = { BASE_URL: "/", MODE: "production", DEV: false, PROD: true, SSR: false };
    const { useDebugValue } = React;
    const { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports;
    let didWarnAboutEqualityFn = false;
    const identity = (arg) => arg;
    function useStore(api, selector = identity, equalityFn) {
      if ((define_import_meta_env_default ? "production" : void 0) !== "production" && equalityFn && !didWarnAboutEqualityFn) {
        console.warn(
          "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
        );
        didWarnAboutEqualityFn = true;
      }
      const slice2 = useSyncExternalStoreWithSelector(
        api.subscribe,
        api.getState,
        api.getServerState || api.getInitialState,
        selector,
        equalityFn
      );
      useDebugValue(slice2);
      return slice2;
    }
    const createImpl = (createState2) => {
      if ((define_import_meta_env_default ? "production" : void 0) !== "production" && typeof createState2 !== "function") {
        console.warn(
          "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
        );
      }
      const api = typeof createState2 === "function" ? createStore(createState2) : createState2;
      const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);
      Object.assign(useBoundStore, api);
      return useBoundStore;
    };
    const create = (createState2) => createState2 ? createImpl(createState2) : createImpl;
    const useAuthStore = create((set) => ({
      authState: "ushan",
      setAuth: (auth) => set(() => ({ authState: auth }))
    }));
    const IsLogin = () => {
      const setAuth = useAuthStore((state) => state.setAuth);
      const logout = async () => {
        try {
          const res = await instance.get("/customer/logout");
          if (res.status === 200) {
            setAuth(false);
          }
        } catch (err) {
          console.log(err);
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "logged", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dropdown", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("a", { className: "btn btn-secondary", role: "button", id: "dropdownMenuLink", "data-bs-toggle": "dropdown", "aria-expanded": "false", children: /* @__PURE__ */ jsxRuntimeExports.jsx(RxAvatar, { className: "icon" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "dropdown-menu", "aria-labelledby": "dropdownMenuLink", children: /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { className: "dropdown-item", onClick: logout, children: "Logout" }) }) })
      ] }) }) });
    };
    const IsNotLogin = () => {
      const navigation = useNavigate();
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "not-login", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "reg-btn", onClick: () => navigation("/register"), children: "register" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "login-btn", onClick: () => navigation("/login"), children: "login" })
      ] });
    };
    const Nav = () => {
      const navigation = useNavigate();
      const auth = useAuthStore((state) => state.authState);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { id: "nav", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "left", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: Logo, alt: "logo", onClick: () => navigation("/") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "right", children: auth ? /* @__PURE__ */ jsxRuntimeExports.jsx(IsLogin, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(IsNotLogin, {}) })
      ] });
    };
    const checkUserAuth = async () => {
      try {
        const res = await instance.get("customer/auth");
        if (res.status === 200) {
          return true;
        } else {
          return false;
        }
      } catch (e2) {
        return false;
      }
    };
    const GetDateCategory = (date2) => {
      const day = date2.getDay();
      if (day === 1) {
        return "mon";
      } else if (day === 2 || day === 3 || day === 4) {
        return "tue_wed_thu";
      } else {
        return "fri_sat_sun";
      }
    };
    const PublicLayout = () => {
      const navigation = useNavigate();
      const [loading, setLoading] = reactExports.useState(null);
      const [activation, setActivation] = reactExports.useState(null);
      const setAuth = useAuthStore((state) => state.setAuth);
      const auth = useAuthStore((state) => state.authState);
      reactExports.useEffect(() => {
        const checkActivation = async (res) => {
          if (res) {
            const res2 = await instance.post("/customer/check-activation");
            setActivation(res2.data.activated);
          } else {
            setActivation(false);
          }
        };
        const setUserAuth = async () => {
          try {
            const res = await checkUserAuth();
            setAuth(res);
            setLoading(false);
            await checkActivation(res);
          } catch (err) {
            console.log(err);
            setActivation(false);
            setLoading(false);
            return false;
          }
        };
        setUserAuth();
      }, []);
      if (loading == null || activation == null) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Loading..." }) });
      }
      if (auth && !activation) {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { id: "registrationSuccess", style: {
          display: "flex",
          flexDirection: "column",
          justifyContent: "center",
          alignItems: "center",
          height: "100vh"
        }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Account not activated. Check your email and activate using activation link" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: async () => {
                const res = await instance.get("/customer/logout");
                if (res.status === 200) {
                  setAuth(false);
                  navigation("/login");
                }
              },
              style: {
                padding: "10px",
                backgroundColor: "#C17603",
                color: "white",
                border: "none",
                borderRadius: "5px"
              },
              children: "Logout"
            }
          ) })
        ] });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { id: "public-layout", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "nav-div", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Nav, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "outlet", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Outlet, {}) })
      ] });
    };
    const ResetPassword = () => {
      const navigation = useNavigate();
      const [tokenData, setTokenData] = reactExports.useState({ token: "", id: "" });
      const [err, setErr] = reactExports.useState(false);
      reactExports.useEffect(() => {
        const token2 = window.location.pathname.split("/")[2];
        const id2 = window.location.pathname.split("/")[3];
        console.log(token2, id2);
        if (!token2 || !id2) {
          navigation("/login");
        }
        setTokenData({ token: token2, id: id2 });
      }, []);
      const [loading, setLoading] = reactExports.useState(false);
      const submit = async (value) => {
        setLoading(true);
        setErr(false);
        const { password, confirmPassword } = value;
        try {
          const res = await instance.post(`/customer/passwd-reset/${tokenData.token}/${tokenData.id}`, { password, confirmPassword });
          console.log(res);
          setLoading(false);
          navigation("/login?reset_password=true");
        } catch (err2) {
          console.log(err2);
          setLoading(false);
          setErr(true);
        }
      };
      const { values: values2, errors, handleChange, touched, handleBlur, handleSubmit, setFieldValue, resetForm, setFieldError } = useFormik({
        initialValues: {
          password: "",
          confirmPassword: ""
        },
        onSubmit: (values22) => submit(values22),
        validationSchema: PasswordUpdateFormValidation
      });
      const fields = [
        {
          _id: 1,
          label: "New Password",
          type: "password",
          name: "password",
          value: values2.password,
          error: errors.password,
          touched: touched.password,
          required: true,
          onChange: handleChange,
          onBlur: handleBlur
        },
        {
          _id: 2,
          label: "Confirm New Password",
          type: "password",
          name: "confirmPassword",
          value: values2.confirmPassword,
          error: errors.confirmPassword,
          touched: touched.confirmPassword,
          required: true,
          onChange: handleChange,
          onBlur: handleBlur
        }
      ];
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        err && /* @__PURE__ */ jsxRuntimeExports.jsx(SnackbarAlert, { msg: "Password Reset Failed", type: "error", variant: "filled" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: "reset", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container d-flex flex-column", id: "reset-passwd", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "row align-items-center justify-content-center min-vh-100", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-12 col-md-8 col-lg-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card shadow-sm", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card-body", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { children: "Update Password" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mb-1", children: "Enter your new password." })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-2", children: fields.map((field, index) => {
              return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { width: "100%" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { htmlFor: field.name, className: "form-label my-2", children: [
                  field.label,
                  " ",
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "require", children: "*" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: field.type,
                    className: `form-control ${field.error && field.touched ? "is-invalid" : "custom-input"}`,
                    id: field.name,
                    name: field.name,
                    value: field.value,
                    onChange: field.onChange,
                    onBlur: field.onBlur
                  }
                ),
                field.error && field.touched ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "invalid-feedback", children: field.error }) : null
              ] }, index);
            }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "my-3 d-grid", children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { type: "submit", className: "btn btn-primary", style: { background: "gray", borderColor: "gray" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { class: "spinner-border spinner-border-sm mx-1", role: "status", "aria-hidden": "true" }),
              "Update Password"
            ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "submit", className: "btn btn-primary", children: "Update Password" }) })
          ] })
        ] }) }) }) }) }) })
      ] });
    };
    const _excluded$S = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
    const styles = {
      entering: {
        opacity: 1
      },
      entered: {
        opacity: 1
      }
    };
    const Fade = /* @__PURE__ */ reactExports.forwardRef(function Fade2(props, ref) {
      const theme = useTheme();
      const defaultTimeout = {
        enter: theme.transitions.duration.enteringScreen,
        exit: theme.transitions.duration.leavingScreen
      };
      const {
        addEndListener,
        appear = true,
        children,
        easing: easing2,
        in: inProp,
        onEnter,
        onEntered,
        onEntering,
        onExit,
        onExited,
        onExiting,
        style: style2,
        timeout = defaultTimeout,
        // eslint-disable-next-line react/prop-types
        TransitionComponent = Transition$1
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$S);
      const nodeRef = reactExports.useRef(null);
      const handleRef = useForkRef(nodeRef, children.ref, ref);
      const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
        if (callback) {
          const node2 = nodeRef.current;
          if (maybeIsAppearing === void 0) {
            callback(node2);
          } else {
            callback(node2, maybeIsAppearing);
          }
        }
      };
      const handleEntering = normalizedTransitionCallback(onEntering);
      const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
        reflow(node2);
        const transitionProps = getTransitionProps({
          style: style2,
          timeout,
          easing: easing2
        }, {
          mode: "enter"
        });
        node2.style.webkitTransition = theme.transitions.create("opacity", transitionProps);
        node2.style.transition = theme.transitions.create("opacity", transitionProps);
        if (onEnter) {
          onEnter(node2, isAppearing);
        }
      });
      const handleEntered = normalizedTransitionCallback(onEntered);
      const handleExiting = normalizedTransitionCallback(onExiting);
      const handleExit = normalizedTransitionCallback((node2) => {
        const transitionProps = getTransitionProps({
          style: style2,
          timeout,
          easing: easing2
        }, {
          mode: "exit"
        });
        node2.style.webkitTransition = theme.transitions.create("opacity", transitionProps);
        node2.style.transition = theme.transitions.create("opacity", transitionProps);
        if (onExit) {
          onExit(node2);
        }
      });
      const handleExited = normalizedTransitionCallback(onExited);
      const handleAddEndListener = (next2) => {
        if (addEndListener) {
          addEndListener(nodeRef.current, next2);
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$1({
        appear,
        in: inProp,
        nodeRef,
        onEnter: handleEnter,
        onEntered: handleEntered,
        onEntering: handleEntering,
        onExit: handleExit,
        onExited: handleExited,
        onExiting: handleExiting,
        addEndListener: handleAddEndListener,
        timeout
      }, other, {
        children: (state, childProps) => {
          return /* @__PURE__ */ reactExports.cloneElement(children, _extends$1({
            style: _extends$1({
              opacity: 0,
              visibility: state === "exited" && !inProp ? "hidden" : void 0
            }, styles[state], style2, children.props.style),
            ref: handleRef
          }, childProps));
        }
      }));
    });
    const Fade$1 = Fade;
    function getBackdropUtilityClass(slot) {
      return generateUtilityClass$1("MuiBackdrop", slot);
    }
    generateUtilityClasses$1("MuiBackdrop", ["root", "invisible"]);
    const _excluded$R = ["children", "className", "component", "components", "componentsProps", "invisible", "open", "slotProps", "slots", "TransitionComponent", "transitionDuration"];
    const useUtilityClasses$H = (ownerState) => {
      const {
        classes,
        invisible
      } = ownerState;
      const slots = {
        root: ["root", invisible && "invisible"]
      };
      return composeClasses(slots, getBackdropUtilityClass, classes);
    };
    const BackdropRoot = styled("div", {
      name: "MuiBackdrop",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, ownerState.invisible && styles2.invisible];
      }
    })(({
      ownerState
    }) => _extends$1({
      position: "fixed",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      right: 0,
      bottom: 0,
      top: 0,
      left: 0,
      backgroundColor: "rgba(0, 0, 0, 0.5)",
      WebkitTapHighlightColor: "transparent"
    }, ownerState.invisible && {
      backgroundColor: "transparent"
    }));
    const Backdrop = /* @__PURE__ */ reactExports.forwardRef(function Backdrop2(inProps, ref) {
      var _slotProps$root, _ref, _slots$root;
      const props = useThemeProps({
        props: inProps,
        name: "MuiBackdrop"
      });
      const {
        children,
        className,
        component = "div",
        components = {},
        componentsProps = {},
        invisible = false,
        open,
        slotProps = {},
        slots = {},
        TransitionComponent = Fade$1,
        transitionDuration
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$R);
      const ownerState = _extends$1({}, props, {
        component,
        invisible
      });
      const classes = useUtilityClasses$H(ownerState);
      const rootSlotProps = (_slotProps$root = slotProps.root) != null ? _slotProps$root : componentsProps.root;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$1({
        in: open,
        timeout: transitionDuration
      }, other, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(BackdropRoot, _extends$1({
          "aria-hidden": true
        }, rootSlotProps, {
          as: (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : component,
          className: clsx(classes.root, className, rootSlotProps == null ? void 0 : rootSlotProps.className),
          ownerState: _extends$1({}, ownerState, rootSlotProps == null ? void 0 : rootSlotProps.ownerState),
          classes,
          ref,
          children
        }))
      }));
    });
    const Backdrop$1 = Backdrop;
    function getModalUtilityClass(slot) {
      return generateUtilityClass$1("MuiModal", slot);
    }
    generateUtilityClasses$1("MuiModal", ["root", "hidden", "backdrop"]);
    const _excluded$Q = ["BackdropComponent", "BackdropProps", "classes", "className", "closeAfterTransition", "children", "container", "component", "components", "componentsProps", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "onBackdropClick", "onClose", "onTransitionEnter", "onTransitionExited", "open", "slotProps", "slots", "theme"];
    const useUtilityClasses$G = (ownerState) => {
      const {
        open,
        exited,
        classes
      } = ownerState;
      const slots = {
        root: ["root", !open && exited && "hidden"],
        backdrop: ["backdrop"]
      };
      return composeClasses(slots, getModalUtilityClass, classes);
    };
    const ModalRoot = styled("div", {
      name: "MuiModal",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, !ownerState.open && ownerState.exited && styles2.hidden];
      }
    })(({
      theme,
      ownerState
    }) => _extends$1({
      position: "fixed",
      zIndex: (theme.vars || theme).zIndex.modal,
      right: 0,
      bottom: 0,
      top: 0,
      left: 0
    }, !ownerState.open && ownerState.exited && {
      visibility: "hidden"
    }));
    const ModalBackdrop = styled(Backdrop$1, {
      name: "MuiModal",
      slot: "Backdrop",
      overridesResolver: (props, styles2) => {
        return styles2.backdrop;
      }
    })({
      zIndex: -1
    });
    const Modal = /* @__PURE__ */ reactExports.forwardRef(function Modal2(inProps, ref) {
      var _ref, _slots$root, _ref2, _slots$backdrop, _slotProps$root, _slotProps$backdrop;
      const props = useThemeProps({
        name: "MuiModal",
        props: inProps
      });
      const {
        BackdropComponent = ModalBackdrop,
        BackdropProps,
        className,
        closeAfterTransition = false,
        children,
        container,
        component,
        components = {},
        componentsProps = {},
        disableAutoFocus = false,
        disableEnforceFocus = false,
        disableEscapeKeyDown = false,
        disablePortal = false,
        disableRestoreFocus = false,
        disableScrollLock = false,
        hideBackdrop = false,
        keepMounted = false,
        onBackdropClick,
        open,
        slotProps,
        slots
        // eslint-disable-next-line react/prop-types
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$Q);
      const propsWithDefaults = _extends$1({}, props, {
        closeAfterTransition,
        disableAutoFocus,
        disableEnforceFocus,
        disableEscapeKeyDown,
        disablePortal,
        disableRestoreFocus,
        disableScrollLock,
        hideBackdrop,
        keepMounted
      });
      const {
        getRootProps,
        getBackdropProps,
        getTransitionProps: getTransitionProps2,
        portalRef,
        isTopModal,
        exited,
        hasTransition
      } = useModal(_extends$1({}, propsWithDefaults, {
        rootRef: ref
      }));
      const ownerState = _extends$1({}, propsWithDefaults, {
        exited
      });
      const classes = useUtilityClasses$G(ownerState);
      const childProps = {};
      if (children.props.tabIndex === void 0) {
        childProps.tabIndex = "-1";
      }
      if (hasTransition) {
        const {
          onEnter,
          onExited
        } = getTransitionProps2();
        childProps.onEnter = onEnter;
        childProps.onExited = onExited;
      }
      const RootSlot = (_ref = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components.Root) != null ? _ref : ModalRoot;
      const BackdropSlot = (_ref2 = (_slots$backdrop = slots == null ? void 0 : slots.backdrop) != null ? _slots$backdrop : components.Backdrop) != null ? _ref2 : BackdropComponent;
      const rootSlotProps = (_slotProps$root = slotProps == null ? void 0 : slotProps.root) != null ? _slotProps$root : componentsProps.root;
      const backdropSlotProps = (_slotProps$backdrop = slotProps == null ? void 0 : slotProps.backdrop) != null ? _slotProps$backdrop : componentsProps.backdrop;
      const rootProps = useSlotProps({
        elementType: RootSlot,
        externalSlotProps: rootSlotProps,
        externalForwardedProps: other,
        getSlotProps: getRootProps,
        additionalProps: {
          ref,
          as: component
        },
        ownerState,
        className: clsx(className, rootSlotProps == null ? void 0 : rootSlotProps.className, classes == null ? void 0 : classes.root, !ownerState.open && ownerState.exited && (classes == null ? void 0 : classes.hidden))
      });
      const backdropProps = useSlotProps({
        elementType: BackdropSlot,
        externalSlotProps: backdropSlotProps,
        additionalProps: BackdropProps,
        getSlotProps: (otherHandlers) => {
          return getBackdropProps(_extends$1({}, otherHandlers, {
            onClick: (e2) => {
              if (onBackdropClick) {
                onBackdropClick(e2);
              }
              if (otherHandlers != null && otherHandlers.onClick) {
                otherHandlers.onClick(e2);
              }
            }
          }));
        },
        className: clsx(backdropSlotProps == null ? void 0 : backdropSlotProps.className, BackdropProps == null ? void 0 : BackdropProps.className, classes == null ? void 0 : classes.backdrop),
        ownerState
      });
      if (!keepMounted && !open && (!hasTransition || exited)) {
        return null;
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, {
        ref: portalRef,
        container,
        disablePortal,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, _extends$1({}, rootProps, {
          children: [!hideBackdrop && BackdropComponent ? /* @__PURE__ */ jsxRuntimeExports.jsx(BackdropSlot, _extends$1({}, backdropProps)) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(FocusTrap, {
            disableEnforceFocus,
            disableAutoFocus,
            disableRestoreFocus,
            isEnabled: isTopModal,
            open,
            children: /* @__PURE__ */ reactExports.cloneElement(children, childProps)
          })]
        }))
      });
    });
    const Modal$1 = Modal;
    function getDialogUtilityClass(slot) {
      return generateUtilityClass$1("MuiDialog", slot);
    }
    const dialogClasses = generateUtilityClasses$1("MuiDialog", ["root", "scrollPaper", "scrollBody", "container", "paper", "paperScrollPaper", "paperScrollBody", "paperWidthFalse", "paperWidthXs", "paperWidthSm", "paperWidthMd", "paperWidthLg", "paperWidthXl", "paperFullWidth", "paperFullScreen"]);
    const dialogClasses$1 = dialogClasses;
    const DialogContext = /* @__PURE__ */ reactExports.createContext({});
    const DialogContext$1 = DialogContext;
    const _excluded$P = ["aria-describedby", "aria-labelledby", "BackdropComponent", "BackdropProps", "children", "className", "disableEscapeKeyDown", "fullScreen", "fullWidth", "maxWidth", "onBackdropClick", "onClose", "open", "PaperComponent", "PaperProps", "scroll", "TransitionComponent", "transitionDuration", "TransitionProps"];
    const DialogBackdrop = styled(Backdrop$1, {
      name: "MuiDialog",
      slot: "Backdrop",
      overrides: (props, styles2) => styles2.backdrop
    })({
      // Improve scrollable dialog support.
      zIndex: -1
    });
    const useUtilityClasses$F = (ownerState) => {
      const {
        classes,
        scroll,
        maxWidth: maxWidth2,
        fullWidth,
        fullScreen
      } = ownerState;
      const slots = {
        root: ["root"],
        container: ["container", `scroll${capitalize(scroll)}`],
        paper: ["paper", `paperScroll${capitalize(scroll)}`, `paperWidth${capitalize(String(maxWidth2))}`, fullWidth && "paperFullWidth", fullScreen && "paperFullScreen"]
      };
      return composeClasses(slots, getDialogUtilityClass, classes);
    };
    const DialogRoot = styled(Modal$1, {
      name: "MuiDialog",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })({
      "@media print": {
        // Use !important to override the Modal inline-style.
        position: "absolute !important"
      }
    });
    const DialogContainer = styled("div", {
      name: "MuiDialog",
      slot: "Container",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.container, styles2[`scroll${capitalize(ownerState.scroll)}`]];
      }
    })(({
      ownerState
    }) => _extends$1({
      height: "100%",
      "@media print": {
        height: "auto"
      },
      // We disable the focus ring for mouse, touch and keyboard users.
      outline: 0
    }, ownerState.scroll === "paper" && {
      display: "flex",
      justifyContent: "center",
      alignItems: "center"
    }, ownerState.scroll === "body" && {
      overflowY: "auto",
      overflowX: "hidden",
      textAlign: "center",
      "&::after": {
        content: '""',
        display: "inline-block",
        verticalAlign: "middle",
        height: "100%",
        width: "0"
      }
    }));
    const DialogPaper = styled(Paper$1, {
      name: "MuiDialog",
      slot: "Paper",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.paper, styles2[`scrollPaper${capitalize(ownerState.scroll)}`], styles2[`paperWidth${capitalize(String(ownerState.maxWidth))}`], ownerState.fullWidth && styles2.paperFullWidth, ownerState.fullScreen && styles2.paperFullScreen];
      }
    })(({
      theme,
      ownerState
    }) => _extends$1({
      margin: 32,
      position: "relative",
      overflowY: "auto",
      // Fix IE11 issue, to remove at some point.
      "@media print": {
        overflowY: "visible",
        boxShadow: "none"
      }
    }, ownerState.scroll === "paper" && {
      display: "flex",
      flexDirection: "column",
      maxHeight: "calc(100% - 64px)"
    }, ownerState.scroll === "body" && {
      display: "inline-block",
      verticalAlign: "middle",
      textAlign: "left"
      // 'initial' doesn't work on IE11
    }, !ownerState.maxWidth && {
      maxWidth: "calc(100% - 64px)"
    }, ownerState.maxWidth === "xs" && {
      maxWidth: theme.breakpoints.unit === "px" ? Math.max(theme.breakpoints.values.xs, 444) : `max(${theme.breakpoints.values.xs}${theme.breakpoints.unit}, 444px)`,
      [`&.${dialogClasses$1.paperScrollBody}`]: {
        [theme.breakpoints.down(Math.max(theme.breakpoints.values.xs, 444) + 32 * 2)]: {
          maxWidth: "calc(100% - 64px)"
        }
      }
    }, ownerState.maxWidth && ownerState.maxWidth !== "xs" && {
      maxWidth: `${theme.breakpoints.values[ownerState.maxWidth]}${theme.breakpoints.unit}`,
      [`&.${dialogClasses$1.paperScrollBody}`]: {
        [theme.breakpoints.down(theme.breakpoints.values[ownerState.maxWidth] + 32 * 2)]: {
          maxWidth: "calc(100% - 64px)"
        }
      }
    }, ownerState.fullWidth && {
      width: "calc(100% - 64px)"
    }, ownerState.fullScreen && {
      margin: 0,
      width: "100%",
      maxWidth: "100%",
      height: "100%",
      maxHeight: "none",
      borderRadius: 0,
      [`&.${dialogClasses$1.paperScrollBody}`]: {
        margin: 0,
        maxWidth: "100%"
      }
    }));
    const Dialog = /* @__PURE__ */ reactExports.forwardRef(function Dialog2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiDialog"
      });
      const theme = useTheme();
      const defaultTransitionDuration = {
        enter: theme.transitions.duration.enteringScreen,
        exit: theme.transitions.duration.leavingScreen
      };
      const {
        "aria-describedby": ariaDescribedby,
        "aria-labelledby": ariaLabelledbyProp,
        BackdropComponent,
        BackdropProps,
        children,
        className,
        disableEscapeKeyDown = false,
        fullScreen = false,
        fullWidth = false,
        maxWidth: maxWidth2 = "sm",
        onBackdropClick,
        onClose,
        open,
        PaperComponent = Paper$1,
        PaperProps = {},
        scroll = "paper",
        TransitionComponent = Fade$1,
        transitionDuration = defaultTransitionDuration,
        TransitionProps
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$P);
      const ownerState = _extends$1({}, props, {
        disableEscapeKeyDown,
        fullScreen,
        fullWidth,
        maxWidth: maxWidth2,
        scroll
      });
      const classes = useUtilityClasses$F(ownerState);
      const backdropClick = reactExports.useRef();
      const handleMouseDown = (event) => {
        backdropClick.current = event.target === event.currentTarget;
      };
      const handleBackdropClick = (event) => {
        if (!backdropClick.current) {
          return;
        }
        backdropClick.current = null;
        if (onBackdropClick) {
          onBackdropClick(event);
        }
        if (onClose) {
          onClose(event, "backdropClick");
        }
      };
      const ariaLabelledby = useId(ariaLabelledbyProp);
      const dialogContextValue = reactExports.useMemo(() => {
        return {
          titleId: ariaLabelledby
        };
      }, [ariaLabelledby]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogRoot, _extends$1({
        className: clsx(classes.root, className),
        closeAfterTransition: true,
        components: {
          Backdrop: DialogBackdrop
        },
        componentsProps: {
          backdrop: _extends$1({
            transitionDuration,
            as: BackdropComponent
          }, BackdropProps)
        },
        disableEscapeKeyDown,
        onClose,
        open,
        ref,
        onClick: handleBackdropClick,
        ownerState
      }, other, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$1({
          appear: true,
          in: open,
          timeout: transitionDuration,
          role: "presentation"
        }, TransitionProps, {
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContainer, {
            className: clsx(classes.container),
            onMouseDown: handleMouseDown,
            ownerState,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogPaper, _extends$1({
              as: PaperComponent,
              elevation: 24,
              role: "dialog",
              "aria-describedby": ariaDescribedby,
              "aria-labelledby": ariaLabelledby
            }, PaperProps, {
              className: clsx(classes.paper, PaperProps.className),
              ownerState,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContext$1.Provider, {
                value: dialogContextValue,
                children
              })
            }))
          })
        }))
      }));
    });
    const MuiDialog = Dialog;
    function getDialogActionsUtilityClass(slot) {
      return generateUtilityClass$1("MuiDialogActions", slot);
    }
    generateUtilityClasses$1("MuiDialogActions", ["root", "spacing"]);
    const _excluded$O = ["className", "disableSpacing"];
    const useUtilityClasses$E = (ownerState) => {
      const {
        classes,
        disableSpacing
      } = ownerState;
      const slots = {
        root: ["root", !disableSpacing && "spacing"]
      };
      return composeClasses(slots, getDialogActionsUtilityClass, classes);
    };
    const DialogActionsRoot = styled("div", {
      name: "MuiDialogActions",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, !ownerState.disableSpacing && styles2.spacing];
      }
    })(({
      ownerState
    }) => _extends$1({
      display: "flex",
      alignItems: "center",
      padding: 8,
      justifyContent: "flex-end",
      flex: "0 0 auto"
    }, !ownerState.disableSpacing && {
      "& > :not(style) ~ :not(style)": {
        marginLeft: 8
      }
    }));
    const DialogActions = /* @__PURE__ */ reactExports.forwardRef(function DialogActions2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiDialogActions"
      });
      const {
        className,
        disableSpacing = false
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$O);
      const ownerState = _extends$1({}, props, {
        disableSpacing
      });
      const classes = useUtilityClasses$E(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogActionsRoot, _extends$1({
        className: clsx(classes.root, className),
        ownerState,
        ref
      }, other));
    });
    const DialogActions$1 = DialogActions;
    function getDialogContentUtilityClass(slot) {
      return generateUtilityClass$1("MuiDialogContent", slot);
    }
    generateUtilityClasses$1("MuiDialogContent", ["root", "dividers"]);
    function getDialogTitleUtilityClass(slot) {
      return generateUtilityClass$1("MuiDialogTitle", slot);
    }
    const dialogTitleClasses = generateUtilityClasses$1("MuiDialogTitle", ["root"]);
    const dialogTitleClasses$1 = dialogTitleClasses;
    const _excluded$N = ["className", "dividers"];
    const useUtilityClasses$D = (ownerState) => {
      const {
        classes,
        dividers
      } = ownerState;
      const slots = {
        root: ["root", dividers && "dividers"]
      };
      return composeClasses(slots, getDialogContentUtilityClass, classes);
    };
    const DialogContentRoot = styled("div", {
      name: "MuiDialogContent",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, ownerState.dividers && styles2.dividers];
      }
    })(({
      theme,
      ownerState
    }) => _extends$1({
      flex: "1 1 auto",
      // Add iOS momentum scrolling for iOS < 13.0
      WebkitOverflowScrolling: "touch",
      overflowY: "auto",
      padding: "20px 24px"
    }, ownerState.dividers ? {
      padding: "16px 24px",
      borderTop: `1px solid ${(theme.vars || theme).palette.divider}`,
      borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`
    } : {
      [`.${dialogTitleClasses$1.root} + &`]: {
        paddingTop: 0
      }
    }));
    const DialogContent = /* @__PURE__ */ reactExports.forwardRef(function DialogContent2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiDialogContent"
      });
      const {
        className,
        dividers = false
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$N);
      const ownerState = _extends$1({}, props, {
        dividers
      });
      const classes = useUtilityClasses$D(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentRoot, _extends$1({
        className: clsx(classes.root, className),
        ownerState,
        ref
      }, other));
    });
    const DialogContent$1 = DialogContent;
    function getTypographyUtilityClass(slot) {
      return generateUtilityClass$1("MuiTypography", slot);
    }
    generateUtilityClasses$1("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]);
    const _excluded$M = ["align", "className", "component", "gutterBottom", "noWrap", "paragraph", "variant", "variantMapping"];
    const useUtilityClasses$C = (ownerState) => {
      const {
        align,
        gutterBottom,
        noWrap,
        paragraph,
        variant,
        classes
      } = ownerState;
      const slots = {
        root: ["root", variant, ownerState.align !== "inherit" && `align${capitalize(align)}`, gutterBottom && "gutterBottom", noWrap && "noWrap", paragraph && "paragraph"]
      };
      return composeClasses(slots, getTypographyUtilityClass, classes);
    };
    const TypographyRoot = styled("span", {
      name: "MuiTypography",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, ownerState.variant && styles2[ownerState.variant], ownerState.align !== "inherit" && styles2[`align${capitalize(ownerState.align)}`], ownerState.noWrap && styles2.noWrap, ownerState.gutterBottom && styles2.gutterBottom, ownerState.paragraph && styles2.paragraph];
      }
    })(({
      theme,
      ownerState
    }) => _extends$1({
      margin: 0
    }, ownerState.variant === "inherit" && {
      // Some elements, like <button> on Chrome have default font that doesn't inherit, reset this.
      font: "inherit"
    }, ownerState.variant !== "inherit" && theme.typography[ownerState.variant], ownerState.align !== "inherit" && {
      textAlign: ownerState.align
    }, ownerState.noWrap && {
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap"
    }, ownerState.gutterBottom && {
      marginBottom: "0.35em"
    }, ownerState.paragraph && {
      marginBottom: 16
    }));
    const defaultVariantMapping = {
      h1: "h1",
      h2: "h2",
      h3: "h3",
      h4: "h4",
      h5: "h5",
      h6: "h6",
      subtitle1: "h6",
      subtitle2: "h6",
      body1: "p",
      body2: "p",
      inherit: "p"
    };
    const colorTransformations = {
      primary: "primary.main",
      textPrimary: "text.primary",
      secondary: "secondary.main",
      textSecondary: "text.secondary",
      error: "error.main"
    };
    const transformDeprecatedColors = (color2) => {
      return colorTransformations[color2] || color2;
    };
    const Typography = /* @__PURE__ */ reactExports.forwardRef(function Typography2(inProps, ref) {
      const themeProps = useThemeProps({
        props: inProps,
        name: "MuiTypography"
      });
      const color2 = transformDeprecatedColors(themeProps.color);
      const props = extendSxProp(_extends$1({}, themeProps, {
        color: color2
      }));
      const {
        align = "inherit",
        className,
        component,
        gutterBottom = false,
        noWrap = false,
        paragraph = false,
        variant = "body1",
        variantMapping = defaultVariantMapping
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$M);
      const ownerState = _extends$1({}, props, {
        align,
        color: color2,
        className,
        component,
        gutterBottom,
        noWrap,
        paragraph,
        variant,
        variantMapping
      });
      const Component = component || (paragraph ? "p" : variantMapping[variant] || defaultVariantMapping[variant]) || "span";
      const classes = useUtilityClasses$C(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(TypographyRoot, _extends$1({
        as: Component,
        ref,
        ownerState,
        className: clsx(classes.root, className)
      }, other));
    });
    const Typography$1 = Typography;
    function getDialogContentTextUtilityClass(slot) {
      return generateUtilityClass$1("MuiDialogContentText", slot);
    }
    generateUtilityClasses$1("MuiDialogContentText", ["root"]);
    const _excluded$L = ["children", "className"];
    const useUtilityClasses$B = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"]
      };
      const composedClasses = composeClasses(slots, getDialogContentTextUtilityClass, classes);
      return _extends$1({}, classes, composedClasses);
    };
    const DialogContentTextRoot = styled(Typography$1, {
      shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
      name: "MuiDialogContentText",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })({});
    const DialogContentText = /* @__PURE__ */ reactExports.forwardRef(function DialogContentText2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiDialogContentText"
      });
      const {
        className
      } = props, ownerState = _objectWithoutPropertiesLoose$1(props, _excluded$L);
      const classes = useUtilityClasses$B(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentTextRoot, _extends$1({
        component: "p",
        variant: "body1",
        color: "text.secondary",
        ref,
        ownerState,
        className: clsx(classes.root, className)
      }, props, {
        classes
      }));
    });
    const DialogContentText$1 = DialogContentText;
    const _excluded$K = ["className", "id"];
    const useUtilityClasses$A = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"]
      };
      return composeClasses(slots, getDialogTitleUtilityClass, classes);
    };
    const DialogTitleRoot = styled(Typography$1, {
      name: "MuiDialogTitle",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })({
      padding: "16px 24px",
      flex: "0 0 auto"
    });
    const DialogTitle = /* @__PURE__ */ reactExports.forwardRef(function DialogTitle2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiDialogTitle"
      });
      const {
        className,
        id: idProp
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$K);
      const ownerState = props;
      const classes = useUtilityClasses$A(ownerState);
      const {
        titleId = idProp
      } = reactExports.useContext(DialogContext$1);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitleRoot, _extends$1({
        component: "h2",
        className: clsx(classes.root, className),
        ownerState,
        ref,
        variant: "h6",
        id: idProp != null ? idProp : titleId
      }, other));
    });
    const DialogTitle$1 = DialogTitle;
    function AlertDialog({ _open, _setOpen }) {
      const navigation = useNavigate();
      const [open, setOpen] = reactExports.useState(_open);
      const clickOk = () => {
        setOpen(false);
        navigation("/login");
      };
      reactExports.useEffect(() => {
        if (_open) {
          setOpen(_open);
        } else {
          setOpen(false);
        }
      }, [_open]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(React.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        MuiDialog,
        {
          open,
          "aria-labelledby": "alert-dialog-title",
          "aria-describedby": "alert-dialog-description",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle$1, { id: "alert-dialog-title", children: "Password Reset Link Sent!" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContent$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentText$1, { id: "alert-dialog-description", children: "We have successfully sent a password reset link to your email address. Please check your inbox." }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(DialogActions$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { onClick: clickOk, autoFocus: true, children: "Ok" }) })
          ]
        }
      ) });
    }
    const ForgotPassword = () => {
      const [loading, setLoading] = reactExports.useState(false);
      const [err, setErr] = reactExports.useState(false);
      const [open, setOpen] = reactExports.useState(false);
      const submit = async (e2) => {
        e2.preventDefault();
        setLoading(true);
        const email = e2.target.email.value;
        console.log(email);
        try {
          const res = await instance.get(`/customer/forgot-password/${email}`);
          console.log(res);
          setOpen(true);
          setLoading(false);
        } catch (err2) {
          setErr(false);
          console.log(err2);
          setLoading(false);
          setErr(true);
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(AlertDialog, { _open: open, _setOpen: setOpen }),
        err && /* @__PURE__ */ jsxRuntimeExports.jsx(SnackbarAlert, { msg: "Email Can't Sent.", type: "error", variant: "filled" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container d-flex flex-column", id: "reset-passwd", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "row align-items-center justify-content-center min-vh-100", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-12 col-md-8 col-lg-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card shadow-sm", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card-body", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { children: "Forgot Password?" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mb-2", children: "Enter your registered email ID to reset the password" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: submit, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { for: "email", className: "form-label", children: "Email" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "email", id: "email", className: "form-control", name: "email", placeholder: "Enter Your Email", required: true })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-3 d-grid", children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { type: "submit", className: "btn btn-primary", style: { background: "gray", borderColor: "gray" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { class: "spinner-border spinner-border-sm mx-1", role: "status", "aria-hidden": "true" }),
              "Reset Password"
            ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "submit", className: "btn btn-primary", children: "Reset Password" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              "Don't have an account? ",
              /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/register", children: "Register" })
            ] })
          ] })
        ] }) }) }) }) }) })
      ] });
    };
    const ActivateAcc = () => {
      useNavigate();
      const [res, setRes] = reactExports.useState({ type: "", message: "" });
      reactExports.useState({ token: "", id: "" });
      reactExports.useEffect(() => {
        const token2 = window.location.pathname.split("/")[2];
        const id2 = window.location.pathname.split("/")[3];
        console.log(token2, id2);
        if (!token2 || !id2) {
          setRes({ type: "error", message: "Invalid token" });
        }
        const activate = async () => {
          try {
            const res2 = await instance.post(`/customer/acc-activate/${token2}/${id2}`);
            console.log(res2);
            setRes({ type: "success", message: "Account activated successfully" });
          } catch (err) {
            console.log(err);
            setRes({ type: "error", message: "Invalid token" });
          }
        };
        activate();
      }, []);
      if (res.type === "") {
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Activating..." });
      }
      if (res.type === "error") {
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: res.message });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { id: "activationSuccess", style: {
        display: "flex",
        flexDirection: "column",
        justifyContent: "center",
        alignItems: "center",
        height: "100vh"
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Account activate successfully." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/", style: { color: "#000" }, children: "Home" })
      ] });
    };
    function AiOutlineCaretDown(props) {
      return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 1024 1024" }, "child": [{ "tag": "path", "attr": { "d": "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" }, "child": [] }] })(props);
    }
    function AiOutlineCaretUp(props) {
      return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 1024 1024" }, "child": [{ "tag": "path", "attr": { "d": "M858.9 689L530.5 308.2c-9.4-10.9-27.5-10.9-37 0L165.1 689c-12.2 14.2-1.2 35 18.5 35h656.8c19.7 0 30.7-20.8 18.5-35z" }, "child": [] }] })(props);
    }
    function AiOutlineClose(props) {
      return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 1024 1024", "fill": "currentColor", "fillRule": "evenodd" }, "child": [{ "tag": "path", "attr": { "d": "M799.855 166.312c.023.007.043.018.084.059l57.69 57.69c.041.041.052.06.059.084a.118.118 0 0 1 0 .069c-.007.023-.018.042-.059.083L569.926 512l287.703 287.703c.041.04.052.06.059.083a.118.118 0 0 1 0 .07c-.007.022-.018.042-.059.083l-57.69 57.69c-.041.041-.06.052-.084.059a.118.118 0 0 1-.069 0c-.023-.007-.042-.018-.083-.059L512 569.926 224.297 857.629c-.04.041-.06.052-.083.059a.118.118 0 0 1-.07 0c-.022-.007-.042-.018-.083-.059l-57.69-57.69c-.041-.041-.052-.06-.059-.084a.118.118 0 0 1 0-.069c.007-.023.018-.042.059-.083L454.073 512 166.371 224.297c-.041-.04-.052-.06-.059-.083a.118.118 0 0 1 0-.07c.007-.022.018-.042.059-.083l57.69-57.69c.041-.041.06-.052.084-.059a.118.118 0 0 1 .069 0c.023.007.042.018.083.059L512 454.073l287.703-287.702c.04-.041.06-.052.083-.059a.118.118 0 0 1 .07 0Z" }, "child": [] }] })(props);
    }
    function BiFilterAlt(props) {
      return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M21 3H5a1 1 0 0 0-1 1v2.59c0 .523.213 1.037.583 1.407L10 13.414V21a1.001 1.001 0 0 0 1.447.895l4-2c.339-.17.553-.516.553-.895v-5.586l5.417-5.417c.37-.37.583-.884.583-1.407V4a1 1 0 0 0-1-1zm-6.707 9.293A.996.996 0 0 0 14 13v5.382l-2 1V13a.996.996 0 0 0-.293-.707L6 6.59V5h14.001l.002 1.583-5.71 5.71z" }, "child": [] }] })(props);
    }
    const SearchEventCard = ({ open, setOpen, useSearch, setParam }) => {
      const navigation = useNavigate();
      const submit = ({ venue_type: venue_type2, start_date, end_date }) => {
        console.log(end_date);
        setParam({ venue_type: venue_type2, start_date, end_date });
        navigation(`/venues/?test=123&venue_type=${venue_type2}&start_date=${start_date}&end_date=${end_date}`);
      };
      const { values: values2, errors, handleChange, touched, handleBlur, handleSubmit, setFieldValue, resetForm, setFieldError } = useFormik({
        initialValues: {
          venue_type: useSearch.venue_type,
          start_date: useSearch.start_date,
          end_date: useSearch.end_date
        },
        onSubmit: (values22) => submit(values22),
        validationSchema: WelcomePageFormValidation
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card", id: "search-event-card", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "title toggle", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: "Book a Venue" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(AiOutlineCaretDown, { className: "icon toggle" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { className: "inputs row", onSubmit: handleSubmit, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "type-of-event", children: "Type of Event" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "select",
              {
                className: "form-select",
                "aria-label": "type-of-event",
                id: "type-of-event",
                name: "venue_type",
                onChange: handleChange,
                onBlur: handleBlur,
                value: values2.venue_type,
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "all", children: " All " }),
                  venue_type.map((option, index) => {
                    return /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: option.value, children: option.label }, index);
                  })
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: touched.venue_type && errors.venue_type ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "red" }, children: errors.venue_type }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { height: "20px" } }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "endDate", children: "Start Date" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                id: "endDate",
                className: "form-control",
                type: "date",
                name: "start_date",
                value: values2.start_date,
                onChange: handleChange,
                onBlur: handleBlur
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: touched.start_date && errors.start_date ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "red" }, children: errors.start_date }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { height: "20px" } }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "endDate", children: "End Date" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                id: "endDate",
                className: "form-control",
                type: "date",
                name: "end_date",
                value: values2.end_date,
                onChange: handleChange,
                onBlur: handleBlur
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: touched.end_date && errors.end_date ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "red" }, children: errors.end_date }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { height: "20px" } }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col submit-col", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "endDate", children: "submit button" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "submit", className: "btn btn-primary", children: "Submit" }),
            typeof open !== "undefined" && !open && /* @__PURE__ */ jsxRuntimeExports.jsx(BiFilterAlt, { className: "icon", onClick: () => setOpen(true) })
          ] })
        ] })
      ] });
    };
    const MotionConfigContext = reactExports.createContext({
      transformPagePoint: (p2) => p2,
      isStatic: false,
      reducedMotion: "never"
    });
    const MotionContext = reactExports.createContext({});
    const PresenceContext = reactExports.createContext(null);
    const isBrowser = typeof document !== "undefined";
    const useIsomorphicLayoutEffect = isBrowser ? reactExports.useLayoutEffect : reactExports.useEffect;
    const LazyContext = reactExports.createContext({ strict: false });
    const camelToDash = (str) => str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
    const optimizedAppearDataId = "framerAppearId";
    const optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);
    const MotionGlobalConfig = {
      skipAnimations: false,
      useManualTiming: false
    };
    class Queue {
      constructor() {
        this.order = [];
        this.scheduled = /* @__PURE__ */ new Set();
      }
      add(process) {
        if (!this.scheduled.has(process)) {
          this.scheduled.add(process);
          this.order.push(process);
          return true;
        }
      }
      remove(process) {
        const index = this.order.indexOf(process);
        if (index !== -1) {
          this.order.splice(index, 1);
          this.scheduled.delete(process);
        }
      }
      clear() {
        this.order.length = 0;
        this.scheduled.clear();
      }
    }
    function createRenderStep(runNextFrame) {
      let thisFrame = new Queue();
      let nextFrame = new Queue();
      let numToRun = 0;
      let isProcessing = false;
      let flushNextFrame = false;
      const toKeepAlive = /* @__PURE__ */ new WeakSet();
      const step = {
        /**
         * Schedule a process to run on the next frame.
         */
        schedule: (callback, keepAlive = false, immediate = false) => {
          const addToCurrentFrame = immediate && isProcessing;
          const queue = addToCurrentFrame ? thisFrame : nextFrame;
          if (keepAlive)
            toKeepAlive.add(callback);
          if (queue.add(callback) && addToCurrentFrame && isProcessing) {
            numToRun = thisFrame.order.length;
          }
          return callback;
        },
        /**
         * Cancel the provided callback from running on the next frame.
         */
        cancel: (callback) => {
          nextFrame.remove(callback);
          toKeepAlive.delete(callback);
        },
        /**
         * Execute all schedule callbacks.
         */
        process: (frameData2) => {
          if (isProcessing) {
            flushNextFrame = true;
            return;
          }
          isProcessing = true;
          [thisFrame, nextFrame] = [nextFrame, thisFrame];
          nextFrame.clear();
          numToRun = thisFrame.order.length;
          if (numToRun) {
            for (let i = 0; i < numToRun; i++) {
              const callback = thisFrame.order[i];
              if (toKeepAlive.has(callback)) {
                step.schedule(callback);
                runNextFrame();
              }
              callback(frameData2);
            }
          }
          isProcessing = false;
          if (flushNextFrame) {
            flushNextFrame = false;
            step.process(frameData2);
          }
        }
      };
      return step;
    }
    const stepsOrder = [
      "prepare",
      "read",
      "update",
      "preRender",
      "render",
      "postRender"
    ];
    const maxElapsed = 40;
    function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
      let runNextFrame = false;
      let useDefaultElapsed = true;
      const state = {
        delta: 0,
        timestamp: 0,
        isProcessing: false
      };
      const steps2 = stepsOrder.reduce((acc, key) => {
        acc[key] = createRenderStep(() => runNextFrame = true);
        return acc;
      }, {});
      const processStep = (stepId) => {
        steps2[stepId].process(state);
      };
      const processBatch = () => {
        const timestamp = performance.now();
        runNextFrame = false;
        state.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);
        state.timestamp = timestamp;
        state.isProcessing = true;
        stepsOrder.forEach(processStep);
        state.isProcessing = false;
        if (runNextFrame && allowKeepAlive) {
          useDefaultElapsed = false;
          scheduleNextBatch(processBatch);
        }
      };
      const wake = () => {
        runNextFrame = true;
        useDefaultElapsed = true;
        if (!state.isProcessing) {
          scheduleNextBatch(processBatch);
        }
      };
      const schedule = stepsOrder.reduce((acc, key) => {
        const step = steps2[key];
        acc[key] = (process, keepAlive = false, immediate = false) => {
          if (!runNextFrame)
            wake();
          return step.schedule(process, keepAlive, immediate);
        };
        return acc;
      }, {});
      const cancel = (process) => stepsOrder.forEach((key) => steps2[key].cancel(process));
      return { schedule, cancel, state, steps: steps2 };
    }
    const { schedule: microtask, cancel: cancelMicrotask } = createRenderBatcher(queueMicrotask, false);
    function useVisualElement(Component, visualState, props, createVisualElement) {
      const { visualElement: parent } = reactExports.useContext(MotionContext);
      const lazyContext = reactExports.useContext(LazyContext);
      const presenceContext = reactExports.useContext(PresenceContext);
      const reducedMotionConfig = reactExports.useContext(MotionConfigContext).reducedMotion;
      const visualElementRef = reactExports.useRef();
      createVisualElement = createVisualElement || lazyContext.renderer;
      if (!visualElementRef.current && createVisualElement) {
        visualElementRef.current = createVisualElement(Component, {
          visualState,
          parent,
          props,
          presenceContext,
          blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
          reducedMotionConfig
        });
      }
      const visualElement = visualElementRef.current;
      reactExports.useInsertionEffect(() => {
        visualElement && visualElement.update(props, presenceContext);
      });
      const wantsHandoff = reactExports.useRef(Boolean(props[optimizedAppearDataAttribute] && !window.HandoffComplete));
      useIsomorphicLayoutEffect(() => {
        if (!visualElement)
          return;
        microtask.postRender(visualElement.render);
        if (wantsHandoff.current && visualElement.animationState) {
          visualElement.animationState.animateChanges();
        }
      });
      reactExports.useEffect(() => {
        if (!visualElement)
          return;
        visualElement.updateFeatures();
        if (!wantsHandoff.current && visualElement.animationState) {
          visualElement.animationState.animateChanges();
        }
        if (wantsHandoff.current) {
          wantsHandoff.current = false;
          window.HandoffComplete = true;
        }
      });
      return visualElement;
    }
    function isRefObject(ref) {
      return ref && typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
    }
    function useMotionRef(visualState, visualElement, externalRef) {
      return reactExports.useCallback(
        (instance2) => {
          instance2 && visualState.mount && visualState.mount(instance2);
          if (visualElement) {
            instance2 ? visualElement.mount(instance2) : visualElement.unmount();
          }
          if (externalRef) {
            if (typeof externalRef === "function") {
              externalRef(instance2);
            } else if (isRefObject(externalRef)) {
              externalRef.current = instance2;
            }
          }
        },
        /**
         * Only pass a new ref callback to React if we've received a visual element
         * factory. Otherwise we'll be mounting/remounting every time externalRef
         * or other dependencies change.
         */
        [visualElement]
      );
    }
    function isVariantLabel(v2) {
      return typeof v2 === "string" || Array.isArray(v2);
    }
    function isAnimationControls(v2) {
      return v2 !== null && typeof v2 === "object" && typeof v2.start === "function";
    }
    const variantPriorityOrder = [
      "animate",
      "whileInView",
      "whileFocus",
      "whileHover",
      "whileTap",
      "whileDrag",
      "exit"
    ];
    const variantProps = ["initial", ...variantPriorityOrder];
    function isControllingVariants(props) {
      return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));
    }
    function isVariantNode(props) {
      return Boolean(isControllingVariants(props) || props.variants);
    }
    function getCurrentTreeVariants(props, context) {
      if (isControllingVariants(props)) {
        const { initial, animate } = props;
        return {
          initial: initial === false || isVariantLabel(initial) ? initial : void 0,
          animate: isVariantLabel(animate) ? animate : void 0
        };
      }
      return props.inherit !== false ? context : {};
    }
    function useCreateMotionContext(props) {
      const { initial, animate } = getCurrentTreeVariants(props, reactExports.useContext(MotionContext));
      return reactExports.useMemo(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);
    }
    function variantLabelsAsDependency(prop) {
      return Array.isArray(prop) ? prop.join(" ") : prop;
    }
    const featureProps = {
      animation: [
        "animate",
        "variants",
        "whileHover",
        "whileTap",
        "exit",
        "whileInView",
        "whileFocus",
        "whileDrag"
      ],
      exit: ["exit"],
      drag: ["drag", "dragControls"],
      focus: ["whileFocus"],
      hover: ["whileHover", "onHoverStart", "onHoverEnd"],
      tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
      pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
      inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
      layout: ["layout", "layoutId"]
    };
    const featureDefinitions = {};
    for (const key in featureProps) {
      featureDefinitions[key] = {
        isEnabled: (props) => featureProps[key].some((name) => !!props[name])
      };
    }
    function loadFeatures(features) {
      for (const key in features) {
        featureDefinitions[key] = {
          ...featureDefinitions[key],
          ...features[key]
        };
      }
    }
    const LayoutGroupContext = reactExports.createContext({});
    const SwitchLayoutGroupContext = reactExports.createContext({});
    const motionComponentSymbol = Symbol.for("motionComponentSymbol");
    function createMotionComponent({ preloadedFeatures: preloadedFeatures2, createVisualElement, useRender, useVisualState, Component }) {
      preloadedFeatures2 && loadFeatures(preloadedFeatures2);
      function MotionComponent(props, externalRef) {
        let MeasureLayout2;
        const configAndProps = {
          ...reactExports.useContext(MotionConfigContext),
          ...props,
          layoutId: useLayoutId(props)
        };
        const { isStatic } = configAndProps;
        const context = useCreateMotionContext(props);
        const visualState = useVisualState(props, isStatic);
        if (!isStatic && isBrowser) {
          context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement);
          const initialLayoutGroupConfig = reactExports.useContext(SwitchLayoutGroupContext);
          const isStrict = reactExports.useContext(LazyContext).strict;
          if (context.visualElement) {
            MeasureLayout2 = context.visualElement.loadFeatures(
              // Note: Pass the full new combined props to correctly re-render dynamic feature components.
              configAndProps,
              isStrict,
              preloadedFeatures2,
              initialLayoutGroupConfig
            );
          }
        }
        return reactExports.createElement(
          MotionContext.Provider,
          { value: context },
          MeasureLayout2 && context.visualElement ? reactExports.createElement(MeasureLayout2, { visualElement: context.visualElement, ...configAndProps }) : null,
          useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)
        );
      }
      const ForwardRefComponent = reactExports.forwardRef(MotionComponent);
      ForwardRefComponent[motionComponentSymbol] = Component;
      return ForwardRefComponent;
    }
    function useLayoutId({ layoutId }) {
      const layoutGroupId = reactExports.useContext(LayoutGroupContext).id;
      return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
    }
    function createMotionProxy(createConfig) {
      function custom(Component, customMotionComponentConfig = {}) {
        return createMotionComponent(createConfig(Component, customMotionComponentConfig));
      }
      if (typeof Proxy === "undefined") {
        return custom;
      }
      const componentCache = /* @__PURE__ */ new Map();
      return new Proxy(custom, {
        /**
         * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
         * The prop name is passed through as `key` and we can use that to generate a `motion`
         * DOM component with that name.
         */
        get: (_target, key) => {
          if (!componentCache.has(key)) {
            componentCache.set(key, custom(key));
          }
          return componentCache.get(key);
        }
      });
    }
    const lowercaseSVGElements = [
      "animate",
      "circle",
      "defs",
      "desc",
      "ellipse",
      "g",
      "image",
      "line",
      "filter",
      "marker",
      "mask",
      "metadata",
      "path",
      "pattern",
      "polygon",
      "polyline",
      "rect",
      "stop",
      "switch",
      "symbol",
      "svg",
      "text",
      "tspan",
      "use",
      "view"
    ];
    function isSVGComponent(Component) {
      if (
        /**
         * If it's not a string, it's a custom React component. Currently we only support
         * HTML custom React components.
         */
        typeof Component !== "string" || /**
         * If it contains a dash, the element is a custom HTML webcomponent.
         */
        Component.includes("-")
      ) {
        return false;
      } else if (
        /**
         * If it's in our list of lowercase SVG tags, it's an SVG component
         */
        lowercaseSVGElements.indexOf(Component) > -1 || /**
         * If it contains a capital letter, it's an SVG component
         */
        /[A-Z]/.test(Component)
      ) {
        return true;
      }
      return false;
    }
    const scaleCorrectors = {};
    function addScaleCorrector(correctors) {
      Object.assign(scaleCorrectors, correctors);
    }
    const transformPropOrder = [
      "transformPerspective",
      "x",
      "y",
      "z",
      "translateX",
      "translateY",
      "translateZ",
      "scale",
      "scaleX",
      "scaleY",
      "rotate",
      "rotateX",
      "rotateY",
      "rotateZ",
      "skew",
      "skewX",
      "skewY"
    ];
    const transformProps = new Set(transformPropOrder);
    function isForcedMotionValue(key, { layout: layout2, layoutId }) {
      return transformProps.has(key) || key.startsWith("origin") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
    }
    const isMotionValue = (value) => Boolean(value && value.getVelocity);
    const translateAlias = {
      x: "translateX",
      y: "translateY",
      z: "translateZ",
      transformPerspective: "perspective"
    };
    const numTransforms = transformPropOrder.length;
    function buildTransform(transform, { enableHardwareAcceleration = true, allowTransformNone = true }, transformIsDefault, transformTemplate) {
      let transformString = "";
      for (let i = 0; i < numTransforms; i++) {
        const key = transformPropOrder[i];
        if (transform[key] !== void 0) {
          const transformName = translateAlias[key] || key;
          transformString += `${transformName}(${transform[key]}) `;
        }
      }
      if (enableHardwareAcceleration && !transform.z) {
        transformString += "translateZ(0)";
      }
      transformString = transformString.trim();
      if (transformTemplate) {
        transformString = transformTemplate(transform, transformIsDefault ? "" : transformString);
      } else if (allowTransformNone && transformIsDefault) {
        transformString = "none";
      }
      return transformString;
    }
    const checkStringStartsWith = (token2) => (key) => typeof key === "string" && key.startsWith(token2);
    const isCSSVariableName = checkStringStartsWith("--");
    const startsAsVariableToken = checkStringStartsWith("var(--");
    const isCSSVariableToken = (key) => startsAsVariableToken(key) && singleCssVariableRegex.test(key);
    const singleCssVariableRegex = /var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)$/i;
    const getValueAsType = (value, type) => {
      return type && typeof value === "number" ? type.transform(value) : value;
    };
    const clamp = (min2, max2, v2) => {
      if (v2 > max2)
        return max2;
      if (v2 < min2)
        return min2;
      return v2;
    };
    const number = {
      test: (v2) => typeof v2 === "number",
      parse: parseFloat,
      transform: (v2) => v2
    };
    const alpha = {
      ...number,
      transform: (v2) => clamp(0, 1, v2)
    };
    const scale = {
      ...number,
      default: 1
    };
    const sanitize = (v2) => Math.round(v2 * 1e5) / 1e5;
    const floatRegex = /(-)?([\d]*\.?[\d])+/g;
    const colorRegex = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi;
    const singleColorRegex = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
    function isString(v2) {
      return typeof v2 === "string";
    }
    const createUnitType = (unit) => ({
      test: (v2) => isString(v2) && v2.endsWith(unit) && v2.split(" ").length === 1,
      parse: parseFloat,
      transform: (v2) => `${v2}${unit}`
    });
    const degrees = createUnitType("deg");
    const percent = createUnitType("%");
    const px = createUnitType("px");
    const vh = createUnitType("vh");
    const vw = createUnitType("vw");
    const progressPercentage = {
      ...percent,
      parse: (v2) => percent.parse(v2) / 100,
      transform: (v2) => percent.transform(v2 * 100)
    };
    const int = {
      ...number,
      transform: Math.round
    };
    const numberValueTypes = {
      // Border props
      borderWidth: px,
      borderTopWidth: px,
      borderRightWidth: px,
      borderBottomWidth: px,
      borderLeftWidth: px,
      borderRadius: px,
      radius: px,
      borderTopLeftRadius: px,
      borderTopRightRadius: px,
      borderBottomRightRadius: px,
      borderBottomLeftRadius: px,
      // Positioning props
      width: px,
      maxWidth: px,
      height: px,
      maxHeight: px,
      size: px,
      top: px,
      right: px,
      bottom: px,
      left: px,
      // Spacing props
      padding: px,
      paddingTop: px,
      paddingRight: px,
      paddingBottom: px,
      paddingLeft: px,
      margin: px,
      marginTop: px,
      marginRight: px,
      marginBottom: px,
      marginLeft: px,
      // Transform props
      rotate: degrees,
      rotateX: degrees,
      rotateY: degrees,
      rotateZ: degrees,
      scale,
      scaleX: scale,
      scaleY: scale,
      scaleZ: scale,
      skew: degrees,
      skewX: degrees,
      skewY: degrees,
      distance: px,
      translateX: px,
      translateY: px,
      translateZ: px,
      x: px,
      y: px,
      z: px,
      perspective: px,
      transformPerspective: px,
      opacity: alpha,
      originX: progressPercentage,
      originY: progressPercentage,
      originZ: px,
      // Misc
      zIndex: int,
      // SVG
      fillOpacity: alpha,
      strokeOpacity: alpha,
      numOctaves: int
    };
    function buildHTMLStyles(state, latestValues, options, transformTemplate) {
      const { style: style2, vars, transform, transformOrigin } = state;
      let hasTransform2 = false;
      let hasTransformOrigin = false;
      let transformIsNone = true;
      for (const key in latestValues) {
        const value = latestValues[key];
        if (isCSSVariableName(key)) {
          vars[key] = value;
          continue;
        }
        const valueType = numberValueTypes[key];
        const valueAsType = getValueAsType(value, valueType);
        if (transformProps.has(key)) {
          hasTransform2 = true;
          transform[key] = valueAsType;
          if (!transformIsNone)
            continue;
          if (value !== (valueType.default || 0))
            transformIsNone = false;
        } else if (key.startsWith("origin")) {
          hasTransformOrigin = true;
          transformOrigin[key] = valueAsType;
        } else {
          style2[key] = valueAsType;
        }
      }
      if (!latestValues.transform) {
        if (hasTransform2 || transformTemplate) {
          style2.transform = buildTransform(state.transform, options, transformIsNone, transformTemplate);
        } else if (style2.transform) {
          style2.transform = "none";
        }
      }
      if (hasTransformOrigin) {
        const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin;
        style2.transformOrigin = `${originX} ${originY} ${originZ}`;
      }
    }
    const createHtmlRenderState = () => ({
      style: {},
      transform: {},
      transformOrigin: {},
      vars: {}
    });
    function copyRawValuesOnly(target, source, props) {
      for (const key in source) {
        if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
          target[key] = source[key];
        }
      }
    }
    function useInitialMotionValues({ transformTemplate }, visualState, isStatic) {
      return reactExports.useMemo(() => {
        const state = createHtmlRenderState();
        buildHTMLStyles(state, visualState, { enableHardwareAcceleration: !isStatic }, transformTemplate);
        return Object.assign({}, state.vars, state.style);
      }, [visualState]);
    }
    function useStyle(props, visualState, isStatic) {
      const styleProp = props.style || {};
      const style2 = {};
      copyRawValuesOnly(style2, styleProp, props);
      Object.assign(style2, useInitialMotionValues(props, visualState, isStatic));
      return style2;
    }
    function useHTMLProps(props, visualState, isStatic) {
      const htmlProps = {};
      const style2 = useStyle(props, visualState, isStatic);
      if (props.drag && props.dragListener !== false) {
        htmlProps.draggable = false;
        style2.userSelect = style2.WebkitUserSelect = style2.WebkitTouchCallout = "none";
        style2.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
      }
      if (props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap)) {
        htmlProps.tabIndex = 0;
      }
      htmlProps.style = style2;
      return htmlProps;
    }
    const validMotionProps = /* @__PURE__ */ new Set([
      "animate",
      "exit",
      "variants",
      "initial",
      "style",
      "values",
      "variants",
      "transition",
      "transformTemplate",
      "custom",
      "inherit",
      "onBeforeLayoutMeasure",
      "onAnimationStart",
      "onAnimationComplete",
      "onUpdate",
      "onDragStart",
      "onDrag",
      "onDragEnd",
      "onMeasureDragConstraints",
      "onDirectionLock",
      "onDragTransitionEnd",
      "_dragX",
      "_dragY",
      "onHoverStart",
      "onHoverEnd",
      "onViewportEnter",
      "onViewportLeave",
      "globalTapTarget",
      "ignoreStrict",
      "viewport"
    ]);
    function isValidMotionProp(key) {
      return key.startsWith("while") || key.startsWith("drag") && key !== "draggable" || key.startsWith("layout") || key.startsWith("onTap") || key.startsWith("onPan") || key.startsWith("onLayout") || validMotionProps.has(key);
    }
    let shouldForward = (key) => !isValidMotionProp(key);
    function loadExternalIsValidProp(isValidProp) {
      if (!isValidProp)
        return;
      shouldForward = (key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
    }
    try {
      loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
    } catch (_a) {
    }
    function filterProps(props, isDom, forwardMotionProps) {
      const filteredProps = {};
      for (const key in props) {
        if (key === "values" && typeof props.values === "object")
          continue;
        if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || // If trying to use native HTML drag events, forward drag listeners
        props["draggable"] && key.startsWith("onDrag")) {
          filteredProps[key] = props[key];
        }
      }
      return filteredProps;
    }
    function calcOrigin$1(origin, offset2, size) {
      return typeof origin === "string" ? origin : px.transform(offset2 + size * origin);
    }
    function calcSVGTransformOrigin(dimensions, originX, originY) {
      const pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width);
      const pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);
      return `${pxOriginX} ${pxOriginY}`;
    }
    const dashKeys = {
      offset: "stroke-dashoffset",
      array: "stroke-dasharray"
    };
    const camelKeys = {
      offset: "strokeDashoffset",
      array: "strokeDasharray"
    };
    function buildSVGPath(attrs, length2, spacing = 1, offset2 = 0, useDashCase = true) {
      attrs.pathLength = 1;
      const keys2 = useDashCase ? dashKeys : camelKeys;
      attrs[keys2.offset] = px.transform(-offset2);
      const pathLength = px.transform(length2);
      const pathSpacing = px.transform(spacing);
      attrs[keys2.array] = `${pathLength} ${pathSpacing}`;
    }
    function buildSVGAttrs(state, {
      attrX,
      attrY,
      attrScale,
      originX,
      originY,
      pathLength,
      pathSpacing = 1,
      pathOffset = 0,
      // This is object creation, which we try to avoid per-frame.
      ...latest
    }, options, isSVGTag2, transformTemplate) {
      buildHTMLStyles(state, latest, options, transformTemplate);
      if (isSVGTag2) {
        if (state.style.viewBox) {
          state.attrs.viewBox = state.style.viewBox;
        }
        return;
      }
      state.attrs = state.style;
      state.style = {};
      const { attrs, style: style2, dimensions } = state;
      if (attrs.transform) {
        if (dimensions)
          style2.transform = attrs.transform;
        delete attrs.transform;
      }
      if (dimensions && (originX !== void 0 || originY !== void 0 || style2.transform)) {
        style2.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);
      }
      if (attrX !== void 0)
        attrs.x = attrX;
      if (attrY !== void 0)
        attrs.y = attrY;
      if (attrScale !== void 0)
        attrs.scale = attrScale;
      if (pathLength !== void 0) {
        buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
      }
    }
    const createSvgRenderState = () => ({
      ...createHtmlRenderState(),
      attrs: {}
    });
    const isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";
    function useSVGProps(props, visualState, _isStatic, Component) {
      const visualProps = reactExports.useMemo(() => {
        const state = createSvgRenderState();
        buildSVGAttrs(state, visualState, { enableHardwareAcceleration: false }, isSVGTag(Component), props.transformTemplate);
        return {
          ...state.attrs,
          style: { ...state.style }
        };
      }, [visualState]);
      if (props.style) {
        const rawStyles = {};
        copyRawValuesOnly(rawStyles, props.style, props);
        visualProps.style = { ...rawStyles, ...visualProps.style };
      }
      return visualProps;
    }
    function createUseRender(forwardMotionProps = false) {
      const useRender = (Component, props, ref, { latestValues }, isStatic) => {
        const useVisualProps = isSVGComponent(Component) ? useSVGProps : useHTMLProps;
        const visualProps = useVisualProps(props, latestValues, isStatic, Component);
        const filteredProps = filterProps(props, typeof Component === "string", forwardMotionProps);
        const elementProps = {
          ...filteredProps,
          ...visualProps,
          ref
        };
        const { children } = props;
        const renderedChildren = reactExports.useMemo(() => isMotionValue(children) ? children.get() : children, [children]);
        return reactExports.createElement(Component, {
          ...elementProps,
          children: renderedChildren
        });
      };
      return useRender;
    }
    function renderHTML(element, { style: style2, vars }, styleProp, projection) {
      Object.assign(element.style, style2, projection && projection.getProjectionStyles(styleProp));
      for (const key in vars) {
        element.style.setProperty(key, vars[key]);
      }
    }
    const camelCaseAttributes = /* @__PURE__ */ new Set([
      "baseFrequency",
      "diffuseConstant",
      "kernelMatrix",
      "kernelUnitLength",
      "keySplines",
      "keyTimes",
      "limitingConeAngle",
      "markerHeight",
      "markerWidth",
      "numOctaves",
      "targetX",
      "targetY",
      "surfaceScale",
      "specularConstant",
      "specularExponent",
      "stdDeviation",
      "tableValues",
      "viewBox",
      "gradientTransform",
      "pathLength",
      "startOffset",
      "textLength",
      "lengthAdjust"
    ]);
    function renderSVG(element, renderState, _styleProp, projection) {
      renderHTML(element, renderState, void 0, projection);
      for (const key in renderState.attrs) {
        element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
      }
    }
    function scrapeMotionValuesFromProps$1(props, prevProps) {
      const { style: style2 } = props;
      const newValues = {};
      for (const key in style2) {
        if (isMotionValue(style2[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props)) {
          newValues[key] = style2[key];
        }
      }
      return newValues;
    }
    function scrapeMotionValuesFromProps(props, prevProps) {
      const newValues = scrapeMotionValuesFromProps$1(props, prevProps);
      for (const key in props) {
        if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {
          const targetKey = transformPropOrder.indexOf(key) !== -1 ? "attr" + key.charAt(0).toUpperCase() + key.substring(1) : key;
          newValues[targetKey] = props[key];
        }
      }
      return newValues;
    }
    function resolveVariantFromProps(props, definition, custom, currentValues = {}, currentVelocity = {}) {
      if (typeof definition === "function") {
        definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);
      }
      if (typeof definition === "string") {
        definition = props.variants && props.variants[definition];
      }
      if (typeof definition === "function") {
        definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);
      }
      return definition;
    }
    function useConstant(init) {
      const ref = reactExports.useRef(null);
      if (ref.current === null) {
        ref.current = init();
      }
      return ref.current;
    }
    const isKeyframesTarget = (v2) => {
      return Array.isArray(v2);
    };
    const isCustomValue = (v2) => {
      return Boolean(v2 && typeof v2 === "object" && v2.mix && v2.toValue);
    };
    const resolveFinalValueInKeyframes = (v2) => {
      return isKeyframesTarget(v2) ? v2[v2.length - 1] || 0 : v2;
    };
    function resolveMotionValue(value) {
      const unwrappedValue = isMotionValue(value) ? value.get() : value;
      return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
    }
    function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2, createRenderState, onMount }, props, context, presenceContext) {
      const state = {
        latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps2),
        renderState: createRenderState()
      };
      if (onMount) {
        state.mount = (instance2) => onMount(props, instance2, state);
      }
      return state;
    }
    const makeUseVisualState = (config2) => (props, isStatic) => {
      const context = reactExports.useContext(MotionContext);
      const presenceContext = reactExports.useContext(PresenceContext);
      const make = () => makeState(config2, props, context, presenceContext);
      return isStatic ? make() : useConstant(make);
    };
    function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
      const values2 = {};
      const motionValues = scrapeMotionValues(props, {});
      for (const key in motionValues) {
        values2[key] = resolveMotionValue(motionValues[key]);
      }
      let { initial, animate } = props;
      const isControllingVariants$1 = isControllingVariants(props);
      const isVariantNode$1 = isVariantNode(props);
      if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
        if (initial === void 0)
          initial = context.initial;
        if (animate === void 0)
          animate = context.animate;
      }
      let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
      isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
      const variantToSet = isInitialAnimationBlocked ? animate : initial;
      if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
        const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
        list.forEach((definition) => {
          const resolved = resolveVariantFromProps(props, definition);
          if (!resolved)
            return;
          const { transitionEnd, transition, ...target } = resolved;
          for (const key in target) {
            let valueTarget = target[key];
            if (Array.isArray(valueTarget)) {
              const index = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
              valueTarget = valueTarget[index];
            }
            if (valueTarget !== null) {
              values2[key] = valueTarget;
            }
          }
          for (const key in transitionEnd)
            values2[key] = transitionEnd[key];
        });
      }
      return values2;
    }
    const noop = (any) => any;
    const { schedule: frame, cancel: cancelFrame, state: frameData, steps } = createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop, true);
    const svgMotionConfig = {
      useVisualState: makeUseVisualState({
        scrapeMotionValuesFromProps,
        createRenderState: createSvgRenderState,
        onMount: (props, instance2, { renderState, latestValues }) => {
          frame.read(() => {
            try {
              renderState.dimensions = typeof instance2.getBBox === "function" ? instance2.getBBox() : instance2.getBoundingClientRect();
            } catch (e2) {
              renderState.dimensions = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
              };
            }
          });
          frame.render(() => {
            buildSVGAttrs(renderState, latestValues, { enableHardwareAcceleration: false }, isSVGTag(instance2.tagName), props.transformTemplate);
            renderSVG(instance2, renderState);
          });
        }
      })
    };
    const htmlMotionConfig = {
      useVisualState: makeUseVisualState({
        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
        createRenderState: createHtmlRenderState
      })
    };
    function createDomMotionConfig(Component, { forwardMotionProps = false }, preloadedFeatures2, createVisualElement) {
      const baseConfig = isSVGComponent(Component) ? svgMotionConfig : htmlMotionConfig;
      return {
        ...baseConfig,
        preloadedFeatures: preloadedFeatures2,
        useRender: createUseRender(forwardMotionProps),
        createVisualElement,
        Component
      };
    }
    function addDomEvent(target, eventName, handler, options = { passive: true }) {
      target.addEventListener(eventName, handler, options);
      return () => target.removeEventListener(eventName, handler);
    }
    const isPrimaryPointer = (event) => {
      if (event.pointerType === "mouse") {
        return typeof event.button !== "number" || event.button <= 0;
      } else {
        return event.isPrimary !== false;
      }
    };
    function extractEventInfo(event, pointType = "page") {
      return {
        point: {
          x: event[pointType + "X"],
          y: event[pointType + "Y"]
        }
      };
    }
    const addPointerInfo = (handler) => {
      return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
    };
    function addPointerEvent(target, eventName, handler, options) {
      return addDomEvent(target, eventName, addPointerInfo(handler), options);
    }
    const combineFunctions = (a, b2) => (v2) => b2(a(v2));
    const pipe = (...transformers) => transformers.reduce(combineFunctions);
    function createLock(name) {
      let lock = null;
      return () => {
        const openLock = () => {
          lock = null;
        };
        if (lock === null) {
          lock = name;
          return openLock;
        }
        return false;
      };
    }
    const globalHorizontalLock = createLock("dragHorizontal");
    const globalVerticalLock = createLock("dragVertical");
    function getGlobalLock(drag2) {
      let lock = false;
      if (drag2 === "y") {
        lock = globalVerticalLock();
      } else if (drag2 === "x") {
        lock = globalHorizontalLock();
      } else {
        const openHorizontal = globalHorizontalLock();
        const openVertical = globalVerticalLock();
        if (openHorizontal && openVertical) {
          lock = () => {
            openHorizontal();
            openVertical();
          };
        } else {
          if (openHorizontal)
            openHorizontal();
          if (openVertical)
            openVertical();
        }
      }
      return lock;
    }
    function isDragActive() {
      const openGestureLock = getGlobalLock(true);
      if (!openGestureLock)
        return true;
      openGestureLock();
      return false;
    }
    class Feature {
      constructor(node2) {
        this.isMounted = false;
        this.node = node2;
      }
      update() {
      }
    }
    function addHoverEvent(node2, isActive) {
      const eventName = "pointer" + (isActive ? "enter" : "leave");
      const callbackName = "onHover" + (isActive ? "Start" : "End");
      const handleEvent = (event, info) => {
        if (event.pointerType === "touch" || isDragActive())
          return;
        const props = node2.getProps();
        if (node2.animationState && props.whileHover) {
          node2.animationState.setActive("whileHover", isActive);
        }
        if (props[callbackName]) {
          frame.update(() => props[callbackName](event, info));
        }
      };
      return addPointerEvent(node2.current, eventName, handleEvent, {
        passive: !node2.getProps()[callbackName]
      });
    }
    class HoverGesture extends Feature {
      mount() {
        this.unmount = pipe(addHoverEvent(this.node, true), addHoverEvent(this.node, false));
      }
      unmount() {
      }
    }
    class FocusGesture extends Feature {
      constructor() {
        super(...arguments);
        this.isActive = false;
      }
      onFocus() {
        let isFocusVisible2 = false;
        try {
          isFocusVisible2 = this.node.current.matches(":focus-visible");
        } catch (e2) {
          isFocusVisible2 = true;
        }
        if (!isFocusVisible2 || !this.node.animationState)
          return;
        this.node.animationState.setActive("whileFocus", true);
        this.isActive = true;
      }
      onBlur() {
        if (!this.isActive || !this.node.animationState)
          return;
        this.node.animationState.setActive("whileFocus", false);
        this.isActive = false;
      }
      mount() {
        this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
      }
      unmount() {
      }
    }
    const isNodeOrChild = (parent, child) => {
      if (!child) {
        return false;
      } else if (parent === child) {
        return true;
      } else {
        return isNodeOrChild(parent, child.parentElement);
      }
    };
    function fireSyntheticPointerEvent(name, handler) {
      if (!handler)
        return;
      const syntheticPointerEvent = new PointerEvent("pointer" + name);
      handler(syntheticPointerEvent, extractEventInfo(syntheticPointerEvent));
    }
    class PressGesture extends Feature {
      constructor() {
        super(...arguments);
        this.removeStartListeners = noop;
        this.removeEndListeners = noop;
        this.removeAccessibleListeners = noop;
        this.startPointerPress = (startEvent, startInfo) => {
          if (this.isPressing)
            return;
          this.removeEndListeners();
          const props = this.node.getProps();
          const endPointerPress = (endEvent, endInfo) => {
            if (!this.checkPressEnd())
              return;
            const { onTap, onTapCancel, globalTapTarget } = this.node.getProps();
            frame.update(() => {
              !globalTapTarget && !isNodeOrChild(this.node.current, endEvent.target) ? onTapCancel && onTapCancel(endEvent, endInfo) : onTap && onTap(endEvent, endInfo);
            });
          };
          const removePointerUpListener = addPointerEvent(window, "pointerup", endPointerPress, { passive: !(props.onTap || props["onPointerUp"]) });
          const removePointerCancelListener = addPointerEvent(window, "pointercancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo), { passive: !(props.onTapCancel || props["onPointerCancel"]) });
          this.removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener);
          this.startPress(startEvent, startInfo);
        };
        this.startAccessiblePress = () => {
          const handleKeydown = (keydownEvent) => {
            if (keydownEvent.key !== "Enter" || this.isPressing)
              return;
            const handleKeyup = (keyupEvent) => {
              if (keyupEvent.key !== "Enter" || !this.checkPressEnd())
                return;
              fireSyntheticPointerEvent("up", (event, info) => {
                const { onTap } = this.node.getProps();
                if (onTap) {
                  frame.update(() => onTap(event, info));
                }
              });
            };
            this.removeEndListeners();
            this.removeEndListeners = addDomEvent(this.node.current, "keyup", handleKeyup);
            fireSyntheticPointerEvent("down", (event, info) => {
              this.startPress(event, info);
            });
          };
          const removeKeydownListener = addDomEvent(this.node.current, "keydown", handleKeydown);
          const handleBlur = () => {
            if (!this.isPressing)
              return;
            fireSyntheticPointerEvent("cancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo));
          };
          const removeBlurListener = addDomEvent(this.node.current, "blur", handleBlur);
          this.removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);
        };
      }
      startPress(event, info) {
        this.isPressing = true;
        const { onTapStart, whileTap } = this.node.getProps();
        if (whileTap && this.node.animationState) {
          this.node.animationState.setActive("whileTap", true);
        }
        if (onTapStart) {
          frame.update(() => onTapStart(event, info));
        }
      }
      checkPressEnd() {
        this.removeEndListeners();
        this.isPressing = false;
        const props = this.node.getProps();
        if (props.whileTap && this.node.animationState) {
          this.node.animationState.setActive("whileTap", false);
        }
        return !isDragActive();
      }
      cancelPress(event, info) {
        if (!this.checkPressEnd())
          return;
        const { onTapCancel } = this.node.getProps();
        if (onTapCancel) {
          frame.update(() => onTapCancel(event, info));
        }
      }
      mount() {
        const props = this.node.getProps();
        const removePointerListener = addPointerEvent(props.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, { passive: !(props.onTapStart || props["onPointerStart"]) });
        const removeFocusListener = addDomEvent(this.node.current, "focus", this.startAccessiblePress);
        this.removeStartListeners = pipe(removePointerListener, removeFocusListener);
      }
      unmount() {
        this.removeStartListeners();
        this.removeEndListeners();
        this.removeAccessibleListeners();
      }
    }
    const observerCallbacks = /* @__PURE__ */ new WeakMap();
    const observers = /* @__PURE__ */ new WeakMap();
    const fireObserverCallback = (entry) => {
      const callback = observerCallbacks.get(entry.target);
      callback && callback(entry);
    };
    const fireAllObserverCallbacks = (entries) => {
      entries.forEach(fireObserverCallback);
    };
    function initIntersectionObserver({ root: root2, ...options }) {
      const lookupRoot = root2 || document;
      if (!observers.has(lookupRoot)) {
        observers.set(lookupRoot, {});
      }
      const rootObservers = observers.get(lookupRoot);
      const key = JSON.stringify(options);
      if (!rootObservers[key]) {
        rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root: root2, ...options });
      }
      return rootObservers[key];
    }
    function observeIntersection(element, options, callback) {
      const rootInteresectionObserver = initIntersectionObserver(options);
      observerCallbacks.set(element, callback);
      rootInteresectionObserver.observe(element);
      return () => {
        observerCallbacks.delete(element);
        rootInteresectionObserver.unobserve(element);
      };
    }
    const thresholdNames = {
      some: 0,
      all: 1
    };
    class InViewFeature extends Feature {
      constructor() {
        super(...arguments);
        this.hasEnteredView = false;
        this.isInView = false;
      }
      startObserver() {
        this.unmount();
        const { viewport: viewport2 = {} } = this.node.getProps();
        const { root: root2, margin: rootMargin, amount = "some", once } = viewport2;
        const options = {
          root: root2 ? root2.current : void 0,
          rootMargin,
          threshold: typeof amount === "number" ? amount : thresholdNames[amount]
        };
        const onIntersectionUpdate = (entry) => {
          const { isIntersecting } = entry;
          if (this.isInView === isIntersecting)
            return;
          this.isInView = isIntersecting;
          if (once && !isIntersecting && this.hasEnteredView) {
            return;
          } else if (isIntersecting) {
            this.hasEnteredView = true;
          }
          if (this.node.animationState) {
            this.node.animationState.setActive("whileInView", isIntersecting);
          }
          const { onViewportEnter, onViewportLeave } = this.node.getProps();
          const callback = isIntersecting ? onViewportEnter : onViewportLeave;
          callback && callback(entry);
        };
        return observeIntersection(this.node.current, options, onIntersectionUpdate);
      }
      mount() {
        this.startObserver();
      }
      update() {
        if (typeof IntersectionObserver === "undefined")
          return;
        const { props, prevProps } = this.node;
        const hasOptionsChanged = ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps));
        if (hasOptionsChanged) {
          this.startObserver();
        }
      }
      unmount() {
      }
    }
    function hasViewportOptionChanged({ viewport: viewport2 = {} }, { viewport: prevViewport = {} } = {}) {
      return (name) => viewport2[name] !== prevViewport[name];
    }
    const gestureAnimations = {
      inView: {
        Feature: InViewFeature
      },
      tap: {
        Feature: PressGesture
      },
      focus: {
        Feature: FocusGesture
      },
      hover: {
        Feature: HoverGesture
      }
    };
    function shallowCompare(next2, prev2) {
      if (!Array.isArray(prev2))
        return false;
      const prevLength = prev2.length;
      if (prevLength !== next2.length)
        return false;
      for (let i = 0; i < prevLength; i++) {
        if (prev2[i] !== next2[i])
          return false;
      }
      return true;
    }
    function getCurrent(visualElement) {
      const current = {};
      visualElement.values.forEach((value, key) => current[key] = value.get());
      return current;
    }
    function getVelocity$1(visualElement) {
      const velocity = {};
      visualElement.values.forEach((value, key) => velocity[key] = value.getVelocity());
      return velocity;
    }
    function resolveVariant(visualElement, definition, custom) {
      const props = visualElement.getProps();
      return resolveVariantFromProps(props, definition, custom !== void 0 ? custom : props.custom, getCurrent(visualElement), getVelocity$1(visualElement));
    }
    let invariant = noop;
    const secondsToMilliseconds = (seconds) => seconds * 1e3;
    const millisecondsToSeconds = (milliseconds) => milliseconds / 1e3;
    const instantAnimationState = {
      current: false
    };
    const isBezierDefinition = (easing2) => Array.isArray(easing2) && typeof easing2[0] === "number";
    function isWaapiSupportedEasing(easing2) {
      return Boolean(!easing2 || typeof easing2 === "string" && supportedWaapiEasing[easing2] || isBezierDefinition(easing2) || Array.isArray(easing2) && easing2.every(isWaapiSupportedEasing));
    }
    const cubicBezierAsString = ([a, b2, c2, d2]) => `cubic-bezier(${a}, ${b2}, ${c2}, ${d2})`;
    const supportedWaapiEasing = {
      linear: "linear",
      ease: "ease",
      easeIn: "ease-in",
      easeOut: "ease-out",
      easeInOut: "ease-in-out",
      circIn: cubicBezierAsString([0, 0.65, 0.55, 1]),
      circOut: cubicBezierAsString([0.55, 0, 1, 0.45]),
      backIn: cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
      backOut: cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
    };
    function mapEasingToNativeEasing(easing2) {
      if (!easing2)
        return void 0;
      return isBezierDefinition(easing2) ? cubicBezierAsString(easing2) : Array.isArray(easing2) ? easing2.map(mapEasingToNativeEasing) : supportedWaapiEasing[easing2];
    }
    function animateStyle(element, valueName, keyframes2, { delay: delay2 = 0, duration: duration2, repeat = 0, repeatType = "loop", ease: ease2, times } = {}) {
      const keyframeOptions = { [valueName]: keyframes2 };
      if (times)
        keyframeOptions.offset = times;
      const easing2 = mapEasingToNativeEasing(ease2);
      if (Array.isArray(easing2))
        keyframeOptions.easing = easing2;
      return element.animate(keyframeOptions, {
        delay: delay2,
        duration: duration2,
        easing: !Array.isArray(easing2) ? easing2 : "linear",
        fill: "both",
        iterations: repeat + 1,
        direction: repeatType === "reverse" ? "alternate" : "normal"
      });
    }
    function getFinalKeyframe(keyframes2, { repeat, repeatType = "loop" }) {
      const index = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : keyframes2.length - 1;
      return keyframes2[index];
    }
    const calcBezier = (t2, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t2 + (3 * a2 - 6 * a1)) * t2 + 3 * a1) * t2;
    const subdivisionPrecision = 1e-7;
    const subdivisionMaxIterations = 12;
    function binarySubdivide(x2, lowerBound, upperBound, mX1, mX2) {
      let currentX;
      let currentT;
      let i = 0;
      do {
        currentT = lowerBound + (upperBound - lowerBound) / 2;
        currentX = calcBezier(currentT, mX1, mX2) - x2;
        if (currentX > 0) {
          upperBound = currentT;
        } else {
          lowerBound = currentT;
        }
      } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);
      return currentT;
    }
    function cubicBezier(mX1, mY1, mX2, mY2) {
      if (mX1 === mY1 && mX2 === mY2)
        return noop;
      const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
      return (t2) => t2 === 0 || t2 === 1 ? t2 : calcBezier(getTForX(t2), mY1, mY2);
    }
    const easeIn = cubicBezier(0.42, 0, 1, 1);
    const easeOut = cubicBezier(0, 0, 0.58, 1);
    const easeInOut = cubicBezier(0.42, 0, 0.58, 1);
    const isEasingArray = (ease2) => {
      return Array.isArray(ease2) && typeof ease2[0] !== "number";
    };
    const mirrorEasing = (easing2) => (p2) => p2 <= 0.5 ? easing2(2 * p2) / 2 : (2 - easing2(2 * (1 - p2))) / 2;
    const reverseEasing = (easing2) => (p2) => 1 - easing2(1 - p2);
    const circIn = (p2) => 1 - Math.sin(Math.acos(p2));
    const circOut = reverseEasing(circIn);
    const circInOut = mirrorEasing(circIn);
    const backOut = cubicBezier(0.33, 1.53, 0.69, 0.99);
    const backIn = reverseEasing(backOut);
    const backInOut = mirrorEasing(backIn);
    const anticipate = (p2) => (p2 *= 2) < 1 ? 0.5 * backIn(p2) : 0.5 * (2 - Math.pow(2, -10 * (p2 - 1)));
    const easingLookup = {
      linear: noop,
      easeIn,
      easeInOut,
      easeOut,
      circIn,
      circInOut,
      circOut,
      backIn,
      backInOut,
      backOut,
      anticipate
    };
    const easingDefinitionToFunction = (definition) => {
      if (Array.isArray(definition)) {
        invariant(definition.length === 4);
        const [x1, y1, x2, y2] = definition;
        return cubicBezier(x1, y1, x2, y2);
      } else if (typeof definition === "string") {
        return easingLookup[definition];
      }
      return definition;
    };
    const progress = (from2, to, value) => {
      const toFromDifference = to - from2;
      return toFromDifference === 0 ? 1 : (value - from2) / toFromDifference;
    };
    const mixNumber$1 = (from2, to, progress2) => {
      return from2 + (to - from2) * progress2;
    };
    function hueToRgb(p2, q2, t2) {
      if (t2 < 0)
        t2 += 1;
      if (t2 > 1)
        t2 -= 1;
      if (t2 < 1 / 6)
        return p2 + (q2 - p2) * 6 * t2;
      if (t2 < 1 / 2)
        return q2;
      if (t2 < 2 / 3)
        return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
      return p2;
    }
    function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
      hue /= 360;
      saturation /= 100;
      lightness /= 100;
      let red2 = 0;
      let green2 = 0;
      let blue2 = 0;
      if (!saturation) {
        red2 = green2 = blue2 = lightness;
      } else {
        const q2 = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
        const p2 = 2 * lightness - q2;
        red2 = hueToRgb(p2, q2, hue + 1 / 3);
        green2 = hueToRgb(p2, q2, hue);
        blue2 = hueToRgb(p2, q2, hue - 1 / 3);
      }
      return {
        red: Math.round(red2 * 255),
        green: Math.round(green2 * 255),
        blue: Math.round(blue2 * 255),
        alpha: alpha2
      };
    }
    const isColorString = (type, testProp) => (v2) => {
      return Boolean(isString(v2) && singleColorRegex.test(v2) && v2.startsWith(type) || testProp && Object.prototype.hasOwnProperty.call(v2, testProp));
    };
    const splitColor = (aName, bName, cName) => (v2) => {
      if (!isString(v2))
        return v2;
      const [a, b2, c2, alpha2] = v2.match(floatRegex);
      return {
        [aName]: parseFloat(a),
        [bName]: parseFloat(b2),
        [cName]: parseFloat(c2),
        alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
      };
    };
    const clampRgbUnit = (v2) => clamp(0, 255, v2);
    const rgbUnit = {
      ...number,
      transform: (v2) => Math.round(clampRgbUnit(v2))
    };
    const rgba = {
      test: isColorString("rgb", "red"),
      parse: splitColor("red", "green", "blue"),
      transform: ({ red: red2, green: green2, blue: blue2, alpha: alpha$12 = 1 }) => "rgba(" + rgbUnit.transform(red2) + ", " + rgbUnit.transform(green2) + ", " + rgbUnit.transform(blue2) + ", " + sanitize(alpha.transform(alpha$12)) + ")"
    };
    function parseHex(v2) {
      let r2 = "";
      let g2 = "";
      let b2 = "";
      let a = "";
      if (v2.length > 5) {
        r2 = v2.substring(1, 3);
        g2 = v2.substring(3, 5);
        b2 = v2.substring(5, 7);
        a = v2.substring(7, 9);
      } else {
        r2 = v2.substring(1, 2);
        g2 = v2.substring(2, 3);
        b2 = v2.substring(3, 4);
        a = v2.substring(4, 5);
        r2 += r2;
        g2 += g2;
        b2 += b2;
        a += a;
      }
      return {
        red: parseInt(r2, 16),
        green: parseInt(g2, 16),
        blue: parseInt(b2, 16),
        alpha: a ? parseInt(a, 16) / 255 : 1
      };
    }
    const hex = {
      test: isColorString("#"),
      parse: parseHex,
      transform: rgba.transform
    };
    const hsla = {
      test: isColorString("hsl", "hue"),
      parse: splitColor("hue", "saturation", "lightness"),
      transform: ({ hue, saturation, lightness, alpha: alpha$12 = 1 }) => {
        return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$12)) + ")";
      }
    };
    const mixLinearColor = (from2, to, v2) => {
      const fromExpo = from2 * from2;
      const expo = v2 * (to * to - fromExpo) + fromExpo;
      return expo < 0 ? 0 : Math.sqrt(expo);
    };
    const colorTypes = [hex, rgba, hsla];
    const getColorType = (v2) => colorTypes.find((type) => type.test(v2));
    function asRGBA(color2) {
      const type = getColorType(color2);
      let model = type.parse(color2);
      if (type === hsla) {
        model = hslaToRgba(model);
      }
      return model;
    }
    const mixColor = (from2, to) => {
      const fromRGBA = asRGBA(from2);
      const toRGBA = asRGBA(to);
      const blended = { ...fromRGBA };
      return (v2) => {
        blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v2);
        blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v2);
        blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v2);
        blended.alpha = mixNumber$1(fromRGBA.alpha, toRGBA.alpha, v2);
        return rgba.transform(blended);
      };
    };
    const color = {
      test: (v2) => rgba.test(v2) || hex.test(v2) || hsla.test(v2),
      parse: (v2) => {
        if (rgba.test(v2)) {
          return rgba.parse(v2);
        } else if (hsla.test(v2)) {
          return hsla.parse(v2);
        } else {
          return hex.parse(v2);
        }
      },
      transform: (v2) => {
        return isString(v2) ? v2 : v2.hasOwnProperty("red") ? rgba.transform(v2) : hsla.transform(v2);
      }
    };
    function test(v2) {
      var _a, _b;
      return isNaN(v2) && isString(v2) && (((_a = v2.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) + (((_b = v2.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) > 0;
    }
    const NUMBER_TOKEN = "number";
    const COLOR_TOKEN = "color";
    const VAR_TOKEN = "var";
    const VAR_FUNCTION_TOKEN = "var(";
    const SPLIT_TOKEN = "${}";
    const complexRegex = /(var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\))|(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))|((-)?([\d]*\.?[\d])+)/gi;
    function analyseComplexValue(value) {
      const originalValue = value.toString();
      const matchedValues = originalValue.match(complexRegex) || [];
      const values2 = [];
      const indexes = {
        color: [],
        number: [],
        var: []
      };
      const types2 = [];
      for (let i = 0; i < matchedValues.length; i++) {
        const parsedValue = matchedValues[i];
        if (color.test(parsedValue)) {
          indexes.color.push(i);
          types2.push(COLOR_TOKEN);
          values2.push(color.parse(parsedValue));
        } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {
          indexes.var.push(i);
          types2.push(VAR_TOKEN);
          values2.push(parsedValue);
        } else {
          indexes.number.push(i);
          types2.push(NUMBER_TOKEN);
          values2.push(parseFloat(parsedValue));
        }
      }
      const tokenised = originalValue.replace(complexRegex, SPLIT_TOKEN);
      const split2 = tokenised.split(SPLIT_TOKEN);
      return { values: values2, split: split2, indexes, types: types2 };
    }
    function parseComplexValue(v2) {
      return analyseComplexValue(v2).values;
    }
    function createTransformer(source) {
      const { split: split2, types: types2 } = analyseComplexValue(source);
      const numSections = split2.length;
      return (v2) => {
        let output = "";
        for (let i = 0; i < numSections; i++) {
          output += split2[i];
          if (v2[i] !== void 0) {
            const type = types2[i];
            if (type === NUMBER_TOKEN) {
              output += sanitize(v2[i]);
            } else if (type === COLOR_TOKEN) {
              output += color.transform(v2[i]);
            } else {
              output += v2[i];
            }
          }
        }
        return output;
      };
    }
    const convertNumbersToZero = (v2) => typeof v2 === "number" ? 0 : v2;
    function getAnimatableNone$1(v2) {
      const parsed = parseComplexValue(v2);
      const transformer = createTransformer(v2);
      return transformer(parsed.map(convertNumbersToZero));
    }
    const complex = {
      test,
      parse: parseComplexValue,
      createTransformer,
      getAnimatableNone: getAnimatableNone$1
    };
    function mixImmediate(a, b2) {
      return (p2) => p2 > 0 ? b2 : a;
    }
    function mixNumber(a, b2) {
      return (p2) => mixNumber$1(a, b2, p2);
    }
    function getMixer(a) {
      if (typeof a === "number") {
        return mixNumber;
      } else if (typeof a === "string") {
        return isCSSVariableToken(a) ? mixImmediate : color.test(a) ? mixColor : mixComplex;
      } else if (Array.isArray(a)) {
        return mixArray;
      } else if (typeof a === "object") {
        return color.test(a) ? mixColor : mixObject;
      }
      return mixImmediate;
    }
    function mixArray(a, b2) {
      const output = [...a];
      const numValues = output.length;
      const blendValue = a.map((v2, i) => getMixer(v2)(v2, b2[i]));
      return (p2) => {
        for (let i = 0; i < numValues; i++) {
          output[i] = blendValue[i](p2);
        }
        return output;
      };
    }
    function mixObject(a, b2) {
      const output = { ...a, ...b2 };
      const blendValue = {};
      for (const key in output) {
        if (a[key] !== void 0 && b2[key] !== void 0) {
          blendValue[key] = getMixer(a[key])(a[key], b2[key]);
        }
      }
      return (v2) => {
        for (const key in blendValue) {
          output[key] = blendValue[key](v2);
        }
        return output;
      };
    }
    function matchOrder(origin, target) {
      var _a;
      const orderedOrigin = [];
      const pointers = { color: 0, var: 0, number: 0 };
      for (let i = 0; i < target.values.length; i++) {
        const type = target.types[i];
        const originIndex = origin.indexes[type][pointers[type]];
        const originValue = (_a = origin.values[originIndex]) !== null && _a !== void 0 ? _a : 0;
        orderedOrigin[i] = originValue;
        pointers[type]++;
      }
      return orderedOrigin;
    }
    const mixComplex = (origin, target) => {
      const template = complex.createTransformer(target);
      const originStats = analyseComplexValue(origin);
      const targetStats = analyseComplexValue(target);
      const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length;
      if (canInterpolate) {
        return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);
      } else {
        return mixImmediate(origin, target);
      }
    };
    function mix(from2, to, p2) {
      if (typeof from2 === "number" && typeof to === "number" && typeof p2 === "number") {
        return mixNumber$1(from2, to, p2);
      }
      const mixer = getMixer(from2);
      return mixer(from2, to);
    }
    function createMixers(output, ease2, customMixer) {
      const mixers = [];
      const mixerFactory = customMixer || mix;
      const numMixers = output.length - 1;
      for (let i = 0; i < numMixers; i++) {
        let mixer = mixerFactory(output[i], output[i + 1]);
        if (ease2) {
          const easingFunction = Array.isArray(ease2) ? ease2[i] || noop : ease2;
          mixer = pipe(easingFunction, mixer);
        }
        mixers.push(mixer);
      }
      return mixers;
    }
    function interpolate(input, output, { clamp: isClamp = true, ease: ease2, mixer } = {}) {
      const inputLength = input.length;
      invariant(inputLength === output.length);
      if (inputLength === 1)
        return () => output[0];
      if (input[0] > input[inputLength - 1]) {
        input = [...input].reverse();
        output = [...output].reverse();
      }
      const mixers = createMixers(output, ease2, mixer);
      const numMixers = mixers.length;
      const interpolator = (v2) => {
        let i = 0;
        if (numMixers > 1) {
          for (; i < input.length - 2; i++) {
            if (v2 < input[i + 1])
              break;
          }
        }
        const progressInRange = progress(input[i], input[i + 1], v2);
        return mixers[i](progressInRange);
      };
      return isClamp ? (v2) => interpolator(clamp(input[0], input[inputLength - 1], v2)) : interpolator;
    }
    function fillOffset(offset2, remaining) {
      const min2 = offset2[offset2.length - 1];
      for (let i = 1; i <= remaining; i++) {
        const offsetProgress = progress(0, remaining, i);
        offset2.push(mixNumber$1(min2, 1, offsetProgress));
      }
    }
    function defaultOffset(arr) {
      const offset2 = [0];
      fillOffset(offset2, arr.length - 1);
      return offset2;
    }
    function convertOffsetToTimes(offset2, duration2) {
      return offset2.map((o) => o * duration2);
    }
    function defaultEasing(values2, easing2) {
      return values2.map(() => easing2 || easeInOut).splice(0, values2.length - 1);
    }
    function keyframes({ duration: duration2 = 300, keyframes: keyframeValues, times, ease: ease2 = "easeInOut" }) {
      const easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2);
      const state = {
        done: false,
        value: keyframeValues[0]
      };
      const absoluteTimes = convertOffsetToTimes(
        // Only use the provided offsets if they're the correct length
        // TODO Maybe we should warn here if there's a length mismatch
        times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
        duration2
      );
      const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
        ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
      });
      return {
        calculatedDuration: duration2,
        next: (t2) => {
          state.value = mapTimeToKeyframe(t2);
          state.done = t2 >= duration2;
          return state;
        }
      };
    }
    function velocityPerSecond(velocity, frameDuration) {
      return frameDuration ? velocity * (1e3 / frameDuration) : 0;
    }
    const velocitySampleDuration = 5;
    function calcGeneratorVelocity(resolveValue, t2, current) {
      const prevT = Math.max(t2 - velocitySampleDuration, 0);
      return velocityPerSecond(current - resolveValue(prevT), t2 - prevT);
    }
    const safeMin = 1e-3;
    const minDuration = 0.01;
    const maxDuration$1 = 10;
    const minDamping = 0.05;
    const maxDamping = 1;
    function findSpring({ duration: duration2 = 800, bounce = 0.25, velocity = 0, mass = 1 }) {
      let envelope;
      let derivative;
      let dampingRatio = 1 - bounce;
      dampingRatio = clamp(minDamping, maxDamping, dampingRatio);
      duration2 = clamp(minDuration, maxDuration$1, millisecondsToSeconds(duration2));
      if (dampingRatio < 1) {
        envelope = (undampedFreq2) => {
          const exponentialDecay = undampedFreq2 * dampingRatio;
          const delta = exponentialDecay * duration2;
          const a = exponentialDecay - velocity;
          const b2 = calcAngularFreq(undampedFreq2, dampingRatio);
          const c2 = Math.exp(-delta);
          return safeMin - a / b2 * c2;
        };
        derivative = (undampedFreq2) => {
          const exponentialDecay = undampedFreq2 * dampingRatio;
          const delta = exponentialDecay * duration2;
          const d2 = delta * velocity + velocity;
          const e2 = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration2;
          const f2 = Math.exp(-delta);
          const g2 = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
          const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
          return factor * ((d2 - e2) * f2) / g2;
        };
      } else {
        envelope = (undampedFreq2) => {
          const a = Math.exp(-undampedFreq2 * duration2);
          const b2 = (undampedFreq2 - velocity) * duration2 + 1;
          return -safeMin + a * b2;
        };
        derivative = (undampedFreq2) => {
          const a = Math.exp(-undampedFreq2 * duration2);
          const b2 = (velocity - undampedFreq2) * (duration2 * duration2);
          return a * b2;
        };
      }
      const initialGuess = 5 / duration2;
      const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
      duration2 = secondsToMilliseconds(duration2);
      if (isNaN(undampedFreq)) {
        return {
          stiffness: 100,
          damping: 10,
          duration: duration2
        };
      } else {
        const stiffness = Math.pow(undampedFreq, 2) * mass;
        return {
          stiffness,
          damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
          duration: duration2
        };
      }
    }
    const rootIterations = 12;
    function approximateRoot(envelope, derivative, initialGuess) {
      let result = initialGuess;
      for (let i = 1; i < rootIterations; i++) {
        result = result - envelope(result) / derivative(result);
      }
      return result;
    }
    function calcAngularFreq(undampedFreq, dampingRatio) {
      return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
    }
    const durationKeys = ["duration", "bounce"];
    const physicsKeys = ["stiffness", "damping", "mass"];
    function isSpringType(options, keys2) {
      return keys2.some((key) => options[key] !== void 0);
    }
    function getSpringOptions(options) {
      let springOptions = {
        velocity: 0,
        stiffness: 100,
        damping: 10,
        mass: 1,
        isResolvedFromDuration: false,
        ...options
      };
      if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
        const derived = findSpring(options);
        springOptions = {
          ...springOptions,
          ...derived,
          mass: 1
        };
        springOptions.isResolvedFromDuration = true;
      }
      return springOptions;
    }
    function spring({ keyframes: keyframes2, restDelta, restSpeed, ...options }) {
      const origin = keyframes2[0];
      const target = keyframes2[keyframes2.length - 1];
      const state = { done: false, value: origin };
      const { stiffness, damping, mass, duration: duration2, velocity, isResolvedFromDuration } = getSpringOptions({
        ...options,
        velocity: -millisecondsToSeconds(options.velocity || 0)
      });
      const initialVelocity = velocity || 0;
      const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
      const initialDelta = target - origin;
      const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));
      const isGranularScale = Math.abs(initialDelta) < 5;
      restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);
      restDelta || (restDelta = isGranularScale ? 5e-3 : 0.5);
      let resolveSpring;
      if (dampingRatio < 1) {
        const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
        resolveSpring = (t2) => {
          const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
          return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t2) + initialDelta * Math.cos(angularFreq * t2));
        };
      } else if (dampingRatio === 1) {
        resolveSpring = (t2) => target - Math.exp(-undampedAngularFreq * t2) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t2);
      } else {
        const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
        resolveSpring = (t2) => {
          const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
          const freqForT = Math.min(dampedAngularFreq * t2, 300);
          return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
        };
      }
      return {
        calculatedDuration: isResolvedFromDuration ? duration2 || null : null,
        next: (t2) => {
          const current = resolveSpring(t2);
          if (!isResolvedFromDuration) {
            let currentVelocity = initialVelocity;
            if (t2 !== 0) {
              if (dampingRatio < 1) {
                currentVelocity = calcGeneratorVelocity(resolveSpring, t2, current);
              } else {
                currentVelocity = 0;
              }
            }
            const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
            const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
            state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
          } else {
            state.done = t2 >= duration2;
          }
          state.value = state.done ? target : current;
          return state;
        }
      };
    }
    function inertia({ keyframes: keyframes2, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min: min2, max: max2, restDelta = 0.5, restSpeed }) {
      const origin = keyframes2[0];
      const state = {
        done: false,
        value: origin
      };
      const isOutOfBounds = (v2) => min2 !== void 0 && v2 < min2 || max2 !== void 0 && v2 > max2;
      const nearestBoundary = (v2) => {
        if (min2 === void 0)
          return max2;
        if (max2 === void 0)
          return min2;
        return Math.abs(min2 - v2) < Math.abs(max2 - v2) ? min2 : max2;
      };
      let amplitude = power * velocity;
      const ideal = origin + amplitude;
      const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
      if (target !== ideal)
        amplitude = target - origin;
      const calcDelta = (t2) => -amplitude * Math.exp(-t2 / timeConstant);
      const calcLatest = (t2) => target + calcDelta(t2);
      const applyFriction = (t2) => {
        const delta = calcDelta(t2);
        const latest = calcLatest(t2);
        state.done = Math.abs(delta) <= restDelta;
        state.value = state.done ? target : latest;
      };
      let timeReachedBoundary;
      let spring$1;
      const checkCatchBoundary = (t2) => {
        if (!isOutOfBounds(state.value))
          return;
        timeReachedBoundary = t2;
        spring$1 = spring({
          keyframes: [state.value, nearestBoundary(state.value)],
          velocity: calcGeneratorVelocity(calcLatest, t2, state.value),
          damping: bounceDamping,
          stiffness: bounceStiffness,
          restDelta,
          restSpeed
        });
      };
      checkCatchBoundary(0);
      return {
        calculatedDuration: null,
        next: (t2) => {
          let hasUpdatedFrame = false;
          if (!spring$1 && timeReachedBoundary === void 0) {
            hasUpdatedFrame = true;
            applyFriction(t2);
            checkCatchBoundary(t2);
          }
          if (timeReachedBoundary !== void 0 && t2 > timeReachedBoundary) {
            return spring$1.next(t2 - timeReachedBoundary);
          } else {
            !hasUpdatedFrame && applyFriction(t2);
            return state;
          }
        }
      };
    }
    let now;
    function clearTime() {
      now = void 0;
    }
    const time = {
      now: () => {
        if (now === void 0) {
          time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now());
        }
        return now;
      },
      set: (newTime) => {
        now = newTime;
        queueMicrotask(clearTime);
      }
    };
    const frameloopDriver = (update) => {
      const passTimestamp = ({ timestamp }) => update(timestamp);
      return {
        start: () => frame.update(passTimestamp, true),
        stop: () => cancelFrame(passTimestamp),
        /**
         * If we're processing this frame we can use the
         * framelocked timestamp to keep things in sync.
         */
        now: () => frameData.isProcessing ? frameData.timestamp : time.now()
      };
    };
    const maxGeneratorDuration = 2e4;
    function calcGeneratorDuration(generator) {
      let duration2 = 0;
      const timeStep = 50;
      let state = generator.next(duration2);
      while (!state.done && duration2 < maxGeneratorDuration) {
        duration2 += timeStep;
        state = generator.next(duration2);
      }
      return duration2 >= maxGeneratorDuration ? Infinity : duration2;
    }
    const types = {
      decay: inertia,
      inertia,
      tween: keyframes,
      keyframes,
      spring
    };
    const percentToProgress = (percent2) => percent2 / 100;
    function animateValue({ autoplay = true, delay: delay2 = 0, driver = frameloopDriver, keyframes: keyframes$12, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", onPlay, onStop, onComplete, onUpdate, ...options }) {
      let speed = 1;
      let hasStopped = false;
      let resolveFinishedPromise;
      let currentFinishedPromise;
      const updateFinishedPromise = () => {
        currentFinishedPromise = new Promise((resolve) => {
          resolveFinishedPromise = resolve;
        });
      };
      updateFinishedPromise();
      let animationDriver;
      const generatorFactory = types[type] || keyframes;
      let mapNumbersToKeyframes;
      if (generatorFactory !== keyframes && typeof keyframes$12[0] !== "number") {
        mapNumbersToKeyframes = pipe(percentToProgress, mix(keyframes$12[0], keyframes$12[1]));
        keyframes$12 = [0, 100];
      }
      const generator = generatorFactory({ ...options, keyframes: keyframes$12 });
      let mirroredGenerator;
      if (repeatType === "mirror") {
        mirroredGenerator = generatorFactory({
          ...options,
          keyframes: [...keyframes$12].reverse(),
          velocity: -(options.velocity || 0)
        });
      }
      let playState = "idle";
      let holdTime = null;
      let startTime = null;
      let cancelTime = null;
      if (generator.calculatedDuration === null && repeat) {
        generator.calculatedDuration = calcGeneratorDuration(generator);
      }
      const { calculatedDuration } = generator;
      let resolvedDuration = Infinity;
      let totalDuration = Infinity;
      if (calculatedDuration !== null) {
        resolvedDuration = calculatedDuration + repeatDelay;
        totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;
      }
      let currentTime = 0;
      const tick = (timestamp) => {
        if (startTime === null)
          return;
        if (speed > 0)
          startTime = Math.min(startTime, timestamp);
        if (speed < 0)
          startTime = Math.min(timestamp - totalDuration / speed, startTime);
        if (holdTime !== null) {
          currentTime = holdTime;
        } else {
          currentTime = Math.round(timestamp - startTime) * speed;
        }
        const timeWithoutDelay = currentTime - delay2 * (speed >= 0 ? 1 : -1);
        const isInDelayPhase = speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
        currentTime = Math.max(timeWithoutDelay, 0);
        if (playState === "finished" && holdTime === null) {
          currentTime = totalDuration;
        }
        let elapsed = currentTime;
        let frameGenerator = generator;
        if (repeat) {
          const progress2 = Math.min(currentTime, totalDuration) / resolvedDuration;
          let currentIteration = Math.floor(progress2);
          let iterationProgress = progress2 % 1;
          if (!iterationProgress && progress2 >= 1) {
            iterationProgress = 1;
          }
          iterationProgress === 1 && currentIteration--;
          currentIteration = Math.min(currentIteration, repeat + 1);
          const isOddIteration = Boolean(currentIteration % 2);
          if (isOddIteration) {
            if (repeatType === "reverse") {
              iterationProgress = 1 - iterationProgress;
              if (repeatDelay) {
                iterationProgress -= repeatDelay / resolvedDuration;
              }
            } else if (repeatType === "mirror") {
              frameGenerator = mirroredGenerator;
            }
          }
          elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;
        }
        const state = isInDelayPhase ? { done: false, value: keyframes$12[0] } : frameGenerator.next(elapsed);
        if (mapNumbersToKeyframes) {
          state.value = mapNumbersToKeyframes(state.value);
        }
        let { done } = state;
        if (!isInDelayPhase && calculatedDuration !== null) {
          done = speed >= 0 ? currentTime >= totalDuration : currentTime <= 0;
        }
        const isAnimationFinished = holdTime === null && (playState === "finished" || playState === "running" && done);
        if (onUpdate) {
          onUpdate(state.value);
        }
        if (isAnimationFinished) {
          finish();
        }
        return state;
      };
      const stopAnimationDriver = () => {
        animationDriver && animationDriver.stop();
        animationDriver = void 0;
      };
      const cancel = () => {
        playState = "idle";
        stopAnimationDriver();
        resolveFinishedPromise();
        updateFinishedPromise();
        startTime = cancelTime = null;
      };
      const finish = () => {
        playState = "finished";
        onComplete && onComplete();
        stopAnimationDriver();
        resolveFinishedPromise();
      };
      const play = () => {
        if (hasStopped)
          return;
        if (!animationDriver)
          animationDriver = driver(tick);
        const now2 = animationDriver.now();
        onPlay && onPlay();
        if (holdTime !== null) {
          startTime = now2 - holdTime;
        } else if (!startTime || playState === "finished") {
          startTime = now2;
        }
        if (playState === "finished") {
          updateFinishedPromise();
        }
        cancelTime = startTime;
        holdTime = null;
        playState = "running";
        animationDriver.start();
      };
      if (autoplay) {
        play();
      }
      const controls = {
        then(resolve, reject) {
          return currentFinishedPromise.then(resolve, reject);
        },
        get time() {
          return millisecondsToSeconds(currentTime);
        },
        set time(newTime) {
          newTime = secondsToMilliseconds(newTime);
          currentTime = newTime;
          if (holdTime !== null || !animationDriver || speed === 0) {
            holdTime = newTime;
          } else {
            startTime = animationDriver.now() - newTime / speed;
          }
        },
        get duration() {
          const duration2 = generator.calculatedDuration === null ? calcGeneratorDuration(generator) : generator.calculatedDuration;
          return millisecondsToSeconds(duration2);
        },
        get speed() {
          return speed;
        },
        set speed(newSpeed) {
          if (newSpeed === speed || !animationDriver)
            return;
          speed = newSpeed;
          controls.time = millisecondsToSeconds(currentTime);
        },
        get state() {
          return playState;
        },
        play,
        pause: () => {
          playState = "paused";
          holdTime = currentTime;
        },
        stop: () => {
          hasStopped = true;
          if (playState === "idle")
            return;
          playState = "idle";
          onStop && onStop();
          cancel();
        },
        cancel: () => {
          if (cancelTime !== null)
            tick(cancelTime);
          cancel();
        },
        complete: () => {
          playState = "finished";
        },
        sample: (elapsed) => {
          startTime = 0;
          return tick(elapsed);
        }
      };
      return controls;
    }
    function memo(callback) {
      let result;
      return () => {
        if (result === void 0)
          result = callback();
        return result;
      };
    }
    const supportsWaapi = memo(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
    const acceleratedValues = /* @__PURE__ */ new Set([
      "opacity",
      "clipPath",
      "filter",
      "transform"
    ]);
    const sampleDelta = 10;
    const maxDuration = 2e4;
    const requiresPregeneratedKeyframes = (valueName, options) => options.type === "spring" || valueName === "backgroundColor" || !isWaapiSupportedEasing(options.ease);
    function createAcceleratedAnimation(value, valueName, { onUpdate, onComplete, ...options }) {
      const canAccelerateAnimation = supportsWaapi() && acceleratedValues.has(valueName) && !options.repeatDelay && options.repeatType !== "mirror" && options.damping !== 0 && options.type !== "inertia";
      if (!canAccelerateAnimation)
        return false;
      let hasStopped = false;
      let resolveFinishedPromise;
      let currentFinishedPromise;
      let pendingCancel = false;
      const updateFinishedPromise = () => {
        currentFinishedPromise = new Promise((resolve) => {
          resolveFinishedPromise = resolve;
        });
      };
      updateFinishedPromise();
      let { keyframes: keyframes2, duration: duration2 = 300, ease: ease2, times } = options;
      if (requiresPregeneratedKeyframes(valueName, options)) {
        const sampleAnimation = animateValue({
          ...options,
          repeat: 0,
          delay: 0
        });
        let state = { done: false, value: keyframes2[0] };
        const pregeneratedKeyframes = [];
        let t2 = 0;
        while (!state.done && t2 < maxDuration) {
          state = sampleAnimation.sample(t2);
          pregeneratedKeyframes.push(state.value);
          t2 += sampleDelta;
        }
        times = void 0;
        keyframes2 = pregeneratedKeyframes;
        duration2 = t2 - sampleDelta;
        ease2 = "linear";
      }
      const animation = animateStyle(value.owner.current, valueName, keyframes2, {
        ...options,
        duration: duration2,
        /**
         * This function is currently not called if ease is provided
         * as a function so the cast is safe.
         *
         * However it would be possible for a future refinement to port
         * in easing pregeneration from Motion One for browsers that
         * support the upcoming `linear()` easing function.
         */
        ease: ease2,
        times
      });
      const cancelAnimation = () => {
        pendingCancel = false;
        animation.cancel();
      };
      const safeCancel = () => {
        pendingCancel = true;
        frame.update(cancelAnimation);
        resolveFinishedPromise();
        updateFinishedPromise();
      };
      animation.onfinish = () => {
        if (pendingCancel)
          return;
        value.set(getFinalKeyframe(keyframes2, options));
        onComplete && onComplete();
        safeCancel();
      };
      const controls = {
        then(resolve, reject) {
          return currentFinishedPromise.then(resolve, reject);
        },
        attachTimeline(timeline) {
          animation.timeline = timeline;
          animation.onfinish = null;
          return noop;
        },
        get time() {
          return millisecondsToSeconds(animation.currentTime || 0);
        },
        set time(newTime) {
          animation.currentTime = secondsToMilliseconds(newTime);
        },
        get speed() {
          return animation.playbackRate;
        },
        set speed(newSpeed) {
          animation.playbackRate = newSpeed;
        },
        get duration() {
          return millisecondsToSeconds(duration2);
        },
        play: () => {
          if (hasStopped)
            return;
          animation.play();
          cancelFrame(cancelAnimation);
        },
        pause: () => animation.pause(),
        stop: () => {
          hasStopped = true;
          if (animation.playState === "idle")
            return;
          const { currentTime } = animation;
          if (currentTime) {
            const sampleAnimation = animateValue({
              ...options,
              autoplay: false
            });
            value.setWithVelocity(sampleAnimation.sample(currentTime - sampleDelta).value, sampleAnimation.sample(currentTime).value, sampleDelta);
          }
          safeCancel();
        },
        complete: () => {
          if (pendingCancel)
            return;
          animation.finish();
        },
        cancel: safeCancel
      };
      return controls;
    }
    function createInstantAnimation({ keyframes: keyframes2, delay: delay2, onUpdate, onComplete }) {
      const setValue = () => {
        onUpdate && onUpdate(keyframes2[keyframes2.length - 1]);
        onComplete && onComplete();
        return {
          time: 0,
          speed: 1,
          duration: 0,
          play: noop,
          pause: noop,
          stop: noop,
          then: (resolve) => {
            resolve();
            return Promise.resolve();
          },
          cancel: noop,
          complete: noop
        };
      };
      return delay2 ? animateValue({
        keyframes: [0, 1],
        duration: 0,
        delay: delay2,
        onComplete: setValue
      }) : setValue();
    }
    const underDampedSpring = {
      type: "spring",
      stiffness: 500,
      damping: 25,
      restSpeed: 10
    };
    const criticallyDampedSpring = (target) => ({
      type: "spring",
      stiffness: 550,
      damping: target === 0 ? 2 * Math.sqrt(550) : 30,
      restSpeed: 10
    });
    const keyframesTransition = {
      type: "keyframes",
      duration: 0.8
    };
    const ease = {
      type: "keyframes",
      ease: [0.25, 0.1, 0.35, 1],
      duration: 0.3
    };
    const getDefaultTransition = (valueKey, { keyframes: keyframes2 }) => {
      if (keyframes2.length > 2) {
        return keyframesTransition;
      } else if (transformProps.has(valueKey)) {
        return valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes2[1]) : underDampedSpring;
      }
      return ease;
    };
    const isAnimatable = (key, value) => {
      if (key === "zIndex")
        return false;
      if (typeof value === "number" || Array.isArray(value))
        return true;
      if (typeof value === "string" && // It's animatable if we have a string
      (complex.test(value) || value === "0") && // And it contains numbers and/or colors
      !value.startsWith("url(")) {
        return true;
      }
      return false;
    };
    const maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
    function applyDefaultFilter(v2) {
      const [name, value] = v2.slice(0, -1).split("(");
      if (name === "drop-shadow")
        return v2;
      const [number2] = value.match(floatRegex) || [];
      if (!number2)
        return v2;
      const unit = value.replace(number2, "");
      let defaultValue = maxDefaults.has(name) ? 1 : 0;
      if (number2 !== value)
        defaultValue *= 100;
      return name + "(" + defaultValue + unit + ")";
    }
    const functionRegex = /([a-z-]*)\(.*?\)/g;
    const filter = {
      ...complex,
      getAnimatableNone: (v2) => {
        const functions = v2.match(functionRegex);
        return functions ? functions.map(applyDefaultFilter).join(" ") : v2;
      }
    };
    const defaultValueTypes = {
      ...numberValueTypes,
      // Color props
      color,
      backgroundColor: color,
      outlineColor: color,
      fill: color,
      stroke: color,
      // Border props
      borderColor: color,
      borderTopColor: color,
      borderRightColor: color,
      borderBottomColor: color,
      borderLeftColor: color,
      filter,
      WebkitFilter: filter
    };
    const getDefaultValueType = (key) => defaultValueTypes[key];
    function getAnimatableNone(key, value) {
      let defaultValueType = getDefaultValueType(key);
      if (defaultValueType !== filter)
        defaultValueType = complex;
      return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
    }
    const isZeroValueString = (v2) => /^0[^.\s]+$/.test(v2);
    function isNone(value) {
      if (typeof value === "number") {
        return value === 0;
      } else if (value !== null) {
        return value === "none" || value === "0" || isZeroValueString(value);
      }
    }
    function getKeyframes(value, valueName, target, transition) {
      const isTargetAnimatable = isAnimatable(valueName, target);
      let keyframes2;
      if (Array.isArray(target)) {
        keyframes2 = [...target];
      } else {
        keyframes2 = [null, target];
      }
      const defaultOrigin = transition.from !== void 0 ? transition.from : value.get();
      let animatableTemplateValue = void 0;
      const noneKeyframeIndexes = [];
      for (let i = 0; i < keyframes2.length; i++) {
        if (keyframes2[i] === null) {
          keyframes2[i] = i === 0 ? defaultOrigin : keyframes2[i - 1];
        }
        if (isNone(keyframes2[i])) {
          noneKeyframeIndexes.push(i);
        }
        if (typeof keyframes2[i] === "string" && keyframes2[i] !== "none" && keyframes2[i] !== "0") {
          animatableTemplateValue = keyframes2[i];
        }
      }
      if (isTargetAnimatable && noneKeyframeIndexes.length && animatableTemplateValue) {
        for (let i = 0; i < noneKeyframeIndexes.length; i++) {
          const index = noneKeyframeIndexes[i];
          keyframes2[index] = getAnimatableNone(valueName, animatableTemplateValue);
        }
      }
      return keyframes2;
    }
    function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from: from2, elapsed, ...transition }) {
      return !!Object.keys(transition).length;
    }
    function getValueTransition(transition, key) {
      return transition[key] || transition["default"] || transition;
    }
    const animateMotionValue = (valueName, value, target, transition = {}) => {
      return (onComplete) => {
        const valueTransition = getValueTransition(transition, valueName) || {};
        const delay2 = valueTransition.delay || transition.delay || 0;
        let { elapsed = 0 } = transition;
        elapsed = elapsed - secondsToMilliseconds(delay2);
        const keyframes2 = getKeyframes(value, valueName, target, valueTransition);
        const originKeyframe = keyframes2[0];
        const targetKeyframe = keyframes2[keyframes2.length - 1];
        const isOriginAnimatable = isAnimatable(valueName, originKeyframe);
        const isTargetAnimatable = isAnimatable(valueName, targetKeyframe);
        let options = {
          keyframes: keyframes2,
          velocity: value.getVelocity(),
          ease: "easeOut",
          ...valueTransition,
          delay: -elapsed,
          onUpdate: (v2) => {
            value.set(v2);
            valueTransition.onUpdate && valueTransition.onUpdate(v2);
          },
          onComplete: () => {
            onComplete();
            valueTransition.onComplete && valueTransition.onComplete();
          }
        };
        if (!isTransitionDefined(valueTransition)) {
          options = {
            ...options,
            ...getDefaultTransition(valueName, options)
          };
        }
        if (options.duration) {
          options.duration = secondsToMilliseconds(options.duration);
        }
        if (options.repeatDelay) {
          options.repeatDelay = secondsToMilliseconds(options.repeatDelay);
        }
        if (!isOriginAnimatable || !isTargetAnimatable || instantAnimationState.current || valueTransition.type === false || MotionGlobalConfig.skipAnimations) {
          return createInstantAnimation(options);
        }
        if (
          /**
           * If this is a handoff animation, the optimised animation will be running via
           * WAAPI. Therefore, this animation must be JS to ensure it runs "under" the
           * optimised animation.
           */
          !transition.isHandoff && value.owner && value.owner.current instanceof HTMLElement && /**
           * If we're outputting values to onUpdate then we can't use WAAPI as there's
           * no way to read the value from WAAPI every frame.
           */
          !value.owner.getProps().onUpdate
        ) {
          const acceleratedAnimation = createAcceleratedAnimation(value, valueName, options);
          if (acceleratedAnimation)
            return acceleratedAnimation;
        }
        return animateValue(options);
      };
    };
    function isWillChangeMotionValue(value) {
      return Boolean(isMotionValue(value) && value.add);
    }
    const isNumericalString = (v2) => /^\-?\d*\.?\d+$/.test(v2);
    function addUniqueItem(arr, item) {
      if (arr.indexOf(item) === -1)
        arr.push(item);
    }
    function removeItem(arr, item) {
      const index = arr.indexOf(item);
      if (index > -1)
        arr.splice(index, 1);
    }
    class SubscriptionManager {
      constructor() {
        this.subscriptions = [];
      }
      add(handler) {
        addUniqueItem(this.subscriptions, handler);
        return () => removeItem(this.subscriptions, handler);
      }
      notify(a, b2, c2) {
        const numSubscriptions = this.subscriptions.length;
        if (!numSubscriptions)
          return;
        if (numSubscriptions === 1) {
          this.subscriptions[0](a, b2, c2);
        } else {
          for (let i = 0; i < numSubscriptions; i++) {
            const handler = this.subscriptions[i];
            handler && handler(a, b2, c2);
          }
        }
      }
      getSize() {
        return this.subscriptions.length;
      }
      clear() {
        this.subscriptions.length = 0;
      }
    }
    const MAX_VELOCITY_DELTA = 30;
    const isFloat = (value) => {
      return !isNaN(parseFloat(value));
    };
    class MotionValue {
      /**
       * @param init - The initiating value
       * @param config - Optional configuration options
       *
       * -  `transformer`: A function to transform incoming values with.
       *
       * @internal
       */
      constructor(init, options = {}) {
        this.version = "11.0.5";
        this.canTrackVelocity = false;
        this.events = {};
        this.updateAndNotify = (v2, render = true) => {
          const currentTime = time.now();
          if (this.updatedAt !== currentTime) {
            this.setPrevFrameValue();
          }
          this.prev = this.current;
          this.setCurrent(v2);
          if (this.current !== this.prev && this.events.change) {
            this.events.change.notify(this.current);
          }
          if (render && this.events.renderRequest) {
            this.events.renderRequest.notify(this.current);
          }
        };
        this.hasAnimated = false;
        this.setCurrent(init);
        this.canTrackVelocity = isFloat(this.current);
        this.owner = options.owner;
      }
      setCurrent(current) {
        this.current = current;
        this.updatedAt = time.now();
      }
      setPrevFrameValue(prevFrameValue = this.current) {
        this.prevFrameValue = prevFrameValue;
        this.prevUpdatedAt = this.updatedAt;
      }
      /**
       * Adds a function that will be notified when the `MotionValue` is updated.
       *
       * It returns a function that, when called, will cancel the subscription.
       *
       * When calling `onChange` inside a React component, it should be wrapped with the
       * `useEffect` hook. As it returns an unsubscribe function, this should be returned
       * from the `useEffect` function to ensure you don't add duplicate subscribers..
       *
       * ```jsx
       * export const MyComponent = () => {
       *   const x = useMotionValue(0)
       *   const y = useMotionValue(0)
       *   const opacity = useMotionValue(1)
       *
       *   useEffect(() => {
       *     function updateOpacity() {
       *       const maxXY = Math.max(x.get(), y.get())
       *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
       *       opacity.set(newOpacity)
       *     }
       *
       *     const unsubscribeX = x.on("change", updateOpacity)
       *     const unsubscribeY = y.on("change", updateOpacity)
       *
       *     return () => {
       *       unsubscribeX()
       *       unsubscribeY()
       *     }
       *   }, [])
       *
       *   return <motion.div style={{ x }} />
       * }
       * ```
       *
       * @param subscriber - A function that receives the latest value.
       * @returns A function that, when called, will cancel this subscription.
       *
       * @deprecated
       */
      onChange(subscription) {
        return this.on("change", subscription);
      }
      on(eventName, callback) {
        if (!this.events[eventName]) {
          this.events[eventName] = new SubscriptionManager();
        }
        const unsubscribe = this.events[eventName].add(callback);
        if (eventName === "change") {
          return () => {
            unsubscribe();
            frame.read(() => {
              if (!this.events.change.getSize()) {
                this.stop();
              }
            });
          };
        }
        return unsubscribe;
      }
      clearListeners() {
        for (const eventManagers in this.events) {
          this.events[eventManagers].clear();
        }
      }
      /**
       * Attaches a passive effect to the `MotionValue`.
       *
       * @internal
       */
      attach(passiveEffect, stopPassiveEffect) {
        this.passiveEffect = passiveEffect;
        this.stopPassiveEffect = stopPassiveEffect;
      }
      /**
       * Sets the state of the `MotionValue`.
       *
       * @remarks
       *
       * ```jsx
       * const x = useMotionValue(0)
       * x.set(10)
       * ```
       *
       * @param latest - Latest value to set.
       * @param render - Whether to notify render subscribers. Defaults to `true`
       *
       * @public
       */
      set(v2, render = true) {
        if (!render || !this.passiveEffect) {
          this.updateAndNotify(v2, render);
        } else {
          this.passiveEffect(v2, this.updateAndNotify);
        }
      }
      setWithVelocity(prev2, current, delta) {
        this.set(current);
        this.prev = void 0;
        this.prevFrameValue = prev2;
        this.prevUpdatedAt = this.updatedAt - delta;
      }
      /**
       * Set the state of the `MotionValue`, stopping any active animations,
       * effects, and resets velocity to `0`.
       */
      jump(v2) {
        this.updateAndNotify(v2);
        this.prev = v2;
        this.prevUpdatedAt = this.prevFrameValue = void 0;
        this.stop();
        if (this.stopPassiveEffect)
          this.stopPassiveEffect();
      }
      /**
       * Returns the latest state of `MotionValue`
       *
       * @returns - The latest state of `MotionValue`
       *
       * @public
       */
      get() {
        return this.current;
      }
      /**
       * @public
       */
      getPrevious() {
        return this.prev;
      }
      /**
       * Returns the latest velocity of `MotionValue`
       *
       * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
       *
       * @public
       */
      getVelocity() {
        const currentTime = time.now();
        if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {
          return 0;
        }
        const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
        return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);
      }
      /**
       * Registers a new animation to control this `MotionValue`. Only one
       * animation can drive a `MotionValue` at one time.
       *
       * ```jsx
       * value.start()
       * ```
       *
       * @param animation - A function that starts the provided animation
       *
       * @internal
       */
      start(startAnimation) {
        this.stop();
        return new Promise((resolve) => {
          this.hasAnimated = true;
          this.animation = startAnimation(resolve);
          if (this.events.animationStart) {
            this.events.animationStart.notify();
          }
        }).then(() => {
          if (this.events.animationComplete) {
            this.events.animationComplete.notify();
          }
          this.clearAnimation();
        });
      }
      /**
       * Stop the currently active animation.
       *
       * @public
       */
      stop() {
        if (this.animation) {
          this.animation.stop();
          if (this.events.animationCancel) {
            this.events.animationCancel.notify();
          }
        }
        this.clearAnimation();
      }
      /**
       * Returns `true` if this value is currently animating.
       *
       * @public
       */
      isAnimating() {
        return !!this.animation;
      }
      clearAnimation() {
        delete this.animation;
      }
      /**
       * Destroy and clean up subscribers to this `MotionValue`.
       *
       * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
       * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
       * created a `MotionValue` via the `motionValue` function.
       *
       * @public
       */
      destroy() {
        this.clearListeners();
        this.stop();
        if (this.stopPassiveEffect) {
          this.stopPassiveEffect();
        }
      }
    }
    function motionValue(init, options) {
      return new MotionValue(init, options);
    }
    const testValueType = (v2) => (type) => type.test(v2);
    const auto = {
      test: (v2) => v2 === "auto",
      parse: (v2) => v2
    };
    const dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
    const findDimensionValueType = (v2) => dimensionValueTypes.find(testValueType(v2));
    const valueTypes = [...dimensionValueTypes, color, complex];
    const findValueType = (v2) => valueTypes.find(testValueType(v2));
    function setMotionValue(visualElement, key, value) {
      if (visualElement.hasValue(key)) {
        visualElement.getValue(key).set(value);
      } else {
        visualElement.addValue(key, motionValue(value));
      }
    }
    function setTarget(visualElement, definition) {
      const resolved = resolveVariant(visualElement, definition);
      let { transitionEnd = {}, transition = {}, ...target } = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {};
      target = { ...target, ...transitionEnd };
      for (const key in target) {
        const value = resolveFinalValueInKeyframes(target[key]);
        setMotionValue(visualElement, key, value);
      }
    }
    function checkTargetForNewValues(visualElement, target, origin) {
      var _a, _b;
      const newValueKeys = Object.keys(target).filter((key) => !visualElement.hasValue(key));
      const numNewValues = newValueKeys.length;
      if (!numNewValues)
        return;
      for (let i = 0; i < numNewValues; i++) {
        const key = newValueKeys[i];
        const targetValue = target[key];
        let value = null;
        if (Array.isArray(targetValue)) {
          value = targetValue[0];
        }
        if (value === null) {
          value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];
        }
        if (value === void 0 || value === null)
          continue;
        if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
          value = parseFloat(value);
        } else if (!findValueType(value) && complex.test(targetValue)) {
          value = getAnimatableNone(key, targetValue);
        }
        visualElement.addValue(key, motionValue(value, { owner: visualElement }));
        if (origin[key] === void 0) {
          origin[key] = value;
        }
        if (value !== null)
          visualElement.setBaseTarget(key, value);
      }
    }
    function getOriginFromTransition(key, transition) {
      if (!transition)
        return;
      const valueTransition = transition[key] || transition["default"] || transition;
      return valueTransition.from;
    }
    function getOrigin(target, transition, visualElement) {
      const origin = {};
      for (const key in target) {
        const transitionOrigin = getOriginFromTransition(key, transition);
        if (transitionOrigin !== void 0) {
          origin[key] = transitionOrigin;
        } else {
          const value = visualElement.getValue(key);
          if (value) {
            origin[key] = value.get();
          }
        }
      }
      return origin;
    }
    function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
      const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
      needsAnimating[key] = false;
      return shouldBlock;
    }
    function hasKeyframesChanged(value, target) {
      const current = value.get();
      if (Array.isArray(target)) {
        for (let i = 0; i < target.length; i++) {
          if (target[i] !== current)
            return true;
        }
      } else {
        return current !== target;
      }
    }
    function animateTarget(visualElement, definition, { delay: delay2 = 0, transitionOverride, type } = {}) {
      let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = visualElement.makeTargetAnimatable(definition);
      const willChange = visualElement.getValue("willChange");
      if (transitionOverride)
        transition = transitionOverride;
      const animations2 = [];
      const animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];
      for (const key in target) {
        const value = visualElement.getValue(key);
        const valueTarget = target[key];
        if (!value || valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
          continue;
        }
        const valueTransition = {
          delay: delay2,
          elapsed: 0,
          ...getValueTransition(transition || {}, key)
        };
        if (window.HandoffAppearAnimations) {
          const appearId = visualElement.getProps()[optimizedAppearDataAttribute];
          if (appearId) {
            const elapsed = window.HandoffAppearAnimations(appearId, key, value, frame);
            if (elapsed !== null) {
              valueTransition.elapsed = elapsed;
              valueTransition.isHandoff = true;
            }
          }
        }
        let canSkip = !valueTransition.isHandoff && !hasKeyframesChanged(value, valueTarget);
        if (valueTransition.type === "spring" && (value.getVelocity() || valueTransition.velocity)) {
          canSkip = false;
        }
        if (value.animation) {
          canSkip = false;
        }
        if (canSkip)
          continue;
        value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && transformProps.has(key) ? { type: false } : valueTransition));
        const animation = value.animation;
        if (isWillChangeMotionValue(willChange)) {
          willChange.add(key);
          animation.then(() => willChange.remove(key));
        }
        animations2.push(animation);
      }
      if (transitionEnd) {
        Promise.all(animations2).then(() => {
          transitionEnd && setTarget(visualElement, transitionEnd);
        });
      }
      return animations2;
    }
    function animateVariant(visualElement, variant, options = {}) {
      const resolved = resolveVariant(visualElement, variant, options.custom);
      let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
      if (options.transitionOverride) {
        transition = options.transitionOverride;
      }
      const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve();
      const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
        const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
        return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
      } : () => Promise.resolve();
      const { when } = transition;
      if (when) {
        const [first, last] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
        return first().then(() => last());
      } else {
        return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
      }
    }
    function animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
      const animations2 = [];
      const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;
      const generateStaggerDuration = staggerDirection === 1 ? (i = 0) => i * staggerChildren : (i = 0) => maxStaggerDuration - i * staggerChildren;
      Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i) => {
        child.notify("AnimationStart", variant);
        animations2.push(animateVariant(child, variant, {
          ...options,
          delay: delayChildren + generateStaggerDuration(i)
        }).then(() => child.notify("AnimationComplete", variant)));
      });
      return Promise.all(animations2);
    }
    function sortByTreeOrder(a, b2) {
      return a.sortNodePosition(b2);
    }
    function animateVisualElement(visualElement, definition, options = {}) {
      visualElement.notify("AnimationStart", definition);
      let animation;
      if (Array.isArray(definition)) {
        const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));
        animation = Promise.all(animations2);
      } else if (typeof definition === "string") {
        animation = animateVariant(visualElement, definition, options);
      } else {
        const resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement, definition, options.custom) : definition;
        animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
      }
      return animation.then(() => visualElement.notify("AnimationComplete", definition));
    }
    const reversePriorityOrder = [...variantPriorityOrder].reverse();
    const numAnimationTypes = variantPriorityOrder.length;
    function animateList(visualElement) {
      return (animations2) => Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));
    }
    function createAnimationState(visualElement) {
      let animate = animateList(visualElement);
      const state = createState();
      let isInitialRender = true;
      const buildResolvedTypeValues = (acc, definition) => {
        const resolved = resolveVariant(visualElement, definition);
        if (resolved) {
          const { transition, transitionEnd, ...target } = resolved;
          acc = { ...acc, ...target, ...transitionEnd };
        }
        return acc;
      };
      function setAnimateFunction(makeAnimator) {
        animate = makeAnimator(visualElement);
      }
      function animateChanges(options, changedActiveType) {
        const props = visualElement.getProps();
        const context = visualElement.getVariantContext(true) || {};
        const animations2 = [];
        const removedKeys = /* @__PURE__ */ new Set();
        let encounteredKeys = {};
        let removedVariantIndex = Infinity;
        for (let i = 0; i < numAnimationTypes; i++) {
          const type = reversePriorityOrder[i];
          const typeState = state[type];
          const prop = props[type] !== void 0 ? props[type] : context[type];
          const propIsVariant = isVariantLabel(prop);
          const activeDelta = type === changedActiveType ? typeState.isActive : null;
          if (activeDelta === false)
            removedVariantIndex = i;
          let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
          if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
            isInherited = false;
          }
          typeState.protectedKeys = { ...encounteredKeys };
          if (
            // If it isn't active and hasn't *just* been set as inactive
            !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
            !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
            isAnimationControls(prop) || typeof prop === "boolean"
          ) {
            continue;
          }
          const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
          let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
          type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
          i > removedVariantIndex && propIsVariant;
          let handledRemovedValues = false;
          const definitionList = Array.isArray(prop) ? prop : [prop];
          let resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});
          if (activeDelta === false)
            resolvedValues = {};
          const { prevResolvedValues = {} } = typeState;
          const allKeys = {
            ...prevResolvedValues,
            ...resolvedValues
          };
          const markToAnimate = (key) => {
            shouldAnimateType = true;
            if (removedKeys.has(key)) {
              handledRemovedValues = true;
              removedKeys.delete(key);
            }
            typeState.needsAnimating[key] = true;
          };
          for (const key in allKeys) {
            const next2 = resolvedValues[key];
            const prev2 = prevResolvedValues[key];
            if (encounteredKeys.hasOwnProperty(key))
              continue;
            let valueHasChanged = false;
            if (isKeyframesTarget(next2) && isKeyframesTarget(prev2)) {
              valueHasChanged = !shallowCompare(next2, prev2);
            } else {
              valueHasChanged = next2 !== prev2;
            }
            if (valueHasChanged) {
              if (next2 !== void 0) {
                markToAnimate(key);
              } else {
                removedKeys.add(key);
              }
            } else if (next2 !== void 0 && removedKeys.has(key)) {
              markToAnimate(key);
            } else {
              typeState.protectedKeys[key] = true;
            }
          }
          typeState.prevProp = prop;
          typeState.prevResolvedValues = resolvedValues;
          if (typeState.isActive) {
            encounteredKeys = { ...encounteredKeys, ...resolvedValues };
          }
          if (isInitialRender && visualElement.blockInitialAnimation) {
            shouldAnimateType = false;
          }
          if (shouldAnimateType && (!isInherited || handledRemovedValues)) {
            animations2.push(...definitionList.map((animation) => ({
              animation,
              options: { type, ...options }
            })));
          }
        }
        if (removedKeys.size) {
          const fallbackAnimation = {};
          removedKeys.forEach((key) => {
            const fallbackTarget = visualElement.getBaseTarget(key);
            if (fallbackTarget !== void 0) {
              fallbackAnimation[key] = fallbackTarget;
            }
          });
          animations2.push({ animation: fallbackAnimation });
        }
        let shouldAnimate = Boolean(animations2.length);
        if (isInitialRender && (props.initial === false || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount) {
          shouldAnimate = false;
        }
        isInitialRender = false;
        return shouldAnimate ? animate(animations2) : Promise.resolve();
      }
      function setActive(type, isActive, options) {
        var _a;
        if (state[type].isActive === isActive)
          return Promise.resolve();
        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => {
          var _a2;
          return (_a2 = child.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(type, isActive);
        });
        state[type].isActive = isActive;
        const animations2 = animateChanges(options, type);
        for (const key in state) {
          state[key].protectedKeys = {};
        }
        return animations2;
      }
      return {
        animateChanges,
        setActive,
        setAnimateFunction,
        getState: () => state
      };
    }
    function checkVariantsDidChange(prev2, next2) {
      if (typeof next2 === "string") {
        return next2 !== prev2;
      } else if (Array.isArray(next2)) {
        return !shallowCompare(next2, prev2);
      }
      return false;
    }
    function createTypeState(isActive = false) {
      return {
        isActive,
        protectedKeys: {},
        needsAnimating: {},
        prevResolvedValues: {}
      };
    }
    function createState() {
      return {
        animate: createTypeState(true),
        whileInView: createTypeState(),
        whileHover: createTypeState(),
        whileTap: createTypeState(),
        whileDrag: createTypeState(),
        whileFocus: createTypeState(),
        exit: createTypeState()
      };
    }
    class AnimationFeature extends Feature {
      /**
       * We dynamically generate the AnimationState manager as it contains a reference
       * to the underlying animation library. We only want to load that if we load this,
       * so people can optionally code split it out using the `m` component.
       */
      constructor(node2) {
        super(node2);
        node2.animationState || (node2.animationState = createAnimationState(node2));
      }
      updateAnimationControlsSubscription() {
        const { animate } = this.node.getProps();
        this.unmount();
        if (isAnimationControls(animate)) {
          this.unmount = animate.subscribe(this.node);
        }
      }
      /**
       * Subscribe any provided AnimationControls to the component's VisualElement
       */
      mount() {
        this.updateAnimationControlsSubscription();
      }
      update() {
        const { animate } = this.node.getProps();
        const { animate: prevAnimate } = this.node.prevProps || {};
        if (animate !== prevAnimate) {
          this.updateAnimationControlsSubscription();
        }
      }
      unmount() {
      }
    }
    let id$1 = 0;
    class ExitAnimationFeature extends Feature {
      constructor() {
        super(...arguments);
        this.id = id$1++;
      }
      update() {
        if (!this.node.presenceContext)
          return;
        const { isPresent, onExitComplete, custom } = this.node.presenceContext;
        const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
        if (!this.node.animationState || isPresent === prevIsPresent) {
          return;
        }
        const exitAnimation = this.node.animationState.setActive("exit", !isPresent, { custom: custom !== null && custom !== void 0 ? custom : this.node.getProps().custom });
        if (onExitComplete && !isPresent) {
          exitAnimation.then(() => onExitComplete(this.id));
        }
      }
      mount() {
        const { register } = this.node.presenceContext || {};
        if (register) {
          this.unmount = register(this.id);
        }
      }
      unmount() {
      }
    }
    const animations = {
      animation: {
        Feature: AnimationFeature
      },
      exit: {
        Feature: ExitAnimationFeature
      }
    };
    const distance = (a, b2) => Math.abs(a - b2);
    function distance2D(a, b2) {
      const xDelta = distance(a.x, b2.x);
      const yDelta = distance(a.y, b2.y);
      return Math.sqrt(xDelta ** 2 + yDelta ** 2);
    }
    class PanSession {
      constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false } = {}) {
        this.startEvent = null;
        this.lastMoveEvent = null;
        this.lastMoveEventInfo = null;
        this.handlers = {};
        this.contextWindow = window;
        this.updatePoint = () => {
          if (!(this.lastMoveEvent && this.lastMoveEventInfo))
            return;
          const info2 = getPanInfo(this.lastMoveEventInfo, this.history);
          const isPanStarted = this.startEvent !== null;
          const isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= 3;
          if (!isPanStarted && !isDistancePastThreshold)
            return;
          const { point: point2 } = info2;
          const { timestamp: timestamp2 } = frameData;
          this.history.push({ ...point2, timestamp: timestamp2 });
          const { onStart, onMove } = this.handlers;
          if (!isPanStarted) {
            onStart && onStart(this.lastMoveEvent, info2);
            this.startEvent = this.lastMoveEvent;
          }
          onMove && onMove(this.lastMoveEvent, info2);
        };
        this.handlePointerMove = (event2, info2) => {
          this.lastMoveEvent = event2;
          this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);
          frame.update(this.updatePoint, true);
        };
        this.handlePointerUp = (event2, info2) => {
          this.end();
          const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;
          if (this.dragSnapToOrigin)
            resumeAnimation && resumeAnimation();
          if (!(this.lastMoveEvent && this.lastMoveEventInfo))
            return;
          const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
          if (this.startEvent && onEnd) {
            onEnd(event2, panInfo);
          }
          onSessionEnd && onSessionEnd(event2, panInfo);
        };
        if (!isPrimaryPointer(event))
          return;
        this.dragSnapToOrigin = dragSnapToOrigin;
        this.handlers = handlers;
        this.transformPagePoint = transformPagePoint;
        this.contextWindow = contextWindow || window;
        const info = extractEventInfo(event);
        const initialInfo = transformPoint(info, this.transformPagePoint);
        const { point } = initialInfo;
        const { timestamp } = frameData;
        this.history = [{ ...point, timestamp }];
        const { onSessionStart } = handlers;
        onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
        this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));
      }
      updateHandlers(handlers) {
        this.handlers = handlers;
      }
      end() {
        this.removeListeners && this.removeListeners();
        cancelFrame(this.updatePoint);
      }
    }
    function transformPoint(info, transformPagePoint) {
      return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
    }
    function subtractPoint(a, b2) {
      return { x: a.x - b2.x, y: a.y - b2.y };
    }
    function getPanInfo({ point }, history) {
      return {
        point,
        delta: subtractPoint(point, lastDevicePoint(history)),
        offset: subtractPoint(point, startDevicePoint(history)),
        velocity: getVelocity(history, 0.1)
      };
    }
    function startDevicePoint(history) {
      return history[0];
    }
    function lastDevicePoint(history) {
      return history[history.length - 1];
    }
    function getVelocity(history, timeDelta) {
      if (history.length < 2) {
        return { x: 0, y: 0 };
      }
      let i = history.length - 1;
      let timestampedPoint = null;
      const lastPoint = lastDevicePoint(history);
      while (i >= 0) {
        timestampedPoint = history[i];
        if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
          break;
        }
        i--;
      }
      if (!timestampedPoint) {
        return { x: 0, y: 0 };
      }
      const time2 = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
      if (time2 === 0) {
        return { x: 0, y: 0 };
      }
      const currentVelocity = {
        x: (lastPoint.x - timestampedPoint.x) / time2,
        y: (lastPoint.y - timestampedPoint.y) / time2
      };
      if (currentVelocity.x === Infinity) {
        currentVelocity.x = 0;
      }
      if (currentVelocity.y === Infinity) {
        currentVelocity.y = 0;
      }
      return currentVelocity;
    }
    function calcLength(axis) {
      return axis.max - axis.min;
    }
    function isNear(value, target = 0, maxDistance = 0.01) {
      return Math.abs(value - target) <= maxDistance;
    }
    function calcAxisDelta(delta, source, target, origin = 0.5) {
      delta.origin = origin;
      delta.originPoint = mixNumber$1(source.min, source.max, delta.origin);
      delta.scale = calcLength(target) / calcLength(source);
      if (isNear(delta.scale, 1, 1e-4) || isNaN(delta.scale))
        delta.scale = 1;
      delta.translate = mixNumber$1(target.min, target.max, delta.origin) - delta.originPoint;
      if (isNear(delta.translate) || isNaN(delta.translate))
        delta.translate = 0;
    }
    function calcBoxDelta(delta, source, target, origin) {
      calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0);
      calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);
    }
    function calcRelativeAxis(target, relative, parent) {
      target.min = parent.min + relative.min;
      target.max = target.min + calcLength(relative);
    }
    function calcRelativeBox(target, relative, parent) {
      calcRelativeAxis(target.x, relative.x, parent.x);
      calcRelativeAxis(target.y, relative.y, parent.y);
    }
    function calcRelativeAxisPosition(target, layout2, parent) {
      target.min = layout2.min - parent.min;
      target.max = target.min + calcLength(layout2);
    }
    function calcRelativePosition(target, layout2, parent) {
      calcRelativeAxisPosition(target.x, layout2.x, parent.x);
      calcRelativeAxisPosition(target.y, layout2.y, parent.y);
    }
    function applyConstraints(point, { min: min2, max: max2 }, elastic) {
      if (min2 !== void 0 && point < min2) {
        point = elastic ? mixNumber$1(min2, point, elastic.min) : Math.max(point, min2);
      } else if (max2 !== void 0 && point > max2) {
        point = elastic ? mixNumber$1(max2, point, elastic.max) : Math.min(point, max2);
      }
      return point;
    }
    function calcRelativeAxisConstraints(axis, min2, max2) {
      return {
        min: min2 !== void 0 ? axis.min + min2 : void 0,
        max: max2 !== void 0 ? axis.max + max2 - (axis.max - axis.min) : void 0
      };
    }
    function calcRelativeConstraints(layoutBox, { top: top2, left: left2, bottom: bottom2, right: right2 }) {
      return {
        x: calcRelativeAxisConstraints(layoutBox.x, left2, right2),
        y: calcRelativeAxisConstraints(layoutBox.y, top2, bottom2)
      };
    }
    function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
      let min2 = constraintsAxis.min - layoutAxis.min;
      let max2 = constraintsAxis.max - layoutAxis.max;
      if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
        [min2, max2] = [max2, min2];
      }
      return { min: min2, max: max2 };
    }
    function calcViewportConstraints(layoutBox, constraintsBox) {
      return {
        x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
        y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
      };
    }
    function calcOrigin(source, target) {
      let origin = 0.5;
      const sourceLength = calcLength(source);
      const targetLength = calcLength(target);
      if (targetLength > sourceLength) {
        origin = progress(target.min, target.max - sourceLength, source.min);
      } else if (sourceLength > targetLength) {
        origin = progress(source.min, source.max - targetLength, target.min);
      }
      return clamp(0, 1, origin);
    }
    function rebaseAxisConstraints(layout2, constraints) {
      const relativeConstraints = {};
      if (constraints.min !== void 0) {
        relativeConstraints.min = constraints.min - layout2.min;
      }
      if (constraints.max !== void 0) {
        relativeConstraints.max = constraints.max - layout2.min;
      }
      return relativeConstraints;
    }
    const defaultElastic = 0.35;
    function resolveDragElastic(dragElastic = defaultElastic) {
      if (dragElastic === false) {
        dragElastic = 0;
      } else if (dragElastic === true) {
        dragElastic = defaultElastic;
      }
      return {
        x: resolveAxisElastic(dragElastic, "left", "right"),
        y: resolveAxisElastic(dragElastic, "top", "bottom")
      };
    }
    function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
      return {
        min: resolvePointElastic(dragElastic, minLabel),
        max: resolvePointElastic(dragElastic, maxLabel)
      };
    }
    function resolvePointElastic(dragElastic, label) {
      return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
    }
    const createAxisDelta = () => ({
      translate: 0,
      scale: 1,
      origin: 0,
      originPoint: 0
    });
    const createDelta = () => ({
      x: createAxisDelta(),
      y: createAxisDelta()
    });
    const createAxis = () => ({ min: 0, max: 0 });
    const createBox = () => ({
      x: createAxis(),
      y: createAxis()
    });
    function eachAxis(callback) {
      return [callback("x"), callback("y")];
    }
    function convertBoundingBoxToBox({ top: top2, left: left2, right: right2, bottom: bottom2 }) {
      return {
        x: { min: left2, max: right2 },
        y: { min: top2, max: bottom2 }
      };
    }
    function convertBoxToBoundingBox({ x: x2, y: y2 }) {
      return { top: y2.min, right: x2.max, bottom: y2.max, left: x2.min };
    }
    function transformBoxPoints(point, transformPoint2) {
      if (!transformPoint2)
        return point;
      const topLeft = transformPoint2({ x: point.left, y: point.top });
      const bottomRight = transformPoint2({ x: point.right, y: point.bottom });
      return {
        top: topLeft.y,
        left: topLeft.x,
        bottom: bottomRight.y,
        right: bottomRight.x
      };
    }
    function isIdentityScale(scale2) {
      return scale2 === void 0 || scale2 === 1;
    }
    function hasScale({ scale: scale2, scaleX, scaleY }) {
      return !isIdentityScale(scale2) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
    }
    function hasTransform(values2) {
      return hasScale(values2) || has2DTranslate(values2) || values2.z || values2.rotate || values2.rotateX || values2.rotateY;
    }
    function has2DTranslate(values2) {
      return is2DTranslate(values2.x) || is2DTranslate(values2.y);
    }
    function is2DTranslate(value) {
      return value && value !== "0%";
    }
    function scalePoint(point, scale2, originPoint) {
      const distanceFromOrigin = point - originPoint;
      const scaled = scale2 * distanceFromOrigin;
      return originPoint + scaled;
    }
    function applyPointDelta(point, translate, scale2, originPoint, boxScale) {
      if (boxScale !== void 0) {
        point = scalePoint(point, boxScale, originPoint);
      }
      return scalePoint(point, scale2, originPoint) + translate;
    }
    function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
      axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
      axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
    }
    function applyBoxDelta(box, { x: x2, y: y2 }) {
      applyAxisDelta(box.x, x2.translate, x2.scale, x2.originPoint);
      applyAxisDelta(box.y, y2.translate, y2.scale, y2.originPoint);
    }
    function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
      const treeLength = treePath.length;
      if (!treeLength)
        return;
      treeScale.x = treeScale.y = 1;
      let node2;
      let delta;
      for (let i = 0; i < treeLength; i++) {
        node2 = treePath[i];
        delta = node2.projectionDelta;
        const instance2 = node2.instance;
        if (instance2 && instance2.style && instance2.style.display === "contents") {
          continue;
        }
        if (isSharedTransition && node2.options.layoutScroll && node2.scroll && node2 !== node2.root) {
          transformBox(box, {
            x: -node2.scroll.offset.x,
            y: -node2.scroll.offset.y
          });
        }
        if (delta) {
          treeScale.x *= delta.x.scale;
          treeScale.y *= delta.y.scale;
          applyBoxDelta(box, delta);
        }
        if (isSharedTransition && hasTransform(node2.latestValues)) {
          transformBox(box, node2.latestValues);
        }
      }
      treeScale.x = snapToDefault(treeScale.x);
      treeScale.y = snapToDefault(treeScale.y);
    }
    function snapToDefault(scale2) {
      if (Number.isInteger(scale2))
        return scale2;
      return scale2 > 1.0000000000001 || scale2 < 0.999999999999 ? scale2 : 1;
    }
    function translateAxis(axis, distance2) {
      axis.min = axis.min + distance2;
      axis.max = axis.max + distance2;
    }
    function transformAxis(axis, transforms, [key, scaleKey, originKey]) {
      const axisOrigin = transforms[originKey] !== void 0 ? transforms[originKey] : 0.5;
      const originPoint = mixNumber$1(axis.min, axis.max, axisOrigin);
      applyAxisDelta(axis, transforms[key], transforms[scaleKey], originPoint, transforms.scale);
    }
    const xKeys$1 = ["x", "scaleX", "originX"];
    const yKeys$1 = ["y", "scaleY", "originY"];
    function transformBox(box, transform) {
      transformAxis(box.x, transform, xKeys$1);
      transformAxis(box.y, transform, yKeys$1);
    }
    function measureViewportBox(instance2, transformPoint2) {
      return convertBoundingBoxToBox(transformBoxPoints(instance2.getBoundingClientRect(), transformPoint2));
    }
    function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
      const viewportBox = measureViewportBox(element, transformPagePoint);
      const { scroll } = rootProjectionNode2;
      if (scroll) {
        translateAxis(viewportBox.x, scroll.offset.x);
        translateAxis(viewportBox.y, scroll.offset.y);
      }
      return viewportBox;
    }
    const getContextWindow = ({ current }) => {
      return current ? current.ownerDocument.defaultView : null;
    };
    const elementDragControls = /* @__PURE__ */ new WeakMap();
    class VisualElementDragControls {
      constructor(visualElement) {
        this.openGlobalLock = null;
        this.isDragging = false;
        this.currentDirection = null;
        this.originPoint = { x: 0, y: 0 };
        this.constraints = false;
        this.hasMutatedConstraints = false;
        this.elastic = createBox();
        this.visualElement = visualElement;
      }
      start(originEvent, { snapToCursor = false } = {}) {
        const { presenceContext } = this.visualElement;
        if (presenceContext && presenceContext.isPresent === false)
          return;
        const onSessionStart = (event) => {
          const { dragSnapToOrigin: dragSnapToOrigin2 } = this.getProps();
          dragSnapToOrigin2 ? this.pauseAnimation() : this.stopAnimation();
          if (snapToCursor) {
            this.snapToCursor(extractEventInfo(event, "page").point);
          }
        };
        const onStart = (event, info) => {
          const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
          if (drag2 && !dragPropagation) {
            if (this.openGlobalLock)
              this.openGlobalLock();
            this.openGlobalLock = getGlobalLock(drag2);
            if (!this.openGlobalLock)
              return;
          }
          this.isDragging = true;
          this.currentDirection = null;
          this.resolveConstraints();
          if (this.visualElement.projection) {
            this.visualElement.projection.isAnimationBlocked = true;
            this.visualElement.projection.target = void 0;
          }
          eachAxis((axis) => {
            let current = this.getAxisMotionValue(axis).get() || 0;
            if (percent.test(current)) {
              const { projection } = this.visualElement;
              if (projection && projection.layout) {
                const measuredAxis = projection.layout.layoutBox[axis];
                if (measuredAxis) {
                  const length2 = calcLength(measuredAxis);
                  current = length2 * (parseFloat(current) / 100);
                }
              }
            }
            this.originPoint[axis] = current;
          });
          if (onDragStart) {
            frame.update(() => onDragStart(event, info), false, true);
          }
          const { animationState } = this.visualElement;
          animationState && animationState.setActive("whileDrag", true);
        };
        const onMove = (event, info) => {
          const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
          if (!dragPropagation && !this.openGlobalLock)
            return;
          const { offset: offset2 } = info;
          if (dragDirectionLock && this.currentDirection === null) {
            this.currentDirection = getCurrentDirection(offset2);
            if (this.currentDirection !== null) {
              onDirectionLock && onDirectionLock(this.currentDirection);
            }
            return;
          }
          this.updateAxis("x", info.point, offset2);
          this.updateAxis("y", info.point, offset2);
          this.visualElement.render();
          onDrag && onDrag(event, info);
        };
        const onSessionEnd = (event, info) => this.stop(event, info);
        const resumeAnimation = () => eachAxis((axis) => {
          var _a;
          return this.getAnimationState(axis) === "paused" && ((_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.play());
        });
        const { dragSnapToOrigin } = this.getProps();
        this.panSession = new PanSession(originEvent, {
          onSessionStart,
          onStart,
          onMove,
          onSessionEnd,
          resumeAnimation
        }, {
          transformPagePoint: this.visualElement.getTransformPagePoint(),
          dragSnapToOrigin,
          contextWindow: getContextWindow(this.visualElement)
        });
      }
      stop(event, info) {
        const isDragging = this.isDragging;
        this.cancel();
        if (!isDragging)
          return;
        const { velocity } = info;
        this.startAnimation(velocity);
        const { onDragEnd } = this.getProps();
        if (onDragEnd) {
          frame.update(() => onDragEnd(event, info));
        }
      }
      cancel() {
        this.isDragging = false;
        const { projection, animationState } = this.visualElement;
        if (projection) {
          projection.isAnimationBlocked = false;
        }
        this.panSession && this.panSession.end();
        this.panSession = void 0;
        const { dragPropagation } = this.getProps();
        if (!dragPropagation && this.openGlobalLock) {
          this.openGlobalLock();
          this.openGlobalLock = null;
        }
        animationState && animationState.setActive("whileDrag", false);
      }
      updateAxis(axis, _point, offset2) {
        const { drag: drag2 } = this.getProps();
        if (!offset2 || !shouldDrag(axis, drag2, this.currentDirection))
          return;
        const axisValue = this.getAxisMotionValue(axis);
        let next2 = this.originPoint[axis] + offset2[axis];
        if (this.constraints && this.constraints[axis]) {
          next2 = applyConstraints(next2, this.constraints[axis], this.elastic[axis]);
        }
        axisValue.set(next2);
      }
      resolveConstraints() {
        var _a;
        const { dragConstraints, dragElastic } = this.getProps();
        const layout2 = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(false) : (_a = this.visualElement.projection) === null || _a === void 0 ? void 0 : _a.layout;
        const prevConstraints = this.constraints;
        if (dragConstraints && isRefObject(dragConstraints)) {
          if (!this.constraints) {
            this.constraints = this.resolveRefConstraints();
          }
        } else {
          if (dragConstraints && layout2) {
            this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints);
          } else {
            this.constraints = false;
          }
        }
        this.elastic = resolveDragElastic(dragElastic);
        if (prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints) {
          eachAxis((axis) => {
            if (this.getAxisMotionValue(axis)) {
              this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]);
            }
          });
        }
      }
      resolveRefConstraints() {
        const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
        if (!constraints || !isRefObject(constraints))
          return false;
        const constraintsElement = constraints.current;
        const { projection } = this.visualElement;
        if (!projection || !projection.layout)
          return false;
        const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
        let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
        if (onMeasureDragConstraints) {
          const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
          this.hasMutatedConstraints = !!userConstraints;
          if (userConstraints) {
            measuredConstraints = convertBoundingBoxToBox(userConstraints);
          }
        }
        return measuredConstraints;
      }
      startAnimation(velocity) {
        const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();
        const constraints = this.constraints || {};
        const momentumAnimations = eachAxis((axis) => {
          if (!shouldDrag(axis, drag2, this.currentDirection)) {
            return;
          }
          let transition = constraints && constraints[axis] || {};
          if (dragSnapToOrigin)
            transition = { min: 0, max: 0 };
          const bounceStiffness = dragElastic ? 200 : 1e6;
          const bounceDamping = dragElastic ? 40 : 1e7;
          const inertia2 = {
            type: "inertia",
            velocity: dragMomentum ? velocity[axis] : 0,
            bounceStiffness,
            bounceDamping,
            timeConstant: 750,
            restDelta: 1,
            restSpeed: 10,
            ...dragTransition,
            ...transition
          };
          return this.startAxisValueAnimation(axis, inertia2);
        });
        return Promise.all(momentumAnimations).then(onDragTransitionEnd);
      }
      startAxisValueAnimation(axis, transition) {
        const axisValue = this.getAxisMotionValue(axis);
        return axisValue.start(animateMotionValue(axis, axisValue, 0, transition));
      }
      stopAnimation() {
        eachAxis((axis) => this.getAxisMotionValue(axis).stop());
      }
      pauseAnimation() {
        eachAxis((axis) => {
          var _a;
          return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.pause();
        });
      }
      getAnimationState(axis) {
        var _a;
        return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.state;
      }
      /**
       * Drag works differently depending on which props are provided.
       *
       * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
       * - Otherwise, we apply the delta to the x/y motion values.
       */
      getAxisMotionValue(axis) {
        const dragKey = "_drag" + axis.toUpperCase();
        const props = this.visualElement.getProps();
        const externalMotionValue = props[dragKey];
        return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
      }
      snapToCursor(point) {
        eachAxis((axis) => {
          const { drag: drag2 } = this.getProps();
          if (!shouldDrag(axis, drag2, this.currentDirection))
            return;
          const { projection } = this.visualElement;
          const axisValue = this.getAxisMotionValue(axis);
          if (projection && projection.layout) {
            const { min: min2, max: max2 } = projection.layout.layoutBox[axis];
            axisValue.set(point[axis] - mixNumber$1(min2, max2, 0.5));
          }
        });
      }
      /**
       * When the viewport resizes we want to check if the measured constraints
       * have changed and, if so, reposition the element within those new constraints
       * relative to where it was before the resize.
       */
      scalePositionWithinConstraints() {
        if (!this.visualElement.current)
          return;
        const { drag: drag2, dragConstraints } = this.getProps();
        const { projection } = this.visualElement;
        if (!isRefObject(dragConstraints) || !projection || !this.constraints)
          return;
        this.stopAnimation();
        const boxProgress = { x: 0, y: 0 };
        eachAxis((axis) => {
          const axisValue = this.getAxisMotionValue(axis);
          if (axisValue) {
            const latest = axisValue.get();
            boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);
          }
        });
        const { transformTemplate } = this.visualElement.getProps();
        this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
        projection.root && projection.root.updateScroll();
        projection.updateLayout();
        this.resolveConstraints();
        eachAxis((axis) => {
          if (!shouldDrag(axis, drag2, null))
            return;
          const axisValue = this.getAxisMotionValue(axis);
          const { min: min2, max: max2 } = this.constraints[axis];
          axisValue.set(mixNumber$1(min2, max2, boxProgress[axis]));
        });
      }
      addListeners() {
        if (!this.visualElement.current)
          return;
        elementDragControls.set(this.visualElement, this);
        const element = this.visualElement.current;
        const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
          const { drag: drag2, dragListener = true } = this.getProps();
          drag2 && dragListener && this.start(event);
        });
        const measureDragConstraints = () => {
          const { dragConstraints } = this.getProps();
          if (isRefObject(dragConstraints)) {
            this.constraints = this.resolveRefConstraints();
          }
        };
        const { projection } = this.visualElement;
        const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
        if (projection && !projection.layout) {
          projection.root && projection.root.updateScroll();
          projection.updateLayout();
        }
        measureDragConstraints();
        const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
        const stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({ delta, hasLayoutChanged }) => {
          if (this.isDragging && hasLayoutChanged) {
            eachAxis((axis) => {
              const motionValue2 = this.getAxisMotionValue(axis);
              if (!motionValue2)
                return;
              this.originPoint[axis] += delta[axis].translate;
              motionValue2.set(motionValue2.get() + delta[axis].translate);
            });
            this.visualElement.render();
          }
        });
        return () => {
          stopResizeListener();
          stopPointerListener();
          stopMeasureLayoutListener();
          stopLayoutUpdateListener && stopLayoutUpdateListener();
        };
      }
      getProps() {
        const props = this.visualElement.getProps();
        const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;
        return {
          ...props,
          drag: drag2,
          dragDirectionLock,
          dragPropagation,
          dragConstraints,
          dragElastic,
          dragMomentum
        };
      }
    }
    function shouldDrag(direction, drag2, currentDirection) {
      return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
    }
    function getCurrentDirection(offset2, lockThreshold = 10) {
      let direction = null;
      if (Math.abs(offset2.y) > lockThreshold) {
        direction = "y";
      } else if (Math.abs(offset2.x) > lockThreshold) {
        direction = "x";
      }
      return direction;
    }
    class DragGesture extends Feature {
      constructor(node2) {
        super(node2);
        this.removeGroupControls = noop;
        this.removeListeners = noop;
        this.controls = new VisualElementDragControls(node2);
      }
      mount() {
        const { dragControls } = this.node.getProps();
        if (dragControls) {
          this.removeGroupControls = dragControls.subscribe(this.controls);
        }
        this.removeListeners = this.controls.addListeners() || noop;
      }
      unmount() {
        this.removeGroupControls();
        this.removeListeners();
      }
    }
    const asyncHandler = (handler) => (event, info) => {
      if (handler) {
        frame.update(() => handler(event, info));
      }
    };
    class PanGesture extends Feature {
      constructor() {
        super(...arguments);
        this.removePointerDownListener = noop;
      }
      onPointerDown(pointerDownEvent) {
        this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
          transformPagePoint: this.node.getTransformPagePoint(),
          contextWindow: getContextWindow(this.node)
        });
      }
      createPanHandlers() {
        const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
        return {
          onSessionStart: asyncHandler(onPanSessionStart),
          onStart: asyncHandler(onPanStart),
          onMove: onPan,
          onEnd: (event, info) => {
            delete this.session;
            if (onPanEnd) {
              frame.update(() => onPanEnd(event, info));
            }
          }
        };
      }
      mount() {
        this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
      }
      update() {
        this.session && this.session.updateHandlers(this.createPanHandlers());
      }
      unmount() {
        this.removePointerDownListener();
        this.session && this.session.end();
      }
    }
    function usePresence() {
      const context = reactExports.useContext(PresenceContext);
      if (context === null)
        return [true, null];
      const { isPresent, onExitComplete, register } = context;
      const id2 = reactExports.useId();
      reactExports.useEffect(() => register(id2), []);
      const safeToRemove = () => onExitComplete && onExitComplete(id2);
      return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
    }
    const globalProjectionState = {
      /**
       * Global flag as to whether the tree has animated since the last time
       * we resized the window
       */
      hasAnimatedSinceResize: true,
      /**
       * We set this to true once, on the first update. Any nodes added to the tree beyond that
       * update will be given a `data-projection-id` attribute.
       */
      hasEverUpdated: false
    };
    function pixelsToPercent(pixels, axis) {
      if (axis.max === axis.min)
        return 0;
      return pixels / (axis.max - axis.min) * 100;
    }
    const correctBorderRadius = {
      correct: (latest, node2) => {
        if (!node2.target)
          return latest;
        if (typeof latest === "string") {
          if (px.test(latest)) {
            latest = parseFloat(latest);
          } else {
            return latest;
          }
        }
        const x2 = pixelsToPercent(latest, node2.target.x);
        const y2 = pixelsToPercent(latest, node2.target.y);
        return `${x2}% ${y2}%`;
      }
    };
    const correctBoxShadow = {
      correct: (latest, { treeScale, projectionDelta }) => {
        const original = latest;
        const shadow = complex.parse(latest);
        if (shadow.length > 5)
          return original;
        const template = complex.createTransformer(latest);
        const offset2 = typeof shadow[0] !== "number" ? 1 : 0;
        const xScale = projectionDelta.x.scale * treeScale.x;
        const yScale = projectionDelta.y.scale * treeScale.y;
        shadow[0 + offset2] /= xScale;
        shadow[1 + offset2] /= yScale;
        const averageScale = mixNumber$1(xScale, yScale, 0.5);
        if (typeof shadow[2 + offset2] === "number")
          shadow[2 + offset2] /= averageScale;
        if (typeof shadow[3 + offset2] === "number")
          shadow[3 + offset2] /= averageScale;
        return template(shadow);
      }
    };
    class MeasureLayoutWithContext extends React.Component {
      /**
       * This only mounts projection nodes for components that
       * need measuring, we might want to do it for all components
       * in order to incorporate transforms
       */
      componentDidMount() {
        const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
        const { projection } = visualElement;
        addScaleCorrector(defaultScaleCorrectors);
        if (projection) {
          if (layoutGroup.group)
            layoutGroup.group.add(projection);
          if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
            switchLayoutGroup.register(projection);
          }
          projection.root.didUpdate();
          projection.addEventListener("animationComplete", () => {
            this.safeToRemove();
          });
          projection.setOptions({
            ...projection.options,
            onExitComplete: () => this.safeToRemove()
          });
        }
        globalProjectionState.hasEverUpdated = true;
      }
      getSnapshotBeforeUpdate(prevProps) {
        const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props;
        const projection = visualElement.projection;
        if (!projection)
          return null;
        projection.isPresent = isPresent;
        if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0) {
          projection.willUpdate();
        } else {
          this.safeToRemove();
        }
        if (prevProps.isPresent !== isPresent) {
          if (isPresent) {
            projection.promote();
          } else if (!projection.relegate()) {
            frame.postRender(() => {
              const stack = projection.getStack();
              if (!stack || !stack.members.length) {
                this.safeToRemove();
              }
            });
          }
        }
        return null;
      }
      componentDidUpdate() {
        const { projection } = this.props.visualElement;
        if (projection) {
          projection.root.didUpdate();
          microtask.postRender(() => {
            if (!projection.currentAnimation && projection.isLead()) {
              this.safeToRemove();
            }
          });
        }
      }
      componentWillUnmount() {
        const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;
        const { projection } = visualElement;
        if (projection) {
          projection.scheduleCheckAfterUnmount();
          if (layoutGroup && layoutGroup.group)
            layoutGroup.group.remove(projection);
          if (promoteContext && promoteContext.deregister)
            promoteContext.deregister(projection);
        }
      }
      safeToRemove() {
        const { safeToRemove } = this.props;
        safeToRemove && safeToRemove();
      }
      render() {
        return null;
      }
    }
    function MeasureLayout(props) {
      const [isPresent, safeToRemove] = usePresence();
      const layoutGroup = reactExports.useContext(LayoutGroupContext);
      return React.createElement(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext), isPresent, safeToRemove });
    }
    const defaultScaleCorrectors = {
      borderRadius: {
        ...correctBorderRadius,
        applyTo: [
          "borderTopLeftRadius",
          "borderTopRightRadius",
          "borderBottomLeftRadius",
          "borderBottomRightRadius"
        ]
      },
      borderTopLeftRadius: correctBorderRadius,
      borderTopRightRadius: correctBorderRadius,
      borderBottomLeftRadius: correctBorderRadius,
      borderBottomRightRadius: correctBorderRadius,
      boxShadow: correctBoxShadow
    };
    const borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
    const numBorders = borders.length;
    const asNumber = (value) => typeof value === "string" ? parseFloat(value) : value;
    const isPx = (value) => typeof value === "number" || px.test(value);
    function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
      if (shouldCrossfadeOpacity) {
        target.opacity = mixNumber$1(
          0,
          // TODO Reinstate this if only child
          lead.opacity !== void 0 ? lead.opacity : 1,
          easeCrossfadeIn(progress2)
        );
        target.opacityExit = mixNumber$1(follow.opacity !== void 0 ? follow.opacity : 1, 0, easeCrossfadeOut(progress2));
      } else if (isOnlyMember) {
        target.opacity = mixNumber$1(follow.opacity !== void 0 ? follow.opacity : 1, lead.opacity !== void 0 ? lead.opacity : 1, progress2);
      }
      for (let i = 0; i < numBorders; i++) {
        const borderLabel = `border${borders[i]}Radius`;
        let followRadius = getRadius(follow, borderLabel);
        let leadRadius = getRadius(lead, borderLabel);
        if (followRadius === void 0 && leadRadius === void 0)
          continue;
        followRadius || (followRadius = 0);
        leadRadius || (leadRadius = 0);
        const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
        if (canMix) {
          target[borderLabel] = Math.max(mixNumber$1(asNumber(followRadius), asNumber(leadRadius), progress2), 0);
          if (percent.test(leadRadius) || percent.test(followRadius)) {
            target[borderLabel] += "%";
          }
        } else {
          target[borderLabel] = leadRadius;
        }
      }
      if (follow.rotate || lead.rotate) {
        target.rotate = mixNumber$1(follow.rotate || 0, lead.rotate || 0, progress2);
      }
    }
    function getRadius(values2, radiusName) {
      return values2[radiusName] !== void 0 ? values2[radiusName] : values2.borderRadius;
    }
    const easeCrossfadeIn = compress(0, 0.5, circOut);
    const easeCrossfadeOut = compress(0.5, 0.95, noop);
    function compress(min2, max2, easing2) {
      return (p2) => {
        if (p2 < min2)
          return 0;
        if (p2 > max2)
          return 1;
        return easing2(progress(min2, max2, p2));
      };
    }
    function copyAxisInto(axis, originAxis) {
      axis.min = originAxis.min;
      axis.max = originAxis.max;
    }
    function copyBoxInto(box, originBox) {
      copyAxisInto(box.x, originBox.x);
      copyAxisInto(box.y, originBox.y);
    }
    function removePointDelta(point, translate, scale2, originPoint, boxScale) {
      point -= translate;
      point = scalePoint(point, 1 / scale2, originPoint);
      if (boxScale !== void 0) {
        point = scalePoint(point, 1 / boxScale, originPoint);
      }
      return point;
    }
    function removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
      if (percent.test(translate)) {
        translate = parseFloat(translate);
        const relativeProgress = mixNumber$1(sourceAxis.min, sourceAxis.max, translate / 100);
        translate = relativeProgress - sourceAxis.min;
      }
      if (typeof translate !== "number")
        return;
      let originPoint = mixNumber$1(originAxis.min, originAxis.max, origin);
      if (axis === originAxis)
        originPoint -= translate;
      axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
      axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
    }
    function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {
      removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
    }
    const xKeys = ["x", "scaleX", "originX"];
    const yKeys = ["y", "scaleY", "originY"];
    function removeBoxTransforms(box, transforms, originBox, sourceBox) {
      removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0);
      removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
    }
    function isAxisDeltaZero(delta) {
      return delta.translate === 0 && delta.scale === 1;
    }
    function isDeltaZero(delta) {
      return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
    }
    function boxEquals(a, b2) {
      return a.x.min === b2.x.min && a.x.max === b2.x.max && a.y.min === b2.y.min && a.y.max === b2.y.max;
    }
    function boxEqualsRounded(a, b2) {
      return Math.round(a.x.min) === Math.round(b2.x.min) && Math.round(a.x.max) === Math.round(b2.x.max) && Math.round(a.y.min) === Math.round(b2.y.min) && Math.round(a.y.max) === Math.round(b2.y.max);
    }
    function aspectRatio(box) {
      return calcLength(box.x) / calcLength(box.y);
    }
    class NodeStack {
      constructor() {
        this.members = [];
      }
      add(node2) {
        addUniqueItem(this.members, node2);
        node2.scheduleRender();
      }
      remove(node2) {
        removeItem(this.members, node2);
        if (node2 === this.prevLead) {
          this.prevLead = void 0;
        }
        if (node2 === this.lead) {
          const prevLead = this.members[this.members.length - 1];
          if (prevLead) {
            this.promote(prevLead);
          }
        }
      }
      relegate(node2) {
        const indexOfNode = this.members.findIndex((member) => node2 === member);
        if (indexOfNode === 0)
          return false;
        let prevLead;
        for (let i = indexOfNode; i >= 0; i--) {
          const member = this.members[i];
          if (member.isPresent !== false) {
            prevLead = member;
            break;
          }
        }
        if (prevLead) {
          this.promote(prevLead);
          return true;
        } else {
          return false;
        }
      }
      promote(node2, preserveFollowOpacity) {
        const prevLead = this.lead;
        if (node2 === prevLead)
          return;
        this.prevLead = prevLead;
        this.lead = node2;
        node2.show();
        if (prevLead) {
          prevLead.instance && prevLead.scheduleRender();
          node2.scheduleRender();
          node2.resumeFrom = prevLead;
          if (preserveFollowOpacity) {
            node2.resumeFrom.preserveOpacity = true;
          }
          if (prevLead.snapshot) {
            node2.snapshot = prevLead.snapshot;
            node2.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
          }
          if (node2.root && node2.root.isUpdating) {
            node2.isLayoutDirty = true;
          }
          const { crossfade } = node2.options;
          if (crossfade === false) {
            prevLead.hide();
          }
        }
      }
      exitAnimationComplete() {
        this.members.forEach((node2) => {
          const { options, resumingFrom } = node2;
          options.onExitComplete && options.onExitComplete();
          if (resumingFrom) {
            resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
          }
        });
      }
      scheduleRender() {
        this.members.forEach((node2) => {
          node2.instance && node2.scheduleRender(false);
        });
      }
      /**
       * Clear any leads that have been removed this render to prevent them from being
       * used in future animations and to prevent memory leaks
       */
      removeLeadSnapshot() {
        if (this.lead && this.lead.snapshot) {
          this.lead.snapshot = void 0;
        }
      }
    }
    function buildProjectionTransform(delta, treeScale, latestTransform) {
      let transform = "";
      const xTranslate = delta.x.translate / treeScale.x;
      const yTranslate = delta.y.translate / treeScale.y;
      if (xTranslate || yTranslate) {
        transform = `translate3d(${xTranslate}px, ${yTranslate}px, 0) `;
      }
      if (treeScale.x !== 1 || treeScale.y !== 1) {
        transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
      }
      if (latestTransform) {
        const { rotate, rotateX, rotateY } = latestTransform;
        if (rotate)
          transform += `rotate(${rotate}deg) `;
        if (rotateX)
          transform += `rotateX(${rotateX}deg) `;
        if (rotateY)
          transform += `rotateY(${rotateY}deg) `;
      }
      const elementScaleX = delta.x.scale * treeScale.x;
      const elementScaleY = delta.y.scale * treeScale.y;
      if (elementScaleX !== 1 || elementScaleY !== 1) {
        transform += `scale(${elementScaleX}, ${elementScaleY})`;
      }
      return transform || "none";
    }
    const compareByDepth = (a, b2) => a.depth - b2.depth;
    class FlatTree {
      constructor() {
        this.children = [];
        this.isDirty = false;
      }
      add(child) {
        addUniqueItem(this.children, child);
        this.isDirty = true;
      }
      remove(child) {
        removeItem(this.children, child);
        this.isDirty = true;
      }
      forEach(callback) {
        this.isDirty && this.children.sort(compareByDepth);
        this.isDirty = false;
        this.children.forEach(callback);
      }
    }
    function delay(callback, timeout) {
      const start2 = time.now();
      const checkElapsed = ({ timestamp }) => {
        const elapsed = timestamp - start2;
        if (elapsed >= timeout) {
          cancelFrame(checkElapsed);
          callback(elapsed - timeout);
        }
      };
      frame.read(checkElapsed, true);
      return () => cancelFrame(checkElapsed);
    }
    function record(data) {
      if (window.MotionDebug) {
        window.MotionDebug.record(data);
      }
    }
    function isSVGElement(element) {
      return element instanceof SVGElement && element.tagName !== "svg";
    }
    function animateSingleValue(value, keyframes2, options) {
      const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
      motionValue$1.start(animateMotionValue("", motionValue$1, keyframes2, options));
      return motionValue$1.animation;
    }
    const transformAxes = ["", "X", "Y", "Z"];
    const hiddenVisibility = { visibility: "hidden" };
    const animationTarget = 1e3;
    let id = 0;
    const projectionFrameData = {
      type: "projectionFrame",
      totalNodes: 0,
      resolvedTargetDeltas: 0,
      recalculatedProjection: 0
    };
    function createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
      return class ProjectionNode {
        constructor(latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {
          this.id = id++;
          this.animationId = 0;
          this.children = /* @__PURE__ */ new Set();
          this.options = {};
          this.isTreeAnimating = false;
          this.isAnimationBlocked = false;
          this.isLayoutDirty = false;
          this.isProjectionDirty = false;
          this.isSharedProjectionDirty = false;
          this.isTransformDirty = false;
          this.updateManuallyBlocked = false;
          this.updateBlockedByResize = false;
          this.isUpdating = false;
          this.isSVG = false;
          this.needsReset = false;
          this.shouldResetTransform = false;
          this.treeScale = { x: 1, y: 1 };
          this.eventHandlers = /* @__PURE__ */ new Map();
          this.hasTreeAnimated = false;
          this.updateScheduled = false;
          this.projectionUpdateScheduled = false;
          this.checkUpdateFailed = () => {
            if (this.isUpdating) {
              this.isUpdating = false;
              this.clearAllSnapshots();
            }
          };
          this.updateProjection = () => {
            this.projectionUpdateScheduled = false;
            projectionFrameData.totalNodes = projectionFrameData.resolvedTargetDeltas = projectionFrameData.recalculatedProjection = 0;
            this.nodes.forEach(propagateDirtyNodes);
            this.nodes.forEach(resolveTargetDelta);
            this.nodes.forEach(calcProjection);
            this.nodes.forEach(cleanDirtyNodes);
            record(projectionFrameData);
          };
          this.hasProjected = false;
          this.isVisible = true;
          this.animationProgress = 0;
          this.sharedNodes = /* @__PURE__ */ new Map();
          this.latestValues = latestValues;
          this.root = parent ? parent.root || parent : this;
          this.path = parent ? [...parent.path, parent] : [];
          this.parent = parent;
          this.depth = parent ? parent.depth + 1 : 0;
          for (let i = 0; i < this.path.length; i++) {
            this.path[i].shouldResetTransform = true;
          }
          if (this.root === this)
            this.nodes = new FlatTree();
        }
        addEventListener(name, handler) {
          if (!this.eventHandlers.has(name)) {
            this.eventHandlers.set(name, new SubscriptionManager());
          }
          return this.eventHandlers.get(name).add(handler);
        }
        notifyListeners(name, ...args) {
          const subscriptionManager = this.eventHandlers.get(name);
          subscriptionManager && subscriptionManager.notify(...args);
        }
        hasListeners(name) {
          return this.eventHandlers.has(name);
        }
        /**
         * Lifecycles
         */
        mount(instance2, isLayoutDirty = this.root.hasTreeAnimated) {
          if (this.instance)
            return;
          this.isSVG = isSVGElement(instance2);
          this.instance = instance2;
          const { layoutId, layout: layout2, visualElement } = this.options;
          if (visualElement && !visualElement.current) {
            visualElement.mount(instance2);
          }
          this.root.nodes.add(this);
          this.parent && this.parent.children.add(this);
          if (isLayoutDirty && (layout2 || layoutId)) {
            this.isLayoutDirty = true;
          }
          if (attachResizeListener) {
            let cancelDelay;
            const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;
            attachResizeListener(instance2, () => {
              this.root.updateBlockedByResize = true;
              cancelDelay && cancelDelay();
              cancelDelay = delay(resizeUnblockUpdate, 250);
              if (globalProjectionState.hasAnimatedSinceResize) {
                globalProjectionState.hasAnimatedSinceResize = false;
                this.nodes.forEach(finishAnimation);
              }
            });
          }
          if (layoutId) {
            this.root.registerSharedNode(layoutId, this);
          }
          if (this.options.animate !== false && visualElement && (layoutId || layout2)) {
            this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout }) => {
              if (this.isTreeAnimationBlocked()) {
                this.target = void 0;
                this.relativeTarget = void 0;
                return;
              }
              const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;
              const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();
              const targetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout) || hasRelativeTargetChanged;
              const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
              if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !this.currentAnimation)) {
                if (this.resumeFrom) {
                  this.resumingFrom = this.resumeFrom;
                  this.resumingFrom.resumingFrom = void 0;
                }
                this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
                const animationOptions = {
                  ...getValueTransition(layoutTransition, "layout"),
                  onPlay: onLayoutAnimationStart,
                  onComplete: onLayoutAnimationComplete
                };
                if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
                  animationOptions.delay = 0;
                  animationOptions.type = false;
                }
                this.startAnimation(animationOptions);
              } else {
                if (!hasLayoutChanged) {
                  finishAnimation(this);
                }
                if (this.isLead() && this.options.onExitComplete) {
                  this.options.onExitComplete();
                }
              }
              this.targetLayout = newLayout;
            });
          }
        }
        unmount() {
          this.options.layoutId && this.willUpdate();
          this.root.nodes.remove(this);
          const stack = this.getStack();
          stack && stack.remove(this);
          this.parent && this.parent.children.delete(this);
          this.instance = void 0;
          cancelFrame(this.updateProjection);
        }
        // only on the root
        blockUpdate() {
          this.updateManuallyBlocked = true;
        }
        unblockUpdate() {
          this.updateManuallyBlocked = false;
        }
        isUpdateBlocked() {
          return this.updateManuallyBlocked || this.updateBlockedByResize;
        }
        isTreeAnimationBlocked() {
          return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
        }
        // Note: currently only running on root node
        startUpdate() {
          if (this.isUpdateBlocked())
            return;
          this.isUpdating = true;
          this.nodes && this.nodes.forEach(resetRotation);
          this.animationId++;
        }
        getTransformTemplate() {
          const { visualElement } = this.options;
          return visualElement && visualElement.getProps().transformTemplate;
        }
        willUpdate(shouldNotifyListeners = true) {
          this.root.hasTreeAnimated = true;
          if (this.root.isUpdateBlocked()) {
            this.options.onExitComplete && this.options.onExitComplete();
            return;
          }
          !this.root.isUpdating && this.root.startUpdate();
          if (this.isLayoutDirty)
            return;
          this.isLayoutDirty = true;
          for (let i = 0; i < this.path.length; i++) {
            const node2 = this.path[i];
            node2.shouldResetTransform = true;
            node2.updateScroll("snapshot");
            if (node2.options.layoutRoot) {
              node2.willUpdate(false);
            }
          }
          const { layoutId, layout: layout2 } = this.options;
          if (layoutId === void 0 && !layout2)
            return;
          const transformTemplate = this.getTransformTemplate();
          this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
          this.updateSnapshot();
          shouldNotifyListeners && this.notifyListeners("willUpdate");
        }
        update() {
          this.updateScheduled = false;
          const updateWasBlocked = this.isUpdateBlocked();
          if (updateWasBlocked) {
            this.unblockUpdate();
            this.clearAllSnapshots();
            this.nodes.forEach(clearMeasurements);
            return;
          }
          if (!this.isUpdating) {
            this.nodes.forEach(clearIsLayoutDirty);
          }
          this.isUpdating = false;
          this.nodes.forEach(resetTransformStyle);
          this.nodes.forEach(updateLayout);
          this.nodes.forEach(notifyLayoutUpdate);
          this.clearAllSnapshots();
          const now2 = time.now();
          frameData.delta = clamp(0, 1e3 / 60, now2 - frameData.timestamp);
          frameData.timestamp = now2;
          frameData.isProcessing = true;
          steps.update.process(frameData);
          steps.preRender.process(frameData);
          steps.render.process(frameData);
          frameData.isProcessing = false;
        }
        didUpdate() {
          if (!this.updateScheduled) {
            this.updateScheduled = true;
            microtask.read(() => this.update());
          }
        }
        clearAllSnapshots() {
          this.nodes.forEach(clearSnapshot);
          this.sharedNodes.forEach(removeLeadSnapshots);
        }
        scheduleUpdateProjection() {
          if (!this.projectionUpdateScheduled) {
            this.projectionUpdateScheduled = true;
            frame.preRender(this.updateProjection, false, true);
          }
        }
        scheduleCheckAfterUnmount() {
          frame.postRender(() => {
            if (this.isLayoutDirty) {
              this.root.didUpdate();
            } else {
              this.root.checkUpdateFailed();
            }
          });
        }
        /**
         * Update measurements
         */
        updateSnapshot() {
          if (this.snapshot || !this.instance)
            return;
          this.snapshot = this.measure();
        }
        updateLayout() {
          if (!this.instance)
            return;
          this.updateScroll();
          if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
            return;
          }
          if (this.resumeFrom && !this.resumeFrom.instance) {
            for (let i = 0; i < this.path.length; i++) {
              const node2 = this.path[i];
              node2.updateScroll();
            }
          }
          const prevLayout = this.layout;
          this.layout = this.measure(false);
          this.layoutCorrected = createBox();
          this.isLayoutDirty = false;
          this.projectionDelta = void 0;
          this.notifyListeners("measure", this.layout.layoutBox);
          const { visualElement } = this.options;
          visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
        }
        updateScroll(phase = "measure") {
          let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
          if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
            needsMeasurement = false;
          }
          if (needsMeasurement) {
            this.scroll = {
              animationId: this.root.animationId,
              phase,
              isRoot: checkIsScrollRoot(this.instance),
              offset: measureScroll(this.instance)
            };
          }
        }
        resetTransform() {
          if (!resetTransform)
            return;
          const isResetRequested = this.isLayoutDirty || this.shouldResetTransform;
          const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
          const transformTemplate = this.getTransformTemplate();
          const transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
          const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
          if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
            resetTransform(this.instance, transformTemplateValue);
            this.shouldResetTransform = false;
            this.scheduleRender();
          }
        }
        measure(removeTransform = true) {
          const pageBox = this.measurePageBox();
          let layoutBox = this.removeElementScroll(pageBox);
          if (removeTransform) {
            layoutBox = this.removeTransform(layoutBox);
          }
          roundBox(layoutBox);
          return {
            animationId: this.root.animationId,
            measuredBox: pageBox,
            layoutBox,
            latestValues: {},
            source: this.id
          };
        }
        measurePageBox() {
          const { visualElement } = this.options;
          if (!visualElement)
            return createBox();
          const box = visualElement.measureViewportBox();
          const { scroll } = this.root;
          if (scroll) {
            translateAxis(box.x, scroll.offset.x);
            translateAxis(box.y, scroll.offset.y);
          }
          return box;
        }
        removeElementScroll(box) {
          const boxWithoutScroll = createBox();
          copyBoxInto(boxWithoutScroll, box);
          for (let i = 0; i < this.path.length; i++) {
            const node2 = this.path[i];
            const { scroll, options } = node2;
            if (node2 !== this.root && scroll && options.layoutScroll) {
              if (scroll.isRoot) {
                copyBoxInto(boxWithoutScroll, box);
                const { scroll: rootScroll } = this.root;
                if (rootScroll) {
                  translateAxis(boxWithoutScroll.x, -rootScroll.offset.x);
                  translateAxis(boxWithoutScroll.y, -rootScroll.offset.y);
                }
              }
              translateAxis(boxWithoutScroll.x, scroll.offset.x);
              translateAxis(boxWithoutScroll.y, scroll.offset.y);
            }
          }
          return boxWithoutScroll;
        }
        applyTransform(box, transformOnly = false) {
          const withTransforms = createBox();
          copyBoxInto(withTransforms, box);
          for (let i = 0; i < this.path.length; i++) {
            const node2 = this.path[i];
            if (!transformOnly && node2.options.layoutScroll && node2.scroll && node2 !== node2.root) {
              transformBox(withTransforms, {
                x: -node2.scroll.offset.x,
                y: -node2.scroll.offset.y
              });
            }
            if (!hasTransform(node2.latestValues))
              continue;
            transformBox(withTransforms, node2.latestValues);
          }
          if (hasTransform(this.latestValues)) {
            transformBox(withTransforms, this.latestValues);
          }
          return withTransforms;
        }
        removeTransform(box) {
          const boxWithoutTransform = createBox();
          copyBoxInto(boxWithoutTransform, box);
          for (let i = 0; i < this.path.length; i++) {
            const node2 = this.path[i];
            if (!node2.instance)
              continue;
            if (!hasTransform(node2.latestValues))
              continue;
            hasScale(node2.latestValues) && node2.updateSnapshot();
            const sourceBox = createBox();
            const nodeBox = node2.measurePageBox();
            copyBoxInto(sourceBox, nodeBox);
            removeBoxTransforms(boxWithoutTransform, node2.latestValues, node2.snapshot ? node2.snapshot.layoutBox : void 0, sourceBox);
          }
          if (hasTransform(this.latestValues)) {
            removeBoxTransforms(boxWithoutTransform, this.latestValues);
          }
          return boxWithoutTransform;
        }
        setTargetDelta(delta) {
          this.targetDelta = delta;
          this.root.scheduleUpdateProjection();
          this.isProjectionDirty = true;
        }
        setOptions(options) {
          this.options = {
            ...this.options,
            ...options,
            crossfade: options.crossfade !== void 0 ? options.crossfade : true
          };
        }
        clearMeasurements() {
          this.scroll = void 0;
          this.layout = void 0;
          this.snapshot = void 0;
          this.prevTransformTemplateValue = void 0;
          this.targetDelta = void 0;
          this.target = void 0;
          this.isLayoutDirty = false;
        }
        forceRelativeParentToResolveTarget() {
          if (!this.relativeParent)
            return;
          if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {
            this.relativeParent.resolveTargetDelta(true);
          }
        }
        resolveTargetDelta(forceRecalculation = false) {
          var _a;
          const lead = this.getLead();
          this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
          this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
          this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
          const isShared = Boolean(this.resumingFrom) || this !== lead;
          const canSkip = !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty) || this.attemptToResolveRelativeTarget);
          if (canSkip)
            return;
          const { layout: layout2, layoutId } = this.options;
          if (!this.layout || !(layout2 || layoutId))
            return;
          this.resolvedRelativeTargetAt = frameData.timestamp;
          if (!this.targetDelta && !this.relativeTarget) {
            const relativeParent = this.getClosestProjectingParent();
            if (relativeParent && relativeParent.layout && this.animationProgress !== 1) {
              this.relativeParent = relativeParent;
              this.forceRelativeParentToResolveTarget();
              this.relativeTarget = createBox();
              this.relativeTargetOrigin = createBox();
              calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);
              copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
            } else {
              this.relativeParent = this.relativeTarget = void 0;
            }
          }
          if (!this.relativeTarget && !this.targetDelta)
            return;
          if (!this.target) {
            this.target = createBox();
            this.targetWithTransforms = createBox();
          }
          if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {
            this.forceRelativeParentToResolveTarget();
            calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
          } else if (this.targetDelta) {
            if (Boolean(this.resumingFrom)) {
              this.target = this.applyTransform(this.layout.layoutBox);
            } else {
              copyBoxInto(this.target, this.layout.layoutBox);
            }
            applyBoxDelta(this.target, this.targetDelta);
          } else {
            copyBoxInto(this.target, this.layout.layoutBox);
          }
          if (this.attemptToResolveRelativeTarget) {
            this.attemptToResolveRelativeTarget = false;
            const relativeParent = this.getClosestProjectingParent();
            if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1) {
              this.relativeParent = relativeParent;
              this.forceRelativeParentToResolveTarget();
              this.relativeTarget = createBox();
              this.relativeTargetOrigin = createBox();
              calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);
              copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
            } else {
              this.relativeParent = this.relativeTarget = void 0;
            }
          }
          projectionFrameData.resolvedTargetDeltas++;
        }
        getClosestProjectingParent() {
          if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {
            return void 0;
          }
          if (this.parent.isProjecting()) {
            return this.parent;
          } else {
            return this.parent.getClosestProjectingParent();
          }
        }
        isProjecting() {
          return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
        }
        calcProjection() {
          var _a;
          const lead = this.getLead();
          const isShared = Boolean(this.resumingFrom) || this !== lead;
          let canSkip = true;
          if (this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty)) {
            canSkip = false;
          }
          if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
            canSkip = false;
          }
          if (this.resolvedRelativeTargetAt === frameData.timestamp) {
            canSkip = false;
          }
          if (canSkip)
            return;
          const { layout: layout2, layoutId } = this.options;
          this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);
          if (!this.isTreeAnimating) {
            this.targetDelta = this.relativeTarget = void 0;
          }
          if (!this.layout || !(layout2 || layoutId))
            return;
          copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
          const prevTreeScaleX = this.treeScale.x;
          const prevTreeScaleY = this.treeScale.y;
          applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
          if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
            lead.target = lead.layout.layoutBox;
            lead.targetWithTransforms = createBox();
          }
          const { target } = lead;
          if (!target) {
            if (this.projectionTransform) {
              this.projectionDelta = createDelta();
              this.projectionTransform = "none";
              this.scheduleRender();
            }
            return;
          }
          if (!this.projectionDelta) {
            this.projectionDelta = createDelta();
            this.projectionDeltaWithTransform = createDelta();
          }
          const prevProjectionTransform = this.projectionTransform;
          calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
          this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale);
          if (this.projectionTransform !== prevProjectionTransform || this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY) {
            this.hasProjected = true;
            this.scheduleRender();
            this.notifyListeners("projectionUpdate", target);
          }
          projectionFrameData.recalculatedProjection++;
        }
        hide() {
          this.isVisible = false;
        }
        show() {
          this.isVisible = true;
        }
        scheduleRender(notifyAll = true) {
          this.options.scheduleRender && this.options.scheduleRender();
          if (notifyAll) {
            const stack = this.getStack();
            stack && stack.scheduleRender();
          }
          if (this.resumingFrom && !this.resumingFrom.instance) {
            this.resumingFrom = void 0;
          }
        }
        setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
          const snapshot = this.snapshot;
          const snapshotLatestValues = snapshot ? snapshot.latestValues : {};
          const mixedValues = { ...this.latestValues };
          const targetDelta = createDelta();
          if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
            this.relativeTarget = this.relativeTargetOrigin = void 0;
          }
          this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
          const relativeLayout = createBox();
          const snapshotSource = snapshot ? snapshot.source : void 0;
          const layoutSource = this.layout ? this.layout.source : void 0;
          const isSharedLayoutAnimation = snapshotSource !== layoutSource;
          const stack = this.getStack();
          const isOnlyMember = !stack || stack.members.length <= 1;
          const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
          this.animationProgress = 0;
          let prevRelativeTarget;
          this.mixTargetDelta = (latest) => {
            const progress2 = latest / 1e3;
            mixAxisDelta(targetDelta.x, delta.x, progress2);
            mixAxisDelta(targetDelta.y, delta.y, progress2);
            this.setTargetDelta(targetDelta);
            if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
              calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
              mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2);
              if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) {
                this.isProjectionDirty = false;
              }
              if (!prevRelativeTarget)
                prevRelativeTarget = createBox();
              copyBoxInto(prevRelativeTarget, this.relativeTarget);
            }
            if (isSharedLayoutAnimation) {
              this.animationValues = mixedValues;
              mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);
            }
            this.root.scheduleUpdateProjection();
            this.scheduleRender();
            this.animationProgress = progress2;
          };
          this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
        }
        startAnimation(options) {
          this.notifyListeners("animationStart");
          this.currentAnimation && this.currentAnimation.stop();
          if (this.resumingFrom && this.resumingFrom.currentAnimation) {
            this.resumingFrom.currentAnimation.stop();
          }
          if (this.pendingAnimation) {
            cancelFrame(this.pendingAnimation);
            this.pendingAnimation = void 0;
          }
          this.pendingAnimation = frame.update(() => {
            globalProjectionState.hasAnimatedSinceResize = true;
            this.currentAnimation = animateSingleValue(0, animationTarget, {
              ...options,
              onUpdate: (latest) => {
                this.mixTargetDelta(latest);
                options.onUpdate && options.onUpdate(latest);
              },
              onComplete: () => {
                options.onComplete && options.onComplete();
                this.completeAnimation();
              }
            });
            if (this.resumingFrom) {
              this.resumingFrom.currentAnimation = this.currentAnimation;
            }
            this.pendingAnimation = void 0;
          });
        }
        completeAnimation() {
          if (this.resumingFrom) {
            this.resumingFrom.currentAnimation = void 0;
            this.resumingFrom.preserveOpacity = void 0;
          }
          const stack = this.getStack();
          stack && stack.exitAnimationComplete();
          this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
          this.notifyListeners("animationComplete");
        }
        finishAnimation() {
          if (this.currentAnimation) {
            this.mixTargetDelta && this.mixTargetDelta(animationTarget);
            this.currentAnimation.stop();
          }
          this.completeAnimation();
        }
        applyTransformsToTarget() {
          const lead = this.getLead();
          let { targetWithTransforms, target, layout: layout2, latestValues } = lead;
          if (!targetWithTransforms || !target || !layout2)
            return;
          if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
            target = this.target || createBox();
            const xLength = calcLength(this.layout.layoutBox.x);
            target.x.min = lead.target.x.min;
            target.x.max = target.x.min + xLength;
            const yLength = calcLength(this.layout.layoutBox.y);
            target.y.min = lead.target.y.min;
            target.y.max = target.y.min + yLength;
          }
          copyBoxInto(targetWithTransforms, target);
          transformBox(targetWithTransforms, latestValues);
          calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
        }
        registerSharedNode(layoutId, node2) {
          if (!this.sharedNodes.has(layoutId)) {
            this.sharedNodes.set(layoutId, new NodeStack());
          }
          const stack = this.sharedNodes.get(layoutId);
          stack.add(node2);
          const config2 = node2.options.initialPromotionConfig;
          node2.promote({
            transition: config2 ? config2.transition : void 0,
            preserveFollowOpacity: config2 && config2.shouldPreserveFollowOpacity ? config2.shouldPreserveFollowOpacity(node2) : void 0
          });
        }
        isLead() {
          const stack = this.getStack();
          return stack ? stack.lead === this : true;
        }
        getLead() {
          var _a;
          const { layoutId } = this.options;
          return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;
        }
        getPrevLead() {
          var _a;
          const { layoutId } = this.options;
          return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : void 0;
        }
        getStack() {
          const { layoutId } = this.options;
          if (layoutId)
            return this.root.sharedNodes.get(layoutId);
        }
        promote({ needsReset, transition, preserveFollowOpacity } = {}) {
          const stack = this.getStack();
          if (stack)
            stack.promote(this, preserveFollowOpacity);
          if (needsReset) {
            this.projectionDelta = void 0;
            this.needsReset = true;
          }
          if (transition)
            this.setOptions({ transition });
        }
        relegate() {
          const stack = this.getStack();
          if (stack) {
            return stack.relegate(this);
          } else {
            return false;
          }
        }
        resetRotation() {
          const { visualElement } = this.options;
          if (!visualElement)
            return;
          let hasRotate = false;
          const { latestValues } = visualElement;
          if (latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ) {
            hasRotate = true;
          }
          if (!hasRotate)
            return;
          const resetValues = {};
          for (let i = 0; i < transformAxes.length; i++) {
            const key = "rotate" + transformAxes[i];
            if (latestValues[key]) {
              resetValues[key] = latestValues[key];
              visualElement.setStaticValue(key, 0);
            }
          }
          visualElement.render();
          for (const key in resetValues) {
            visualElement.setStaticValue(key, resetValues[key]);
          }
          visualElement.scheduleRender();
        }
        getProjectionStyles(styleProp) {
          var _a, _b;
          if (!this.instance || this.isSVG)
            return void 0;
          if (!this.isVisible) {
            return hiddenVisibility;
          }
          const styles2 = {
            visibility: ""
          };
          const transformTemplate = this.getTransformTemplate();
          if (this.needsReset) {
            this.needsReset = false;
            styles2.opacity = "";
            styles2.pointerEvents = resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "";
            styles2.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
            return styles2;
          }
          const lead = this.getLead();
          if (!this.projectionDelta || !this.layout || !lead.target) {
            const emptyStyles = {};
            if (this.options.layoutId) {
              emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
              emptyStyles.pointerEvents = resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "";
            }
            if (this.hasProjected && !hasTransform(this.latestValues)) {
              emptyStyles.transform = transformTemplate ? transformTemplate({}, "") : "none";
              this.hasProjected = false;
            }
            return emptyStyles;
          }
          const valuesToRender = lead.animationValues || lead.latestValues;
          this.applyTransformsToTarget();
          styles2.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
          if (transformTemplate) {
            styles2.transform = transformTemplate(valuesToRender, styles2.transform);
          }
          const { x: x2, y: y2 } = this.projectionDelta;
          styles2.transformOrigin = `${x2.origin * 100}% ${y2.origin * 100}% 0`;
          if (lead.animationValues) {
            styles2.opacity = lead === this ? (_b = (_a = valuesToRender.opacity) !== null && _a !== void 0 ? _a : this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
          } else {
            styles2.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
          }
          for (const key in scaleCorrectors) {
            if (valuesToRender[key] === void 0)
              continue;
            const { correct, applyTo } = scaleCorrectors[key];
            const corrected = styles2.transform === "none" ? valuesToRender[key] : correct(valuesToRender[key], lead);
            if (applyTo) {
              const num = applyTo.length;
              for (let i = 0; i < num; i++) {
                styles2[applyTo[i]] = corrected;
              }
            } else {
              styles2[key] = corrected;
            }
          }
          if (this.options.layoutId) {
            styles2.pointerEvents = lead === this ? resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "" : "none";
          }
          return styles2;
        }
        clearSnapshot() {
          this.resumeFrom = this.snapshot = void 0;
        }
        // Only run on root
        resetTree() {
          this.root.nodes.forEach((node2) => {
            var _a;
            return (_a = node2.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();
          });
          this.root.nodes.forEach(clearMeasurements);
          this.root.sharedNodes.clear();
        }
      };
    }
    function updateLayout(node2) {
      node2.updateLayout();
    }
    function notifyLayoutUpdate(node2) {
      var _a;
      const snapshot = ((_a = node2.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) || node2.snapshot;
      if (node2.isLead() && node2.layout && snapshot && node2.hasListeners("didUpdate")) {
        const { layoutBox: layout2, measuredBox: measuredLayout } = node2.layout;
        const { animationType } = node2.options;
        const isShared = snapshot.source !== node2.layout.source;
        if (animationType === "size") {
          eachAxis((axis) => {
            const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
            const length2 = calcLength(axisSnapshot);
            axisSnapshot.min = layout2[axis].min;
            axisSnapshot.max = axisSnapshot.min + length2;
          });
        } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2)) {
          eachAxis((axis) => {
            const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
            const length2 = calcLength(layout2[axis]);
            axisSnapshot.max = axisSnapshot.min + length2;
            if (node2.relativeTarget && !node2.currentAnimation) {
              node2.isProjectionDirty = true;
              node2.relativeTarget[axis].max = node2.relativeTarget[axis].min + length2;
            }
          });
        }
        const layoutDelta = createDelta();
        calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox);
        const visualDelta = createDelta();
        if (isShared) {
          calcBoxDelta(visualDelta, node2.applyTransform(measuredLayout, true), snapshot.measuredBox);
        } else {
          calcBoxDelta(visualDelta, layout2, snapshot.layoutBox);
        }
        const hasLayoutChanged = !isDeltaZero(layoutDelta);
        let hasRelativeTargetChanged = false;
        if (!node2.resumeFrom) {
          const relativeParent = node2.getClosestProjectingParent();
          if (relativeParent && !relativeParent.resumeFrom) {
            const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
            if (parentSnapshot && parentLayout) {
              const relativeSnapshot = createBox();
              calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
              const relativeLayout = createBox();
              calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox);
              if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {
                hasRelativeTargetChanged = true;
              }
              if (relativeParent.options.layoutRoot) {
                node2.relativeTarget = relativeLayout;
                node2.relativeTargetOrigin = relativeSnapshot;
                node2.relativeParent = relativeParent;
              }
            }
          }
        }
        node2.notifyListeners("didUpdate", {
          layout: layout2,
          snapshot,
          delta: visualDelta,
          layoutDelta,
          hasLayoutChanged,
          hasRelativeTargetChanged
        });
      } else if (node2.isLead()) {
        const { onExitComplete } = node2.options;
        onExitComplete && onExitComplete();
      }
      node2.options.transition = void 0;
    }
    function propagateDirtyNodes(node2) {
      projectionFrameData.totalNodes++;
      if (!node2.parent)
        return;
      if (!node2.isProjecting()) {
        node2.isProjectionDirty = node2.parent.isProjectionDirty;
      }
      node2.isSharedProjectionDirty || (node2.isSharedProjectionDirty = Boolean(node2.isProjectionDirty || node2.parent.isProjectionDirty || node2.parent.isSharedProjectionDirty));
      node2.isTransformDirty || (node2.isTransformDirty = node2.parent.isTransformDirty);
    }
    function cleanDirtyNodes(node2) {
      node2.isProjectionDirty = node2.isSharedProjectionDirty = node2.isTransformDirty = false;
    }
    function clearSnapshot(node2) {
      node2.clearSnapshot();
    }
    function clearMeasurements(node2) {
      node2.clearMeasurements();
    }
    function clearIsLayoutDirty(node2) {
      node2.isLayoutDirty = false;
    }
    function resetTransformStyle(node2) {
      const { visualElement } = node2.options;
      if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
        visualElement.notify("BeforeLayoutMeasure");
      }
      node2.resetTransform();
    }
    function finishAnimation(node2) {
      node2.finishAnimation();
      node2.targetDelta = node2.relativeTarget = node2.target = void 0;
      node2.isProjectionDirty = true;
    }
    function resolveTargetDelta(node2) {
      node2.resolveTargetDelta();
    }
    function calcProjection(node2) {
      node2.calcProjection();
    }
    function resetRotation(node2) {
      node2.resetRotation();
    }
    function removeLeadSnapshots(stack) {
      stack.removeLeadSnapshot();
    }
    function mixAxisDelta(output, delta, p2) {
      output.translate = mixNumber$1(delta.translate, 0, p2);
      output.scale = mixNumber$1(delta.scale, 1, p2);
      output.origin = delta.origin;
      output.originPoint = delta.originPoint;
    }
    function mixAxis(output, from2, to, p2) {
      output.min = mixNumber$1(from2.min, to.min, p2);
      output.max = mixNumber$1(from2.max, to.max, p2);
    }
    function mixBox(output, from2, to, p2) {
      mixAxis(output.x, from2.x, to.x, p2);
      mixAxis(output.y, from2.y, to.y, p2);
    }
    function hasOpacityCrossfade(node2) {
      return node2.animationValues && node2.animationValues.opacityExit !== void 0;
    }
    const defaultLayoutTransition = {
      duration: 0.45,
      ease: [0.4, 0, 0.1, 1]
    };
    const userAgentContains = (string2) => typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string2);
    const roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop;
    function roundAxis(axis) {
      axis.min = roundPoint(axis.min);
      axis.max = roundPoint(axis.max);
    }
    function roundBox(box) {
      roundAxis(box.x);
      roundAxis(box.y);
    }
    function shouldAnimatePositionOnly(animationType, snapshot, layout2) {
      return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout2), 0.2);
    }
    const DocumentProjectionNode = createProjectionNode({
      attachResizeListener: (ref, notify) => addDomEvent(ref, "resize", notify),
      measureScroll: () => ({
        x: document.documentElement.scrollLeft || document.body.scrollLeft,
        y: document.documentElement.scrollTop || document.body.scrollTop
      }),
      checkIsScrollRoot: () => true
    });
    const rootProjectionNode = {
      current: void 0
    };
    const HTMLProjectionNode = createProjectionNode({
      measureScroll: (instance2) => ({
        x: instance2.scrollLeft,
        y: instance2.scrollTop
      }),
      defaultParent: () => {
        if (!rootProjectionNode.current) {
          const documentNode = new DocumentProjectionNode({});
          documentNode.mount(window);
          documentNode.setOptions({ layoutScroll: true });
          rootProjectionNode.current = documentNode;
        }
        return rootProjectionNode.current;
      },
      resetTransform: (instance2, value) => {
        instance2.style.transform = value !== void 0 ? value : "none";
      },
      checkIsScrollRoot: (instance2) => Boolean(window.getComputedStyle(instance2).position === "fixed")
    });
    const drag = {
      pan: {
        Feature: PanGesture
      },
      drag: {
        Feature: DragGesture,
        ProjectionNode: HTMLProjectionNode,
        MeasureLayout
      }
    };
    const splitCSSVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
    function parseCSSVariable(current) {
      const match2 = splitCSSVariableRegex.exec(current);
      if (!match2)
        return [,];
      const [, token2, fallback] = match2;
      return [token2, fallback];
    }
    function getVariableValue(current, element, depth = 1) {
      const [token2, fallback] = parseCSSVariable(current);
      if (!token2)
        return;
      const resolved = window.getComputedStyle(element).getPropertyValue(token2);
      if (resolved) {
        const trimmed = resolved.trim();
        return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
      } else if (isCSSVariableToken(fallback)) {
        return getVariableValue(fallback, element, depth + 1);
      } else {
        return fallback;
      }
    }
    function resolveCSSVariables(visualElement, { ...target }, transitionEnd) {
      const element = visualElement.current;
      if (!(element instanceof Element))
        return { target, transitionEnd };
      if (transitionEnd) {
        transitionEnd = { ...transitionEnd };
      }
      visualElement.values.forEach((value) => {
        const current = value.get();
        if (!isCSSVariableToken(current))
          return;
        const resolved = getVariableValue(current, element);
        if (resolved)
          value.set(resolved);
      });
      for (const key in target) {
        const current = target[key];
        if (!isCSSVariableToken(current))
          continue;
        const resolved = getVariableValue(current, element);
        if (!resolved)
          continue;
        target[key] = resolved;
        if (!transitionEnd)
          transitionEnd = {};
        if (transitionEnd[key] === void 0) {
          transitionEnd[key] = current;
        }
      }
      return { target, transitionEnd };
    }
    const positionalKeys = /* @__PURE__ */ new Set([
      "width",
      "height",
      "top",
      "left",
      "right",
      "bottom",
      "x",
      "y",
      "translateX",
      "translateY"
    ]);
    const isPositionalKey = (key) => positionalKeys.has(key);
    const hasPositionalKey = (target) => {
      return Object.keys(target).some(isPositionalKey);
    };
    const isNumOrPxType = (v2) => v2 === number || v2 === px;
    const getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(", ")[pos]);
    const getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform }) => {
      if (transform === "none" || !transform)
        return 0;
      const matrix3d = transform.match(/^matrix3d\((.+)\)$/);
      if (matrix3d) {
        return getPosFromMatrix(matrix3d[1], pos3);
      } else {
        const matrix = transform.match(/^matrix\((.+)\)$/);
        if (matrix) {
          return getPosFromMatrix(matrix[1], pos2);
        } else {
          return 0;
        }
      }
    };
    const transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
    const nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));
    function removeNonTranslationalTransform(visualElement) {
      const removedTransforms = [];
      nonTranslationalTransformKeys.forEach((key) => {
        const value = visualElement.getValue(key);
        if (value !== void 0) {
          removedTransforms.push([key, value.get()]);
          value.set(key.startsWith("scale") ? 1 : 0);
        }
      });
      if (removedTransforms.length)
        visualElement.render();
      return removedTransforms;
    }
    const positionalValues = {
      // Dimensions
      width: ({ x: x2 }, { paddingLeft = "0", paddingRight = "0" }) => x2.max - x2.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
      height: ({ y: y2 }, { paddingTop = "0", paddingBottom = "0" }) => y2.max - y2.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
      top: (_bbox, { top: top2 }) => parseFloat(top2),
      left: (_bbox, { left: left2 }) => parseFloat(left2),
      bottom: ({ y: y2 }, { top: top2 }) => parseFloat(top2) + (y2.max - y2.min),
      right: ({ x: x2 }, { left: left2 }) => parseFloat(left2) + (x2.max - x2.min),
      // Transform
      x: getTranslateFromMatrix(4, 13),
      y: getTranslateFromMatrix(5, 14)
    };
    positionalValues.translateX = positionalValues.x;
    positionalValues.translateY = positionalValues.y;
    const convertChangedValueTypes = (target, visualElement, changedKeys) => {
      const originBbox = visualElement.measureViewportBox();
      const element = visualElement.current;
      const elementComputedStyle = getComputedStyle(element);
      const { display } = elementComputedStyle;
      const origin = {};
      if (display === "none") {
        visualElement.setStaticValue("display", target.display || "block");
      }
      changedKeys.forEach((key) => {
        origin[key] = positionalValues[key](originBbox, elementComputedStyle);
      });
      visualElement.render();
      const targetBbox = visualElement.measureViewportBox();
      changedKeys.forEach((key) => {
        const value = visualElement.getValue(key);
        value && value.jump(origin[key]);
        target[key] = positionalValues[key](targetBbox, elementComputedStyle);
      });
      return target;
    };
    const checkAndConvertChangedValueTypes = (visualElement, target, origin = {}, transitionEnd = {}) => {
      target = { ...target };
      transitionEnd = { ...transitionEnd };
      const targetPositionalKeys = Object.keys(target).filter(isPositionalKey);
      let removedTransformValues = [];
      let hasAttemptedToRemoveTransformValues = false;
      const changedValueTypeKeys = [];
      targetPositionalKeys.forEach((key) => {
        const value = visualElement.getValue(key);
        if (!visualElement.hasValue(key))
          return;
        let from2 = origin[key];
        let fromType = findDimensionValueType(from2);
        const to = target[key];
        let toType;
        if (isKeyframesTarget(to)) {
          const numKeyframes = to.length;
          const fromIndex = to[0] === null ? 1 : 0;
          from2 = to[fromIndex];
          fromType = findDimensionValueType(from2);
          for (let i = fromIndex; i < numKeyframes; i++) {
            if (to[i] === null)
              break;
            if (!toType) {
              toType = findDimensionValueType(to[i]);
            } else {
              invariant(findDimensionValueType(to[i]) === toType);
            }
          }
        } else {
          toType = findDimensionValueType(to);
        }
        if (fromType !== toType) {
          if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {
            const current = value.get();
            if (typeof current === "string") {
              value.set(parseFloat(current));
            }
            if (typeof to === "string") {
              target[key] = parseFloat(to);
            } else if (Array.isArray(to) && toType === px) {
              target[key] = to.map(parseFloat);
            }
          } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from2 === 0 || to === 0)) {
            if (from2 === 0) {
              value.set(toType.transform(from2));
            } else {
              target[key] = fromType.transform(to);
            }
          } else {
            if (!hasAttemptedToRemoveTransformValues) {
              removedTransformValues = removeNonTranslationalTransform(visualElement);
              hasAttemptedToRemoveTransformValues = true;
            }
            changedValueTypeKeys.push(key);
            transitionEnd[key] = transitionEnd[key] !== void 0 ? transitionEnd[key] : target[key];
            value.jump(to);
          }
        }
      });
      if (changedValueTypeKeys.length) {
        const scrollY = changedValueTypeKeys.indexOf("height") >= 0 ? window.pageYOffset : null;
        const convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);
        if (removedTransformValues.length) {
          removedTransformValues.forEach(([key, value]) => {
            visualElement.getValue(key).set(value);
          });
        }
        visualElement.render();
        if (isBrowser && scrollY !== null) {
          window.scrollTo({ top: scrollY });
        }
        return { target: convertedTarget, transitionEnd };
      } else {
        return { target, transitionEnd };
      }
    };
    function unitConversion(visualElement, target, origin, transitionEnd) {
      return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : { target, transitionEnd };
    }
    const parseDomVariant = (visualElement, target, origin, transitionEnd) => {
      const resolved = resolveCSSVariables(visualElement, target, transitionEnd);
      target = resolved.target;
      transitionEnd = resolved.transitionEnd;
      return unitConversion(visualElement, target, origin, transitionEnd);
    };
    const prefersReducedMotion = { current: null };
    const hasReducedMotionListener = { current: false };
    function initPrefersReducedMotion() {
      hasReducedMotionListener.current = true;
      if (!isBrowser)
        return;
      if (window.matchMedia) {
        const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
        const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
        motionMediaQuery.addListener(setReducedMotionPreferences);
        setReducedMotionPreferences();
      } else {
        prefersReducedMotion.current = false;
      }
    }
    function updateMotionValuesFromProps(element, next2, prev2) {
      const { willChange } = next2;
      for (const key in next2) {
        const nextValue = next2[key];
        const prevValue = prev2[key];
        if (isMotionValue(nextValue)) {
          element.addValue(key, nextValue);
          if (isWillChangeMotionValue(willChange)) {
            willChange.add(key);
          }
        } else if (isMotionValue(prevValue)) {
          element.addValue(key, motionValue(nextValue, { owner: element }));
          if (isWillChangeMotionValue(willChange)) {
            willChange.remove(key);
          }
        } else if (prevValue !== nextValue) {
          if (element.hasValue(key)) {
            const existingValue = element.getValue(key);
            !existingValue.hasAnimated && existingValue.set(nextValue);
          } else {
            const latestValue = element.getStaticValue(key);
            element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
          }
        }
      }
      for (const key in prev2) {
        if (next2[key] === void 0)
          element.removeValue(key);
      }
      return next2;
    }
    const visualElementStore = /* @__PURE__ */ new WeakMap();
    const featureNames = Object.keys(featureDefinitions);
    const numFeatures = featureNames.length;
    const propEventHandlers = [
      "AnimationStart",
      "AnimationComplete",
      "Update",
      "BeforeLayoutMeasure",
      "LayoutMeasure",
      "LayoutAnimationStart",
      "LayoutAnimationComplete"
    ];
    const numVariantProps = variantProps.length;
    class VisualElement {
      constructor({ parent, props, presenceContext, reducedMotionConfig, visualState }, options = {}) {
        this.current = null;
        this.children = /* @__PURE__ */ new Set();
        this.isVariantNode = false;
        this.isControllingVariants = false;
        this.shouldReduceMotion = null;
        this.values = /* @__PURE__ */ new Map();
        this.features = {};
        this.valueSubscriptions = /* @__PURE__ */ new Map();
        this.prevMotionValues = {};
        this.events = {};
        this.propEventSubscriptions = {};
        this.notifyUpdate = () => this.notify("Update", this.latestValues);
        this.render = () => {
          if (!this.current)
            return;
          this.triggerBuild();
          this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
        };
        this.scheduleRender = () => frame.render(this.render, false, true);
        const { latestValues, renderState } = visualState;
        this.latestValues = latestValues;
        this.baseTarget = { ...latestValues };
        this.initialValues = props.initial ? { ...latestValues } : {};
        this.renderState = renderState;
        this.parent = parent;
        this.props = props;
        this.presenceContext = presenceContext;
        this.depth = parent ? parent.depth + 1 : 0;
        this.reducedMotionConfig = reducedMotionConfig;
        this.options = options;
        this.isControllingVariants = isControllingVariants(props);
        this.isVariantNode = isVariantNode(props);
        if (this.isVariantNode) {
          this.variantChildren = /* @__PURE__ */ new Set();
        }
        this.manuallyAnimateOnMount = Boolean(parent && parent.current);
        const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {});
        for (const key in initialMotionValues) {
          const value = initialMotionValues[key];
          if (latestValues[key] !== void 0 && isMotionValue(value)) {
            value.set(latestValues[key], false);
            if (isWillChangeMotionValue(willChange)) {
              willChange.add(key);
            }
          }
        }
      }
      /**
       * This method takes React props and returns found MotionValues. For example, HTML
       * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
       *
       * This isn't an abstract method as it needs calling in the constructor, but it is
       * intended to be one.
       */
      scrapeMotionValuesFromProps(_props, _prevProps) {
        return {};
      }
      mount(instance2) {
        this.current = instance2;
        visualElementStore.set(instance2, this);
        if (this.projection && !this.projection.instance) {
          this.projection.mount(instance2);
        }
        if (this.parent && this.isVariantNode && !this.isControllingVariants) {
          this.removeFromVariantTree = this.parent.addVariantChild(this);
        }
        this.values.forEach((value, key) => this.bindToMotionValue(key, value));
        if (!hasReducedMotionListener.current) {
          initPrefersReducedMotion();
        }
        this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
        if (this.parent)
          this.parent.children.add(this);
        this.update(this.props, this.presenceContext);
      }
      unmount() {
        visualElementStore.delete(this.current);
        this.projection && this.projection.unmount();
        cancelFrame(this.notifyUpdate);
        cancelFrame(this.render);
        this.valueSubscriptions.forEach((remove) => remove());
        this.removeFromVariantTree && this.removeFromVariantTree();
        this.parent && this.parent.children.delete(this);
        for (const key in this.events) {
          this.events[key].clear();
        }
        for (const key in this.features) {
          this.features[key].unmount();
        }
        this.current = null;
      }
      bindToMotionValue(key, value) {
        const valueIsTransform = transformProps.has(key);
        const removeOnChange = value.on("change", (latestValue) => {
          this.latestValues[key] = latestValue;
          this.props.onUpdate && frame.update(this.notifyUpdate, false, true);
          if (valueIsTransform && this.projection) {
            this.projection.isTransformDirty = true;
          }
        });
        const removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);
        this.valueSubscriptions.set(key, () => {
          removeOnChange();
          removeOnRenderRequest();
        });
      }
      sortNodePosition(other) {
        if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
          return 0;
        }
        return this.sortInstanceNodePosition(this.current, other.current);
      }
      loadFeatures({ children, ...renderedProps }, isStrict, preloadedFeatures2, initialLayoutGroupConfig) {
        let ProjectionNodeConstructor;
        let MeasureLayout2;
        for (let i = 0; i < numFeatures; i++) {
          const name = featureNames[i];
          const { isEnabled, Feature: FeatureConstructor, ProjectionNode, MeasureLayout: MeasureLayoutComponent } = featureDefinitions[name];
          if (ProjectionNode)
            ProjectionNodeConstructor = ProjectionNode;
          if (isEnabled(renderedProps)) {
            if (!this.features[name] && FeatureConstructor) {
              this.features[name] = new FeatureConstructor(this);
            }
            if (MeasureLayoutComponent) {
              MeasureLayout2 = MeasureLayoutComponent;
            }
          }
        }
        if ((this.type === "html" || this.type === "svg") && !this.projection && ProjectionNodeConstructor) {
          this.projection = new ProjectionNodeConstructor(this.latestValues, this.parent && this.parent.projection);
          const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot } = renderedProps;
          this.projection.setOptions({
            layoutId,
            layout: layout2,
            alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
            visualElement: this,
            scheduleRender: () => this.scheduleRender(),
            /**
             * TODO: Update options in an effect. This could be tricky as it'll be too late
             * to update by the time layout animations run.
             * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
             * ensuring it gets called if there's no potential layout animations.
             *
             */
            animationType: typeof layout2 === "string" ? layout2 : "both",
            initialPromotionConfig: initialLayoutGroupConfig,
            layoutScroll,
            layoutRoot
          });
        }
        return MeasureLayout2;
      }
      updateFeatures() {
        for (const key in this.features) {
          const feature = this.features[key];
          if (feature.isMounted) {
            feature.update();
          } else {
            feature.mount();
            feature.isMounted = true;
          }
        }
      }
      triggerBuild() {
        this.build(this.renderState, this.latestValues, this.options, this.props);
      }
      /**
       * Measure the current viewport box with or without transforms.
       * Only measures axis-aligned boxes, rotate and skew must be manually
       * removed with a re-render to work.
       */
      measureViewportBox() {
        return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
      }
      getStaticValue(key) {
        return this.latestValues[key];
      }
      setStaticValue(key, value) {
        this.latestValues[key] = value;
      }
      /**
       * Make a target animatable by Popmotion. For instance, if we're
       * trying to animate width from 100px to 100vw we need to measure 100vw
       * in pixels to determine what we really need to animate to. This is also
       * pluggable to support Framer's custom value types like Color,
       * and CSS variables.
       */
      makeTargetAnimatable(target, canMutate = true) {
        return this.makeTargetAnimatableFromInstance(target, canMutate);
      }
      /**
       * Update the provided props. Ensure any newly-added motion values are
       * added to our map, old ones removed, and listeners updated.
       */
      update(props, presenceContext) {
        if (props.transformTemplate || this.props.transformTemplate) {
          this.scheduleRender();
        }
        this.prevProps = this.props;
        this.props = props;
        this.prevPresenceContext = this.presenceContext;
        this.presenceContext = presenceContext;
        for (let i = 0; i < propEventHandlers.length; i++) {
          const key = propEventHandlers[i];
          if (this.propEventSubscriptions[key]) {
            this.propEventSubscriptions[key]();
            delete this.propEventSubscriptions[key];
          }
          const listener = props["on" + key];
          if (listener) {
            this.propEventSubscriptions[key] = this.on(key, listener);
          }
        }
        this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps), this.prevMotionValues);
        if (this.handleChildMotionValue) {
          this.handleChildMotionValue();
        }
      }
      getProps() {
        return this.props;
      }
      /**
       * Returns the variant definition with a given name.
       */
      getVariant(name) {
        return this.props.variants ? this.props.variants[name] : void 0;
      }
      /**
       * Returns the defined default transition on this component.
       */
      getDefaultTransition() {
        return this.props.transition;
      }
      getTransformPagePoint() {
        return this.props.transformPagePoint;
      }
      getClosestVariantNode() {
        return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
      }
      getVariantContext(startAtParent = false) {
        if (startAtParent) {
          return this.parent ? this.parent.getVariantContext() : void 0;
        }
        if (!this.isControllingVariants) {
          const context2 = this.parent ? this.parent.getVariantContext() || {} : {};
          if (this.props.initial !== void 0) {
            context2.initial = this.props.initial;
          }
          return context2;
        }
        const context = {};
        for (let i = 0; i < numVariantProps; i++) {
          const name = variantProps[i];
          const prop = this.props[name];
          if (isVariantLabel(prop) || prop === false) {
            context[name] = prop;
          }
        }
        return context;
      }
      /**
       * Add a child visual element to our set of children.
       */
      addVariantChild(child) {
        const closestVariantNode = this.getClosestVariantNode();
        if (closestVariantNode) {
          closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
          return () => closestVariantNode.variantChildren.delete(child);
        }
      }
      /**
       * Add a motion value and bind it to this visual element.
       */
      addValue(key, value) {
        if (value !== this.values.get(key)) {
          this.removeValue(key);
          this.bindToMotionValue(key, value);
        }
        this.values.set(key, value);
        this.latestValues[key] = value.get();
      }
      /**
       * Remove a motion value and unbind any active subscriptions.
       */
      removeValue(key) {
        this.values.delete(key);
        const unsubscribe = this.valueSubscriptions.get(key);
        if (unsubscribe) {
          unsubscribe();
          this.valueSubscriptions.delete(key);
        }
        delete this.latestValues[key];
        this.removeValueFromRenderState(key, this.renderState);
      }
      /**
       * Check whether we have a motion value for this key
       */
      hasValue(key) {
        return this.values.has(key);
      }
      getValue(key, defaultValue) {
        if (this.props.values && this.props.values[key]) {
          return this.props.values[key];
        }
        let value = this.values.get(key);
        if (value === void 0 && defaultValue !== void 0) {
          value = motionValue(defaultValue, { owner: this });
          this.addValue(key, value);
        }
        return value;
      }
      /**
       * If we're trying to animate to a previously unencountered value,
       * we need to check for it in our state and as a last resort read it
       * directly from the instance (which might have performance implications).
       */
      readValue(key) {
        var _a;
        return this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : (_a = this.getBaseTargetFromProps(this.props, key)) !== null && _a !== void 0 ? _a : this.readValueFromInstance(this.current, key, this.options);
      }
      /**
       * Set the base target to later animate back to. This is currently
       * only hydrated on creation and when we first read a value.
       */
      setBaseTarget(key, value) {
        this.baseTarget[key] = value;
      }
      /**
       * Find the base target for a value thats been removed from all animation
       * props.
       */
      getBaseTarget(key) {
        var _a;
        const { initial } = this.props;
        const valueFromInitial = typeof initial === "string" || typeof initial === "object" ? (_a = resolveVariantFromProps(this.props, initial)) === null || _a === void 0 ? void 0 : _a[key] : void 0;
        if (initial && valueFromInitial !== void 0) {
          return valueFromInitial;
        }
        const target = this.getBaseTargetFromProps(this.props, key);
        if (target !== void 0 && !isMotionValue(target))
          return target;
        return this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];
      }
      on(eventName, callback) {
        if (!this.events[eventName]) {
          this.events[eventName] = new SubscriptionManager();
        }
        return this.events[eventName].add(callback);
      }
      notify(eventName, ...args) {
        if (this.events[eventName]) {
          this.events[eventName].notify(...args);
        }
      }
    }
    class DOMVisualElement extends VisualElement {
      sortInstanceNodePosition(a, b2) {
        return a.compareDocumentPosition(b2) & 2 ? 1 : -1;
      }
      getBaseTargetFromProps(props, key) {
        return props.style ? props.style[key] : void 0;
      }
      removeValueFromRenderState(key, { vars, style: style2 }) {
        delete vars[key];
        delete style2[key];
      }
      makeTargetAnimatableFromInstance({ transition, transitionEnd, ...target }, isMounted) {
        const origin = getOrigin(target, transition || {}, this);
        if (isMounted) {
          checkTargetForNewValues(this, target, origin);
          const parsed = parseDomVariant(this, target, origin, transitionEnd);
          transitionEnd = parsed.transitionEnd;
          target = parsed.target;
        }
        return {
          transition,
          transitionEnd,
          ...target
        };
      }
    }
    function getComputedStyle$1(element) {
      return window.getComputedStyle(element);
    }
    class HTMLVisualElement extends DOMVisualElement {
      constructor() {
        super(...arguments);
        this.type = "html";
      }
      readValueFromInstance(instance2, key) {
        if (transformProps.has(key)) {
          const defaultType = getDefaultValueType(key);
          return defaultType ? defaultType.default || 0 : 0;
        } else {
          const computedStyle = getComputedStyle$1(instance2);
          const value = (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
          return typeof value === "string" ? value.trim() : value;
        }
      }
      measureInstanceViewportBox(instance2, { transformPagePoint }) {
        return measureViewportBox(instance2, transformPagePoint);
      }
      build(renderState, latestValues, options, props) {
        buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);
      }
      scrapeMotionValuesFromProps(props, prevProps) {
        return scrapeMotionValuesFromProps$1(props, prevProps);
      }
      handleChildMotionValue() {
        if (this.childSubscription) {
          this.childSubscription();
          delete this.childSubscription;
        }
        const { children } = this.props;
        if (isMotionValue(children)) {
          this.childSubscription = children.on("change", (latest) => {
            if (this.current)
              this.current.textContent = `${latest}`;
          });
        }
      }
      renderInstance(instance2, renderState, styleProp, projection) {
        renderHTML(instance2, renderState, styleProp, projection);
      }
    }
    class SVGVisualElement extends DOMVisualElement {
      constructor() {
        super(...arguments);
        this.type = "svg";
        this.isSVGTag = false;
      }
      getBaseTargetFromProps(props, key) {
        return props[key];
      }
      readValueFromInstance(instance2, key) {
        if (transformProps.has(key)) {
          const defaultType = getDefaultValueType(key);
          return defaultType ? defaultType.default || 0 : 0;
        }
        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
        return instance2.getAttribute(key);
      }
      measureInstanceViewportBox() {
        return createBox();
      }
      scrapeMotionValuesFromProps(props, prevProps) {
        return scrapeMotionValuesFromProps(props, prevProps);
      }
      build(renderState, latestValues, options, props) {
        buildSVGAttrs(renderState, latestValues, options, this.isSVGTag, props.transformTemplate);
      }
      renderInstance(instance2, renderState, styleProp, projection) {
        renderSVG(instance2, renderState, styleProp, projection);
      }
      mount(instance2) {
        this.isSVGTag = isSVGTag(instance2.tagName);
        super.mount(instance2);
      }
    }
    const createDomVisualElement = (Component, options) => {
      return isSVGComponent(Component) ? new SVGVisualElement(options, { enableHardwareAcceleration: false }) : new HTMLVisualElement(options, { enableHardwareAcceleration: true });
    };
    const layout = {
      layout: {
        ProjectionNode: HTMLProjectionNode,
        MeasureLayout
      }
    };
    const preloadedFeatures = {
      ...animations,
      ...gestureAnimations,
      ...drag,
      ...layout
    };
    const motion = /* @__PURE__ */ createMotionProxy((Component, config2) => createDomMotionConfig(Component, config2, preloadedFeatures, createDomVisualElement));
    const Section = ({ item }) => {
      const [expand, setExpand] = reactExports.useState(true);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "section-title", onClick: () => setExpand((prv) => !prv), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: item.title }),
          expand ? /* @__PURE__ */ jsxRuntimeExports.jsx(AiOutlineCaretUp, { className: "icon" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(AiOutlineCaretDown, { className: "icon" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.ul,
          {
            initial: { height: 0, opacity: 0 },
            animate: { height: expand ? "auto" : 0, opacity: expand ? 1 : 0 },
            transition: { duration: 0.3 },
            className: "item",
            children: item.options.map((option, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "element", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "checkbox", id: option.id, value: { itemId: item.id, optionId: option.id } }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: option.id, children: option.title })
            ] }, index))
          }
        )
      ] });
    };
    const FilterSideBar = ({ setOpen }) => {
      const sample = [
        {
          id: "1",
          title: "Price (LKR)",
          options: [
            {
              id: "1",
              title: "0 - 1000"
            },
            {
              id: "2",
              title: "1000 - 2000"
            },
            {
              id: "3",
              title: "2000 - 3000"
            }
          ]
        },
        {
          id: "2",
          title: "Type of Event",
          options: [
            {
              id: "4",
              title: "Wedding"
            },
            {
              id: "5",
              title: "Party"
            },
            {
              id: "6",
              title: "Conference"
            }
          ]
        }
      ];
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { id: "filter-side-bar", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "title", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Filters" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "close", children: /* @__PURE__ */ jsxRuntimeExports.jsx(AiOutlineClose, { className: "icon", onClick: () => setOpen(false) }) })
        ] }),
        sample.map((item, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(Section, { item }, index))
      ] });
    };
    const VenueCard = ({ venue, param }) => {
      const navigation = useNavigate();
      const {
        id: id2,
        name,
        thumbnail,
        description,
        min_const,
        gallery,
        capacity,
        stage,
        floor_area,
        ceiling_height,
        venue_type: venue_type2,
        floor_plan,
        refundable_deposit,
        advance_payment,
        cancelation_fee,
        active
      } = venue;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { id: "venue-card", className: "card", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "image", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: `${base_url}/public/venue-image/${thumbnail}`, alt: "venue" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "details", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "top", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "title", children: name }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "description", children: description.length > 160 ? `${description.substring(0, 130)} ...` : description }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("table", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tbody", { children: [
              capacity !== 1 && capacity !== "1" && /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: "Capacity (No. of pax)" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { children: [
                  ": ",
                  capacity
                ] })
              ] }),
              floor_area !== "1" && floor_area !== 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: "Floor size (Sq ft)" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { children: [
                  ": ",
                  floor_area
                ] })
              ] })
            ] }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "price", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "amount", children: [
              "LKR ",
              parseFloat(min_const).toLocaleString("en-US", { minimumFractionDigits: 2, maximumFractionDigits: 2 })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "btn", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn btn-primary", onClick: () => {
              navigation(`/venue/${id2}/?test=123&venue_type=${param.venue_type}&start_date=${param.start_date}&end_date=${param.end_date}`);
            }, children: "Book Now" }) })
          ] })
        ] })
      ] });
    };
    function getCircularProgressUtilityClass(slot) {
      return generateUtilityClass$1("MuiCircularProgress", slot);
    }
    generateUtilityClasses$1("MuiCircularProgress", ["root", "determinate", "indeterminate", "colorPrimary", "colorSecondary", "svg", "circle", "circleDeterminate", "circleIndeterminate", "circleDisableShrink"]);
    const _excluded$J = ["className", "color", "disableShrink", "size", "style", "thickness", "value", "variant"];
    let _ = (t2) => t2, _t, _t2, _t3, _t4;
    const SIZE = 44;
    const circularRotateKeyframe = keyframes$1(_t || (_t = _`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`));
    const circularDashKeyframe = keyframes$1(_t2 || (_t2 = _`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -125px;
  }
`));
    const useUtilityClasses$z = (ownerState) => {
      const {
        classes,
        variant,
        color: color2,
        disableShrink
      } = ownerState;
      const slots = {
        root: ["root", variant, `color${capitalize(color2)}`],
        svg: ["svg"],
        circle: ["circle", `circle${capitalize(variant)}`, disableShrink && "circleDisableShrink"]
      };
      return composeClasses(slots, getCircularProgressUtilityClass, classes);
    };
    const CircularProgressRoot = styled("span", {
      name: "MuiCircularProgress",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, styles2[ownerState.variant], styles2[`color${capitalize(ownerState.color)}`]];
      }
    })(({
      ownerState,
      theme
    }) => _extends$1({
      display: "inline-block"
    }, ownerState.variant === "determinate" && {
      transition: theme.transitions.create("transform")
    }, ownerState.color !== "inherit" && {
      color: (theme.vars || theme).palette[ownerState.color].main
    }), ({
      ownerState
    }) => ownerState.variant === "indeterminate" && css(_t3 || (_t3 = _`
      animation: ${0} 1.4s linear infinite;
    `), circularRotateKeyframe));
    const CircularProgressSVG = styled("svg", {
      name: "MuiCircularProgress",
      slot: "Svg",
      overridesResolver: (props, styles2) => styles2.svg
    })({
      display: "block"
      // Keeps the progress centered
    });
    const CircularProgressCircle = styled("circle", {
      name: "MuiCircularProgress",
      slot: "Circle",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.circle, styles2[`circle${capitalize(ownerState.variant)}`], ownerState.disableShrink && styles2.circleDisableShrink];
      }
    })(({
      ownerState,
      theme
    }) => _extends$1({
      stroke: "currentColor"
    }, ownerState.variant === "determinate" && {
      transition: theme.transitions.create("stroke-dashoffset")
    }, ownerState.variant === "indeterminate" && {
      // Some default value that looks fine waiting for the animation to kicks in.
      strokeDasharray: "80px, 200px",
      strokeDashoffset: 0
      // Add the unit to fix a Edge 16 and below bug.
    }), ({
      ownerState
    }) => ownerState.variant === "indeterminate" && !ownerState.disableShrink && css(_t4 || (_t4 = _`
      animation: ${0} 1.4s ease-in-out infinite;
    `), circularDashKeyframe));
    const CircularProgress = /* @__PURE__ */ reactExports.forwardRef(function CircularProgress2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiCircularProgress"
      });
      const {
        className,
        color: color2 = "primary",
        disableShrink = false,
        size = 40,
        style: style2,
        thickness = 3.6,
        value = 0,
        variant = "indeterminate"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$J);
      const ownerState = _extends$1({}, props, {
        color: color2,
        disableShrink,
        size,
        thickness,
        value,
        variant
      });
      const classes = useUtilityClasses$z(ownerState);
      const circleStyle = {};
      const rootStyle = {};
      const rootProps = {};
      if (variant === "determinate") {
        const circumference = 2 * Math.PI * ((SIZE - thickness) / 2);
        circleStyle.strokeDasharray = circumference.toFixed(3);
        rootProps["aria-valuenow"] = Math.round(value);
        circleStyle.strokeDashoffset = `${((100 - value) / 100 * circumference).toFixed(3)}px`;
        rootStyle.transform = "rotate(-90deg)";
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressRoot, _extends$1({
        className: clsx(classes.root, className),
        style: _extends$1({
          width: size,
          height: size
        }, rootStyle, style2),
        ownerState,
        ref,
        role: "progressbar"
      }, rootProps, other, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressSVG, {
          className: classes.svg,
          ownerState,
          viewBox: `${SIZE / 2} ${SIZE / 2} ${SIZE} ${SIZE}`,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressCircle, {
            className: classes.circle,
            style: circleStyle,
            ownerState,
            cx: SIZE,
            cy: SIZE,
            r: (SIZE - thickness) / 2,
            fill: "none",
            strokeWidth: thickness
          })
        })
      }));
    });
    const CircularProgress$1 = CircularProgress;
    const Venues = () => {
      const currentUrl = window.location.href;
      const urlParams = new URLSearchParams(currentUrl);
      const [param, setParam] = reactExports.useState({
        start_date: urlParams.get("start_date"),
        venue_type: urlParams.get("venue_type"),
        end_date: urlParams.get("end_date")
      });
      const [sideBarOpen, setSideBarOpen] = reactExports.useState();
      const [venue, setVenue] = reactExports.useState([]);
      const [loading, setLoading] = reactExports.useState(true);
      reactExports.useEffect(() => {
        const handleResize = () => {
          const windowSize = window.innerWidth;
          if (windowSize < 880) {
            setSideBarOpen(false);
          } else {
            setSideBarOpen(true);
          }
        };
        handleResize();
        window.addEventListener("resize", handleResize);
        return () => {
          window.removeEventListener("resize", handleResize);
        };
      }, []);
      reactExports.useEffect(() => {
        setLoading(true);
        const getVenues = async () => {
          let queryParam = `?check=abc&start_date=${param.start_date}&end_date=${param.end_date}&venue_type=${param.venue_type}`;
          try {
            const res = await instance.get(`/customer/venues${queryParam}`);
            console.log(res.data);
            if (res.status === 200) {
              setVenue(res.data);
            }
            setLoading(false);
          } catch (err) {
            console.log(err);
            setLoading(false);
          }
        };
        getVenues();
      }, [param.start_date, param.venue_type, param.end_date]);
      if (sideBarOpen == null) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Loading..." });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { id: "events", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "event-search", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SearchEventCard,
          {
            open: sideBarOpen,
            setOpen: setSideBarOpen,
            setParam,
            useSearch: {
              venue_type: param.venue_type,
              start_date: param.start_date,
              end_date: param.end_date
            }
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "section-title", children: "Search Criteria" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "section-container", children: [
            sideBarOpen && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "back-drop" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "side-bar", children: sideBarOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(FilterSideBar, { setOpen: setSideBarOpen }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "venue-card-section", children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                style: {
                  display: "flex",
                  justifyContent: "center",
                  alignItems: "center",
                  height: "100%",
                  maxHeight: "100px"
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress$1, { color: "inherit" })
              }
            ) : (venue == null ? void 0 : venue.length) > 0 ? venue.map((venue2, index) => {
              return /* @__PURE__ */ jsxRuntimeExports.jsx(VenueCard, { venue: venue2, param }, index);
            }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "card",
                style: {
                  height: "100%",
                  maxHeight: "100px",
                  boxShadow: "1px 4px 21.100000381469727px 0px #C2C2C240"
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card-body text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-center", children: "Not Venue Found" }) })
              }
            ) })
          ] })
        ] })
      ] });
    };
    function useMediaQueryOld(query, defaultMatches, matchMedia, ssrMatchMedia, noSsr) {
      const [match2, setMatch] = reactExports.useState(() => {
        if (noSsr && matchMedia) {
          return matchMedia(query).matches;
        }
        if (ssrMatchMedia) {
          return ssrMatchMedia(query).matches;
        }
        return defaultMatches;
      });
      useEnhancedEffect(() => {
        let active = true;
        if (!matchMedia) {
          return void 0;
        }
        const queryList = matchMedia(query);
        const updateMatch = () => {
          if (active) {
            setMatch(queryList.matches);
          }
        };
        updateMatch();
        queryList.addListener(updateMatch);
        return () => {
          active = false;
          queryList.removeListener(updateMatch);
        };
      }, [query, matchMedia]);
      return match2;
    }
    const maybeReactUseSyncExternalStore = reactExports.useSyncExternalStore;
    function useMediaQueryNew(query, defaultMatches, matchMedia, ssrMatchMedia, noSsr) {
      const getDefaultSnapshot = reactExports.useCallback(() => defaultMatches, [defaultMatches]);
      const getServerSnapshot = reactExports.useMemo(() => {
        if (noSsr && matchMedia) {
          return () => matchMedia(query).matches;
        }
        if (ssrMatchMedia !== null) {
          const {
            matches
          } = ssrMatchMedia(query);
          return () => matches;
        }
        return getDefaultSnapshot;
      }, [getDefaultSnapshot, query, ssrMatchMedia, noSsr, matchMedia]);
      const [getSnapshot, subscribe] = reactExports.useMemo(() => {
        if (matchMedia === null) {
          return [getDefaultSnapshot, () => () => {
          }];
        }
        const mediaQueryList = matchMedia(query);
        return [() => mediaQueryList.matches, (notify) => {
          mediaQueryList.addListener(notify);
          return () => {
            mediaQueryList.removeListener(notify);
          };
        }];
      }, [getDefaultSnapshot, matchMedia, query]);
      const match2 = maybeReactUseSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      return match2;
    }
    function useMediaQuery(queryInput, options = {}) {
      const theme = useTheme$2();
      const supportMatchMedia = typeof window !== "undefined" && typeof window.matchMedia !== "undefined";
      const {
        defaultMatches = false,
        matchMedia = supportMatchMedia ? window.matchMedia : null,
        ssrMatchMedia = null,
        noSsr = false
      } = getThemeProps({
        name: "MuiUseMediaQuery",
        props: options,
        theme
      });
      let query = typeof queryInput === "function" ? queryInput(theme) : queryInput;
      query = query.replace(/^@media( ?)/m, "");
      const useMediaQueryImplementation = maybeReactUseSyncExternalStore !== void 0 ? useMediaQueryNew : useMediaQueryOld;
      const match2 = useMediaQueryImplementation(query, defaultMatches, matchMedia, ssrMatchMedia, noSsr);
      return match2;
    }
    const areViewsEqual = (views, expectedViews) => {
      if (views.length !== expectedViews.length) {
        return false;
      }
      return expectedViews.every((expectedView) => views.includes(expectedView));
    };
    const applyDefaultViewProps = ({
      openTo,
      defaultOpenTo,
      views,
      defaultViews
    }) => {
      const viewsWithDefault = views != null ? views : defaultViews;
      let openToWithDefault;
      if (openTo != null) {
        openToWithDefault = openTo;
      } else if (viewsWithDefault.includes(defaultOpenTo)) {
        openToWithDefault = defaultOpenTo;
      } else if (viewsWithDefault.length > 0) {
        openToWithDefault = viewsWithDefault[0];
      } else {
        throw new Error("MUI: The `views` prop must contain at least one view");
      }
      return {
        views: viewsWithDefault,
        openTo: openToWithDefault
      };
    };
    const replaceInvalidDateByNull = (utils2, value) => value == null || !utils2.isValid(value) ? null : value;
    const areDatesEqual = (utils2, a, b2) => {
      if (!utils2.isValid(a) && a != null && !utils2.isValid(b2) && b2 != null) {
        return true;
      }
      return utils2.isEqual(a, b2);
    };
    const getMonthsInYear = (utils2, year) => {
      const firstMonth = utils2.startOfYear(year);
      const months = [firstMonth];
      while (months.length < 12) {
        const prevMonth = months[months.length - 1];
        months.push(utils2.addMonths(prevMonth, 1));
      }
      return months;
    };
    const mergeDateAndTime = (utils2, dateParam, timeParam) => {
      let mergedDate = dateParam;
      mergedDate = utils2.setHours(mergedDate, utils2.getHours(timeParam));
      mergedDate = utils2.setMinutes(mergedDate, utils2.getMinutes(timeParam));
      mergedDate = utils2.setSeconds(mergedDate, utils2.getSeconds(timeParam));
      return mergedDate;
    };
    const getTodayDate = (utils2, timezone, valueType) => valueType === "date" ? utils2.startOfDay(utils2.dateWithTimezone(void 0, timezone)) : utils2.dateWithTimezone(void 0, timezone);
    const formatMeridiem = (utils2, meridiem) => {
      const date2 = utils2.setHours(utils2.date(), meridiem === "am" ? 2 : 14);
      return utils2.format(date2, "meridiem");
    };
    const timeViews = ["hours", "minutes", "seconds"];
    const isTimeView = (view) => timeViews.includes(view);
    const isInternalTimeView = (view) => timeViews.includes(view) || view === "meridiem";
    const getMeridiem = (date2, utils2) => {
      if (!date2) {
        return null;
      }
      return utils2.getHours(date2) >= 12 ? "pm" : "am";
    };
    const convertValueToMeridiem = (value, meridiem, ampm) => {
      if (ampm) {
        const currentMeridiem = value >= 12 ? "pm" : "am";
        if (currentMeridiem !== meridiem) {
          return meridiem === "am" ? value - 12 : value + 12;
        }
      }
      return value;
    };
    const convertToMeridiem = (time2, meridiem, ampm, utils2) => {
      const newHoursAmount = convertValueToMeridiem(utils2.getHours(time2), meridiem, ampm);
      return utils2.setHours(time2, newHoursAmount);
    };
    const getSecondsInDay = (date2, utils2) => {
      return utils2.getHours(date2) * 3600 + utils2.getMinutes(date2) * 60 + utils2.getSeconds(date2);
    };
    const createIsAfterIgnoreDatePart = (disableIgnoringDatePartForTimeValidation, utils2) => (dateLeft, dateRight) => {
      if (disableIgnoringDatePartForTimeValidation) {
        return utils2.isAfter(dateLeft, dateRight);
      }
      return getSecondsInDay(dateLeft, utils2) > getSecondsInDay(dateRight, utils2);
    };
    const resolveTimeFormat = (utils2, {
      format,
      views,
      ampm
    }) => {
      if (format != null) {
        return format;
      }
      const formats = utils2.formats;
      if (areViewsEqual(views, ["hours"])) {
        return ampm ? `${formats.hours12h} ${formats.meridiem}` : formats.hours24h;
      }
      if (areViewsEqual(views, ["minutes"])) {
        return formats.minutes;
      }
      if (areViewsEqual(views, ["seconds"])) {
        return formats.seconds;
      }
      if (areViewsEqual(views, ["minutes", "seconds"])) {
        return `${formats.minutes}:${formats.seconds}`;
      }
      if (areViewsEqual(views, ["hours", "minutes", "seconds"])) {
        return ampm ? `${formats.hours12h}:${formats.minutes}:${formats.seconds} ${formats.meridiem}` : `${formats.hours24h}:${formats.minutes}:${formats.seconds}`;
      }
      return ampm ? `${formats.hours12h}:${formats.minutes} ${formats.meridiem}` : `${formats.hours24h}:${formats.minutes}`;
    };
    const SECTION_TYPE_GRANULARITY = {
      year: 1,
      month: 2,
      day: 3,
      hours: 4,
      minutes: 5,
      seconds: 6,
      milliseconds: 7
    };
    const getSectionTypeGranularity = (sections) => Math.max(...sections.map((section) => {
      var _SECTION_TYPE_GRANULA;
      return (_SECTION_TYPE_GRANULA = SECTION_TYPE_GRANULARITY[section.type]) != null ? _SECTION_TYPE_GRANULA : 1;
    }));
    const roundDate = (utils2, granularity, date2) => {
      if (granularity === SECTION_TYPE_GRANULARITY.year) {
        return utils2.startOfYear(date2);
      }
      if (granularity === SECTION_TYPE_GRANULARITY.month) {
        return utils2.startOfMonth(date2);
      }
      if (granularity === SECTION_TYPE_GRANULARITY.day) {
        return utils2.startOfDay(date2);
      }
      let roundedDate = date2;
      if (granularity < SECTION_TYPE_GRANULARITY.minutes) {
        roundedDate = utils2.setMinutes(roundedDate, 0);
      }
      if (granularity < SECTION_TYPE_GRANULARITY.seconds) {
        roundedDate = utils2.setSeconds(roundedDate, 0);
      }
      if (granularity < SECTION_TYPE_GRANULARITY.milliseconds) {
        roundedDate = utils2.setMilliseconds(roundedDate, 0);
      }
      return roundedDate;
    };
    const getDefaultReferenceDate = ({
      props,
      utils: utils2,
      granularity,
      timezone,
      getTodayDate: inGetTodayDate
    }) => {
      var _props$disableIgnorin;
      let referenceDate = inGetTodayDate ? inGetTodayDate() : roundDate(utils2, granularity, getTodayDate(utils2, timezone));
      if (props.minDate != null && utils2.isAfterDay(props.minDate, referenceDate)) {
        referenceDate = roundDate(utils2, granularity, props.minDate);
      }
      if (props.maxDate != null && utils2.isBeforeDay(props.maxDate, referenceDate)) {
        referenceDate = roundDate(utils2, granularity, props.maxDate);
      }
      const isAfter = createIsAfterIgnoreDatePart((_props$disableIgnorin = props.disableIgnoringDatePartForTimeValidation) != null ? _props$disableIgnorin : false, utils2);
      if (props.minTime != null && isAfter(props.minTime, referenceDate)) {
        referenceDate = roundDate(utils2, granularity, props.disableIgnoringDatePartForTimeValidation ? props.minTime : mergeDateAndTime(utils2, referenceDate, props.minTime));
      }
      if (props.maxTime != null && isAfter(referenceDate, props.maxTime)) {
        referenceDate = roundDate(utils2, granularity, props.disableIgnoringDatePartForTimeValidation ? props.maxTime : mergeDateAndTime(utils2, referenceDate, props.maxTime));
      }
      return referenceDate;
    };
    const getDateSectionConfigFromFormatToken = (utils2, formatToken) => {
      const config2 = utils2.formatTokenMap[formatToken];
      if (config2 == null) {
        throw new Error([`MUI: The token "${formatToken}" is not supported by the Date and Time Pickers.`, "Please try using another token or open an issue on https://github.com/mui/mui-x/issues/new/choose if you think it should be supported."].join("\n"));
      }
      if (typeof config2 === "string") {
        return {
          type: config2,
          contentType: config2 === "meridiem" ? "letter" : "digit",
          maxLength: void 0
        };
      }
      return {
        type: config2.sectionType,
        contentType: config2.contentType,
        maxLength: config2.maxLength
      };
    };
    const getDeltaFromKeyCode = (keyCode) => {
      switch (keyCode) {
        case "ArrowUp":
          return 1;
        case "ArrowDown":
          return -1;
        case "PageUp":
          return 5;
        case "PageDown":
          return -5;
        default:
          return 0;
      }
    };
    const getDaysInWeekStr = (utils2, timezone, format) => {
      const elements = [];
      const now2 = utils2.dateWithTimezone(void 0, timezone);
      const startDate = utils2.startOfWeek(now2);
      const endDate = utils2.endOfWeek(now2);
      let current = startDate;
      while (utils2.isBefore(current, endDate)) {
        elements.push(current);
        current = utils2.addDays(current, 1);
      }
      return elements.map((weekDay) => utils2.formatByString(weekDay, format));
    };
    const getLetterEditingOptions = (utils2, timezone, sectionType, format) => {
      switch (sectionType) {
        case "month": {
          return getMonthsInYear(utils2, utils2.dateWithTimezone(void 0, timezone)).map((month) => utils2.formatByString(month, format));
        }
        case "weekDay": {
          return getDaysInWeekStr(utils2, timezone, format);
        }
        case "meridiem": {
          const now2 = utils2.dateWithTimezone(void 0, timezone);
          return [utils2.startOfDay(now2), utils2.endOfDay(now2)].map((date2) => utils2.formatByString(date2, format));
        }
        default: {
          return [];
        }
      }
    };
    const cleanLeadingZeros = (utils2, valueStr, size) => {
      let cleanValueStr = valueStr;
      cleanValueStr = Number(cleanValueStr).toString();
      while (cleanValueStr.length < size) {
        cleanValueStr = `0${cleanValueStr}`;
      }
      return cleanValueStr;
    };
    const cleanDigitSectionValue = (utils2, timezone, value, sectionBoundaries, section) => {
      if (section.type === "day" && section.contentType === "digit-with-letter") {
        const date2 = utils2.setDate(sectionBoundaries.longestMonth, value);
        return utils2.formatByString(date2, section.format);
      }
      const valueStr = value.toString();
      if (section.hasLeadingZerosInInput) {
        return cleanLeadingZeros(utils2, valueStr, section.maxLength);
      }
      return valueStr;
    };
    const adjustSectionValue = (utils2, timezone, section, keyCode, sectionsValueBoundaries, activeDate, stepsAttributes) => {
      const delta = getDeltaFromKeyCode(keyCode);
      const isStart = keyCode === "Home";
      const isEnd = keyCode === "End";
      const shouldSetAbsolute = section.value === "" || isStart || isEnd;
      const adjustDigitSection = () => {
        const sectionBoundaries = sectionsValueBoundaries[section.type]({
          currentDate: activeDate,
          format: section.format,
          contentType: section.contentType
        });
        const getCleanValue = (value) => cleanDigitSectionValue(utils2, timezone, value, sectionBoundaries, section);
        const step = section.type === "minutes" && stepsAttributes != null && stepsAttributes.minutesStep ? stepsAttributes.minutesStep : 1;
        const currentSectionValue = parseInt(section.value, 10);
        let newSectionValueNumber = currentSectionValue + delta * step;
        if (shouldSetAbsolute) {
          if (section.type === "year" && !isEnd && !isStart) {
            return utils2.formatByString(utils2.dateWithTimezone(void 0, timezone), section.format);
          }
          if (delta > 0 || isStart) {
            newSectionValueNumber = sectionBoundaries.minimum;
          } else {
            newSectionValueNumber = sectionBoundaries.maximum;
          }
        }
        if (newSectionValueNumber % step !== 0) {
          if (delta < 0 || isStart) {
            newSectionValueNumber += step - (step + newSectionValueNumber) % step;
          }
          if (delta > 0 || isEnd) {
            newSectionValueNumber -= newSectionValueNumber % step;
          }
        }
        if (newSectionValueNumber > sectionBoundaries.maximum) {
          return getCleanValue(sectionBoundaries.minimum + (newSectionValueNumber - sectionBoundaries.maximum - 1) % (sectionBoundaries.maximum - sectionBoundaries.minimum + 1));
        }
        if (newSectionValueNumber < sectionBoundaries.minimum) {
          return getCleanValue(sectionBoundaries.maximum - (sectionBoundaries.minimum - newSectionValueNumber - 1) % (sectionBoundaries.maximum - sectionBoundaries.minimum + 1));
        }
        return getCleanValue(newSectionValueNumber);
      };
      const adjustLetterSection = () => {
        const options = getLetterEditingOptions(utils2, timezone, section.type, section.format);
        if (options.length === 0) {
          return section.value;
        }
        if (shouldSetAbsolute) {
          if (delta > 0 || isStart) {
            return options[0];
          }
          return options[options.length - 1];
        }
        const currentOptionIndex = options.indexOf(section.value);
        const newOptionIndex = (currentOptionIndex + options.length + delta) % options.length;
        return options[newOptionIndex];
      };
      if (section.contentType === "digit" || section.contentType === "digit-with-letter") {
        return adjustDigitSection();
      }
      return adjustLetterSection();
    };
    const getSectionVisibleValue = (section, target) => {
      let value = section.value || section.placeholder;
      const hasLeadingZeros = target === "non-input" ? section.hasLeadingZerosInFormat : section.hasLeadingZerosInInput;
      if (target === "non-input" && section.hasLeadingZerosInInput && !section.hasLeadingZerosInFormat) {
        value = Number(value).toString();
      }
      const shouldAddInvisibleSpace = ["input-rtl", "input-ltr"].includes(target) && section.contentType === "digit" && !hasLeadingZeros && value.length === 1;
      if (shouldAddInvisibleSpace) {
        value = `${value}‎`;
      }
      if (target === "input-rtl") {
        value = `⁨${value}⁩`;
      }
      return value;
    };
    const cleanString = (dirtyString) => dirtyString.replace(/[\u2066\u2067\u2068\u2069]/g, "");
    const addPositionPropertiesToSections = (sections, isRTL) => {
      let position2 = 0;
      let positionInInput = isRTL ? 1 : 0;
      const newSections = [];
      for (let i = 0; i < sections.length; i += 1) {
        const section = sections[i];
        const renderedValue = getSectionVisibleValue(section, isRTL ? "input-rtl" : "input-ltr");
        const sectionStr = `${section.startSeparator}${renderedValue}${section.endSeparator}`;
        const sectionLength = cleanString(sectionStr).length;
        const sectionLengthInInput = sectionStr.length;
        const cleanedValue = cleanString(renderedValue);
        const startInInput = positionInInput + renderedValue.indexOf(cleanedValue[0]) + section.startSeparator.length;
        const endInInput = startInInput + cleanedValue.length;
        newSections.push(_extends$1({}, section, {
          start: position2,
          end: position2 + sectionLength,
          startInInput,
          endInInput
        }));
        position2 += sectionLength;
        positionInInput += sectionLengthInInput;
      }
      return newSections;
    };
    const getSectionPlaceholder = (utils2, timezone, localeText, sectionConfig, sectionFormat) => {
      switch (sectionConfig.type) {
        case "year": {
          return localeText.fieldYearPlaceholder({
            digitAmount: utils2.formatByString(utils2.dateWithTimezone(void 0, timezone), sectionFormat).length,
            format: sectionFormat
          });
        }
        case "month": {
          return localeText.fieldMonthPlaceholder({
            contentType: sectionConfig.contentType,
            format: sectionFormat
          });
        }
        case "day": {
          return localeText.fieldDayPlaceholder({
            format: sectionFormat
          });
        }
        case "weekDay": {
          return localeText.fieldWeekDayPlaceholder({
            contentType: sectionConfig.contentType,
            format: sectionFormat
          });
        }
        case "hours": {
          return localeText.fieldHoursPlaceholder({
            format: sectionFormat
          });
        }
        case "minutes": {
          return localeText.fieldMinutesPlaceholder({
            format: sectionFormat
          });
        }
        case "seconds": {
          return localeText.fieldSecondsPlaceholder({
            format: sectionFormat
          });
        }
        case "meridiem": {
          return localeText.fieldMeridiemPlaceholder({
            format: sectionFormat
          });
        }
        default: {
          return sectionFormat;
        }
      }
    };
    const changeSectionValueFormat = (utils2, valueStr, currentFormat, newFormat) => {
      return utils2.formatByString(utils2.parse(valueStr, currentFormat), newFormat);
    };
    const isFourDigitYearFormat = (utils2, timezone, format) => utils2.formatByString(utils2.dateWithTimezone(void 0, timezone), format).length === 4;
    const doesSectionFormatHaveLeadingZeros = (utils2, timezone, contentType, sectionType, format) => {
      if (contentType !== "digit") {
        return false;
      }
      const now2 = utils2.dateWithTimezone(void 0, timezone);
      switch (sectionType) {
        case "year": {
          if (isFourDigitYearFormat(utils2, timezone, format)) {
            const formatted0001 = utils2.formatByString(utils2.setYear(now2, 1), format);
            return formatted0001 === "0001";
          }
          const formatted2001 = utils2.formatByString(utils2.setYear(now2, 2001), format);
          return formatted2001 === "01";
        }
        case "month": {
          return utils2.formatByString(utils2.startOfYear(now2), format).length > 1;
        }
        case "day": {
          return utils2.formatByString(utils2.startOfMonth(now2), format).length > 1;
        }
        case "weekDay": {
          return utils2.formatByString(utils2.startOfWeek(now2), format).length > 1;
        }
        case "hours": {
          return utils2.formatByString(utils2.setHours(now2, 1), format).length > 1;
        }
        case "minutes": {
          return utils2.formatByString(utils2.setMinutes(now2, 1), format).length > 1;
        }
        case "seconds": {
          return utils2.formatByString(utils2.setSeconds(now2, 1), format).length > 1;
        }
        default: {
          throw new Error("Invalid section type");
        }
      }
    };
    const getEscapedPartsFromFormat = (utils2, format) => {
      const escapedParts = [];
      const {
        start: startChar,
        end: endChar
      } = utils2.escapedCharacters;
      const regExp = new RegExp(`(\\${startChar}[^\\${endChar}]*\\${endChar})+`, "g");
      let match2 = null;
      while (match2 = regExp.exec(format)) {
        escapedParts.push({
          start: match2.index,
          end: regExp.lastIndex - 1
        });
      }
      return escapedParts;
    };
    const splitFormatIntoSections = (utils2, timezone, localeText, format, date2, formatDensity, shouldRespectLeadingZeros, isRTL) => {
      let startSeparator = "";
      const sections = [];
      const now2 = utils2.date();
      const commitToken = (token2) => {
        if (token2 === "") {
          return null;
        }
        const sectionConfig = getDateSectionConfigFromFormatToken(utils2, token2);
        const hasLeadingZerosInFormat = doesSectionFormatHaveLeadingZeros(utils2, timezone, sectionConfig.contentType, sectionConfig.type, token2);
        const hasLeadingZerosInInput = shouldRespectLeadingZeros ? hasLeadingZerosInFormat : sectionConfig.contentType === "digit";
        const isValidDate = date2 != null && utils2.isValid(date2);
        let sectionValue = isValidDate ? utils2.formatByString(date2, token2) : "";
        let maxLength = null;
        if (hasLeadingZerosInInput) {
          if (hasLeadingZerosInFormat) {
            maxLength = sectionValue === "" ? utils2.formatByString(now2, token2).length : sectionValue.length;
          } else {
            if (sectionConfig.maxLength == null) {
              throw new Error(`MUI: The token ${token2} should have a 'maxDigitNumber' property on it's adapter`);
            }
            maxLength = sectionConfig.maxLength;
            if (isValidDate) {
              sectionValue = cleanLeadingZeros(utils2, sectionValue, maxLength);
            }
          }
        }
        sections.push(_extends$1({}, sectionConfig, {
          format: token2,
          maxLength,
          value: sectionValue,
          placeholder: getSectionPlaceholder(utils2, timezone, localeText, sectionConfig, token2),
          hasLeadingZeros: hasLeadingZerosInFormat,
          hasLeadingZerosInFormat,
          hasLeadingZerosInInput,
          startSeparator: sections.length === 0 ? startSeparator : "",
          endSeparator: "",
          modified: false
        }));
        return null;
      };
      let formatExpansionOverflow = 10;
      let prevFormat = format;
      let nextFormat = utils2.expandFormat(format);
      while (nextFormat !== prevFormat) {
        prevFormat = nextFormat;
        nextFormat = utils2.expandFormat(prevFormat);
        formatExpansionOverflow -= 1;
        if (formatExpansionOverflow < 0) {
          throw new Error("MUI: The format expansion seems to be  enter in an infinite loop. Please open an issue with the format passed to the picker component");
        }
      }
      const expandedFormat = nextFormat;
      const escapedParts = getEscapedPartsFromFormat(utils2, expandedFormat);
      const isTokenStartRegExp = new RegExp(`^(${Object.keys(utils2.formatTokenMap).sort((a, b2) => b2.length - a.length).join("|")})`, "g");
      let currentTokenValue = "";
      for (let i = 0; i < expandedFormat.length; i += 1) {
        const escapedPartOfCurrentChar = escapedParts.find((escapeIndex) => escapeIndex.start <= i && escapeIndex.end >= i);
        const char2 = expandedFormat[i];
        const isEscapedChar = escapedPartOfCurrentChar != null;
        const potentialToken = `${currentTokenValue}${expandedFormat.slice(i)}`;
        const regExpMatch = isTokenStartRegExp.test(potentialToken);
        if (!isEscapedChar && char2.match(/([A-Za-z]+)/) && regExpMatch) {
          currentTokenValue = potentialToken.slice(0, isTokenStartRegExp.lastIndex);
          i += isTokenStartRegExp.lastIndex - 1;
        } else {
          const isEscapeBoundary = isEscapedChar && (escapedPartOfCurrentChar == null ? void 0 : escapedPartOfCurrentChar.start) === i || (escapedPartOfCurrentChar == null ? void 0 : escapedPartOfCurrentChar.end) === i;
          if (!isEscapeBoundary) {
            commitToken(currentTokenValue);
            currentTokenValue = "";
            if (sections.length === 0) {
              startSeparator += char2;
            } else {
              sections[sections.length - 1].endSeparator += char2;
            }
          }
        }
      }
      commitToken(currentTokenValue);
      return sections.map((section) => {
        const cleanSeparator = (separator) => {
          let cleanedSeparator = separator;
          if (isRTL && cleanedSeparator !== null && cleanedSeparator.includes(" ")) {
            cleanedSeparator = `⁩${cleanedSeparator}⁦`;
          }
          if (formatDensity === "spacious" && ["/", ".", "-"].includes(cleanedSeparator)) {
            cleanedSeparator = ` ${cleanedSeparator} `;
          }
          return cleanedSeparator;
        };
        section.startSeparator = cleanSeparator(section.startSeparator);
        section.endSeparator = cleanSeparator(section.endSeparator);
        return section;
      });
    };
    const getDateFromDateSections = (utils2, sections) => {
      const shouldSkipWeekDays = sections.some((section) => section.type === "day");
      const sectionFormats = [];
      const sectionValues = [];
      for (let i = 0; i < sections.length; i += 1) {
        const section = sections[i];
        const shouldSkip = shouldSkipWeekDays && section.type === "weekDay";
        if (!shouldSkip) {
          sectionFormats.push(section.format);
          sectionValues.push(getSectionVisibleValue(section, "non-input"));
        }
      }
      const formatWithoutSeparator = sectionFormats.join(" ");
      const dateWithoutSeparatorStr = sectionValues.join(" ");
      return utils2.parse(dateWithoutSeparatorStr, formatWithoutSeparator);
    };
    const createDateStrForInputFromSections = (sections, isRTL) => {
      const formattedSections = sections.map((section) => {
        const dateValue = getSectionVisibleValue(section, isRTL ? "input-rtl" : "input-ltr");
        return `${section.startSeparator}${dateValue}${section.endSeparator}`;
      });
      const dateStr = formattedSections.join("");
      if (!isRTL) {
        return dateStr;
      }
      return `⁦${dateStr}⁩`;
    };
    const getSectionsBoundaries = (utils2, timezone) => {
      const today = utils2.dateWithTimezone(void 0, timezone);
      const endOfYear = utils2.endOfYear(today);
      const endOfDay = utils2.endOfDay(today);
      const {
        maxDaysInMonth,
        longestMonth
      } = getMonthsInYear(utils2, today).reduce((acc, month) => {
        const daysInMonth = utils2.getDaysInMonth(month);
        if (daysInMonth > acc.maxDaysInMonth) {
          return {
            maxDaysInMonth: daysInMonth,
            longestMonth: month
          };
        }
        return acc;
      }, {
        maxDaysInMonth: 0,
        longestMonth: null
      });
      return {
        year: ({
          format
        }) => ({
          minimum: 0,
          maximum: isFourDigitYearFormat(utils2, timezone, format) ? 9999 : 99
        }),
        month: () => ({
          minimum: 1,
          // Assumption: All years have the same amount of months
          maximum: utils2.getMonth(endOfYear) + 1
        }),
        day: ({
          currentDate
        }) => ({
          minimum: 1,
          maximum: currentDate != null && utils2.isValid(currentDate) ? utils2.getDaysInMonth(currentDate) : maxDaysInMonth,
          longestMonth
        }),
        weekDay: ({
          format,
          contentType
        }) => {
          if (contentType === "digit") {
            const daysInWeek = getDaysInWeekStr(utils2, timezone, format).map(Number);
            return {
              minimum: Math.min(...daysInWeek),
              maximum: Math.max(...daysInWeek)
            };
          }
          return {
            minimum: 1,
            maximum: 7
          };
        },
        hours: ({
          format
        }) => {
          const lastHourInDay = utils2.getHours(endOfDay);
          const hasMeridiem = utils2.formatByString(utils2.endOfDay(today), format) !== lastHourInDay.toString();
          if (hasMeridiem) {
            return {
              minimum: 1,
              maximum: Number(utils2.formatByString(utils2.startOfDay(today), format))
            };
          }
          return {
            minimum: 0,
            maximum: lastHourInDay
          };
        },
        minutes: () => ({
          minimum: 0,
          // Assumption: All years have the same amount of minutes
          maximum: utils2.getMinutes(endOfDay)
        }),
        seconds: () => ({
          minimum: 0,
          // Assumption: All years have the same amount of seconds
          maximum: utils2.getSeconds(endOfDay)
        }),
        meridiem: () => ({
          minimum: 0,
          maximum: 0
        })
      };
    };
    const transferDateSectionValue = (utils2, timezone, section, dateToTransferFrom, dateToTransferTo) => {
      switch (section.type) {
        case "year": {
          return utils2.setYear(dateToTransferTo, utils2.getYear(dateToTransferFrom));
        }
        case "month": {
          return utils2.setMonth(dateToTransferTo, utils2.getMonth(dateToTransferFrom));
        }
        case "weekDay": {
          const formattedDaysInWeek = getDaysInWeekStr(utils2, timezone, section.format);
          const dayInWeekStrOfActiveDate = utils2.formatByString(dateToTransferFrom, section.format);
          const dayInWeekOfActiveDate = formattedDaysInWeek.indexOf(dayInWeekStrOfActiveDate);
          const dayInWeekOfNewSectionValue = formattedDaysInWeek.indexOf(section.value);
          const diff = dayInWeekOfNewSectionValue - dayInWeekOfActiveDate;
          return utils2.addDays(dateToTransferFrom, diff);
        }
        case "day": {
          return utils2.setDate(dateToTransferTo, utils2.getDate(dateToTransferFrom));
        }
        case "meridiem": {
          const isAM = utils2.getHours(dateToTransferFrom) < 12;
          const mergedDateHours = utils2.getHours(dateToTransferTo);
          if (isAM && mergedDateHours >= 12) {
            return utils2.addHours(dateToTransferTo, -12);
          }
          if (!isAM && mergedDateHours < 12) {
            return utils2.addHours(dateToTransferTo, 12);
          }
          return dateToTransferTo;
        }
        case "hours": {
          return utils2.setHours(dateToTransferTo, utils2.getHours(dateToTransferFrom));
        }
        case "minutes": {
          return utils2.setMinutes(dateToTransferTo, utils2.getMinutes(dateToTransferFrom));
        }
        case "seconds": {
          return utils2.setSeconds(dateToTransferTo, utils2.getSeconds(dateToTransferFrom));
        }
        default: {
          return dateToTransferTo;
        }
      }
    };
    const reliableSectionModificationOrder = {
      year: 1,
      month: 2,
      day: 3,
      weekDay: 4,
      hours: 5,
      minutes: 6,
      seconds: 7,
      meridiem: 8
    };
    const mergeDateIntoReferenceDate = (utils2, timezone, dateToTransferFrom, sections, referenceDate, shouldLimitToEditedSections) => (
      // cloning sections before sort to avoid mutating it
      [...sections].sort((a, b2) => reliableSectionModificationOrder[a.type] - reliableSectionModificationOrder[b2.type]).reduce((mergedDate, section) => {
        if (!shouldLimitToEditedSections || section.modified) {
          return transferDateSectionValue(utils2, timezone, section, dateToTransferFrom, mergedDate);
        }
        return mergedDate;
      }, referenceDate)
    );
    const isAndroid = () => navigator.userAgent.toLowerCase().indexOf("android") > -1;
    const getSectionOrder = (sections, isRTL) => {
      const neighbors = {};
      if (!isRTL) {
        sections.forEach((_2, index) => {
          const leftIndex = index === 0 ? null : index - 1;
          const rightIndex = index === sections.length - 1 ? null : index + 1;
          neighbors[index] = {
            leftIndex,
            rightIndex
          };
        });
        return {
          neighbors,
          startIndex: 0,
          endIndex: sections.length - 1
        };
      }
      const rtl2ltr = {};
      const ltr2rtl = {};
      let groupedSectionsStart = 0;
      let groupedSectionsEnd = 0;
      let RTLIndex = sections.length - 1;
      while (RTLIndex >= 0) {
        groupedSectionsEnd = sections.findIndex(
          // eslint-disable-next-line @typescript-eslint/no-loop-func
          (section, index) => {
            var _section$endSeparator;
            return index >= groupedSectionsStart && ((_section$endSeparator = section.endSeparator) == null ? void 0 : _section$endSeparator.includes(" ")) && // Special case where the spaces were not there in the initial input
            section.endSeparator !== " / ";
          }
        );
        if (groupedSectionsEnd === -1) {
          groupedSectionsEnd = sections.length - 1;
        }
        for (let i = groupedSectionsEnd; i >= groupedSectionsStart; i -= 1) {
          ltr2rtl[i] = RTLIndex;
          rtl2ltr[RTLIndex] = i;
          RTLIndex -= 1;
        }
        groupedSectionsStart = groupedSectionsEnd + 1;
      }
      sections.forEach((_2, index) => {
        const rtlIndex = ltr2rtl[index];
        const leftIndex = rtlIndex === 0 ? null : rtl2ltr[rtlIndex - 1];
        const rightIndex = rtlIndex === sections.length - 1 ? null : rtl2ltr[rtlIndex + 1];
        neighbors[index] = {
          leftIndex,
          rightIndex
        };
      });
      return {
        neighbors,
        startIndex: rtl2ltr[0],
        endIndex: rtl2ltr[sections.length - 1]
      };
    };
    const _excluded$I = ["value", "referenceDate"];
    const singleItemValueManager = {
      emptyValue: null,
      getTodayValue: getTodayDate,
      getInitialReferenceValue: (_ref) => {
        let {
          value,
          referenceDate
        } = _ref, params = _objectWithoutPropertiesLoose$1(_ref, _excluded$I);
        if (value != null && params.utils.isValid(value)) {
          return value;
        }
        if (referenceDate != null) {
          return referenceDate;
        }
        return getDefaultReferenceDate(params);
      },
      cleanValue: replaceInvalidDateByNull,
      areValuesEqual: areDatesEqual,
      isSameError: (a, b2) => a === b2,
      hasError: (error) => error != null,
      defaultErrorState: null,
      getTimezone: (utils2, value) => value == null || !utils2.isValid(value) ? null : utils2.getTimezone(value),
      setTimezone: (utils2, timezone, value) => value == null ? null : utils2.setTimezone(value, timezone)
    };
    const singleItemFieldValueManager = {
      updateReferenceValue: (utils2, value, prevReferenceValue) => value == null || !utils2.isValid(value) ? prevReferenceValue : value,
      getSectionsFromValue: (utils2, date2, prevSections, isRTL, getSectionsFromDate) => {
        const shouldReUsePrevDateSections = !utils2.isValid(date2) && !!prevSections;
        if (shouldReUsePrevDateSections) {
          return prevSections;
        }
        return addPositionPropertiesToSections(getSectionsFromDate(date2), isRTL);
      },
      getValueStrFromSections: createDateStrForInputFromSections,
      getActiveDateManager: (utils2, state) => ({
        date: state.value,
        referenceDate: state.referenceValue,
        getSections: (sections) => sections,
        getNewValuesFromNewActiveDate: (newActiveDate) => ({
          value: newActiveDate,
          referenceValue: newActiveDate == null || !utils2.isValid(newActiveDate) ? state.referenceValue : newActiveDate
        })
      }),
      parseValueStr: (valueStr, referenceValue, parseDate) => parseDate(valueStr.trim(), referenceValue)
    };
    function formControlState({
      props,
      states,
      muiFormControl
    }) {
      return states.reduce((acc, state) => {
        acc[state] = props[state];
        if (muiFormControl) {
          if (typeof props[state] === "undefined") {
            acc[state] = muiFormControl[state];
          }
        }
        return acc;
      }, {});
    }
    const FormControlContext = /* @__PURE__ */ reactExports.createContext(void 0);
    const FormControlContext$1 = FormControlContext;
    function useFormControl() {
      return reactExports.useContext(FormControlContext$1);
    }
    function GlobalStyles(props) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$1, _extends$1({}, props, {
        defaultTheme: defaultTheme$2,
        themeId: THEME_ID
      }));
    }
    function hasValue(value) {
      return value != null && !(Array.isArray(value) && value.length === 0);
    }
    function isFilled(obj, SSR = false) {
      return obj && (hasValue(obj.value) && obj.value !== "" || SSR && hasValue(obj.defaultValue) && obj.defaultValue !== "");
    }
    function isAdornedStart(obj) {
      return obj.startAdornment;
    }
    function getInputBaseUtilityClass(slot) {
      return generateUtilityClass$1("MuiInputBase", slot);
    }
    const inputBaseClasses = generateUtilityClasses$1("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]);
    const inputBaseClasses$1 = inputBaseClasses;
    const _excluded$H = ["aria-describedby", "autoComplete", "autoFocus", "className", "color", "components", "componentsProps", "defaultValue", "disabled", "disableInjectingGlobalStyles", "endAdornment", "error", "fullWidth", "id", "inputComponent", "inputProps", "inputRef", "margin", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onClick", "onFocus", "onKeyDown", "onKeyUp", "placeholder", "readOnly", "renderSuffix", "rows", "size", "slotProps", "slots", "startAdornment", "type", "value"];
    const rootOverridesResolver = (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.formControl && styles2.formControl, ownerState.startAdornment && styles2.adornedStart, ownerState.endAdornment && styles2.adornedEnd, ownerState.error && styles2.error, ownerState.size === "small" && styles2.sizeSmall, ownerState.multiline && styles2.multiline, ownerState.color && styles2[`color${capitalize(ownerState.color)}`], ownerState.fullWidth && styles2.fullWidth, ownerState.hiddenLabel && styles2.hiddenLabel];
    };
    const inputOverridesResolver = (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.input, ownerState.size === "small" && styles2.inputSizeSmall, ownerState.multiline && styles2.inputMultiline, ownerState.type === "search" && styles2.inputTypeSearch, ownerState.startAdornment && styles2.inputAdornedStart, ownerState.endAdornment && styles2.inputAdornedEnd, ownerState.hiddenLabel && styles2.inputHiddenLabel];
    };
    const useUtilityClasses$y = (ownerState) => {
      const {
        classes,
        color: color2,
        disabled,
        error,
        endAdornment,
        focused,
        formControl,
        fullWidth,
        hiddenLabel,
        multiline,
        readOnly,
        size,
        startAdornment,
        type
      } = ownerState;
      const slots = {
        root: ["root", `color${capitalize(color2)}`, disabled && "disabled", error && "error", fullWidth && "fullWidth", focused && "focused", formControl && "formControl", size && size !== "medium" && `size${capitalize(size)}`, multiline && "multiline", startAdornment && "adornedStart", endAdornment && "adornedEnd", hiddenLabel && "hiddenLabel", readOnly && "readOnly"],
        input: ["input", disabled && "disabled", type === "search" && "inputTypeSearch", multiline && "inputMultiline", size === "small" && "inputSizeSmall", hiddenLabel && "inputHiddenLabel", startAdornment && "inputAdornedStart", endAdornment && "inputAdornedEnd", readOnly && "readOnly"]
      };
      return composeClasses(slots, getInputBaseUtilityClass, classes);
    };
    const InputBaseRoot = styled("div", {
      name: "MuiInputBase",
      slot: "Root",
      overridesResolver: rootOverridesResolver
    })(({
      theme,
      ownerState
    }) => _extends$1({}, theme.typography.body1, {
      color: (theme.vars || theme).palette.text.primary,
      lineHeight: "1.4375em",
      // 23px
      boxSizing: "border-box",
      // Prevent padding issue with fullWidth.
      position: "relative",
      cursor: "text",
      display: "inline-flex",
      alignItems: "center",
      [`&.${inputBaseClasses$1.disabled}`]: {
        color: (theme.vars || theme).palette.text.disabled,
        cursor: "default"
      }
    }, ownerState.multiline && _extends$1({
      padding: "4px 0 5px"
    }, ownerState.size === "small" && {
      paddingTop: 1
    }), ownerState.fullWidth && {
      width: "100%"
    }));
    const InputBaseComponent = styled("input", {
      name: "MuiInputBase",
      slot: "Input",
      overridesResolver: inputOverridesResolver
    })(({
      theme,
      ownerState
    }) => {
      const light2 = theme.palette.mode === "light";
      const placeholder = _extends$1({
        color: "currentColor"
      }, theme.vars ? {
        opacity: theme.vars.opacity.inputPlaceholder
      } : {
        opacity: light2 ? 0.42 : 0.5
      }, {
        transition: theme.transitions.create("opacity", {
          duration: theme.transitions.duration.shorter
        })
      });
      const placeholderHidden = {
        opacity: "0 !important"
      };
      const placeholderVisible = theme.vars ? {
        opacity: theme.vars.opacity.inputPlaceholder
      } : {
        opacity: light2 ? 0.42 : 0.5
      };
      return _extends$1({
        font: "inherit",
        letterSpacing: "inherit",
        color: "currentColor",
        padding: "4px 0 5px",
        border: 0,
        boxSizing: "content-box",
        background: "none",
        height: "1.4375em",
        // Reset 23pxthe native input line-height
        margin: 0,
        // Reset for Safari
        WebkitTapHighlightColor: "transparent",
        display: "block",
        // Make the flex item shrink with Firefox
        minWidth: 0,
        width: "100%",
        // Fix IE11 width issue
        animationName: "mui-auto-fill-cancel",
        animationDuration: "10ms",
        "&::-webkit-input-placeholder": placeholder,
        "&::-moz-placeholder": placeholder,
        // Firefox 19+
        "&:-ms-input-placeholder": placeholder,
        // IE11
        "&::-ms-input-placeholder": placeholder,
        // Edge
        "&:focus": {
          outline: 0
        },
        // Reset Firefox invalid required input style
        "&:invalid": {
          boxShadow: "none"
        },
        "&::-webkit-search-decoration": {
          // Remove the padding when type=search.
          WebkitAppearance: "none"
        },
        // Show and hide the placeholder logic
        [`label[data-shrink=false] + .${inputBaseClasses$1.formControl} &`]: {
          "&::-webkit-input-placeholder": placeholderHidden,
          "&::-moz-placeholder": placeholderHidden,
          // Firefox 19+
          "&:-ms-input-placeholder": placeholderHidden,
          // IE11
          "&::-ms-input-placeholder": placeholderHidden,
          // Edge
          "&:focus::-webkit-input-placeholder": placeholderVisible,
          "&:focus::-moz-placeholder": placeholderVisible,
          // Firefox 19+
          "&:focus:-ms-input-placeholder": placeholderVisible,
          // IE11
          "&:focus::-ms-input-placeholder": placeholderVisible
          // Edge
        },
        [`&.${inputBaseClasses$1.disabled}`]: {
          opacity: 1,
          // Reset iOS opacity
          WebkitTextFillColor: (theme.vars || theme).palette.text.disabled
          // Fix opacity Safari bug
        },
        "&:-webkit-autofill": {
          animationDuration: "5000s",
          animationName: "mui-auto-fill"
        }
      }, ownerState.size === "small" && {
        paddingTop: 1
      }, ownerState.multiline && {
        height: "auto",
        resize: "none",
        padding: 0,
        paddingTop: 0
      }, ownerState.type === "search" && {
        // Improve type search style.
        MozAppearance: "textfield"
      });
    });
    const inputGlobalStyles = /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles, {
      styles: {
        "@keyframes mui-auto-fill": {
          from: {
            display: "block"
          }
        },
        "@keyframes mui-auto-fill-cancel": {
          from: {
            display: "block"
          }
        }
      }
    });
    const InputBase = /* @__PURE__ */ reactExports.forwardRef(function InputBase2(inProps, ref) {
      var _slotProps$input;
      const props = useThemeProps({
        props: inProps,
        name: "MuiInputBase"
      });
      const {
        "aria-describedby": ariaDescribedby,
        autoComplete,
        autoFocus,
        className,
        components = {},
        componentsProps = {},
        defaultValue,
        disabled,
        disableInjectingGlobalStyles,
        endAdornment,
        fullWidth = false,
        id: id2,
        inputComponent = "input",
        inputProps: inputPropsProp = {},
        inputRef: inputRefProp,
        maxRows,
        minRows,
        multiline = false,
        name,
        onBlur,
        onChange,
        onClick,
        onFocus,
        onKeyDown,
        onKeyUp,
        placeholder,
        readOnly,
        renderSuffix,
        rows,
        slotProps = {},
        slots = {},
        startAdornment,
        type = "text",
        value: valueProp
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$H);
      const value = inputPropsProp.value != null ? inputPropsProp.value : valueProp;
      const {
        current: isControlled
      } = reactExports.useRef(value != null);
      const inputRef = reactExports.useRef();
      const handleInputRefWarning = reactExports.useCallback((instance2) => {
      }, []);
      const handleInputRef = useForkRef(inputRef, inputRefProp, inputPropsProp.ref, handleInputRefWarning);
      const [focused, setFocused] = reactExports.useState(false);
      const muiFormControl = useFormControl();
      const fcs = formControlState({
        props,
        muiFormControl,
        states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
      });
      fcs.focused = muiFormControl ? muiFormControl.focused : focused;
      reactExports.useEffect(() => {
        if (!muiFormControl && disabled && focused) {
          setFocused(false);
          if (onBlur) {
            onBlur();
          }
        }
      }, [muiFormControl, disabled, focused, onBlur]);
      const onFilled = muiFormControl && muiFormControl.onFilled;
      const onEmpty = muiFormControl && muiFormControl.onEmpty;
      const checkDirty = reactExports.useCallback((obj) => {
        if (isFilled(obj)) {
          if (onFilled) {
            onFilled();
          }
        } else if (onEmpty) {
          onEmpty();
        }
      }, [onFilled, onEmpty]);
      useEnhancedEffect(() => {
        if (isControlled) {
          checkDirty({
            value
          });
        }
      }, [value, checkDirty, isControlled]);
      const handleFocus = (event) => {
        if (fcs.disabled) {
          event.stopPropagation();
          return;
        }
        if (onFocus) {
          onFocus(event);
        }
        if (inputPropsProp.onFocus) {
          inputPropsProp.onFocus(event);
        }
        if (muiFormControl && muiFormControl.onFocus) {
          muiFormControl.onFocus(event);
        } else {
          setFocused(true);
        }
      };
      const handleBlur = (event) => {
        if (onBlur) {
          onBlur(event);
        }
        if (inputPropsProp.onBlur) {
          inputPropsProp.onBlur(event);
        }
        if (muiFormControl && muiFormControl.onBlur) {
          muiFormControl.onBlur(event);
        } else {
          setFocused(false);
        }
      };
      const handleChange = (event, ...args) => {
        if (!isControlled) {
          const element = event.target || inputRef.current;
          if (element == null) {
            throw new Error(formatMuiErrorMessage(1));
          }
          checkDirty({
            value: element.value
          });
        }
        if (inputPropsProp.onChange) {
          inputPropsProp.onChange(event, ...args);
        }
        if (onChange) {
          onChange(event, ...args);
        }
      };
      reactExports.useEffect(() => {
        checkDirty(inputRef.current);
      }, []);
      const handleClick = (event) => {
        if (inputRef.current && event.currentTarget === event.target) {
          inputRef.current.focus();
        }
        if (onClick) {
          onClick(event);
        }
      };
      let InputComponent = inputComponent;
      let inputProps = inputPropsProp;
      if (multiline && InputComponent === "input") {
        if (rows) {
          inputProps = _extends$1({
            type: void 0,
            minRows: rows,
            maxRows: rows
          }, inputProps);
        } else {
          inputProps = _extends$1({
            type: void 0,
            maxRows,
            minRows
          }, inputProps);
        }
        InputComponent = TextareaAutosize;
      }
      const handleAutoFill = (event) => {
        checkDirty(event.animationName === "mui-auto-fill-cancel" ? inputRef.current : {
          value: "x"
        });
      };
      reactExports.useEffect(() => {
        if (muiFormControl) {
          muiFormControl.setAdornedStart(Boolean(startAdornment));
        }
      }, [muiFormControl, startAdornment]);
      const ownerState = _extends$1({}, props, {
        color: fcs.color || "primary",
        disabled: fcs.disabled,
        endAdornment,
        error: fcs.error,
        focused: fcs.focused,
        formControl: muiFormControl,
        fullWidth,
        hiddenLabel: fcs.hiddenLabel,
        multiline,
        size: fcs.size,
        startAdornment,
        type
      });
      const classes = useUtilityClasses$y(ownerState);
      const Root = slots.root || components.Root || InputBaseRoot;
      const rootProps = slotProps.root || componentsProps.root || {};
      const Input2 = slots.input || components.Input || InputBaseComponent;
      inputProps = _extends$1({}, inputProps, (_slotProps$input = slotProps.input) != null ? _slotProps$input : componentsProps.input);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [!disableInjectingGlobalStyles && inputGlobalStyles, /* @__PURE__ */ jsxRuntimeExports.jsxs(Root, _extends$1({}, rootProps, !isHostComponent(Root) && {
          ownerState: _extends$1({}, ownerState, rootProps.ownerState)
        }, {
          ref,
          onClick: handleClick
        }, other, {
          className: clsx(classes.root, rootProps.className, className, readOnly && "MuiInputBase-readOnly"),
          children: [startAdornment, /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext$1.Provider, {
            value: null,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input2, _extends$1({
              ownerState,
              "aria-invalid": fcs.error,
              "aria-describedby": ariaDescribedby,
              autoComplete,
              autoFocus,
              defaultValue,
              disabled: fcs.disabled,
              id: id2,
              onAnimationStart: handleAutoFill,
              name,
              placeholder,
              readOnly,
              required: fcs.required,
              rows,
              value,
              onKeyDown,
              onKeyUp,
              type
            }, inputProps, !isHostComponent(Input2) && {
              as: InputComponent,
              ownerState: _extends$1({}, ownerState, inputProps.ownerState)
            }, {
              ref: handleInputRef,
              className: clsx(classes.input, inputProps.className, readOnly && "MuiInputBase-readOnly"),
              onBlur: handleBlur,
              onChange: handleChange,
              onFocus: handleFocus
            }))
          }), endAdornment, renderSuffix ? renderSuffix(_extends$1({}, fcs, {
            startAdornment
          })) : null]
        }))]
      });
    });
    const InputBase$1 = InputBase;
    function getInputUtilityClass(slot) {
      return generateUtilityClass$1("MuiInput", slot);
    }
    const inputClasses = _extends$1({}, inputBaseClasses$1, generateUtilityClasses$1("MuiInput", ["root", "underline", "input"]));
    const inputClasses$1 = inputClasses;
    const _excluded$G = ["disableUnderline", "components", "componentsProps", "fullWidth", "inputComponent", "multiline", "slotProps", "slots", "type"];
    const useUtilityClasses$x = (ownerState) => {
      const {
        classes,
        disableUnderline
      } = ownerState;
      const slots = {
        root: ["root", !disableUnderline && "underline"],
        input: ["input"]
      };
      const composedClasses = composeClasses(slots, getInputUtilityClass, classes);
      return _extends$1({}, classes, composedClasses);
    };
    const InputRoot = styled(InputBaseRoot, {
      shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
      name: "MuiInput",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [...rootOverridesResolver(props, styles2), !ownerState.disableUnderline && styles2.underline];
      }
    })(({
      theme,
      ownerState
    }) => {
      const light2 = theme.palette.mode === "light";
      let bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
      if (theme.vars) {
        bottomLineColor = `rgba(${theme.vars.palette.common.onBackgroundChannel} / ${theme.vars.opacity.inputUnderline})`;
      }
      return _extends$1({
        position: "relative"
      }, ownerState.formControl && {
        "label + &": {
          marginTop: 16
        }
      }, !ownerState.disableUnderline && {
        "&::after": {
          borderBottom: `2px solid ${(theme.vars || theme).palette[ownerState.color].main}`,
          left: 0,
          bottom: 0,
          // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: theme.transitions.create("transform", {
            duration: theme.transitions.duration.shorter,
            easing: theme.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${inputClasses$1.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${inputClasses$1.error}`]: {
          "&::before, &::after": {
            borderBottomColor: (theme.vars || theme).palette.error.main
          }
        },
        "&::before": {
          borderBottom: `1px solid ${bottomLineColor}`,
          left: 0,
          bottom: 0,
          // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: theme.transitions.create("border-bottom-color", {
            duration: theme.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${inputClasses$1.disabled}, .${inputClasses$1.error}):before`]: {
          borderBottom: `2px solid ${(theme.vars || theme).palette.text.primary}`,
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            borderBottom: `1px solid ${bottomLineColor}`
          }
        },
        [`&.${inputClasses$1.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      });
    });
    const InputInput = styled(InputBaseComponent, {
      name: "MuiInput",
      slot: "Input",
      overridesResolver: inputOverridesResolver
    })({});
    const Input = /* @__PURE__ */ reactExports.forwardRef(function Input2(inProps, ref) {
      var _ref, _slots$root, _ref2, _slots$input;
      const props = useThemeProps({
        props: inProps,
        name: "MuiInput"
      });
      const {
        disableUnderline,
        components = {},
        componentsProps: componentsPropsProp,
        fullWidth = false,
        inputComponent = "input",
        multiline = false,
        slotProps,
        slots = {},
        type = "text"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$G);
      const classes = useUtilityClasses$x(props);
      const ownerState = {
        disableUnderline
      };
      const inputComponentsProps = {
        root: {
          ownerState
        }
      };
      const componentsProps = (slotProps != null ? slotProps : componentsPropsProp) ? deepmerge(slotProps != null ? slotProps : componentsPropsProp, inputComponentsProps) : inputComponentsProps;
      const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : InputRoot;
      const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : InputInput;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase$1, _extends$1({
        slots: {
          root: RootSlot,
          input: InputSlot
        },
        slotProps: componentsProps,
        fullWidth,
        inputComponent,
        multiline,
        ref,
        type
      }, other, {
        classes
      }));
    });
    Input.muiName = "Input";
    const Input$1 = Input;
    function getFilledInputUtilityClass(slot) {
      return generateUtilityClass$1("MuiFilledInput", slot);
    }
    const filledInputClasses = _extends$1({}, inputBaseClasses$1, generateUtilityClasses$1("MuiFilledInput", ["root", "underline", "input"]));
    const filledInputClasses$1 = filledInputClasses;
    const _excluded$F = ["disableUnderline", "components", "componentsProps", "fullWidth", "hiddenLabel", "inputComponent", "multiline", "slotProps", "slots", "type"];
    const useUtilityClasses$w = (ownerState) => {
      const {
        classes,
        disableUnderline
      } = ownerState;
      const slots = {
        root: ["root", !disableUnderline && "underline"],
        input: ["input"]
      };
      const composedClasses = composeClasses(slots, getFilledInputUtilityClass, classes);
      return _extends$1({}, classes, composedClasses);
    };
    const FilledInputRoot = styled(InputBaseRoot, {
      shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
      name: "MuiFilledInput",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [...rootOverridesResolver(props, styles2), !ownerState.disableUnderline && styles2.underline];
      }
    })(({
      theme,
      ownerState
    }) => {
      var _palette;
      const light2 = theme.palette.mode === "light";
      const bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
      const backgroundColor2 = light2 ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)";
      const hoverBackground = light2 ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)";
      const disabledBackground = light2 ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
      return _extends$1({
        position: "relative",
        backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2,
        borderTopLeftRadius: (theme.vars || theme).shape.borderRadius,
        borderTopRightRadius: (theme.vars || theme).shape.borderRadius,
        transition: theme.transitions.create("background-color", {
          duration: theme.transitions.duration.shorter,
          easing: theme.transitions.easing.easeOut
        }),
        "&:hover": {
          backgroundColor: theme.vars ? theme.vars.palette.FilledInput.hoverBg : hoverBackground,
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2
          }
        },
        [`&.${filledInputClasses$1.focused}`]: {
          backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2
        },
        [`&.${filledInputClasses$1.disabled}`]: {
          backgroundColor: theme.vars ? theme.vars.palette.FilledInput.disabledBg : disabledBackground
        }
      }, !ownerState.disableUnderline && {
        "&::after": {
          borderBottom: `2px solid ${(_palette = (theme.vars || theme).palette[ownerState.color || "primary"]) == null ? void 0 : _palette.main}`,
          left: 0,
          bottom: 0,
          // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: theme.transitions.create("transform", {
            duration: theme.transitions.duration.shorter,
            easing: theme.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${filledInputClasses$1.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${filledInputClasses$1.error}`]: {
          "&::before, &::after": {
            borderBottomColor: (theme.vars || theme).palette.error.main
          }
        },
        "&::before": {
          borderBottom: `1px solid ${theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / ${theme.vars.opacity.inputUnderline})` : bottomLineColor}`,
          left: 0,
          bottom: 0,
          // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: theme.transitions.create("border-bottom-color", {
            duration: theme.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${filledInputClasses$1.disabled}, .${filledInputClasses$1.error}):before`]: {
          borderBottom: `1px solid ${(theme.vars || theme).palette.text.primary}`
        },
        [`&.${filledInputClasses$1.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }, ownerState.startAdornment && {
        paddingLeft: 12
      }, ownerState.endAdornment && {
        paddingRight: 12
      }, ownerState.multiline && _extends$1({
        padding: "25px 12px 8px"
      }, ownerState.size === "small" && {
        paddingTop: 21,
        paddingBottom: 4
      }, ownerState.hiddenLabel && {
        paddingTop: 16,
        paddingBottom: 17
      }, ownerState.hiddenLabel && ownerState.size === "small" && {
        paddingTop: 8,
        paddingBottom: 9
      }));
    });
    const FilledInputInput = styled(InputBaseComponent, {
      name: "MuiFilledInput",
      slot: "Input",
      overridesResolver: inputOverridesResolver
    })(({
      theme,
      ownerState
    }) => _extends$1({
      paddingTop: 25,
      paddingRight: 12,
      paddingBottom: 8,
      paddingLeft: 12
    }, !theme.vars && {
      "&:-webkit-autofill": {
        WebkitBoxShadow: theme.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
        WebkitTextFillColor: theme.palette.mode === "light" ? null : "#fff",
        caretColor: theme.palette.mode === "light" ? null : "#fff",
        borderTopLeftRadius: "inherit",
        borderTopRightRadius: "inherit"
      }
    }, theme.vars && {
      "&:-webkit-autofill": {
        borderTopLeftRadius: "inherit",
        borderTopRightRadius: "inherit"
      },
      [theme.getColorSchemeSelector("dark")]: {
        "&:-webkit-autofill": {
          WebkitBoxShadow: "0 0 0 100px #266798 inset",
          WebkitTextFillColor: "#fff",
          caretColor: "#fff"
        }
      }
    }, ownerState.size === "small" && {
      paddingTop: 21,
      paddingBottom: 4
    }, ownerState.hiddenLabel && {
      paddingTop: 16,
      paddingBottom: 17
    }, ownerState.startAdornment && {
      paddingLeft: 0
    }, ownerState.endAdornment && {
      paddingRight: 0
    }, ownerState.hiddenLabel && ownerState.size === "small" && {
      paddingTop: 8,
      paddingBottom: 9
    }, ownerState.multiline && {
      paddingTop: 0,
      paddingBottom: 0,
      paddingLeft: 0,
      paddingRight: 0
    }));
    const FilledInput = /* @__PURE__ */ reactExports.forwardRef(function FilledInput2(inProps, ref) {
      var _ref, _slots$root, _ref2, _slots$input;
      const props = useThemeProps({
        props: inProps,
        name: "MuiFilledInput"
      });
      const {
        components = {},
        componentsProps: componentsPropsProp,
        fullWidth = false,
        // declare here to prevent spreading to DOM
        inputComponent = "input",
        multiline = false,
        slotProps,
        slots = {},
        type = "text"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$F);
      const ownerState = _extends$1({}, props, {
        fullWidth,
        inputComponent,
        multiline,
        type
      });
      const classes = useUtilityClasses$w(props);
      const filledInputComponentsProps = {
        root: {
          ownerState
        },
        input: {
          ownerState
        }
      };
      const componentsProps = (slotProps != null ? slotProps : componentsPropsProp) ? deepmerge(filledInputComponentsProps, slotProps != null ? slotProps : componentsPropsProp) : filledInputComponentsProps;
      const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : FilledInputRoot;
      const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : FilledInputInput;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase$1, _extends$1({
        slots: {
          root: RootSlot,
          input: InputSlot
        },
        componentsProps,
        fullWidth,
        inputComponent,
        multiline,
        ref,
        type
      }, other, {
        classes
      }));
    });
    FilledInput.muiName = "Input";
    const FilledInput$1 = FilledInput;
    var _span$3;
    const _excluded$E = ["children", "classes", "className", "label", "notched"];
    const NotchedOutlineRoot$1 = styled("fieldset", {
      shouldForwardProp: rootShouldForwardProp
    })({
      textAlign: "left",
      position: "absolute",
      bottom: 0,
      right: 0,
      top: -5,
      left: 0,
      margin: 0,
      padding: "0 8px",
      pointerEvents: "none",
      borderRadius: "inherit",
      borderStyle: "solid",
      borderWidth: 1,
      overflow: "hidden",
      minWidth: "0%"
    });
    const NotchedOutlineLegend = styled("legend", {
      shouldForwardProp: rootShouldForwardProp
    })(({
      ownerState,
      theme
    }) => _extends$1({
      float: "unset",
      // Fix conflict with bootstrap
      width: "auto",
      // Fix conflict with bootstrap
      overflow: "hidden"
    }, !ownerState.withLabel && {
      padding: 0,
      lineHeight: "11px",
      // sync with `height` in `legend` styles
      transition: theme.transitions.create("width", {
        duration: 150,
        easing: theme.transitions.easing.easeOut
      })
    }, ownerState.withLabel && _extends$1({
      display: "block",
      // Fix conflict with normalize.css and sanitize.css
      padding: 0,
      height: 11,
      // sync with `lineHeight` in `legend` styles
      fontSize: "0.75em",
      visibility: "hidden",
      maxWidth: 0.01,
      transition: theme.transitions.create("max-width", {
        duration: 50,
        easing: theme.transitions.easing.easeOut
      }),
      whiteSpace: "nowrap",
      "& > span": {
        paddingLeft: 5,
        paddingRight: 5,
        display: "inline-block",
        opacity: 0,
        visibility: "visible"
      }
    }, ownerState.notched && {
      maxWidth: "100%",
      transition: theme.transitions.create("max-width", {
        duration: 100,
        easing: theme.transitions.easing.easeOut,
        delay: 50
      })
    })));
    function NotchedOutline(props) {
      const {
        className,
        label,
        notched
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$E);
      const withLabel = label != null && label !== "";
      const ownerState = _extends$1({}, props, {
        notched,
        withLabel
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineRoot$1, _extends$1({
        "aria-hidden": true,
        className,
        ownerState
      }, other, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineLegend, {
          ownerState,
          children: withLabel ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
            children: label
          }) : (
            // notranslate needed while Google Translate will not fix zero-width space issue
            _span$3 || (_span$3 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
              className: "notranslate",
              children: "​"
            }))
          )
        })
      }));
    }
    function getOutlinedInputUtilityClass(slot) {
      return generateUtilityClass$1("MuiOutlinedInput", slot);
    }
    const outlinedInputClasses = _extends$1({}, inputBaseClasses$1, generateUtilityClasses$1("MuiOutlinedInput", ["root", "notchedOutline", "input"]));
    const outlinedInputClasses$1 = outlinedInputClasses;
    const _excluded$D = ["components", "fullWidth", "inputComponent", "label", "multiline", "notched", "slots", "type"];
    const useUtilityClasses$v = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        notchedOutline: ["notchedOutline"],
        input: ["input"]
      };
      const composedClasses = composeClasses(slots, getOutlinedInputUtilityClass, classes);
      return _extends$1({}, classes, composedClasses);
    };
    const OutlinedInputRoot = styled(InputBaseRoot, {
      shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
      name: "MuiOutlinedInput",
      slot: "Root",
      overridesResolver: rootOverridesResolver
    })(({
      theme,
      ownerState
    }) => {
      const borderColor2 = theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
      return _extends$1({
        position: "relative",
        borderRadius: (theme.vars || theme).shape.borderRadius,
        [`&:hover .${outlinedInputClasses$1.notchedOutline}`]: {
          borderColor: (theme.vars || theme).palette.text.primary
        },
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          [`&:hover .${outlinedInputClasses$1.notchedOutline}`]: {
            borderColor: theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor2
          }
        },
        [`&.${outlinedInputClasses$1.focused} .${outlinedInputClasses$1.notchedOutline}`]: {
          borderColor: (theme.vars || theme).palette[ownerState.color].main,
          borderWidth: 2
        },
        [`&.${outlinedInputClasses$1.error} .${outlinedInputClasses$1.notchedOutline}`]: {
          borderColor: (theme.vars || theme).palette.error.main
        },
        [`&.${outlinedInputClasses$1.disabled} .${outlinedInputClasses$1.notchedOutline}`]: {
          borderColor: (theme.vars || theme).palette.action.disabled
        }
      }, ownerState.startAdornment && {
        paddingLeft: 14
      }, ownerState.endAdornment && {
        paddingRight: 14
      }, ownerState.multiline && _extends$1({
        padding: "16.5px 14px"
      }, ownerState.size === "small" && {
        padding: "8.5px 14px"
      }));
    });
    const NotchedOutlineRoot = styled(NotchedOutline, {
      name: "MuiOutlinedInput",
      slot: "NotchedOutline",
      overridesResolver: (props, styles2) => styles2.notchedOutline
    })(({
      theme
    }) => {
      const borderColor2 = theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
      return {
        borderColor: theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor2
      };
    });
    const OutlinedInputInput = styled(InputBaseComponent, {
      name: "MuiOutlinedInput",
      slot: "Input",
      overridesResolver: inputOverridesResolver
    })(({
      theme,
      ownerState
    }) => _extends$1({
      padding: "16.5px 14px"
    }, !theme.vars && {
      "&:-webkit-autofill": {
        WebkitBoxShadow: theme.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
        WebkitTextFillColor: theme.palette.mode === "light" ? null : "#fff",
        caretColor: theme.palette.mode === "light" ? null : "#fff",
        borderRadius: "inherit"
      }
    }, theme.vars && {
      "&:-webkit-autofill": {
        borderRadius: "inherit"
      },
      [theme.getColorSchemeSelector("dark")]: {
        "&:-webkit-autofill": {
          WebkitBoxShadow: "0 0 0 100px #266798 inset",
          WebkitTextFillColor: "#fff",
          caretColor: "#fff"
        }
      }
    }, ownerState.size === "small" && {
      padding: "8.5px 14px"
    }, ownerState.multiline && {
      padding: 0
    }, ownerState.startAdornment && {
      paddingLeft: 0
    }, ownerState.endAdornment && {
      paddingRight: 0
    }));
    const OutlinedInput = /* @__PURE__ */ reactExports.forwardRef(function OutlinedInput2(inProps, ref) {
      var _ref, _slots$root, _ref2, _slots$input, _React$Fragment;
      const props = useThemeProps({
        props: inProps,
        name: "MuiOutlinedInput"
      });
      const {
        components = {},
        fullWidth = false,
        inputComponent = "input",
        label,
        multiline = false,
        notched,
        slots = {},
        type = "text"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$D);
      const classes = useUtilityClasses$v(props);
      const muiFormControl = useFormControl();
      const fcs = formControlState({
        props,
        muiFormControl,
        states: ["color", "disabled", "error", "focused", "hiddenLabel", "size", "required"]
      });
      const ownerState = _extends$1({}, props, {
        color: fcs.color || "primary",
        disabled: fcs.disabled,
        error: fcs.error,
        focused: fcs.focused,
        formControl: muiFormControl,
        fullWidth,
        hiddenLabel: fcs.hiddenLabel,
        multiline,
        size: fcs.size,
        type
      });
      const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : OutlinedInputRoot;
      const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : OutlinedInputInput;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase$1, _extends$1({
        slots: {
          root: RootSlot,
          input: InputSlot
        },
        renderSuffix: (state) => /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineRoot, {
          ownerState,
          className: classes.notchedOutline,
          label: label != null && label !== "" && fcs.required ? _React$Fragment || (_React$Fragment = /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
            children: [label, " ", "*"]
          })) : label,
          notched: typeof notched !== "undefined" ? notched : Boolean(state.startAdornment || state.filled || state.focused)
        }),
        fullWidth,
        inputComponent,
        multiline,
        ref,
        type
      }, other, {
        classes: _extends$1({}, classes, {
          notchedOutline: null
        })
      }));
    });
    OutlinedInput.muiName = "Input";
    const OutlinedInput$1 = OutlinedInput;
    function getFormLabelUtilityClasses(slot) {
      return generateUtilityClass$1("MuiFormLabel", slot);
    }
    const formLabelClasses = generateUtilityClasses$1("MuiFormLabel", ["root", "colorSecondary", "focused", "disabled", "error", "filled", "required", "asterisk"]);
    const formLabelClasses$1 = formLabelClasses;
    const _excluded$C = ["children", "className", "color", "component", "disabled", "error", "filled", "focused", "required"];
    const useUtilityClasses$u = (ownerState) => {
      const {
        classes,
        color: color2,
        focused,
        disabled,
        error,
        filled,
        required
      } = ownerState;
      const slots = {
        root: ["root", `color${capitalize(color2)}`, disabled && "disabled", error && "error", filled && "filled", focused && "focused", required && "required"],
        asterisk: ["asterisk", error && "error"]
      };
      return composeClasses(slots, getFormLabelUtilityClasses, classes);
    };
    const FormLabelRoot = styled("label", {
      name: "MuiFormLabel",
      slot: "Root",
      overridesResolver: ({
        ownerState
      }, styles2) => {
        return _extends$1({}, styles2.root, ownerState.color === "secondary" && styles2.colorSecondary, ownerState.filled && styles2.filled);
      }
    })(({
      theme,
      ownerState
    }) => _extends$1({
      color: (theme.vars || theme).palette.text.secondary
    }, theme.typography.body1, {
      lineHeight: "1.4375em",
      padding: 0,
      position: "relative",
      [`&.${formLabelClasses$1.focused}`]: {
        color: (theme.vars || theme).palette[ownerState.color].main
      },
      [`&.${formLabelClasses$1.disabled}`]: {
        color: (theme.vars || theme).palette.text.disabled
      },
      [`&.${formLabelClasses$1.error}`]: {
        color: (theme.vars || theme).palette.error.main
      }
    }));
    const AsteriskComponent = styled("span", {
      name: "MuiFormLabel",
      slot: "Asterisk",
      overridesResolver: (props, styles2) => styles2.asterisk
    })(({
      theme
    }) => ({
      [`&.${formLabelClasses$1.error}`]: {
        color: (theme.vars || theme).palette.error.main
      }
    }));
    const FormLabel = /* @__PURE__ */ reactExports.forwardRef(function FormLabel2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiFormLabel"
      });
      const {
        children,
        className,
        component = "label"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$C);
      const muiFormControl = useFormControl();
      const fcs = formControlState({
        props,
        muiFormControl,
        states: ["color", "required", "focused", "disabled", "error", "filled"]
      });
      const ownerState = _extends$1({}, props, {
        color: fcs.color || "primary",
        component,
        disabled: fcs.disabled,
        error: fcs.error,
        filled: fcs.filled,
        focused: fcs.focused,
        required: fcs.required
      });
      const classes = useUtilityClasses$u(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(FormLabelRoot, _extends$1({
        as: component,
        ownerState,
        className: clsx(classes.root, className),
        ref
      }, other, {
        children: [children, fcs.required && /* @__PURE__ */ jsxRuntimeExports.jsxs(AsteriskComponent, {
          ownerState,
          "aria-hidden": true,
          className: classes.asterisk,
          children: [" ", "*"]
        })]
      }));
    });
    const FormLabel$1 = FormLabel;
    function getInputLabelUtilityClasses(slot) {
      return generateUtilityClass$1("MuiInputLabel", slot);
    }
    generateUtilityClasses$1("MuiInputLabel", ["root", "focused", "disabled", "error", "required", "asterisk", "formControl", "sizeSmall", "shrink", "animated", "standard", "filled", "outlined"]);
    const _excluded$B = ["disableAnimation", "margin", "shrink", "variant", "className"];
    const useUtilityClasses$t = (ownerState) => {
      const {
        classes,
        formControl,
        size,
        shrink,
        disableAnimation,
        variant,
        required
      } = ownerState;
      const slots = {
        root: ["root", formControl && "formControl", !disableAnimation && "animated", shrink && "shrink", size && size !== "normal" && `size${capitalize(size)}`, variant],
        asterisk: [required && "asterisk"]
      };
      const composedClasses = composeClasses(slots, getInputLabelUtilityClasses, classes);
      return _extends$1({}, classes, composedClasses);
    };
    const InputLabelRoot = styled(FormLabel$1, {
      shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
      name: "MuiInputLabel",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [{
          [`& .${formLabelClasses$1.asterisk}`]: styles2.asterisk
        }, styles2.root, ownerState.formControl && styles2.formControl, ownerState.size === "small" && styles2.sizeSmall, ownerState.shrink && styles2.shrink, !ownerState.disableAnimation && styles2.animated, ownerState.focused && styles2.focused, styles2[ownerState.variant]];
      }
    })(({
      theme,
      ownerState
    }) => _extends$1({
      display: "block",
      transformOrigin: "top left",
      whiteSpace: "nowrap",
      overflow: "hidden",
      textOverflow: "ellipsis",
      maxWidth: "100%"
    }, ownerState.formControl && {
      position: "absolute",
      left: 0,
      top: 0,
      // slight alteration to spec spacing to match visual spec result
      transform: "translate(0, 20px) scale(1)"
    }, ownerState.size === "small" && {
      // Compensation for the `Input.inputSizeSmall` style.
      transform: "translate(0, 17px) scale(1)"
    }, ownerState.shrink && {
      transform: "translate(0, -1.5px) scale(0.75)",
      transformOrigin: "top left",
      maxWidth: "133%"
    }, !ownerState.disableAnimation && {
      transition: theme.transitions.create(["color", "transform", "max-width"], {
        duration: theme.transitions.duration.shorter,
        easing: theme.transitions.easing.easeOut
      })
    }, ownerState.variant === "filled" && _extends$1({
      // Chrome's autofill feature gives the input field a yellow background.
      // Since the input field is behind the label in the HTML tree,
      // the input field is drawn last and hides the label with an opaque background color.
      // zIndex: 1 will raise the label above opaque background-colors of input.
      zIndex: 1,
      pointerEvents: "none",
      transform: "translate(12px, 16px) scale(1)",
      maxWidth: "calc(100% - 24px)"
    }, ownerState.size === "small" && {
      transform: "translate(12px, 13px) scale(1)"
    }, ownerState.shrink && _extends$1({
      userSelect: "none",
      pointerEvents: "auto",
      transform: "translate(12px, 7px) scale(0.75)",
      maxWidth: "calc(133% - 24px)"
    }, ownerState.size === "small" && {
      transform: "translate(12px, 4px) scale(0.75)"
    })), ownerState.variant === "outlined" && _extends$1({
      // see comment above on filled.zIndex
      zIndex: 1,
      pointerEvents: "none",
      transform: "translate(14px, 16px) scale(1)",
      maxWidth: "calc(100% - 24px)"
    }, ownerState.size === "small" && {
      transform: "translate(14px, 9px) scale(1)"
    }, ownerState.shrink && {
      userSelect: "none",
      pointerEvents: "auto",
      // Theoretically, we should have (8+5)*2/0.75 = 34px
      // but it feels a better when it bleeds a bit on the left, so 32px.
      maxWidth: "calc(133% - 32px)",
      transform: "translate(14px, -9px) scale(0.75)"
    })));
    const InputLabel = /* @__PURE__ */ reactExports.forwardRef(function InputLabel2(inProps, ref) {
      const props = useThemeProps({
        name: "MuiInputLabel",
        props: inProps
      });
      const {
        disableAnimation = false,
        shrink: shrinkProp,
        className
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$B);
      const muiFormControl = useFormControl();
      let shrink = shrinkProp;
      if (typeof shrink === "undefined" && muiFormControl) {
        shrink = muiFormControl.filled || muiFormControl.focused || muiFormControl.adornedStart;
      }
      const fcs = formControlState({
        props,
        muiFormControl,
        states: ["size", "variant", "required", "focused"]
      });
      const ownerState = _extends$1({}, props, {
        disableAnimation,
        formControl: muiFormControl,
        shrink,
        size: fcs.size,
        variant: fcs.variant,
        required: fcs.required,
        focused: fcs.focused
      });
      const classes = useUtilityClasses$t(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabelRoot, _extends$1({
        "data-shrink": shrink,
        ownerState,
        ref,
        className: clsx(classes.root, className)
      }, other, {
        classes
      }));
    });
    const InputLabel$1 = InputLabel;
    function getFormControlUtilityClasses(slot) {
      return generateUtilityClass$1("MuiFormControl", slot);
    }
    generateUtilityClasses$1("MuiFormControl", ["root", "marginNone", "marginNormal", "marginDense", "fullWidth", "disabled"]);
    const _excluded$A = ["children", "className", "color", "component", "disabled", "error", "focused", "fullWidth", "hiddenLabel", "margin", "required", "size", "variant"];
    const useUtilityClasses$s = (ownerState) => {
      const {
        classes,
        margin: margin2,
        fullWidth
      } = ownerState;
      const slots = {
        root: ["root", margin2 !== "none" && `margin${capitalize(margin2)}`, fullWidth && "fullWidth"]
      };
      return composeClasses(slots, getFormControlUtilityClasses, classes);
    };
    const FormControlRoot = styled("div", {
      name: "MuiFormControl",
      slot: "Root",
      overridesResolver: ({
        ownerState
      }, styles2) => {
        return _extends$1({}, styles2.root, styles2[`margin${capitalize(ownerState.margin)}`], ownerState.fullWidth && styles2.fullWidth);
      }
    })(({
      ownerState
    }) => _extends$1({
      display: "inline-flex",
      flexDirection: "column",
      position: "relative",
      // Reset fieldset default style.
      minWidth: 0,
      padding: 0,
      margin: 0,
      border: 0,
      verticalAlign: "top"
    }, ownerState.margin === "normal" && {
      marginTop: 16,
      marginBottom: 8
    }, ownerState.margin === "dense" && {
      marginTop: 8,
      marginBottom: 4
    }, ownerState.fullWidth && {
      width: "100%"
    }));
    const FormControl = /* @__PURE__ */ reactExports.forwardRef(function FormControl2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiFormControl"
      });
      const {
        children,
        className,
        color: color2 = "primary",
        component = "div",
        disabled = false,
        error = false,
        focused: visuallyFocused,
        fullWidth = false,
        hiddenLabel = false,
        margin: margin2 = "none",
        required = false,
        size = "medium",
        variant = "outlined"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$A);
      const ownerState = _extends$1({}, props, {
        color: color2,
        component,
        disabled,
        error,
        fullWidth,
        hiddenLabel,
        margin: margin2,
        required,
        size,
        variant
      });
      const classes = useUtilityClasses$s(ownerState);
      const [adornedStart, setAdornedStart] = reactExports.useState(() => {
        let initialAdornedStart = false;
        if (children) {
          reactExports.Children.forEach(children, (child) => {
            if (!isMuiElement(child, ["Input", "Select"])) {
              return;
            }
            const input = isMuiElement(child, ["Select"]) ? child.props.input : child;
            if (input && isAdornedStart(input.props)) {
              initialAdornedStart = true;
            }
          });
        }
        return initialAdornedStart;
      });
      const [filled, setFilled] = reactExports.useState(() => {
        let initialFilled = false;
        if (children) {
          reactExports.Children.forEach(children, (child) => {
            if (!isMuiElement(child, ["Input", "Select"])) {
              return;
            }
            if (isFilled(child.props, true) || isFilled(child.props.inputProps, true)) {
              initialFilled = true;
            }
          });
        }
        return initialFilled;
      });
      const [focusedState, setFocused] = reactExports.useState(false);
      if (disabled && focusedState) {
        setFocused(false);
      }
      const focused = visuallyFocused !== void 0 && !disabled ? visuallyFocused : focusedState;
      let registerEffect;
      const childContext = reactExports.useMemo(() => {
        return {
          adornedStart,
          setAdornedStart,
          color: color2,
          disabled,
          error,
          filled,
          focused,
          fullWidth,
          hiddenLabel,
          size,
          onBlur: () => {
            setFocused(false);
          },
          onEmpty: () => {
            setFilled(false);
          },
          onFilled: () => {
            setFilled(true);
          },
          onFocus: () => {
            setFocused(true);
          },
          registerEffect,
          required,
          variant
        };
      }, [adornedStart, color2, disabled, error, filled, focused, fullWidth, hiddenLabel, registerEffect, required, size, variant]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext$1.Provider, {
        value: childContext,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlRoot, _extends$1({
          as: component,
          ownerState,
          className: clsx(classes.root, className),
          ref
        }, other, {
          children
        }))
      });
    });
    const FormControl$1 = FormControl;
    function getFormHelperTextUtilityClasses(slot) {
      return generateUtilityClass$1("MuiFormHelperText", slot);
    }
    const formHelperTextClasses = generateUtilityClasses$1("MuiFormHelperText", ["root", "error", "disabled", "sizeSmall", "sizeMedium", "contained", "focused", "filled", "required"]);
    const formHelperTextClasses$1 = formHelperTextClasses;
    var _span$2;
    const _excluded$z = ["children", "className", "component", "disabled", "error", "filled", "focused", "margin", "required", "variant"];
    const useUtilityClasses$r = (ownerState) => {
      const {
        classes,
        contained,
        size,
        disabled,
        error,
        filled,
        focused,
        required
      } = ownerState;
      const slots = {
        root: ["root", disabled && "disabled", error && "error", size && `size${capitalize(size)}`, contained && "contained", focused && "focused", filled && "filled", required && "required"]
      };
      return composeClasses(slots, getFormHelperTextUtilityClasses, classes);
    };
    const FormHelperTextRoot = styled("p", {
      name: "MuiFormHelperText",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, ownerState.size && styles2[`size${capitalize(ownerState.size)}`], ownerState.contained && styles2.contained, ownerState.filled && styles2.filled];
      }
    })(({
      theme,
      ownerState
    }) => _extends$1({
      color: (theme.vars || theme).palette.text.secondary
    }, theme.typography.caption, {
      textAlign: "left",
      marginTop: 3,
      marginRight: 0,
      marginBottom: 0,
      marginLeft: 0,
      [`&.${formHelperTextClasses$1.disabled}`]: {
        color: (theme.vars || theme).palette.text.disabled
      },
      [`&.${formHelperTextClasses$1.error}`]: {
        color: (theme.vars || theme).palette.error.main
      }
    }, ownerState.size === "small" && {
      marginTop: 4
    }, ownerState.contained && {
      marginLeft: 14,
      marginRight: 14
    }));
    const FormHelperText = /* @__PURE__ */ reactExports.forwardRef(function FormHelperText2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiFormHelperText"
      });
      const {
        children,
        className,
        component = "p"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$z);
      const muiFormControl = useFormControl();
      const fcs = formControlState({
        props,
        muiFormControl,
        states: ["variant", "size", "disabled", "error", "filled", "focused", "required"]
      });
      const ownerState = _extends$1({}, props, {
        component,
        contained: fcs.variant === "filled" || fcs.variant === "outlined",
        variant: fcs.variant,
        size: fcs.size,
        disabled: fcs.disabled,
        error: fcs.error,
        filled: fcs.filled,
        focused: fcs.focused,
        required: fcs.required
      });
      const classes = useUtilityClasses$r(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(FormHelperTextRoot, _extends$1({
        as: component,
        ownerState,
        className: clsx(classes.root, className),
        ref
      }, other, {
        children: children === " " ? (
          // notranslate needed while Google Translate will not fix zero-width space issue
          _span$2 || (_span$2 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
            className: "notranslate",
            children: "​"
          }))
        ) : children
      }));
    });
    const FormHelperText$1 = FormHelperText;
    const ListContext = /* @__PURE__ */ reactExports.createContext({});
    const ListContext$1 = ListContext;
    function getListUtilityClass(slot) {
      return generateUtilityClass$1("MuiList", slot);
    }
    generateUtilityClasses$1("MuiList", ["root", "padding", "dense", "subheader"]);
    const _excluded$y = ["children", "className", "component", "dense", "disablePadding", "subheader"];
    const useUtilityClasses$q = (ownerState) => {
      const {
        classes,
        disablePadding,
        dense,
        subheader
      } = ownerState;
      const slots = {
        root: ["root", !disablePadding && "padding", dense && "dense", subheader && "subheader"]
      };
      return composeClasses(slots, getListUtilityClass, classes);
    };
    const ListRoot = styled("ul", {
      name: "MuiList",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, !ownerState.disablePadding && styles2.padding, ownerState.dense && styles2.dense, ownerState.subheader && styles2.subheader];
      }
    })(({
      ownerState
    }) => _extends$1({
      listStyle: "none",
      margin: 0,
      padding: 0,
      position: "relative"
    }, !ownerState.disablePadding && {
      paddingTop: 8,
      paddingBottom: 8
    }, ownerState.subheader && {
      paddingTop: 0
    }));
    const List = /* @__PURE__ */ reactExports.forwardRef(function List2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiList"
      });
      const {
        children,
        className,
        component = "ul",
        dense = false,
        disablePadding = false,
        subheader
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$y);
      const context = reactExports.useMemo(() => ({
        dense
      }), [dense]);
      const ownerState = _extends$1({}, props, {
        component,
        dense,
        disablePadding
      });
      const classes = useUtilityClasses$q(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext$1.Provider, {
        value: context,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ListRoot, _extends$1({
          as: component,
          className: clsx(classes.root, className),
          ref,
          ownerState
        }, other, {
          children: [subheader, children]
        }))
      });
    });
    const List$1 = List;
    const _excluded$x = ["actions", "autoFocus", "autoFocusItem", "children", "className", "disabledItemsFocusable", "disableListWrap", "onKeyDown", "variant"];
    function nextItem(list, item, disableListWrap) {
      if (list === item) {
        return list.firstChild;
      }
      if (item && item.nextElementSibling) {
        return item.nextElementSibling;
      }
      return disableListWrap ? null : list.firstChild;
    }
    function previousItem(list, item, disableListWrap) {
      if (list === item) {
        return disableListWrap ? list.firstChild : list.lastChild;
      }
      if (item && item.previousElementSibling) {
        return item.previousElementSibling;
      }
      return disableListWrap ? null : list.lastChild;
    }
    function textCriteriaMatches(nextFocus, textCriteria) {
      if (textCriteria === void 0) {
        return true;
      }
      let text = nextFocus.innerText;
      if (text === void 0) {
        text = nextFocus.textContent;
      }
      text = text.trim().toLowerCase();
      if (text.length === 0) {
        return false;
      }
      if (textCriteria.repeating) {
        return text[0] === textCriteria.keys[0];
      }
      return text.indexOf(textCriteria.keys.join("")) === 0;
    }
    function moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {
      let wrappedOnce = false;
      let nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : false);
      while (nextFocus) {
        if (nextFocus === list.firstChild) {
          if (wrappedOnce) {
            return false;
          }
          wrappedOnce = true;
        }
        const nextFocusDisabled = disabledItemsFocusable ? false : nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
        if (!nextFocus.hasAttribute("tabindex") || !textCriteriaMatches(nextFocus, textCriteria) || nextFocusDisabled) {
          nextFocus = traversalFunction(list, nextFocus, disableListWrap);
        } else {
          nextFocus.focus();
          return true;
        }
      }
      return false;
    }
    const MenuList = /* @__PURE__ */ reactExports.forwardRef(function MenuList2(props, ref) {
      const {
        // private
        // eslint-disable-next-line react/prop-types
        actions,
        autoFocus = false,
        autoFocusItem = false,
        children,
        className,
        disabledItemsFocusable = false,
        disableListWrap = false,
        onKeyDown,
        variant = "selectedMenu"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$x);
      const listRef = reactExports.useRef(null);
      const textCriteriaRef = reactExports.useRef({
        keys: [],
        repeating: true,
        previousKeyMatched: true,
        lastTime: null
      });
      useEnhancedEffect(() => {
        if (autoFocus) {
          listRef.current.focus();
        }
      }, [autoFocus]);
      reactExports.useImperativeHandle(actions, () => ({
        adjustStyleForScrollbar: (containerElement, theme) => {
          const noExplicitWidth = !listRef.current.style.width;
          if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {
            const scrollbarSize = `${getScrollbarSize(ownerDocument(containerElement))}px`;
            listRef.current.style[theme.direction === "rtl" ? "paddingLeft" : "paddingRight"] = scrollbarSize;
            listRef.current.style.width = `calc(100% + ${scrollbarSize})`;
          }
          return listRef.current;
        }
      }), []);
      const handleKeyDown2 = (event) => {
        const list = listRef.current;
        const key = event.key;
        const currentFocus = ownerDocument(list).activeElement;
        if (key === "ArrowDown") {
          event.preventDefault();
          moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, nextItem);
        } else if (key === "ArrowUp") {
          event.preventDefault();
          moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, previousItem);
        } else if (key === "Home") {
          event.preventDefault();
          moveFocus(list, null, disableListWrap, disabledItemsFocusable, nextItem);
        } else if (key === "End") {
          event.preventDefault();
          moveFocus(list, null, disableListWrap, disabledItemsFocusable, previousItem);
        } else if (key.length === 1) {
          const criteria = textCriteriaRef.current;
          const lowerKey = key.toLowerCase();
          const currTime = performance.now();
          if (criteria.keys.length > 0) {
            if (currTime - criteria.lastTime > 500) {
              criteria.keys = [];
              criteria.repeating = true;
              criteria.previousKeyMatched = true;
            } else if (criteria.repeating && lowerKey !== criteria.keys[0]) {
              criteria.repeating = false;
            }
          }
          criteria.lastTime = currTime;
          criteria.keys.push(lowerKey);
          const keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);
          if (criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus(list, currentFocus, false, disabledItemsFocusable, nextItem, criteria))) {
            event.preventDefault();
          } else {
            criteria.previousKeyMatched = false;
          }
        }
        if (onKeyDown) {
          onKeyDown(event);
        }
      };
      const handleRef = useForkRef(listRef, ref);
      let activeItemIndex = -1;
      reactExports.Children.forEach(children, (child, index) => {
        if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
          if (activeItemIndex === index) {
            activeItemIndex += 1;
            if (activeItemIndex >= children.length) {
              activeItemIndex = -1;
            }
          }
          return;
        }
        if (!child.props.disabled) {
          if (variant === "selectedMenu" && child.props.selected) {
            activeItemIndex = index;
          } else if (activeItemIndex === -1) {
            activeItemIndex = index;
          }
        }
        if (activeItemIndex === index && (child.props.disabled || child.props.muiSkipListHighlight || child.type.muiSkipListHighlight)) {
          activeItemIndex += 1;
          if (activeItemIndex >= children.length) {
            activeItemIndex = -1;
          }
        }
      });
      const items = reactExports.Children.map(children, (child, index) => {
        if (index === activeItemIndex) {
          const newChildProps = {};
          if (autoFocusItem) {
            newChildProps.autoFocus = true;
          }
          if (child.props.tabIndex === void 0 && variant === "selectedMenu") {
            newChildProps.tabIndex = 0;
          }
          return /* @__PURE__ */ reactExports.cloneElement(child, newChildProps);
        }
        return child;
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(List$1, _extends$1({
        role: "menu",
        ref: handleRef,
        className,
        onKeyDown: handleKeyDown2,
        tabIndex: autoFocus ? 0 : -1
      }, other, {
        children: items
      }));
    });
    const MenuList$1 = MenuList;
    function getPopoverUtilityClass(slot) {
      return generateUtilityClass$1("MuiPopover", slot);
    }
    generateUtilityClasses$1("MuiPopover", ["root", "paper"]);
    const _excluded$w = ["onEntering"], _excluded2$7 = ["action", "anchorEl", "anchorOrigin", "anchorPosition", "anchorReference", "children", "className", "container", "elevation", "marginThreshold", "open", "PaperProps", "slots", "slotProps", "transformOrigin", "TransitionComponent", "transitionDuration", "TransitionProps", "disableScrollLock"], _excluded3$3 = ["slotProps"];
    function getOffsetTop(rect, vertical) {
      let offset2 = 0;
      if (typeof vertical === "number") {
        offset2 = vertical;
      } else if (vertical === "center") {
        offset2 = rect.height / 2;
      } else if (vertical === "bottom") {
        offset2 = rect.height;
      }
      return offset2;
    }
    function getOffsetLeft(rect, horizontal) {
      let offset2 = 0;
      if (typeof horizontal === "number") {
        offset2 = horizontal;
      } else if (horizontal === "center") {
        offset2 = rect.width / 2;
      } else if (horizontal === "right") {
        offset2 = rect.width;
      }
      return offset2;
    }
    function getTransformOriginValue(transformOrigin) {
      return [transformOrigin.horizontal, transformOrigin.vertical].map((n2) => typeof n2 === "number" ? `${n2}px` : n2).join(" ");
    }
    function resolveAnchorEl(anchorEl) {
      return typeof anchorEl === "function" ? anchorEl() : anchorEl;
    }
    const useUtilityClasses$p = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        paper: ["paper"]
      };
      return composeClasses(slots, getPopoverUtilityClass, classes);
    };
    const PopoverRoot = styled(Modal$1, {
      name: "MuiPopover",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })({});
    const PopoverPaper = styled(Paper$1, {
      name: "MuiPopover",
      slot: "Paper",
      overridesResolver: (props, styles2) => styles2.paper
    })({
      position: "absolute",
      overflowY: "auto",
      overflowX: "hidden",
      // So we see the popover when it's empty.
      // It's most likely on issue on userland.
      minWidth: 16,
      minHeight: 16,
      maxWidth: "calc(100% - 32px)",
      maxHeight: "calc(100% - 32px)",
      // We disable the focus ring for mouse, touch and keyboard users.
      outline: 0
    });
    const Popover = /* @__PURE__ */ reactExports.forwardRef(function Popover2(inProps, ref) {
      var _slotProps$paper, _slots$root, _slots$paper;
      const props = useThemeProps({
        props: inProps,
        name: "MuiPopover"
      });
      const {
        action,
        anchorEl,
        anchorOrigin = {
          vertical: "top",
          horizontal: "left"
        },
        anchorPosition,
        anchorReference = "anchorEl",
        children,
        className,
        container: containerProp,
        elevation = 8,
        marginThreshold = 16,
        open,
        PaperProps: PaperPropsProp = {},
        slots,
        slotProps,
        transformOrigin = {
          vertical: "top",
          horizontal: "left"
        },
        TransitionComponent = Grow$1,
        transitionDuration: transitionDurationProp = "auto",
        TransitionProps: {
          onEntering
        } = {},
        disableScrollLock = false
      } = props, TransitionProps = _objectWithoutPropertiesLoose$1(props.TransitionProps, _excluded$w), other = _objectWithoutPropertiesLoose$1(props, _excluded2$7);
      const externalPaperSlotProps = (_slotProps$paper = slotProps == null ? void 0 : slotProps.paper) != null ? _slotProps$paper : PaperPropsProp;
      const paperRef = reactExports.useRef();
      const handlePaperRef = useForkRef(paperRef, externalPaperSlotProps.ref);
      const ownerState = _extends$1({}, props, {
        anchorOrigin,
        anchorReference,
        elevation,
        marginThreshold,
        externalPaperSlotProps,
        transformOrigin,
        TransitionComponent,
        transitionDuration: transitionDurationProp,
        TransitionProps
      });
      const classes = useUtilityClasses$p(ownerState);
      const getAnchorOffset = reactExports.useCallback(() => {
        if (anchorReference === "anchorPosition") {
          return anchorPosition;
        }
        const resolvedAnchorEl = resolveAnchorEl(anchorEl);
        const anchorElement = resolvedAnchorEl && resolvedAnchorEl.nodeType === 1 ? resolvedAnchorEl : ownerDocument(paperRef.current).body;
        const anchorRect = anchorElement.getBoundingClientRect();
        return {
          top: anchorRect.top + getOffsetTop(anchorRect, anchorOrigin.vertical),
          left: anchorRect.left + getOffsetLeft(anchorRect, anchorOrigin.horizontal)
        };
      }, [anchorEl, anchorOrigin.horizontal, anchorOrigin.vertical, anchorPosition, anchorReference]);
      const getTransformOrigin = reactExports.useCallback((elemRect) => {
        return {
          vertical: getOffsetTop(elemRect, transformOrigin.vertical),
          horizontal: getOffsetLeft(elemRect, transformOrigin.horizontal)
        };
      }, [transformOrigin.horizontal, transformOrigin.vertical]);
      const getPositioningStyle = reactExports.useCallback((element) => {
        const elemRect = {
          width: element.offsetWidth,
          height: element.offsetHeight
        };
        const elemTransformOrigin = getTransformOrigin(elemRect);
        if (anchorReference === "none") {
          return {
            top: null,
            left: null,
            transformOrigin: getTransformOriginValue(elemTransformOrigin)
          };
        }
        const anchorOffset = getAnchorOffset();
        let top2 = anchorOffset.top - elemTransformOrigin.vertical;
        let left2 = anchorOffset.left - elemTransformOrigin.horizontal;
        const bottom2 = top2 + elemRect.height;
        const right2 = left2 + elemRect.width;
        const containerWindow = ownerWindow(resolveAnchorEl(anchorEl));
        const heightThreshold = containerWindow.innerHeight - marginThreshold;
        const widthThreshold = containerWindow.innerWidth - marginThreshold;
        if (marginThreshold !== null && top2 < marginThreshold) {
          const diff = top2 - marginThreshold;
          top2 -= diff;
          elemTransformOrigin.vertical += diff;
        } else if (marginThreshold !== null && bottom2 > heightThreshold) {
          const diff = bottom2 - heightThreshold;
          top2 -= diff;
          elemTransformOrigin.vertical += diff;
        }
        if (marginThreshold !== null && left2 < marginThreshold) {
          const diff = left2 - marginThreshold;
          left2 -= diff;
          elemTransformOrigin.horizontal += diff;
        } else if (right2 > widthThreshold) {
          const diff = right2 - widthThreshold;
          left2 -= diff;
          elemTransformOrigin.horizontal += diff;
        }
        return {
          top: `${Math.round(top2)}px`,
          left: `${Math.round(left2)}px`,
          transformOrigin: getTransformOriginValue(elemTransformOrigin)
        };
      }, [anchorEl, anchorReference, getAnchorOffset, getTransformOrigin, marginThreshold]);
      const [isPositioned, setIsPositioned] = reactExports.useState(open);
      const setPositioningStyles = reactExports.useCallback(() => {
        const element = paperRef.current;
        if (!element) {
          return;
        }
        const positioning = getPositioningStyle(element);
        if (positioning.top !== null) {
          element.style.top = positioning.top;
        }
        if (positioning.left !== null) {
          element.style.left = positioning.left;
        }
        element.style.transformOrigin = positioning.transformOrigin;
        setIsPositioned(true);
      }, [getPositioningStyle]);
      reactExports.useEffect(() => {
        if (disableScrollLock) {
          window.addEventListener("scroll", setPositioningStyles);
        }
        return () => window.removeEventListener("scroll", setPositioningStyles);
      }, [anchorEl, disableScrollLock, setPositioningStyles]);
      const handleEntering = (element, isAppearing) => {
        if (onEntering) {
          onEntering(element, isAppearing);
        }
        setPositioningStyles();
      };
      const handleExited = () => {
        setIsPositioned(false);
      };
      reactExports.useEffect(() => {
        if (open) {
          setPositioningStyles();
        }
      });
      reactExports.useImperativeHandle(action, () => open ? {
        updatePosition: () => {
          setPositioningStyles();
        }
      } : null, [open, setPositioningStyles]);
      reactExports.useEffect(() => {
        if (!open) {
          return void 0;
        }
        const handleResize = debounce$1(() => {
          setPositioningStyles();
        });
        const containerWindow = ownerWindow(anchorEl);
        containerWindow.addEventListener("resize", handleResize);
        return () => {
          handleResize.clear();
          containerWindow.removeEventListener("resize", handleResize);
        };
      }, [anchorEl, open, setPositioningStyles]);
      let transitionDuration = transitionDurationProp;
      if (transitionDurationProp === "auto" && !TransitionComponent.muiSupportAuto) {
        transitionDuration = void 0;
      }
      const container = containerProp || (anchorEl ? ownerDocument(resolveAnchorEl(anchorEl)).body : void 0);
      const RootSlot = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : PopoverRoot;
      const PaperSlot = (_slots$paper = slots == null ? void 0 : slots.paper) != null ? _slots$paper : PopoverPaper;
      const paperProps = useSlotProps({
        elementType: PaperSlot,
        externalSlotProps: _extends$1({}, externalPaperSlotProps, {
          style: isPositioned ? externalPaperSlotProps.style : _extends$1({}, externalPaperSlotProps.style, {
            opacity: 0
          })
        }),
        additionalProps: {
          elevation,
          ref: handlePaperRef
        },
        ownerState,
        className: clsx(classes.paper, externalPaperSlotProps == null ? void 0 : externalPaperSlotProps.className)
      });
      const _useSlotProps = useSlotProps({
        elementType: RootSlot,
        externalSlotProps: (slotProps == null ? void 0 : slotProps.root) || {},
        externalForwardedProps: other,
        additionalProps: {
          ref,
          slotProps: {
            backdrop: {
              invisible: true
            }
          },
          container,
          open
        },
        ownerState,
        className: clsx(classes.root, className)
      }), {
        slotProps: rootSlotPropsProp
      } = _useSlotProps, rootProps = _objectWithoutPropertiesLoose$1(_useSlotProps, _excluded3$3);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(RootSlot, _extends$1({}, rootProps, !isHostComponent(RootSlot) && {
        slotProps: rootSlotPropsProp,
        disableScrollLock
      }, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$1({
          appear: true,
          in: open,
          onEntering: handleEntering,
          onExited: handleExited,
          timeout: transitionDuration
        }, TransitionProps, {
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(PaperSlot, _extends$1({}, paperProps, {
            children
          }))
        }))
      }));
    });
    const Popover$1 = Popover;
    function getMenuUtilityClass(slot) {
      return generateUtilityClass$1("MuiMenu", slot);
    }
    generateUtilityClasses$1("MuiMenu", ["root", "paper", "list"]);
    const _excluded$v = ["onEntering"], _excluded2$6 = ["autoFocus", "children", "className", "disableAutoFocusItem", "MenuListProps", "onClose", "open", "PaperProps", "PopoverClasses", "transitionDuration", "TransitionProps", "variant", "slots", "slotProps"];
    const RTL_ORIGIN = {
      vertical: "top",
      horizontal: "right"
    };
    const LTR_ORIGIN = {
      vertical: "top",
      horizontal: "left"
    };
    const useUtilityClasses$o = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        paper: ["paper"],
        list: ["list"]
      };
      return composeClasses(slots, getMenuUtilityClass, classes);
    };
    const MenuRoot = styled(Popover$1, {
      shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
      name: "MuiMenu",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })({});
    const MenuPaper = styled(PopoverPaper, {
      name: "MuiMenu",
      slot: "Paper",
      overridesResolver: (props, styles2) => styles2.paper
    })({
      // specZ: The maximum height of a simple menu should be one or more rows less than the view
      // height. This ensures a tappable area outside of the simple menu with which to dismiss
      // the menu.
      maxHeight: "calc(100% - 96px)",
      // Add iOS momentum scrolling for iOS < 13.0
      WebkitOverflowScrolling: "touch"
    });
    const MenuMenuList = styled(MenuList$1, {
      name: "MuiMenu",
      slot: "List",
      overridesResolver: (props, styles2) => styles2.list
    })({
      // We disable the focus ring for mouse, touch and keyboard users.
      outline: 0
    });
    const Menu = /* @__PURE__ */ reactExports.forwardRef(function Menu2(inProps, ref) {
      var _slots$paper, _slotProps$paper;
      const props = useThemeProps({
        props: inProps,
        name: "MuiMenu"
      });
      const {
        autoFocus = true,
        children,
        className,
        disableAutoFocusItem = false,
        MenuListProps = {},
        onClose,
        open,
        PaperProps = {},
        PopoverClasses,
        transitionDuration = "auto",
        TransitionProps: {
          onEntering
        } = {},
        variant = "selectedMenu",
        slots = {},
        slotProps = {}
      } = props, TransitionProps = _objectWithoutPropertiesLoose$1(props.TransitionProps, _excluded$v), other = _objectWithoutPropertiesLoose$1(props, _excluded2$6);
      const theme = useTheme();
      const isRtl = theme.direction === "rtl";
      const ownerState = _extends$1({}, props, {
        autoFocus,
        disableAutoFocusItem,
        MenuListProps,
        onEntering,
        PaperProps,
        transitionDuration,
        TransitionProps,
        variant
      });
      const classes = useUtilityClasses$o(ownerState);
      const autoFocusItem = autoFocus && !disableAutoFocusItem && open;
      const menuListActionsRef = reactExports.useRef(null);
      const handleEntering = (element, isAppearing) => {
        if (menuListActionsRef.current) {
          menuListActionsRef.current.adjustStyleForScrollbar(element, theme);
        }
        if (onEntering) {
          onEntering(element, isAppearing);
        }
      };
      const handleListKeyDown = (event) => {
        if (event.key === "Tab") {
          event.preventDefault();
          if (onClose) {
            onClose(event, "tabKeyDown");
          }
        }
      };
      let activeItemIndex = -1;
      reactExports.Children.map(children, (child, index) => {
        if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
          return;
        }
        if (!child.props.disabled) {
          if (variant === "selectedMenu" && child.props.selected) {
            activeItemIndex = index;
          } else if (activeItemIndex === -1) {
            activeItemIndex = index;
          }
        }
      });
      const PaperSlot = (_slots$paper = slots.paper) != null ? _slots$paper : MenuPaper;
      const paperExternalSlotProps = (_slotProps$paper = slotProps.paper) != null ? _slotProps$paper : PaperProps;
      const rootSlotProps = useSlotProps({
        elementType: slots.root,
        externalSlotProps: slotProps.root,
        ownerState,
        className: [classes.root, className]
      });
      const paperSlotProps = useSlotProps({
        elementType: PaperSlot,
        externalSlotProps: paperExternalSlotProps,
        ownerState,
        className: classes.paper
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRoot, _extends$1({
        onClose,
        anchorOrigin: {
          vertical: "bottom",
          horizontal: isRtl ? "right" : "left"
        },
        transformOrigin: isRtl ? RTL_ORIGIN : LTR_ORIGIN,
        slots: {
          paper: PaperSlot,
          root: slots.root
        },
        slotProps: {
          root: rootSlotProps,
          paper: paperSlotProps
        },
        open,
        ref,
        transitionDuration,
        TransitionProps: _extends$1({
          onEntering: handleEntering
        }, TransitionProps),
        ownerState
      }, other, {
        classes: PopoverClasses,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuMenuList, _extends$1({
          onKeyDown: handleListKeyDown,
          actions: menuListActionsRef,
          autoFocus: autoFocus && (activeItemIndex === -1 || disableAutoFocusItem),
          autoFocusItem,
          variant
        }, MenuListProps, {
          className: clsx(classes.list, MenuListProps.className),
          children
        }))
      }));
    });
    const Menu$1 = Menu;
    function getNativeSelectUtilityClasses(slot) {
      return generateUtilityClass$1("MuiNativeSelect", slot);
    }
    const nativeSelectClasses = generateUtilityClasses$1("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
    const nativeSelectClasses$1 = nativeSelectClasses;
    const _excluded$u = ["className", "disabled", "error", "IconComponent", "inputRef", "variant"];
    const useUtilityClasses$n = (ownerState) => {
      const {
        classes,
        variant,
        disabled,
        multiple,
        open,
        error
      } = ownerState;
      const slots = {
        select: ["select", variant, disabled && "disabled", multiple && "multiple", error && "error"],
        icon: ["icon", `icon${capitalize(variant)}`, open && "iconOpen", disabled && "disabled"]
      };
      return composeClasses(slots, getNativeSelectUtilityClasses, classes);
    };
    const nativeSelectSelectStyles = ({
      ownerState,
      theme
    }) => _extends$1({
      MozAppearance: "none",
      // Reset
      WebkitAppearance: "none",
      // Reset
      // When interacting quickly, the text can end up selected.
      // Native select can't be selected either.
      userSelect: "none",
      borderRadius: 0,
      // Reset
      cursor: "pointer",
      "&:focus": _extends$1({}, theme.vars ? {
        backgroundColor: `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.05)`
      } : {
        backgroundColor: theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.05)" : "rgba(255, 255, 255, 0.05)"
      }, {
        borderRadius: 0
        // Reset Chrome style
      }),
      // Remove IE11 arrow
      "&::-ms-expand": {
        display: "none"
      },
      [`&.${nativeSelectClasses$1.disabled}`]: {
        cursor: "default"
      },
      "&[multiple]": {
        height: "auto"
      },
      "&:not([multiple]) option, &:not([multiple]) optgroup": {
        backgroundColor: (theme.vars || theme).palette.background.paper
      },
      // Bump specificity to allow extending custom inputs
      "&&&": {
        paddingRight: 24,
        minWidth: 16
        // So it doesn't collapse.
      }
    }, ownerState.variant === "filled" && {
      "&&&": {
        paddingRight: 32
      }
    }, ownerState.variant === "outlined" && {
      borderRadius: (theme.vars || theme).shape.borderRadius,
      "&:focus": {
        borderRadius: (theme.vars || theme).shape.borderRadius
        // Reset the reset for Chrome style
      },
      "&&&": {
        paddingRight: 32
      }
    });
    const NativeSelectSelect = styled("select", {
      name: "MuiNativeSelect",
      slot: "Select",
      shouldForwardProp: rootShouldForwardProp,
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.select, styles2[ownerState.variant], ownerState.error && styles2.error, {
          [`&.${nativeSelectClasses$1.multiple}`]: styles2.multiple
        }];
      }
    })(nativeSelectSelectStyles);
    const nativeSelectIconStyles = ({
      ownerState,
      theme
    }) => _extends$1({
      // We use a position absolute over a flexbox in order to forward the pointer events
      // to the input and to support wrapping tags..
      position: "absolute",
      right: 0,
      top: "calc(50% - .5em)",
      // Center vertically, height is 1em
      pointerEvents: "none",
      // Don't block pointer events on the select under the icon.
      color: (theme.vars || theme).palette.action.active,
      [`&.${nativeSelectClasses$1.disabled}`]: {
        color: (theme.vars || theme).palette.action.disabled
      }
    }, ownerState.open && {
      transform: "rotate(180deg)"
    }, ownerState.variant === "filled" && {
      right: 7
    }, ownerState.variant === "outlined" && {
      right: 7
    });
    const NativeSelectIcon = styled("svg", {
      name: "MuiNativeSelect",
      slot: "Icon",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.icon, ownerState.variant && styles2[`icon${capitalize(ownerState.variant)}`], ownerState.open && styles2.iconOpen];
      }
    })(nativeSelectIconStyles);
    const NativeSelectInput = /* @__PURE__ */ reactExports.forwardRef(function NativeSelectInput2(props, ref) {
      const {
        className,
        disabled,
        error,
        IconComponent,
        inputRef,
        variant = "standard"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$u);
      const ownerState = _extends$1({}, props, {
        disabled,
        variant,
        error
      });
      const classes = useUtilityClasses$n(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(NativeSelectSelect, _extends$1({
          ownerState,
          className: clsx(classes.select, className),
          disabled,
          ref: inputRef || ref
        }, other)), props.multiple ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(NativeSelectIcon, {
          as: IconComponent,
          ownerState,
          className: classes.icon
        })]
      });
    });
    const NativeSelectInput$1 = NativeSelectInput;
    function getSelectUtilityClasses(slot) {
      return generateUtilityClass$1("MuiSelect", slot);
    }
    const selectClasses = generateUtilityClasses$1("MuiSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
    var _span$1;
    const _excluded$t = ["aria-describedby", "aria-label", "autoFocus", "autoWidth", "children", "className", "defaultOpen", "defaultValue", "disabled", "displayEmpty", "error", "IconComponent", "inputRef", "labelId", "MenuProps", "multiple", "name", "onBlur", "onChange", "onClose", "onFocus", "onOpen", "open", "readOnly", "renderValue", "SelectDisplayProps", "tabIndex", "type", "value", "variant"];
    const SelectSelect = styled("div", {
      name: "MuiSelect",
      slot: "Select",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [
          // Win specificity over the input base
          {
            [`&.${selectClasses.select}`]: styles2.select
          },
          {
            [`&.${selectClasses.select}`]: styles2[ownerState.variant]
          },
          {
            [`&.${selectClasses.error}`]: styles2.error
          },
          {
            [`&.${selectClasses.multiple}`]: styles2.multiple
          }
        ];
      }
    })(nativeSelectSelectStyles, {
      // Win specificity over the input base
      [`&.${selectClasses.select}`]: {
        height: "auto",
        // Resets for multiple select with chips
        minHeight: "1.4375em",
        // Required for select\text-field height consistency
        textOverflow: "ellipsis",
        whiteSpace: "nowrap",
        overflow: "hidden"
      }
    });
    const SelectIcon = styled("svg", {
      name: "MuiSelect",
      slot: "Icon",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.icon, ownerState.variant && styles2[`icon${capitalize(ownerState.variant)}`], ownerState.open && styles2.iconOpen];
      }
    })(nativeSelectIconStyles);
    const SelectNativeInput = styled("input", {
      shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "classes",
      name: "MuiSelect",
      slot: "NativeInput",
      overridesResolver: (props, styles2) => styles2.nativeInput
    })({
      bottom: 0,
      left: 0,
      position: "absolute",
      opacity: 0,
      pointerEvents: "none",
      width: "100%",
      boxSizing: "border-box"
    });
    function areEqualValues(a, b2) {
      if (typeof b2 === "object" && b2 !== null) {
        return a === b2;
      }
      return String(a) === String(b2);
    }
    function isEmpty(display) {
      return display == null || typeof display === "string" && !display.trim();
    }
    const useUtilityClasses$m = (ownerState) => {
      const {
        classes,
        variant,
        disabled,
        multiple,
        open,
        error
      } = ownerState;
      const slots = {
        select: ["select", variant, disabled && "disabled", multiple && "multiple", error && "error"],
        icon: ["icon", `icon${capitalize(variant)}`, open && "iconOpen", disabled && "disabled"],
        nativeInput: ["nativeInput"]
      };
      return composeClasses(slots, getSelectUtilityClasses, classes);
    };
    const SelectInput = /* @__PURE__ */ reactExports.forwardRef(function SelectInput2(props, ref) {
      var _MenuProps$slotProps;
      const {
        "aria-describedby": ariaDescribedby,
        "aria-label": ariaLabel,
        autoFocus,
        autoWidth,
        children,
        className,
        defaultOpen,
        defaultValue,
        disabled,
        displayEmpty,
        error = false,
        IconComponent,
        inputRef: inputRefProp,
        labelId,
        MenuProps = {},
        multiple,
        name,
        onBlur,
        onChange,
        onClose,
        onFocus,
        onOpen,
        open: openProp,
        readOnly,
        renderValue,
        SelectDisplayProps = {},
        tabIndex: tabIndexProp,
        value: valueProp,
        variant = "standard"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$t);
      const [value, setValueState] = useControlled({
        controlled: valueProp,
        default: defaultValue,
        name: "Select"
      });
      const [openState, setOpenState] = useControlled({
        controlled: openProp,
        default: defaultOpen,
        name: "Select"
      });
      const inputRef = reactExports.useRef(null);
      const displayRef = reactExports.useRef(null);
      const [displayNode, setDisplayNode] = reactExports.useState(null);
      const {
        current: isOpenControlled
      } = reactExports.useRef(openProp != null);
      const [menuMinWidthState, setMenuMinWidthState] = reactExports.useState();
      const handleRef = useForkRef(ref, inputRefProp);
      const handleDisplayRef = reactExports.useCallback((node2) => {
        displayRef.current = node2;
        if (node2) {
          setDisplayNode(node2);
        }
      }, []);
      const anchorElement = displayNode == null ? void 0 : displayNode.parentNode;
      reactExports.useImperativeHandle(handleRef, () => ({
        focus: () => {
          displayRef.current.focus();
        },
        node: inputRef.current,
        value
      }), [value]);
      reactExports.useEffect(() => {
        if (defaultOpen && openState && displayNode && !isOpenControlled) {
          setMenuMinWidthState(autoWidth ? null : anchorElement.clientWidth);
          displayRef.current.focus();
        }
      }, [displayNode, autoWidth]);
      reactExports.useEffect(() => {
        if (autoFocus) {
          displayRef.current.focus();
        }
      }, [autoFocus]);
      reactExports.useEffect(() => {
        if (!labelId) {
          return void 0;
        }
        const label = ownerDocument(displayRef.current).getElementById(labelId);
        if (label) {
          const handler = () => {
            if (getSelection().isCollapsed) {
              displayRef.current.focus();
            }
          };
          label.addEventListener("click", handler);
          return () => {
            label.removeEventListener("click", handler);
          };
        }
        return void 0;
      }, [labelId]);
      const update = (open2, event) => {
        if (open2) {
          if (onOpen) {
            onOpen(event);
          }
        } else if (onClose) {
          onClose(event);
        }
        if (!isOpenControlled) {
          setMenuMinWidthState(autoWidth ? null : anchorElement.clientWidth);
          setOpenState(open2);
        }
      };
      const handleMouseDown = (event) => {
        if (event.button !== 0) {
          return;
        }
        event.preventDefault();
        displayRef.current.focus();
        update(true, event);
      };
      const handleClose = (event) => {
        update(false, event);
      };
      const childrenArray = reactExports.Children.toArray(children);
      const handleChange = (event) => {
        const child = childrenArray.find((childItem) => childItem.props.value === event.target.value);
        if (child === void 0) {
          return;
        }
        setValueState(child.props.value);
        if (onChange) {
          onChange(event, child);
        }
      };
      const handleItemClick = (child) => (event) => {
        let newValue;
        if (!event.currentTarget.hasAttribute("tabindex")) {
          return;
        }
        if (multiple) {
          newValue = Array.isArray(value) ? value.slice() : [];
          const itemIndex = value.indexOf(child.props.value);
          if (itemIndex === -1) {
            newValue.push(child.props.value);
          } else {
            newValue.splice(itemIndex, 1);
          }
        } else {
          newValue = child.props.value;
        }
        if (child.props.onClick) {
          child.props.onClick(event);
        }
        if (value !== newValue) {
          setValueState(newValue);
          if (onChange) {
            const nativeEvent = event.nativeEvent || event;
            const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
            Object.defineProperty(clonedEvent, "target", {
              writable: true,
              value: {
                value: newValue,
                name
              }
            });
            onChange(clonedEvent, child);
          }
        }
        if (!multiple) {
          update(false, event);
        }
      };
      const handleKeyDown2 = (event) => {
        if (!readOnly) {
          const validKeys = [
            " ",
            "ArrowUp",
            "ArrowDown",
            // The native select doesn't respond to enter on macOS, but it's recommended by
            // https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/
            "Enter"
          ];
          if (validKeys.indexOf(event.key) !== -1) {
            event.preventDefault();
            update(true, event);
          }
        }
      };
      const open = displayNode !== null && openState;
      const handleBlur = (event) => {
        if (!open && onBlur) {
          Object.defineProperty(event, "target", {
            writable: true,
            value: {
              value,
              name
            }
          });
          onBlur(event);
        }
      };
      delete other["aria-invalid"];
      let display;
      let displaySingle;
      const displayMultiple = [];
      let computeDisplay = false;
      if (isFilled({
        value
      }) || displayEmpty) {
        if (renderValue) {
          display = renderValue(value);
        } else {
          computeDisplay = true;
        }
      }
      const items = childrenArray.map((child) => {
        if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
          return null;
        }
        let selected;
        if (multiple) {
          if (!Array.isArray(value)) {
            throw new Error(formatMuiErrorMessage(2));
          }
          selected = value.some((v2) => areEqualValues(v2, child.props.value));
          if (selected && computeDisplay) {
            displayMultiple.push(child.props.children);
          }
        } else {
          selected = areEqualValues(value, child.props.value);
          if (selected && computeDisplay) {
            displaySingle = child.props.children;
          }
        }
        return /* @__PURE__ */ reactExports.cloneElement(child, {
          "aria-selected": selected ? "true" : "false",
          onClick: handleItemClick(child),
          onKeyUp: (event) => {
            if (event.key === " ") {
              event.preventDefault();
            }
            if (child.props.onKeyUp) {
              child.props.onKeyUp(event);
            }
          },
          role: "option",
          selected,
          value: void 0,
          // The value is most likely not a valid HTML attribute.
          "data-value": child.props.value
          // Instead, we provide it as a data attribute.
        });
      });
      if (computeDisplay) {
        if (multiple) {
          if (displayMultiple.length === 0) {
            display = null;
          } else {
            display = displayMultiple.reduce((output, child, index) => {
              output.push(child);
              if (index < displayMultiple.length - 1) {
                output.push(", ");
              }
              return output;
            }, []);
          }
        } else {
          display = displaySingle;
        }
      }
      let menuMinWidth = menuMinWidthState;
      if (!autoWidth && isOpenControlled && displayNode) {
        menuMinWidth = anchorElement.clientWidth;
      }
      let tabIndex;
      if (typeof tabIndexProp !== "undefined") {
        tabIndex = tabIndexProp;
      } else {
        tabIndex = disabled ? null : 0;
      }
      const buttonId = SelectDisplayProps.id || (name ? `mui-component-select-${name}` : void 0);
      const ownerState = _extends$1({}, props, {
        variant,
        value,
        open,
        error
      });
      const classes = useUtilityClasses$m(ownerState);
      const paperProps = _extends$1({}, MenuProps.PaperProps, (_MenuProps$slotProps = MenuProps.slotProps) == null ? void 0 : _MenuProps$slotProps.paper);
      const listboxId = useId();
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SelectSelect, _extends$1({
          ref: handleDisplayRef,
          tabIndex,
          role: "combobox",
          "aria-controls": listboxId,
          "aria-disabled": disabled ? "true" : void 0,
          "aria-expanded": open ? "true" : "false",
          "aria-haspopup": "listbox",
          "aria-label": ariaLabel,
          "aria-labelledby": [labelId, buttonId].filter(Boolean).join(" ") || void 0,
          "aria-describedby": ariaDescribedby,
          onKeyDown: handleKeyDown2,
          onMouseDown: disabled || readOnly ? null : handleMouseDown,
          onBlur: handleBlur,
          onFocus
        }, SelectDisplayProps, {
          ownerState,
          className: clsx(SelectDisplayProps.className, classes.select, className),
          id: buttonId,
          children: isEmpty(display) ? (
            // notranslate needed while Google Translate will not fix zero-width space issue
            _span$1 || (_span$1 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
              className: "notranslate",
              children: "​"
            }))
          ) : display
        })), /* @__PURE__ */ jsxRuntimeExports.jsx(SelectNativeInput, _extends$1({
          "aria-invalid": error,
          value: Array.isArray(value) ? value.join(",") : value,
          name,
          ref: inputRef,
          "aria-hidden": true,
          onChange: handleChange,
          tabIndex: -1,
          disabled,
          className: classes.nativeInput,
          autoFocus,
          ownerState
        }, other)), /* @__PURE__ */ jsxRuntimeExports.jsx(SelectIcon, {
          as: IconComponent,
          className: classes.icon,
          ownerState
        }), /* @__PURE__ */ jsxRuntimeExports.jsx(Menu$1, _extends$1({
          id: `menu-${name || ""}`,
          anchorEl: anchorElement,
          open,
          onClose: handleClose,
          anchorOrigin: {
            vertical: "bottom",
            horizontal: "center"
          },
          transformOrigin: {
            vertical: "top",
            horizontal: "center"
          }
        }, MenuProps, {
          MenuListProps: _extends$1({
            "aria-labelledby": labelId,
            role: "listbox",
            "aria-multiselectable": multiple ? "true" : void 0,
            disableListWrap: true,
            id: listboxId
          }, MenuProps.MenuListProps),
          slotProps: _extends$1({}, MenuProps.slotProps, {
            paper: _extends$1({}, paperProps, {
              style: _extends$1({
                minWidth: menuMinWidth
              }, paperProps != null ? paperProps.style : null)
            })
          }),
          children: items
        }))]
      });
    });
    const SelectInput$1 = SelectInput;
    const ArrowDropDownIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      d: "M7 10l5 5 5-5z"
    }), "ArrowDropDown");
    const _excluded$s = ["autoWidth", "children", "classes", "className", "defaultOpen", "displayEmpty", "IconComponent", "id", "input", "inputProps", "label", "labelId", "MenuProps", "multiple", "native", "onClose", "onOpen", "open", "renderValue", "SelectDisplayProps", "variant"], _excluded2$5 = ["root"];
    const useUtilityClasses$l = (ownerState) => {
      const {
        classes
      } = ownerState;
      return classes;
    };
    const styledRootConfig = {
      name: "MuiSelect",
      overridesResolver: (props, styles2) => styles2.root,
      shouldForwardProp: (prop) => rootShouldForwardProp(prop) && prop !== "variant",
      slot: "Root"
    };
    const StyledInput = styled(Input$1, styledRootConfig)("");
    const StyledOutlinedInput = styled(OutlinedInput$1, styledRootConfig)("");
    const StyledFilledInput = styled(FilledInput$1, styledRootConfig)("");
    const Select = /* @__PURE__ */ reactExports.forwardRef(function Select2(inProps, ref) {
      const props = useThemeProps({
        name: "MuiSelect",
        props: inProps
      });
      const {
        autoWidth = false,
        children,
        classes: classesProp = {},
        className,
        defaultOpen = false,
        displayEmpty = false,
        IconComponent = ArrowDropDownIcon,
        id: id2,
        input,
        inputProps,
        label,
        labelId,
        MenuProps,
        multiple = false,
        native = false,
        onClose,
        onOpen,
        open,
        renderValue,
        SelectDisplayProps,
        variant: variantProp = "outlined"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$s);
      const inputComponent = native ? NativeSelectInput$1 : SelectInput$1;
      const muiFormControl = useFormControl();
      const fcs = formControlState({
        props,
        muiFormControl,
        states: ["variant", "error"]
      });
      const variant = fcs.variant || variantProp;
      const ownerState = _extends$1({}, props, {
        variant,
        classes: classesProp
      });
      const classes = useUtilityClasses$l(ownerState);
      const restOfClasses = _objectWithoutPropertiesLoose$1(classes, _excluded2$5);
      const InputComponent = input || {
        standard: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledInput, {
          ownerState
        }),
        outlined: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledOutlinedInput, {
          label,
          ownerState
        }),
        filled: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledFilledInput, {
          ownerState
        })
      }[variant];
      const inputComponentRef = useForkRef(ref, InputComponent.ref);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
        children: /* @__PURE__ */ reactExports.cloneElement(InputComponent, _extends$1({
          // Most of the logic is implemented in `SelectInput`.
          // The `Select` component is a simple API wrapper to expose something better to play with.
          inputComponent,
          inputProps: _extends$1({
            children,
            error: fcs.error,
            IconComponent,
            variant,
            type: void 0,
            // We render a select. We can ignore the type provided by the `Input`.
            multiple
          }, native ? {
            id: id2
          } : {
            autoWidth,
            defaultOpen,
            displayEmpty,
            labelId,
            MenuProps,
            onClose,
            onOpen,
            open,
            renderValue,
            SelectDisplayProps: _extends$1({
              id: id2
            }, SelectDisplayProps)
          }, inputProps, {
            classes: inputProps ? deepmerge(restOfClasses, inputProps.classes) : restOfClasses
          }, input ? input.props.inputProps : {})
        }, (multiple && native || displayEmpty) && variant === "outlined" ? {
          notched: true
        } : {}, {
          ref: inputComponentRef,
          className: clsx(InputComponent.props.className, className, classes.root)
        }, !input && {
          variant
        }, other))
      });
    });
    Select.muiName = "Select";
    const Select$1 = Select;
    function getTextFieldUtilityClass(slot) {
      return generateUtilityClass$1("MuiTextField", slot);
    }
    generateUtilityClasses$1("MuiTextField", ["root"]);
    const _excluded$r = ["autoComplete", "autoFocus", "children", "className", "color", "defaultValue", "disabled", "error", "FormHelperTextProps", "fullWidth", "helperText", "id", "InputLabelProps", "inputProps", "InputProps", "inputRef", "label", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onFocus", "placeholder", "required", "rows", "select", "SelectProps", "type", "value", "variant"];
    const variantComponent = {
      standard: Input$1,
      filled: FilledInput$1,
      outlined: OutlinedInput$1
    };
    const useUtilityClasses$k = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"]
      };
      return composeClasses(slots, getTextFieldUtilityClass, classes);
    };
    const TextFieldRoot = styled(FormControl$1, {
      name: "MuiTextField",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })({});
    const TextField = /* @__PURE__ */ reactExports.forwardRef(function TextField2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiTextField"
      });
      const {
        autoComplete,
        autoFocus = false,
        children,
        className,
        color: color2 = "primary",
        defaultValue,
        disabled = false,
        error = false,
        FormHelperTextProps,
        fullWidth = false,
        helperText,
        id: idOverride,
        InputLabelProps,
        inputProps,
        InputProps,
        inputRef,
        label,
        maxRows,
        minRows,
        multiline = false,
        name,
        onBlur,
        onChange,
        onFocus,
        placeholder,
        required = false,
        rows,
        select = false,
        SelectProps,
        type,
        value,
        variant = "outlined"
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$r);
      const ownerState = _extends$1({}, props, {
        autoFocus,
        color: color2,
        disabled,
        error,
        fullWidth,
        multiline,
        required,
        select,
        variant
      });
      const classes = useUtilityClasses$k(ownerState);
      const InputMore = {};
      if (variant === "outlined") {
        if (InputLabelProps && typeof InputLabelProps.shrink !== "undefined") {
          InputMore.notched = InputLabelProps.shrink;
        }
        InputMore.label = label;
      }
      if (select) {
        if (!SelectProps || !SelectProps.native) {
          InputMore.id = void 0;
        }
        InputMore["aria-describedby"] = void 0;
      }
      const id2 = useId(idOverride);
      const helperTextId = helperText && id2 ? `${id2}-helper-text` : void 0;
      const inputLabelId = label && id2 ? `${id2}-label` : void 0;
      const InputComponent = variantComponent[variant];
      const InputElement = /* @__PURE__ */ jsxRuntimeExports.jsx(InputComponent, _extends$1({
        "aria-describedby": helperTextId,
        autoComplete,
        autoFocus,
        defaultValue,
        fullWidth,
        multiline,
        name,
        rows,
        maxRows,
        minRows,
        type,
        value,
        id: id2,
        inputRef,
        onBlur,
        onChange,
        onFocus,
        placeholder,
        inputProps
      }, InputMore, InputProps));
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(TextFieldRoot, _extends$1({
        className: clsx(classes.root, className),
        disabled,
        error,
        fullWidth,
        ref,
        required,
        color: color2,
        variant,
        ownerState
      }, other, {
        children: [label != null && label !== "" && /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel$1, _extends$1({
          htmlFor: id2,
          id: inputLabelId
        }, InputLabelProps, {
          children: label
        })), select ? /* @__PURE__ */ jsxRuntimeExports.jsx(Select$1, _extends$1({
          "aria-describedby": helperTextId,
          id: id2,
          labelId: inputLabelId,
          value,
          input: InputElement
        }, SelectProps, {
          children
        })) : InputElement, helperText && /* @__PURE__ */ jsxRuntimeExports.jsx(FormHelperText$1, _extends$1({
          id: helperTextId
        }, FormHelperTextProps, {
          children: helperText
        }))]
      }));
    });
    const MuiTextField = TextField;
    const _excluded$q = ["localeText"];
    const MuiPickersAdapterContext = /* @__PURE__ */ reactExports.createContext(null);
    const LocalizationProvider = function LocalizationProvider2(inProps) {
      var _React$useContext;
      const {
        localeText: inLocaleText
      } = inProps, otherInProps = _objectWithoutPropertiesLoose$1(inProps, _excluded$q);
      const {
        utils: parentUtils,
        localeText: parentLocaleText
      } = (_React$useContext = reactExports.useContext(MuiPickersAdapterContext)) != null ? _React$useContext : {
        utils: void 0,
        localeText: void 0
      };
      const props = useThemeProps({
        // We don't want to pass the `localeText` prop to the theme, that way it will always return the theme value,
        // We will then merge this theme value with our value manually
        props: otherInProps,
        name: "MuiLocalizationProvider"
      });
      const {
        children,
        dateAdapter: DateAdapter,
        dateFormats,
        dateLibInstance,
        adapterLocale,
        localeText: themeLocaleText
      } = props;
      const localeText = reactExports.useMemo(() => _extends$1({}, themeLocaleText, parentLocaleText, inLocaleText), [themeLocaleText, parentLocaleText, inLocaleText]);
      const utils2 = reactExports.useMemo(() => {
        if (!DateAdapter) {
          if (parentUtils) {
            return parentUtils;
          }
          return null;
        }
        const adapter = new DateAdapter({
          locale: adapterLocale,
          formats: dateFormats,
          instance: dateLibInstance
        });
        if (!adapter.isMUIAdapter) {
          throw new Error(["MUI: The date adapter should be imported from `@mui/x-date-pickers` or `@mui/x-date-pickers-pro`, not from `@date-io`", "For example, `import { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs'` instead of `import AdapterDayjs from '@date-io/dayjs'`", "More information on the installation documentation: https://mui.com/x/react-date-pickers/getting-started/#installation"].join(`
`));
        }
        return adapter;
      }, [DateAdapter, adapterLocale, dateFormats, dateLibInstance, parentUtils]);
      const defaultDates = reactExports.useMemo(() => {
        if (!utils2) {
          return null;
        }
        return {
          minDate: utils2.date("1900-01-01T00:00:00.000"),
          maxDate: utils2.date("2099-12-31T00:00:00.000")
        };
      }, [utils2]);
      const contextValue = reactExports.useMemo(() => {
        return {
          utils: utils2,
          defaultDates,
          localeText
        };
      }, [defaultDates, utils2, localeText]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(MuiPickersAdapterContext.Provider, {
        value: contextValue,
        children
      });
    };
    const getPickersLocalization = (pickersTranslations) => {
      return {
        components: {
          MuiLocalizationProvider: {
            defaultProps: {
              localeText: _extends$1({}, pickersTranslations)
            }
          }
        }
      };
    };
    const enUSPickers = {
      // Calendar navigation
      previousMonth: "Previous month",
      nextMonth: "Next month",
      // View navigation
      openPreviousView: "open previous view",
      openNextView: "open next view",
      calendarViewSwitchingButtonAriaLabel: (view) => view === "year" ? "year view is open, switch to calendar view" : "calendar view is open, switch to year view",
      // DateRange placeholders
      start: "Start",
      end: "End",
      // Action bar
      cancelButtonLabel: "Cancel",
      clearButtonLabel: "Clear",
      okButtonLabel: "OK",
      todayButtonLabel: "Today",
      // Toolbar titles
      datePickerToolbarTitle: "Select date",
      dateTimePickerToolbarTitle: "Select date & time",
      timePickerToolbarTitle: "Select time",
      dateRangePickerToolbarTitle: "Select date range",
      // Clock labels
      clockLabelText: (view, time2, adapter) => `Select ${view}. ${time2 === null ? "No time selected" : `Selected time is ${adapter.format(time2, "fullTime")}`}`,
      hoursClockNumberText: (hours) => `${hours} hours`,
      minutesClockNumberText: (minutes) => `${minutes} minutes`,
      secondsClockNumberText: (seconds) => `${seconds} seconds`,
      // Digital clock labels
      selectViewText: (view) => `Select ${view}`,
      // Calendar labels
      calendarWeekNumberHeaderLabel: "Week number",
      calendarWeekNumberHeaderText: "#",
      calendarWeekNumberAriaLabelText: (weekNumber) => `Week ${weekNumber}`,
      calendarWeekNumberText: (weekNumber) => `${weekNumber}`,
      // Open picker labels
      openDatePickerDialogue: (value, utils2) => value !== null && utils2.isValid(value) ? `Choose date, selected date is ${utils2.format(value, "fullDate")}` : "Choose date",
      openTimePickerDialogue: (value, utils2) => value !== null && utils2.isValid(value) ? `Choose time, selected time is ${utils2.format(value, "fullTime")}` : "Choose time",
      fieldClearLabel: "Clear value",
      // Table labels
      timeTableLabel: "pick time",
      dateTableLabel: "pick date",
      // Field section placeholders
      fieldYearPlaceholder: (params) => "Y".repeat(params.digitAmount),
      fieldMonthPlaceholder: (params) => params.contentType === "letter" ? "MMMM" : "MM",
      fieldDayPlaceholder: () => "DD",
      fieldWeekDayPlaceholder: (params) => params.contentType === "letter" ? "EEEE" : "EE",
      fieldHoursPlaceholder: () => "hh",
      fieldMinutesPlaceholder: () => "mm",
      fieldSecondsPlaceholder: () => "ss",
      fieldMeridiemPlaceholder: () => "aa"
    };
    const DEFAULT_LOCALE = enUSPickers;
    getPickersLocalization(enUSPickers);
    const useLocalizationContext = () => {
      const localization = reactExports.useContext(MuiPickersAdapterContext);
      if (localization === null) {
        throw new Error(["MUI: Can not find the date and time pickers localization context.", "It looks like you forgot to wrap your component in LocalizationProvider.", "This can also happen if you are bundling multiple versions of the `@mui/x-date-pickers` package"].join("\n"));
      }
      if (localization.utils === null) {
        throw new Error(["MUI: Can not find the date and time pickers adapter from its localization context.", "It looks like you forgot to pass a `dateAdapter` to your LocalizationProvider."].join("\n"));
      }
      const localeText = reactExports.useMemo(() => _extends$1({}, DEFAULT_LOCALE, localization.localeText), [localization.localeText]);
      return reactExports.useMemo(() => _extends$1({}, localization, {
        localeText
      }), [localization, localeText]);
    };
    const useUtils = () => useLocalizationContext().utils;
    const useLocaleText = () => useLocalizationContext().localeText;
    const useNow = (timezone) => {
      const utils2 = useUtils();
      const now2 = reactExports.useRef();
      if (now2.current === void 0) {
        now2.current = utils2.dateWithTimezone(void 0, timezone);
      }
      return now2.current;
    };
    function useValidation(props, validate, isSameError, defaultErrorState) {
      const {
        value,
        onError
      } = props;
      const adapter = useLocalizationContext();
      const previousValidationErrorRef = reactExports.useRef(defaultErrorState);
      const validationError = validate({
        adapter,
        value,
        props
      });
      reactExports.useEffect(() => {
        if (onError && !isSameError(validationError, previousValidationErrorRef.current)) {
          onError(validationError, value);
        }
        previousValidationErrorRef.current = validationError;
      }, [isSameError, onError, previousValidationErrorRef, validationError, value]);
      return validationError;
    }
    const useValueWithTimezone = ({
      timezone: timezoneProp,
      value: valueProp,
      defaultValue,
      onChange,
      valueManager
    }) => {
      var _ref, _ref2;
      const utils2 = useUtils();
      const firstDefaultValue = reactExports.useRef(defaultValue);
      const inputValue = (_ref = valueProp != null ? valueProp : firstDefaultValue.current) != null ? _ref : valueManager.emptyValue;
      const inputTimezone = reactExports.useMemo(() => valueManager.getTimezone(utils2, inputValue), [utils2, valueManager, inputValue]);
      const setInputTimezone = useEventCallback((newValue) => {
        if (inputTimezone == null) {
          return newValue;
        }
        return valueManager.setTimezone(utils2, inputTimezone, newValue);
      });
      const timezoneToRender = (_ref2 = timezoneProp != null ? timezoneProp : inputTimezone) != null ? _ref2 : "default";
      const valueWithTimezoneToRender = reactExports.useMemo(() => valueManager.setTimezone(utils2, timezoneToRender, inputValue), [valueManager, utils2, timezoneToRender, inputValue]);
      const handleValueChange = useEventCallback((newValue, ...otherParams) => {
        const newValueWithInputTimezone = setInputTimezone(newValue);
        onChange == null || onChange(newValueWithInputTimezone, ...otherParams);
      });
      return {
        value: valueWithTimezoneToRender,
        handleValueChange,
        timezone: timezoneToRender
      };
    };
    const useControlledValueWithTimezone = ({
      name,
      timezone: timezoneProp,
      value: valueProp,
      defaultValue,
      onChange: onChangeProp,
      valueManager
    }) => {
      const [valueWithInputTimezone, setValue] = useControlled({
        name,
        state: "value",
        controlled: valueProp,
        default: defaultValue != null ? defaultValue : valueManager.emptyValue
      });
      const onChange = useEventCallback((newValue, ...otherParams) => {
        setValue(newValue);
        onChangeProp == null || onChangeProp(newValue, ...otherParams);
      });
      return useValueWithTimezone({
        timezone: timezoneProp,
        value: valueWithInputTimezone,
        defaultValue: void 0,
        onChange,
        valueManager
      });
    };
    const useFieldState = (params) => {
      const utils2 = useUtils();
      const localeText = useLocaleText();
      const adapter = useLocalizationContext();
      const theme = useTheme();
      const isRTL = theme.direction === "rtl";
      const {
        valueManager,
        fieldValueManager,
        valueType,
        validator: validator2,
        internalProps,
        internalProps: {
          value: valueProp,
          defaultValue,
          referenceDate: referenceDateProp,
          onChange,
          format,
          formatDensity = "dense",
          selectedSections: selectedSectionsProp,
          onSelectedSectionsChange,
          shouldRespectLeadingZeros = false,
          timezone: timezoneProp
        }
      } = params;
      const {
        timezone,
        value: valueFromTheOutside,
        handleValueChange
      } = useValueWithTimezone({
        timezone: timezoneProp,
        value: valueProp,
        defaultValue,
        onChange,
        valueManager
      });
      const sectionsValueBoundaries = reactExports.useMemo(() => getSectionsBoundaries(utils2, timezone), [utils2, timezone]);
      const getSectionsFromValue = reactExports.useCallback((value, fallbackSections = null) => fieldValueManager.getSectionsFromValue(utils2, value, fallbackSections, isRTL, (date2) => splitFormatIntoSections(utils2, timezone, localeText, format, date2, formatDensity, shouldRespectLeadingZeros, isRTL)), [fieldValueManager, format, localeText, isRTL, shouldRespectLeadingZeros, utils2, formatDensity, timezone]);
      const placeholder = reactExports.useMemo(() => fieldValueManager.getValueStrFromSections(getSectionsFromValue(valueManager.emptyValue), isRTL), [fieldValueManager, getSectionsFromValue, valueManager.emptyValue, isRTL]);
      const [state, setState] = reactExports.useState(() => {
        const sections = getSectionsFromValue(valueFromTheOutside);
        const stateWithoutReferenceDate = {
          sections,
          value: valueFromTheOutside,
          referenceValue: valueManager.emptyValue,
          tempValueStrAndroid: null
        };
        const granularity = getSectionTypeGranularity(sections);
        const referenceValue = valueManager.getInitialReferenceValue({
          referenceDate: referenceDateProp,
          value: valueFromTheOutside,
          utils: utils2,
          props: internalProps,
          granularity,
          timezone
        });
        return _extends$1({}, stateWithoutReferenceDate, {
          referenceValue
        });
      });
      const [selectedSections, innerSetSelectedSections] = useControlled({
        controlled: selectedSectionsProp,
        default: null,
        name: "useField",
        state: "selectedSectionIndexes"
      });
      const setSelectedSections = (newSelectedSections) => {
        innerSetSelectedSections(newSelectedSections);
        onSelectedSectionsChange == null || onSelectedSectionsChange(newSelectedSections);
        setState((prevState) => _extends$1({}, prevState, {
          selectedSectionQuery: null
        }));
      };
      const selectedSectionIndexes = reactExports.useMemo(() => {
        if (selectedSections == null) {
          return null;
        }
        if (selectedSections === "all") {
          return {
            startIndex: 0,
            endIndex: state.sections.length - 1,
            shouldSelectBoundarySelectors: true
          };
        }
        if (typeof selectedSections === "number") {
          return {
            startIndex: selectedSections,
            endIndex: selectedSections
          };
        }
        if (typeof selectedSections === "string") {
          const selectedSectionIndex = state.sections.findIndex((section) => section.type === selectedSections);
          return {
            startIndex: selectedSectionIndex,
            endIndex: selectedSectionIndex
          };
        }
        return selectedSections;
      }, [selectedSections, state.sections]);
      const publishValue = ({
        value,
        referenceValue,
        sections
      }) => {
        setState((prevState) => _extends$1({}, prevState, {
          sections,
          value,
          referenceValue,
          tempValueStrAndroid: null
        }));
        if (valueManager.areValuesEqual(utils2, state.value, value)) {
          return;
        }
        const context = {
          validationError: validator2({
            adapter,
            value,
            props: _extends$1({}, internalProps, {
              value,
              timezone
            })
          })
        };
        handleValueChange(value, context);
      };
      const setSectionValue = (sectionIndex, newSectionValue) => {
        const newSections = [...state.sections];
        newSections[sectionIndex] = _extends$1({}, newSections[sectionIndex], {
          value: newSectionValue,
          modified: true
        });
        return addPositionPropertiesToSections(newSections, isRTL);
      };
      const clearValue = () => {
        publishValue({
          value: valueManager.emptyValue,
          referenceValue: state.referenceValue,
          sections: getSectionsFromValue(valueManager.emptyValue)
        });
      };
      const clearActiveSection = () => {
        if (selectedSectionIndexes == null) {
          return;
        }
        const activeSection = state.sections[selectedSectionIndexes.startIndex];
        const activeDateManager = fieldValueManager.getActiveDateManager(utils2, state, activeSection);
        const nonEmptySectionCountBefore = activeDateManager.getSections(state.sections).filter((section) => section.value !== "").length;
        const hasNoOtherNonEmptySections = nonEmptySectionCountBefore === (activeSection.value === "" ? 0 : 1);
        const newSections = setSectionValue(selectedSectionIndexes.startIndex, "");
        const newActiveDate = hasNoOtherNonEmptySections ? null : utils2.date(/* @__PURE__ */ new Date(""));
        const newValues = activeDateManager.getNewValuesFromNewActiveDate(newActiveDate);
        if ((newActiveDate != null && !utils2.isValid(newActiveDate)) !== (activeDateManager.date != null && !utils2.isValid(activeDateManager.date))) {
          publishValue(_extends$1({}, newValues, {
            sections: newSections
          }));
        } else {
          setState((prevState) => _extends$1({}, prevState, newValues, {
            sections: newSections,
            tempValueStrAndroid: null
          }));
        }
      };
      const updateValueFromValueStr = (valueStr) => {
        const parseDateStr = (dateStr, referenceDate) => {
          const date2 = utils2.parse(dateStr, format);
          if (date2 == null || !utils2.isValid(date2)) {
            return null;
          }
          const sections = splitFormatIntoSections(utils2, timezone, localeText, format, date2, formatDensity, shouldRespectLeadingZeros, isRTL);
          return mergeDateIntoReferenceDate(utils2, timezone, date2, sections, referenceDate, false);
        };
        const newValue = fieldValueManager.parseValueStr(valueStr, state.referenceValue, parseDateStr);
        const newReferenceValue = fieldValueManager.updateReferenceValue(utils2, newValue, state.referenceValue);
        publishValue({
          value: newValue,
          referenceValue: newReferenceValue,
          sections: getSectionsFromValue(newValue, state.sections)
        });
      };
      const updateSectionValue = ({
        activeSection,
        newSectionValue,
        shouldGoToNextSection
      }) => {
        if (shouldGoToNextSection && selectedSectionIndexes && selectedSectionIndexes.startIndex < state.sections.length - 1) {
          setSelectedSections(selectedSectionIndexes.startIndex + 1);
        } else if (selectedSectionIndexes && selectedSectionIndexes.startIndex !== selectedSectionIndexes.endIndex) {
          setSelectedSections(selectedSectionIndexes.startIndex);
        }
        const activeDateManager = fieldValueManager.getActiveDateManager(utils2, state, activeSection);
        const newSections = setSectionValue(selectedSectionIndexes.startIndex, newSectionValue);
        const newActiveDateSections = activeDateManager.getSections(newSections);
        const newActiveDate = getDateFromDateSections(utils2, newActiveDateSections);
        let values2;
        let shouldPublish;
        if (newActiveDate != null && utils2.isValid(newActiveDate)) {
          const mergedDate = mergeDateIntoReferenceDate(utils2, timezone, newActiveDate, newActiveDateSections, activeDateManager.referenceDate, true);
          values2 = activeDateManager.getNewValuesFromNewActiveDate(mergedDate);
          shouldPublish = true;
        } else {
          values2 = activeDateManager.getNewValuesFromNewActiveDate(newActiveDate);
          shouldPublish = (newActiveDate != null && !utils2.isValid(newActiveDate)) !== (activeDateManager.date != null && !utils2.isValid(activeDateManager.date));
        }
        if (shouldPublish) {
          return publishValue(_extends$1({}, values2, {
            sections: newSections
          }));
        }
        return setState((prevState) => _extends$1({}, prevState, values2, {
          sections: newSections,
          tempValueStrAndroid: null
        }));
      };
      const setTempAndroidValueStr = (tempValueStrAndroid) => setState((prev2) => _extends$1({}, prev2, {
        tempValueStrAndroid
      }));
      reactExports.useEffect(() => {
        const sections = getSectionsFromValue(state.value);
        setState((prevState) => _extends$1({}, prevState, {
          sections
        }));
      }, [format, utils2.locale]);
      reactExports.useEffect(() => {
        let shouldUpdate = false;
        if (!valueManager.areValuesEqual(utils2, state.value, valueFromTheOutside)) {
          shouldUpdate = true;
        } else {
          shouldUpdate = valueManager.getTimezone(utils2, state.value) !== valueManager.getTimezone(utils2, valueFromTheOutside);
        }
        if (shouldUpdate) {
          setState((prevState) => _extends$1({}, prevState, {
            value: valueFromTheOutside,
            referenceValue: fieldValueManager.updateReferenceValue(utils2, valueFromTheOutside, prevState.referenceValue),
            sections: getSectionsFromValue(valueFromTheOutside)
          }));
        }
      }, [valueFromTheOutside]);
      return {
        state,
        selectedSectionIndexes,
        setSelectedSections,
        clearValue,
        clearActiveSection,
        updateSectionValue,
        updateValueFromValueStr,
        setTempAndroidValueStr,
        sectionsValueBoundaries,
        placeholder,
        timezone
      };
    };
    const QUERY_LIFE_DURATION_MS = 5e3;
    const isQueryResponseWithoutValue = (response) => response.saveQuery != null;
    const useFieldCharacterEditing = ({
      sections,
      updateSectionValue,
      sectionsValueBoundaries,
      setTempAndroidValueStr,
      timezone
    }) => {
      const utils2 = useUtils();
      const [query, setQuery] = reactExports.useState(null);
      const resetQuery = useEventCallback(() => setQuery(null));
      reactExports.useEffect(() => {
        var _sections$query$secti;
        if (query != null && ((_sections$query$secti = sections[query.sectionIndex]) == null ? void 0 : _sections$query$secti.type) !== query.sectionType) {
          resetQuery();
        }
      }, [sections, query, resetQuery]);
      reactExports.useEffect(() => {
        if (query != null) {
          const timeout = setTimeout(() => resetQuery(), QUERY_LIFE_DURATION_MS);
          return () => {
            window.clearTimeout(timeout);
          };
        }
        return () => {
        };
      }, [query, resetQuery]);
      const applyQuery = ({
        keyPressed,
        sectionIndex
      }, getFirstSectionValueMatchingWithQuery, isValidQueryValue) => {
        const cleanKeyPressed = keyPressed.toLowerCase();
        const activeSection = sections[sectionIndex];
        if (query != null && (!isValidQueryValue || isValidQueryValue(query.value)) && query.sectionIndex === sectionIndex) {
          const concatenatedQueryValue = `${query.value}${cleanKeyPressed}`;
          const queryResponse2 = getFirstSectionValueMatchingWithQuery(concatenatedQueryValue, activeSection);
          if (!isQueryResponseWithoutValue(queryResponse2)) {
            setQuery({
              sectionIndex,
              value: concatenatedQueryValue,
              sectionType: activeSection.type
            });
            return queryResponse2;
          }
        }
        const queryResponse = getFirstSectionValueMatchingWithQuery(cleanKeyPressed, activeSection);
        if (isQueryResponseWithoutValue(queryResponse) && !queryResponse.saveQuery) {
          resetQuery();
          return null;
        }
        setQuery({
          sectionIndex,
          value: cleanKeyPressed,
          sectionType: activeSection.type
        });
        if (isQueryResponseWithoutValue(queryResponse)) {
          return null;
        }
        return queryResponse;
      };
      const applyLetterEditing = (params) => {
        const findMatchingOptions = (format, options, queryValue) => {
          const matchingValues = options.filter((option) => option.toLowerCase().startsWith(queryValue));
          if (matchingValues.length === 0) {
            return {
              saveQuery: false
            };
          }
          return {
            sectionValue: matchingValues[0],
            shouldGoToNextSection: matchingValues.length === 1
          };
        };
        const testQueryOnFormatAndFallbackFormat = (queryValue, activeSection, fallbackFormat, formatFallbackValue) => {
          const getOptions = (format) => getLetterEditingOptions(utils2, timezone, activeSection.type, format);
          if (activeSection.contentType === "letter") {
            return findMatchingOptions(activeSection.format, getOptions(activeSection.format), queryValue);
          }
          if (fallbackFormat && formatFallbackValue != null && getDateSectionConfigFromFormatToken(utils2, fallbackFormat).contentType === "letter") {
            const fallbackOptions = getOptions(fallbackFormat);
            const response = findMatchingOptions(fallbackFormat, fallbackOptions, queryValue);
            if (isQueryResponseWithoutValue(response)) {
              return {
                saveQuery: false
              };
            }
            return _extends$1({}, response, {
              sectionValue: formatFallbackValue(response.sectionValue, fallbackOptions)
            });
          }
          return {
            saveQuery: false
          };
        };
        const getFirstSectionValueMatchingWithQuery = (queryValue, activeSection) => {
          switch (activeSection.type) {
            case "month": {
              const formatFallbackValue = (fallbackValue) => changeSectionValueFormat(utils2, fallbackValue, utils2.formats.month, activeSection.format);
              return testQueryOnFormatAndFallbackFormat(queryValue, activeSection, utils2.formats.month, formatFallbackValue);
            }
            case "weekDay": {
              const formatFallbackValue = (fallbackValue, fallbackOptions) => fallbackOptions.indexOf(fallbackValue).toString();
              return testQueryOnFormatAndFallbackFormat(queryValue, activeSection, utils2.formats.weekday, formatFallbackValue);
            }
            case "meridiem": {
              return testQueryOnFormatAndFallbackFormat(queryValue, activeSection);
            }
            default: {
              return {
                saveQuery: false
              };
            }
          }
        };
        return applyQuery(params, getFirstSectionValueMatchingWithQuery);
      };
      const applyNumericEditing = (params) => {
        const getNewSectionValue = (queryValue, section) => {
          const queryValueNumber = Number(`${queryValue}`);
          const sectionBoundaries = sectionsValueBoundaries[section.type]({
            currentDate: null,
            format: section.format,
            contentType: section.contentType
          });
          if (queryValueNumber > sectionBoundaries.maximum) {
            return {
              saveQuery: false
            };
          }
          if (queryValueNumber < sectionBoundaries.minimum) {
            return {
              saveQuery: true
            };
          }
          const shouldGoToNextSection = Number(`${queryValue}0`) > sectionBoundaries.maximum || queryValue.length === sectionBoundaries.maximum.toString().length;
          const newSectionValue = cleanDigitSectionValue(utils2, timezone, queryValueNumber, sectionBoundaries, section);
          return {
            sectionValue: newSectionValue,
            shouldGoToNextSection
          };
        };
        const getFirstSectionValueMatchingWithQuery = (queryValue, activeSection) => {
          if (activeSection.contentType === "digit" || activeSection.contentType === "digit-with-letter") {
            return getNewSectionValue(queryValue, activeSection);
          }
          if (activeSection.type === "month") {
            const hasLeadingZerosInFormat = doesSectionFormatHaveLeadingZeros(utils2, timezone, "digit", "month", "MM");
            const response = getNewSectionValue(queryValue, {
              type: activeSection.type,
              format: "MM",
              hasLeadingZerosInFormat,
              hasLeadingZerosInInput: true,
              contentType: "digit",
              maxLength: 2
            });
            if (isQueryResponseWithoutValue(response)) {
              return response;
            }
            const formattedValue = changeSectionValueFormat(utils2, response.sectionValue, "MM", activeSection.format);
            return _extends$1({}, response, {
              sectionValue: formattedValue
            });
          }
          if (activeSection.type === "weekDay") {
            const response = getNewSectionValue(queryValue, activeSection);
            if (isQueryResponseWithoutValue(response)) {
              return response;
            }
            const formattedValue = getDaysInWeekStr(utils2, timezone, activeSection.format)[Number(response.sectionValue) - 1];
            return _extends$1({}, response, {
              sectionValue: formattedValue
            });
          }
          return {
            saveQuery: false
          };
        };
        return applyQuery(params, getFirstSectionValueMatchingWithQuery, (queryValue) => !Number.isNaN(Number(queryValue)));
      };
      const applyCharacterEditing = useEventCallback((params) => {
        const activeSection = sections[params.sectionIndex];
        const isNumericEditing = !Number.isNaN(Number(params.keyPressed));
        const response = isNumericEditing ? applyNumericEditing(params) : applyLetterEditing(params);
        if (response == null) {
          setTempAndroidValueStr(null);
        } else {
          updateSectionValue({
            activeSection,
            newSectionValue: response.sectionValue,
            shouldGoToNextSection: response.shouldGoToNextSection
          });
        }
      });
      return {
        applyCharacterEditing,
        resetCharacterQuery: resetQuery
      };
    };
    function arrayIncludes(array2, itemOrItems) {
      if (Array.isArray(itemOrItems)) {
        return itemOrItems.every((item) => array2.indexOf(item) !== -1);
      }
      return array2.indexOf(itemOrItems) !== -1;
    }
    const onSpaceOrEnter = (innerFn, externalEvent) => (event) => {
      if (event.key === "Enter" || event.key === " ") {
        innerFn(event);
        event.preventDefault();
        event.stopPropagation();
      }
      if (externalEvent) {
        externalEvent(event);
      }
    };
    const getActiveElement = (root2 = document) => {
      const activeEl = root2.activeElement;
      if (!activeEl) {
        return null;
      }
      if (activeEl.shadowRoot) {
        return getActiveElement(activeEl.shadowRoot);
      }
      return activeEl;
    };
    const DEFAULT_DESKTOP_MODE_MEDIA_QUERY = "@media (pointer: fine)";
    const _excluded$p = ["onClick", "onKeyDown", "onFocus", "onBlur", "onMouseUp", "onPaste", "error", "clearable", "onClear", "disabled"];
    const useField = (params) => {
      const utils2 = useUtils();
      const {
        state,
        selectedSectionIndexes,
        setSelectedSections,
        clearValue,
        clearActiveSection,
        updateSectionValue,
        updateValueFromValueStr,
        setTempAndroidValueStr,
        sectionsValueBoundaries,
        placeholder,
        timezone
      } = useFieldState(params);
      const {
        inputRef: inputRefProp,
        internalProps,
        internalProps: {
          readOnly = false,
          unstableFieldRef,
          minutesStep
        },
        forwardedProps: {
          onClick,
          onKeyDown,
          onFocus,
          onBlur,
          onMouseUp,
          onPaste,
          error,
          clearable,
          onClear,
          disabled
        },
        fieldValueManager,
        valueManager,
        validator: validator2
      } = params, otherForwardedProps = _objectWithoutPropertiesLoose$1(params.forwardedProps, _excluded$p);
      const {
        applyCharacterEditing,
        resetCharacterQuery
      } = useFieldCharacterEditing({
        sections: state.sections,
        updateSectionValue,
        sectionsValueBoundaries,
        setTempAndroidValueStr,
        timezone
      });
      const inputRef = reactExports.useRef(null);
      const handleRef = useForkRef(inputRefProp, inputRef);
      const focusTimeoutRef = reactExports.useRef(void 0);
      const theme = useTheme();
      const isRTL = theme.direction === "rtl";
      const sectionOrder = reactExports.useMemo(() => getSectionOrder(state.sections, isRTL), [state.sections, isRTL]);
      const syncSelectionFromDOM = () => {
        var _selectionStart;
        if (readOnly) {
          setSelectedSections(null);
          return;
        }
        const browserStartIndex = (_selectionStart = inputRef.current.selectionStart) != null ? _selectionStart : 0;
        let nextSectionIndex;
        if (browserStartIndex <= state.sections[0].startInInput) {
          nextSectionIndex = 1;
        } else if (browserStartIndex >= state.sections[state.sections.length - 1].endInInput) {
          nextSectionIndex = 1;
        } else {
          nextSectionIndex = state.sections.findIndex((section) => section.startInInput - section.startSeparator.length > browserStartIndex);
        }
        const sectionIndex = nextSectionIndex === -1 ? state.sections.length - 1 : nextSectionIndex - 1;
        setSelectedSections(sectionIndex);
      };
      const handleInputClick = useEventCallback((event, ...args) => {
        if (event.isDefaultPrevented()) {
          return;
        }
        onClick == null || onClick(event, ...args);
        syncSelectionFromDOM();
      });
      const handleInputMouseUp = useEventCallback((event) => {
        onMouseUp == null || onMouseUp(event);
        event.preventDefault();
      });
      const handleInputFocus = useEventCallback((...args) => {
        onFocus == null || onFocus(...args);
        const input = inputRef.current;
        window.clearTimeout(focusTimeoutRef.current);
        focusTimeoutRef.current = setTimeout(() => {
          if (!input || input !== inputRef.current) {
            return;
          }
          if (selectedSectionIndexes != null || readOnly) {
            return;
          }
          if (
            // avoid selecting all sections when focusing empty field without value
            input.value.length && Number(input.selectionEnd) - Number(input.selectionStart) === input.value.length
          ) {
            setSelectedSections("all");
          } else {
            syncSelectionFromDOM();
          }
        });
      });
      const handleInputBlur = useEventCallback((...args) => {
        onBlur == null || onBlur(...args);
        setSelectedSections(null);
      });
      const handleInputPaste = useEventCallback((event) => {
        onPaste == null || onPaste(event);
        if (readOnly) {
          event.preventDefault();
          return;
        }
        const pastedValue = event.clipboardData.getData("text");
        if (selectedSectionIndexes && selectedSectionIndexes.startIndex === selectedSectionIndexes.endIndex) {
          const activeSection = state.sections[selectedSectionIndexes.startIndex];
          const lettersOnly = /^[a-zA-Z]+$/.test(pastedValue);
          const digitsOnly = /^[0-9]+$/.test(pastedValue);
          const digitsAndLetterOnly = /^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(pastedValue);
          const isValidPastedValue = activeSection.contentType === "letter" && lettersOnly || activeSection.contentType === "digit" && digitsOnly || activeSection.contentType === "digit-with-letter" && digitsAndLetterOnly;
          if (isValidPastedValue) {
            resetCharacterQuery();
            updateSectionValue({
              activeSection,
              newSectionValue: pastedValue,
              shouldGoToNextSection: true
            });
            event.preventDefault();
            return;
          }
          if (lettersOnly || digitsOnly) {
            event.preventDefault();
            return;
          }
        }
        event.preventDefault();
        resetCharacterQuery();
        updateValueFromValueStr(pastedValue);
      });
      const handleInputChange = useEventCallback((event) => {
        if (readOnly) {
          return;
        }
        const targetValue = event.target.value;
        if (targetValue === "") {
          resetCharacterQuery();
          clearValue();
          return;
        }
        const eventData = event.nativeEvent.data;
        const shouldUseEventData = eventData && eventData.length > 1;
        const valueStr2 = shouldUseEventData ? eventData : targetValue;
        const cleanValueStr = cleanString(valueStr2);
        if (selectedSectionIndexes == null || shouldUseEventData) {
          updateValueFromValueStr(shouldUseEventData ? eventData : cleanValueStr);
          return;
        }
        let keyPressed;
        if (selectedSectionIndexes.startIndex === 0 && selectedSectionIndexes.endIndex === state.sections.length - 1 && cleanValueStr.length === 1) {
          keyPressed = cleanValueStr;
        } else {
          const prevValueStr = cleanString(fieldValueManager.getValueStrFromSections(state.sections, isRTL));
          let startOfDiffIndex = -1;
          let endOfDiffIndex = -1;
          for (let i = 0; i < prevValueStr.length; i += 1) {
            if (startOfDiffIndex === -1 && prevValueStr[i] !== cleanValueStr[i]) {
              startOfDiffIndex = i;
            }
            if (endOfDiffIndex === -1 && prevValueStr[prevValueStr.length - i - 1] !== cleanValueStr[cleanValueStr.length - i - 1]) {
              endOfDiffIndex = i;
            }
          }
          const activeSection = state.sections[selectedSectionIndexes.startIndex];
          const hasDiffOutsideOfActiveSection = startOfDiffIndex < activeSection.start || prevValueStr.length - endOfDiffIndex - 1 > activeSection.end;
          if (hasDiffOutsideOfActiveSection) {
            return;
          }
          const activeSectionEndRelativeToNewValue = cleanValueStr.length - prevValueStr.length + activeSection.end - cleanString(activeSection.endSeparator || "").length;
          keyPressed = cleanValueStr.slice(activeSection.start + cleanString(activeSection.startSeparator || "").length, activeSectionEndRelativeToNewValue);
        }
        if (keyPressed.length === 0) {
          if (isAndroid()) {
            setTempAndroidValueStr(valueStr2);
          } else {
            resetCharacterQuery();
            clearActiveSection();
          }
          return;
        }
        applyCharacterEditing({
          keyPressed,
          sectionIndex: selectedSectionIndexes.startIndex
        });
      });
      const handleInputKeyDown = useEventCallback((event) => {
        onKeyDown == null || onKeyDown(event);
        switch (true) {
          case (event.key === "a" && (event.ctrlKey || event.metaKey)): {
            event.preventDefault();
            setSelectedSections("all");
            break;
          }
          case event.key === "ArrowRight": {
            event.preventDefault();
            if (selectedSectionIndexes == null) {
              setSelectedSections(sectionOrder.startIndex);
            } else if (selectedSectionIndexes.startIndex !== selectedSectionIndexes.endIndex) {
              setSelectedSections(selectedSectionIndexes.endIndex);
            } else {
              const nextSectionIndex = sectionOrder.neighbors[selectedSectionIndexes.startIndex].rightIndex;
              if (nextSectionIndex !== null) {
                setSelectedSections(nextSectionIndex);
              }
            }
            break;
          }
          case event.key === "ArrowLeft": {
            event.preventDefault();
            if (selectedSectionIndexes == null) {
              setSelectedSections(sectionOrder.endIndex);
            } else if (selectedSectionIndexes.startIndex !== selectedSectionIndexes.endIndex) {
              setSelectedSections(selectedSectionIndexes.startIndex);
            } else {
              const nextSectionIndex = sectionOrder.neighbors[selectedSectionIndexes.startIndex].leftIndex;
              if (nextSectionIndex !== null) {
                setSelectedSections(nextSectionIndex);
              }
            }
            break;
          }
          case event.key === "Delete": {
            event.preventDefault();
            if (readOnly) {
              break;
            }
            if (selectedSectionIndexes == null || selectedSectionIndexes.startIndex === 0 && selectedSectionIndexes.endIndex === state.sections.length - 1) {
              clearValue();
            } else {
              clearActiveSection();
            }
            resetCharacterQuery();
            break;
          }
          case ["ArrowUp", "ArrowDown", "Home", "End", "PageUp", "PageDown"].includes(event.key): {
            event.preventDefault();
            if (readOnly || selectedSectionIndexes == null) {
              break;
            }
            const activeSection = state.sections[selectedSectionIndexes.startIndex];
            const activeDateManager = fieldValueManager.getActiveDateManager(utils2, state, activeSection);
            const newSectionValue = adjustSectionValue(utils2, timezone, activeSection, event.key, sectionsValueBoundaries, activeDateManager.date, {
              minutesStep
            });
            updateSectionValue({
              activeSection,
              newSectionValue,
              shouldGoToNextSection: false
            });
            break;
          }
        }
      });
      useEnhancedEffect(() => {
        if (!inputRef.current) {
          return;
        }
        if (selectedSectionIndexes == null) {
          if (inputRef.current.scrollLeft) {
            inputRef.current.scrollLeft = 0;
          }
          return;
        }
        const firstSelectedSection = state.sections[selectedSectionIndexes.startIndex];
        const lastSelectedSection = state.sections[selectedSectionIndexes.endIndex];
        let selectionStart = firstSelectedSection.startInInput;
        let selectionEnd = lastSelectedSection.endInInput;
        if (selectedSectionIndexes.shouldSelectBoundarySelectors) {
          selectionStart -= firstSelectedSection.startSeparator.length;
          selectionEnd += lastSelectedSection.endSeparator.length;
        }
        if (selectionStart !== inputRef.current.selectionStart || selectionEnd !== inputRef.current.selectionEnd) {
          const currentScrollTop = inputRef.current.scrollTop;
          if (inputRef.current === getActiveElement(document)) {
            inputRef.current.setSelectionRange(selectionStart, selectionEnd);
          }
          inputRef.current.scrollTop = currentScrollTop;
        }
      });
      const validationError = useValidation(_extends$1({}, internalProps, {
        value: state.value,
        timezone
      }), validator2, valueManager.isSameError, valueManager.defaultErrorState);
      const inputError = reactExports.useMemo(() => {
        if (error !== void 0) {
          return error;
        }
        return valueManager.hasError(validationError);
      }, [valueManager, validationError, error]);
      reactExports.useEffect(() => {
        if (!inputError && !selectedSectionIndexes) {
          resetCharacterQuery();
        }
      }, [state.referenceValue, selectedSectionIndexes, inputError]);
      reactExports.useEffect(() => {
        if (inputRef.current && inputRef.current === document.activeElement) {
          setSelectedSections("all");
        }
        return () => window.clearTimeout(focusTimeoutRef.current);
      }, []);
      reactExports.useEffect(() => {
        if (state.tempValueStrAndroid != null && selectedSectionIndexes != null) {
          resetCharacterQuery();
          clearActiveSection();
        }
      }, [state.tempValueStrAndroid]);
      const valueStr = reactExports.useMemo(() => {
        var _state$tempValueStrAn;
        return (_state$tempValueStrAn = state.tempValueStrAndroid) != null ? _state$tempValueStrAn : fieldValueManager.getValueStrFromSections(state.sections, isRTL);
      }, [state.sections, fieldValueManager, state.tempValueStrAndroid, isRTL]);
      const inputMode = reactExports.useMemo(() => {
        if (selectedSectionIndexes == null) {
          return "text";
        }
        if (state.sections[selectedSectionIndexes.startIndex].contentType === "letter") {
          return "text";
        }
        return "numeric";
      }, [selectedSectionIndexes, state.sections]);
      const inputHasFocus = inputRef.current && inputRef.current === getActiveElement(document);
      const areAllSectionsEmpty = valueManager.areValuesEqual(utils2, state.value, valueManager.emptyValue);
      const shouldShowPlaceholder = !inputHasFocus && areAllSectionsEmpty;
      reactExports.useImperativeHandle(unstableFieldRef, () => ({
        getSections: () => state.sections,
        getActiveSectionIndex: () => {
          var _selectionStart2, _selectionEnd;
          const browserStartIndex = (_selectionStart2 = inputRef.current.selectionStart) != null ? _selectionStart2 : 0;
          const browserEndIndex = (_selectionEnd = inputRef.current.selectionEnd) != null ? _selectionEnd : 0;
          if (browserStartIndex === 0 && browserEndIndex === 0) {
            return null;
          }
          const nextSectionIndex = browserStartIndex <= state.sections[0].startInInput ? 1 : state.sections.findIndex((section) => section.startInInput - section.startSeparator.length > browserStartIndex);
          return nextSectionIndex === -1 ? state.sections.length - 1 : nextSectionIndex - 1;
        },
        setSelectedSections: (activeSectionIndex) => setSelectedSections(activeSectionIndex)
      }));
      const handleClearValue = useEventCallback((event, ...args) => {
        var _inputRef$current;
        event.preventDefault();
        onClear == null || onClear(event, ...args);
        clearValue();
        inputRef == null || (_inputRef$current = inputRef.current) == null || _inputRef$current.focus();
        setSelectedSections(0);
      });
      return _extends$1({
        placeholder,
        autoComplete: "off",
        disabled: Boolean(disabled)
      }, otherForwardedProps, {
        value: shouldShowPlaceholder ? "" : valueStr,
        inputMode,
        readOnly,
        onClick: handleInputClick,
        onFocus: handleInputFocus,
        onBlur: handleInputBlur,
        onPaste: handleInputPaste,
        onChange: handleInputChange,
        onKeyDown: handleInputKeyDown,
        onMouseUp: handleInputMouseUp,
        onClear: handleClearValue,
        error: inputError,
        ref: handleRef,
        clearable: Boolean(clearable && !areAllSectionsEmpty && !readOnly && !disabled)
      });
    };
    const validateTime = ({
      adapter,
      value,
      props
    }) => {
      if (value === null) {
        return null;
      }
      const {
        minTime,
        maxTime,
        minutesStep,
        shouldDisableClock,
        shouldDisableTime,
        disableIgnoringDatePartForTimeValidation = false,
        disablePast,
        disableFuture,
        timezone
      } = props;
      const now2 = adapter.utils.dateWithTimezone(void 0, timezone);
      const isAfter = createIsAfterIgnoreDatePart(disableIgnoringDatePartForTimeValidation, adapter.utils);
      switch (true) {
        case !adapter.utils.isValid(value):
          return "invalidDate";
        case Boolean(minTime && isAfter(minTime, value)):
          return "minTime";
        case Boolean(maxTime && isAfter(value, maxTime)):
          return "maxTime";
        case Boolean(disableFuture && adapter.utils.isAfter(value, now2)):
          return "disableFuture";
        case Boolean(disablePast && adapter.utils.isBefore(value, now2)):
          return "disablePast";
        case Boolean(shouldDisableTime && shouldDisableTime(value, "hours")):
          return "shouldDisableTime-hours";
        case Boolean(shouldDisableTime && shouldDisableTime(value, "minutes")):
          return "shouldDisableTime-minutes";
        case Boolean(shouldDisableTime && shouldDisableTime(value, "seconds")):
          return "shouldDisableTime-seconds";
        case Boolean(shouldDisableClock && shouldDisableClock(adapter.utils.getHours(value), "hours")):
          return "shouldDisableClock-hours";
        case Boolean(shouldDisableClock && shouldDisableClock(adapter.utils.getMinutes(value), "minutes")):
          return "shouldDisableClock-minutes";
        case Boolean(shouldDisableClock && shouldDisableClock(adapter.utils.getSeconds(value), "seconds")):
          return "shouldDisableClock-seconds";
        case Boolean(minutesStep && adapter.utils.getMinutes(value) % minutesStep !== 0):
          return "minutesStep";
        default:
          return null;
      }
    };
    const DATE_VALIDATION_PROP_NAMES = ["disablePast", "disableFuture", "minDate", "maxDate", "shouldDisableDate", "shouldDisableMonth", "shouldDisableYear"];
    const TIME_VALIDATION_PROP_NAMES = ["disablePast", "disableFuture", "minTime", "maxTime", "shouldDisableClock", "shouldDisableTime", "minutesStep", "ampm", "disableIgnoringDatePartForTimeValidation"];
    const DATE_TIME_VALIDATION_PROP_NAMES = ["minDateTime", "maxDateTime"];
    const VALIDATION_PROP_NAMES = [...DATE_VALIDATION_PROP_NAMES, ...TIME_VALIDATION_PROP_NAMES, ...DATE_TIME_VALIDATION_PROP_NAMES];
    const extractValidationProps = (props) => VALIDATION_PROP_NAMES.reduce((extractedProps, propName) => {
      if (props.hasOwnProperty(propName)) {
        extractedProps[propName] = props[propName];
      }
      return extractedProps;
    }, {});
    const SHARED_FIELD_INTERNAL_PROP_NAMES = ["value", "defaultValue", "referenceDate", "format", "formatDensity", "onChange", "timezone", "readOnly", "onError", "shouldRespectLeadingZeros", "selectedSections", "onSelectedSectionsChange", "unstableFieldRef"];
    const splitFieldInternalAndForwardedProps = (props, valueType) => {
      const forwardedProps = _extends$1({}, props);
      const internalProps = {};
      const extractProp = (propName) => {
        if (forwardedProps.hasOwnProperty(propName)) {
          internalProps[propName] = forwardedProps[propName];
          delete forwardedProps[propName];
        }
      };
      SHARED_FIELD_INTERNAL_PROP_NAMES.forEach(extractProp);
      if (valueType === "date") {
        DATE_VALIDATION_PROP_NAMES.forEach(extractProp);
      } else if (valueType === "time") {
        TIME_VALIDATION_PROP_NAMES.forEach(extractProp);
      } else if (valueType === "date-time") {
        DATE_VALIDATION_PROP_NAMES.forEach(extractProp);
        TIME_VALIDATION_PROP_NAMES.forEach(extractProp);
        DATE_TIME_VALIDATION_PROP_NAMES.forEach(extractProp);
      }
      return {
        forwardedProps,
        internalProps
      };
    };
    const useDefaultizedTimeField = (props) => {
      var _props$ampm, _props$disablePast, _props$disableFuture, _props$format;
      const utils2 = useUtils();
      const ampm = (_props$ampm = props.ampm) != null ? _props$ampm : utils2.is12HourCycleInCurrentLocale();
      const defaultFormat = ampm ? utils2.formats.fullTime12h : utils2.formats.fullTime24h;
      return _extends$1({}, props, {
        disablePast: (_props$disablePast = props.disablePast) != null ? _props$disablePast : false,
        disableFuture: (_props$disableFuture = props.disableFuture) != null ? _props$disableFuture : false,
        format: (_props$format = props.format) != null ? _props$format : defaultFormat
      });
    };
    const useTimeField = ({
      props: inProps,
      inputRef
    }) => {
      const props = useDefaultizedTimeField(inProps);
      const {
        forwardedProps,
        internalProps
      } = splitFieldInternalAndForwardedProps(props, "time");
      return useField({
        inputRef,
        forwardedProps,
        internalProps,
        valueManager: singleItemValueManager,
        fieldValueManager: singleItemFieldValueManager,
        validator: validateTime,
        valueType: "time"
      });
    };
    function getInputAdornmentUtilityClass(slot) {
      return generateUtilityClass$1("MuiInputAdornment", slot);
    }
    const inputAdornmentClasses = generateUtilityClasses$1("MuiInputAdornment", ["root", "filled", "standard", "outlined", "positionStart", "positionEnd", "disablePointerEvents", "hiddenLabel", "sizeSmall"]);
    const inputAdornmentClasses$1 = inputAdornmentClasses;
    var _span;
    const _excluded$o = ["children", "className", "component", "disablePointerEvents", "disableTypography", "position", "variant"];
    const overridesResolver$2 = (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, styles2[`position${capitalize(ownerState.position)}`], ownerState.disablePointerEvents === true && styles2.disablePointerEvents, styles2[ownerState.variant]];
    };
    const useUtilityClasses$j = (ownerState) => {
      const {
        classes,
        disablePointerEvents,
        hiddenLabel,
        position: position2,
        size,
        variant
      } = ownerState;
      const slots = {
        root: ["root", disablePointerEvents && "disablePointerEvents", position2 && `position${capitalize(position2)}`, variant, hiddenLabel && "hiddenLabel", size && `size${capitalize(size)}`]
      };
      return composeClasses(slots, getInputAdornmentUtilityClass, classes);
    };
    const InputAdornmentRoot = styled("div", {
      name: "MuiInputAdornment",
      slot: "Root",
      overridesResolver: overridesResolver$2
    })(({
      theme,
      ownerState
    }) => _extends$1({
      display: "flex",
      height: "0.01em",
      // Fix IE11 flexbox alignment. To remove at some point.
      maxHeight: "2em",
      alignItems: "center",
      whiteSpace: "nowrap",
      color: (theme.vars || theme).palette.action.active
    }, ownerState.variant === "filled" && {
      // Styles applied to the root element if `variant="filled"`.
      [`&.${inputAdornmentClasses$1.positionStart}&:not(.${inputAdornmentClasses$1.hiddenLabel})`]: {
        marginTop: 16
      }
    }, ownerState.position === "start" && {
      // Styles applied to the root element if `position="start"`.
      marginRight: 8
    }, ownerState.position === "end" && {
      // Styles applied to the root element if `position="end"`.
      marginLeft: 8
    }, ownerState.disablePointerEvents === true && {
      // Styles applied to the root element if `disablePointerEvents={true}`.
      pointerEvents: "none"
    }));
    const InputAdornment = /* @__PURE__ */ reactExports.forwardRef(function InputAdornment2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiInputAdornment"
      });
      const {
        children,
        className,
        component = "div",
        disablePointerEvents = false,
        disableTypography = false,
        position: position2,
        variant: variantProp
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$o);
      const muiFormControl = useFormControl() || {};
      let variant = variantProp;
      if (variantProp && muiFormControl.variant)
        ;
      if (muiFormControl && !variant) {
        variant = muiFormControl.variant;
      }
      const ownerState = _extends$1({}, props, {
        hiddenLabel: muiFormControl.hiddenLabel,
        size: muiFormControl.size,
        disablePointerEvents,
        position: position2,
        variant
      });
      const classes = useUtilityClasses$j(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext$1.Provider, {
        value: null,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(InputAdornmentRoot, _extends$1({
          as: component,
          ownerState,
          className: clsx(classes.root, className),
          ref
        }, other, {
          children: typeof children === "string" && !disableTypography ? /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, {
            color: "text.secondary",
            children
          }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
            children: [position2 === "start" ? (
              /* notranslate needed while Google Translate will not fix zero-width space issue */
              _span || (_span = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
                className: "notranslate",
                children: "​"
              }))
            ) : null, children]
          })
        }))
      });
    });
    const MuiInputAdornment = InputAdornment;
    const unstable_ClassNameGenerator = {
      configure: (generator) => {
        ClassNameGenerator.configure(generator);
      }
    };
    const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      capitalize,
      createChainedFunction,
      createSvgIcon: createSvgIcon$1,
      debounce: debounce$1,
      deprecatedPropType,
      isMuiElement,
      ownerDocument,
      ownerWindow,
      requirePropFactory,
      setRef,
      unstable_ClassNameGenerator,
      unstable_useEnhancedEffect: useEnhancedEffect,
      unstable_useId: useId,
      unsupportedProp,
      useControlled,
      useEventCallback,
      useForkRef,
      useIsFocusVisible
    }, Symbol.toStringTag, { value: "Module" }));
    createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      d: "M7 10l5 5 5-5z"
    }), "ArrowDropDown");
    const ArrowLeftIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      d: "M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"
    }), "ArrowLeft");
    const ArrowRightIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      d: "M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"
    }), "ArrowRight");
    createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      d: "M17 12h-5v5h5v-5zM16 1v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2h-1V1h-2zm3 18H5V8h14v11z"
    }), "Calendar");
    const ClockIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
        d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
      }), /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
        d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"
      })]
    }), "Clock");
    createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      d: "M9 11H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2zm2-7h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11z"
    }), "DateRange");
    createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
        d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
      }), /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
        d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"
      })]
    }), "Time");
    const ClearIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
    }), "Clear");
    function getPickersArrowSwitcherUtilityClass(slot) {
      return generateUtilityClass$1("MuiPickersArrowSwitcher", slot);
    }
    generateUtilityClasses$1("MuiPickersArrowSwitcher", ["root", "spacer", "button"]);
    const _excluded$n = ["children", "className", "slots", "slotProps", "isNextDisabled", "isNextHidden", "onGoToNext", "nextLabel", "isPreviousDisabled", "isPreviousHidden", "onGoToPrevious", "previousLabel"], _excluded2$4 = ["ownerState"], _excluded3$2 = ["ownerState"];
    const PickersArrowSwitcherRoot = styled("div", {
      name: "MuiPickersArrowSwitcher",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })({
      display: "flex"
    });
    const PickersArrowSwitcherSpacer = styled("div", {
      name: "MuiPickersArrowSwitcher",
      slot: "Spacer",
      overridesResolver: (props, styles2) => styles2.spacer
    })(({
      theme
    }) => ({
      width: theme.spacing(3)
    }));
    const PickersArrowSwitcherButton = styled(IconButton$1, {
      name: "MuiPickersArrowSwitcher",
      slot: "Button",
      overridesResolver: (props, styles2) => styles2.button
    })(({
      ownerState
    }) => _extends$1({}, ownerState.hidden && {
      visibility: "hidden"
    }));
    const useUtilityClasses$i = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        spacer: ["spacer"],
        button: ["button"]
      };
      return composeClasses(slots, getPickersArrowSwitcherUtilityClass, classes);
    };
    const PickersArrowSwitcher = /* @__PURE__ */ reactExports.forwardRef(function PickersArrowSwitcher2(inProps, ref) {
      var _slots$previousIconBu, _slots$nextIconButton, _slots$leftArrowIcon, _slots$rightArrowIcon;
      const theme = useTheme();
      const isRTL = theme.direction === "rtl";
      const props = useThemeProps({
        props: inProps,
        name: "MuiPickersArrowSwitcher"
      });
      const {
        children,
        className,
        slots,
        slotProps,
        isNextDisabled,
        isNextHidden,
        onGoToNext,
        nextLabel,
        isPreviousDisabled,
        isPreviousHidden,
        onGoToPrevious,
        previousLabel
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$n);
      const ownerState = props;
      const classes = useUtilityClasses$i(ownerState);
      const nextProps = {
        isDisabled: isNextDisabled,
        isHidden: isNextHidden,
        goTo: onGoToNext,
        label: nextLabel
      };
      const previousProps = {
        isDisabled: isPreviousDisabled,
        isHidden: isPreviousHidden,
        goTo: onGoToPrevious,
        label: previousLabel
      };
      const PreviousIconButton = (_slots$previousIconBu = slots == null ? void 0 : slots.previousIconButton) != null ? _slots$previousIconBu : PickersArrowSwitcherButton;
      const previousIconButtonProps = useSlotProps({
        elementType: PreviousIconButton,
        externalSlotProps: slotProps == null ? void 0 : slotProps.previousIconButton,
        additionalProps: {
          size: "medium",
          title: previousProps.label,
          "aria-label": previousProps.label,
          disabled: previousProps.isDisabled,
          edge: "end",
          onClick: previousProps.goTo
        },
        ownerState: _extends$1({}, ownerState, {
          hidden: previousProps.isHidden
        }),
        className: classes.button
      });
      const NextIconButton = (_slots$nextIconButton = slots == null ? void 0 : slots.nextIconButton) != null ? _slots$nextIconButton : PickersArrowSwitcherButton;
      const nextIconButtonProps = useSlotProps({
        elementType: NextIconButton,
        externalSlotProps: slotProps == null ? void 0 : slotProps.nextIconButton,
        additionalProps: {
          size: "medium",
          title: nextProps.label,
          "aria-label": nextProps.label,
          disabled: nextProps.isDisabled,
          edge: "start",
          onClick: nextProps.goTo
        },
        ownerState: _extends$1({}, ownerState, {
          hidden: nextProps.isHidden
        }),
        className: classes.button
      });
      const LeftArrowIcon = (_slots$leftArrowIcon = slots == null ? void 0 : slots.leftArrowIcon) != null ? _slots$leftArrowIcon : ArrowLeftIcon;
      const _useSlotProps = useSlotProps({
        elementType: LeftArrowIcon,
        externalSlotProps: slotProps == null ? void 0 : slotProps.leftArrowIcon,
        additionalProps: {
          fontSize: "inherit"
        },
        ownerState: void 0
      }), leftArrowIconProps = _objectWithoutPropertiesLoose$1(_useSlotProps, _excluded2$4);
      const RightArrowIcon = (_slots$rightArrowIcon = slots == null ? void 0 : slots.rightArrowIcon) != null ? _slots$rightArrowIcon : ArrowRightIcon;
      const _useSlotProps2 = useSlotProps({
        elementType: RightArrowIcon,
        externalSlotProps: slotProps == null ? void 0 : slotProps.rightArrowIcon,
        additionalProps: {
          fontSize: "inherit"
        },
        ownerState: void 0
      }), rightArrowIconProps = _objectWithoutPropertiesLoose$1(_useSlotProps2, _excluded3$2);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersArrowSwitcherRoot, _extends$1({
        ref,
        className: clsx(classes.root, className),
        ownerState
      }, other, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(PreviousIconButton, _extends$1({}, previousIconButtonProps, {
          children: isRTL ? /* @__PURE__ */ jsxRuntimeExports.jsx(RightArrowIcon, _extends$1({}, rightArrowIconProps)) : /* @__PURE__ */ jsxRuntimeExports.jsx(LeftArrowIcon, _extends$1({}, leftArrowIconProps))
        })), children ? /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, {
          variant: "subtitle1",
          component: "span",
          children
        }) : /* @__PURE__ */ jsxRuntimeExports.jsx(PickersArrowSwitcherSpacer, {
          className: classes.spacer,
          ownerState
        }), /* @__PURE__ */ jsxRuntimeExports.jsx(NextIconButton, _extends$1({}, nextIconButtonProps, {
          children: isRTL ? /* @__PURE__ */ jsxRuntimeExports.jsx(LeftArrowIcon, _extends$1({}, leftArrowIconProps)) : /* @__PURE__ */ jsxRuntimeExports.jsx(RightArrowIcon, _extends$1({}, rightArrowIconProps))
        }))]
      }));
    });
    const DIALOG_WIDTH = 320;
    const VIEW_HEIGHT = 334;
    const DIGITAL_CLOCK_VIEW_HEIGHT = 232;
    const MULTI_SECTION_CLOCK_SECTION_WIDTH = 48;
    const PickersModalDialogRoot = styled(MuiDialog)({
      [`& .${dialogClasses$1.container}`]: {
        outline: 0
      },
      [`& .${dialogClasses$1.paper}`]: {
        outline: 0,
        minWidth: DIALOG_WIDTH
      }
    });
    const PickersModalDialogContent = styled(DialogContent$1)({
      "&:first-of-type": {
        padding: 0
      }
    });
    function PickersModalDialog(props) {
      var _slots$dialog, _slots$mobileTransiti;
      const {
        children,
        onDismiss,
        open,
        slots,
        slotProps
      } = props;
      const Dialog2 = (_slots$dialog = slots == null ? void 0 : slots.dialog) != null ? _slots$dialog : PickersModalDialogRoot;
      const Transition2 = (_slots$mobileTransiti = slots == null ? void 0 : slots.mobileTransition) != null ? _slots$mobileTransiti : Fade$1;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog2, _extends$1({
        open,
        onClose: onDismiss
      }, slotProps == null ? void 0 : slotProps.dialog, {
        TransitionComponent: Transition2,
        TransitionProps: slotProps == null ? void 0 : slotProps.mobileTransition,
        PaperComponent: slots == null ? void 0 : slots.mobilePaper,
        PaperProps: slotProps == null ? void 0 : slotProps.mobilePaper,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(PickersModalDialogContent, {
          children
        })
      }));
    }
    const _excluded$m = ["anchorEl", "component", "components", "componentsProps", "container", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "transition", "slots", "slotProps"];
    const PopperRoot = styled(Popper$2, {
      name: "MuiPopper",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })({});
    const Popper = /* @__PURE__ */ reactExports.forwardRef(function Popper2(inProps, ref) {
      var _slots$root;
      const theme = useTheme$2();
      const props = useThemeProps({
        props: inProps,
        name: "MuiPopper"
      });
      const {
        anchorEl,
        component,
        components,
        componentsProps,
        container,
        disablePortal,
        keepMounted,
        modifiers,
        open,
        placement,
        popperOptions,
        popperRef,
        transition,
        slots,
        slotProps
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$m);
      const RootComponent = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components == null ? void 0 : components.Root;
      const otherProps = _extends$1({
        anchorEl,
        container,
        disablePortal,
        keepMounted,
        modifiers,
        open,
        placement,
        popperOptions,
        popperRef,
        transition
      }, other);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperRoot, _extends$1({
        as: component,
        direction: theme == null ? void 0 : theme.direction,
        slots: {
          root: RootComponent
        },
        slotProps: slotProps != null ? slotProps : componentsProps
      }, otherProps, {
        ref
      }));
    });
    const Popper$1 = Popper;
    function getPickersPopperUtilityClass(slot) {
      return generateUtilityClass$1("MuiPickersPopper", slot);
    }
    generateUtilityClasses$1("MuiPickersPopper", ["root", "paper"]);
    const PREFERS_REDUCED_MOTION = "@media (prefers-reduced-motion: reduce)";
    const mobileVersionMatches = typeof navigator !== "undefined" && navigator.userAgent.match(/android\s(\d+)|OS\s(\d+)/i);
    const androidVersion = mobileVersionMatches && mobileVersionMatches[1] ? parseInt(mobileVersionMatches[1], 10) : null;
    const iOSVersion = mobileVersionMatches && mobileVersionMatches[2] ? parseInt(mobileVersionMatches[2], 10) : null;
    const slowAnimationDevices = androidVersion && androidVersion < 10 || iOSVersion && iOSVersion < 13 || false;
    const useDefaultReduceAnimations = () => {
      const prefersReduced = useMediaQuery(PREFERS_REDUCED_MOTION, {
        defaultMatches: false
      });
      return prefersReduced || slowAnimationDevices;
    };
    const _excluded$l = ["PaperComponent", "popperPlacement", "ownerState", "children", "paperSlotProps", "paperClasses", "onPaperClick", "onPaperTouchStart"];
    const useUtilityClasses$h = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        paper: ["paper"]
      };
      return composeClasses(slots, getPickersPopperUtilityClass, classes);
    };
    const PickersPopperRoot = styled(Popper$1, {
      name: "MuiPickersPopper",
      slot: "Root",
      overridesResolver: (_2, styles2) => styles2.root
    })(({
      theme
    }) => ({
      zIndex: theme.zIndex.modal
    }));
    const PickersPopperPaper = styled(Paper$1, {
      name: "MuiPickersPopper",
      slot: "Paper",
      overridesResolver: (_2, styles2) => styles2.paper
    })(({
      ownerState
    }) => _extends$1({
      outline: 0,
      transformOrigin: "top center"
    }, ownerState.placement.includes("top") && {
      transformOrigin: "bottom center"
    }));
    function clickedRootScrollbar(event, doc) {
      return doc.documentElement.clientWidth < event.clientX || doc.documentElement.clientHeight < event.clientY;
    }
    function useClickAwayListener(active, onClickAway) {
      const movedRef = reactExports.useRef(false);
      const syntheticEventRef = reactExports.useRef(false);
      const nodeRef = reactExports.useRef(null);
      const activatedRef = reactExports.useRef(false);
      reactExports.useEffect(() => {
        if (!active) {
          return void 0;
        }
        function armClickAwayListener() {
          activatedRef.current = true;
        }
        document.addEventListener("mousedown", armClickAwayListener, true);
        document.addEventListener("touchstart", armClickAwayListener, true);
        return () => {
          document.removeEventListener("mousedown", armClickAwayListener, true);
          document.removeEventListener("touchstart", armClickAwayListener, true);
          activatedRef.current = false;
        };
      }, [active]);
      const handleClickAway = useEventCallback((event) => {
        if (!activatedRef.current) {
          return;
        }
        const insideReactTree = syntheticEventRef.current;
        syntheticEventRef.current = false;
        const doc = ownerDocument(nodeRef.current);
        if (!nodeRef.current || // is a TouchEvent?
        "clientX" in event && clickedRootScrollbar(event, doc)) {
          return;
        }
        if (movedRef.current) {
          movedRef.current = false;
          return;
        }
        let insideDOM;
        if (event.composedPath) {
          insideDOM = event.composedPath().indexOf(nodeRef.current) > -1;
        } else {
          insideDOM = !doc.documentElement.contains(event.target) || nodeRef.current.contains(event.target);
        }
        if (!insideDOM && !insideReactTree) {
          onClickAway(event);
        }
      });
      const handleSynthetic = () => {
        syntheticEventRef.current = true;
      };
      reactExports.useEffect(() => {
        if (active) {
          const doc = ownerDocument(nodeRef.current);
          const handleTouchMove = () => {
            movedRef.current = true;
          };
          doc.addEventListener("touchstart", handleClickAway);
          doc.addEventListener("touchmove", handleTouchMove);
          return () => {
            doc.removeEventListener("touchstart", handleClickAway);
            doc.removeEventListener("touchmove", handleTouchMove);
          };
        }
        return void 0;
      }, [active, handleClickAway]);
      reactExports.useEffect(() => {
        if (active) {
          const doc = ownerDocument(nodeRef.current);
          doc.addEventListener("click", handleClickAway);
          return () => {
            doc.removeEventListener("click", handleClickAway);
            syntheticEventRef.current = false;
          };
        }
        return void 0;
      }, [active, handleClickAway]);
      return [nodeRef, handleSynthetic, handleSynthetic];
    }
    const PickersPopperPaperWrapper = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        PaperComponent,
        popperPlacement,
        ownerState: inOwnerState,
        children,
        paperSlotProps,
        paperClasses,
        onPaperClick,
        onPaperTouchStart
        // picks up the style props provided by `Transition`
        // https://mui.com/material-ui/transitions/#child-requirement
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$l);
      const ownerState = _extends$1({}, inOwnerState, {
        placement: popperPlacement
      });
      const paperProps = useSlotProps({
        elementType: PaperComponent,
        externalSlotProps: paperSlotProps,
        additionalProps: {
          tabIndex: -1,
          elevation: 8,
          ref
        },
        className: paperClasses,
        ownerState
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PaperComponent, _extends$1({}, other, paperProps, {
        onClick: (event) => {
          var _paperProps$onClick;
          onPaperClick(event);
          (_paperProps$onClick = paperProps.onClick) == null || _paperProps$onClick.call(paperProps, event);
        },
        onTouchStart: (event) => {
          var _paperProps$onTouchSt;
          onPaperTouchStart(event);
          (_paperProps$onTouchSt = paperProps.onTouchStart) == null || _paperProps$onTouchSt.call(paperProps, event);
        },
        ownerState,
        children
      }));
    });
    function PickersPopper(inProps) {
      var _slots$desktopTransit, _slots$desktopTrapFoc, _slots$desktopPaper, _slots$popper;
      const props = useThemeProps({
        props: inProps,
        name: "MuiPickersPopper"
      });
      const {
        anchorEl,
        children,
        containerRef = null,
        shouldRestoreFocus,
        onBlur,
        onDismiss,
        open,
        role,
        placement,
        slots,
        slotProps,
        reduceAnimations: inReduceAnimations
      } = props;
      reactExports.useEffect(() => {
        function handleKeyDown3(nativeEvent) {
          if (open && (nativeEvent.key === "Escape" || nativeEvent.key === "Esc")) {
            onDismiss();
          }
        }
        document.addEventListener("keydown", handleKeyDown3);
        return () => {
          document.removeEventListener("keydown", handleKeyDown3);
        };
      }, [onDismiss, open]);
      const lastFocusedElementRef = reactExports.useRef(null);
      reactExports.useEffect(() => {
        if (role === "tooltip" || shouldRestoreFocus && !shouldRestoreFocus()) {
          return;
        }
        if (open) {
          lastFocusedElementRef.current = getActiveElement(document);
        } else if (lastFocusedElementRef.current && lastFocusedElementRef.current instanceof HTMLElement) {
          setTimeout(() => {
            if (lastFocusedElementRef.current instanceof HTMLElement) {
              lastFocusedElementRef.current.focus();
            }
          });
        }
      }, [open, role, shouldRestoreFocus]);
      const [clickAwayRef, onPaperClick, onPaperTouchStart] = useClickAwayListener(open, onBlur != null ? onBlur : onDismiss);
      const paperRef = reactExports.useRef(null);
      const handleRef = useForkRef(paperRef, containerRef);
      const handlePaperRef = useForkRef(handleRef, clickAwayRef);
      const ownerState = props;
      const classes = useUtilityClasses$h(ownerState);
      const defaultReduceAnimations = useDefaultReduceAnimations();
      const reduceAnimations = inReduceAnimations != null ? inReduceAnimations : defaultReduceAnimations;
      const handleKeyDown2 = (event) => {
        if (event.key === "Escape") {
          event.stopPropagation();
          onDismiss();
        }
      };
      const Transition2 = ((_slots$desktopTransit = slots == null ? void 0 : slots.desktopTransition) != null ? _slots$desktopTransit : reduceAnimations) ? Fade$1 : Grow$1;
      const FocusTrap$1 = (_slots$desktopTrapFoc = slots == null ? void 0 : slots.desktopTrapFocus) != null ? _slots$desktopTrapFoc : FocusTrap;
      const Paper2 = (_slots$desktopPaper = slots == null ? void 0 : slots.desktopPaper) != null ? _slots$desktopPaper : PickersPopperPaper;
      const Popper2 = (_slots$popper = slots == null ? void 0 : slots.popper) != null ? _slots$popper : PickersPopperRoot;
      const popperProps = useSlotProps({
        elementType: Popper2,
        externalSlotProps: slotProps == null ? void 0 : slotProps.popper,
        additionalProps: {
          transition: true,
          role,
          open,
          anchorEl,
          placement,
          onKeyDown: handleKeyDown2
        },
        className: classes.root,
        ownerState: props
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Popper2, _extends$1({}, popperProps, {
        children: ({
          TransitionProps,
          placement: popperPlacement
        }) => /* @__PURE__ */ jsxRuntimeExports.jsx(FocusTrap$1, _extends$1({
          open,
          disableAutoFocus: true,
          disableRestoreFocus: true,
          disableEnforceFocus: role === "tooltip",
          isEnabled: () => true
        }, slotProps == null ? void 0 : slotProps.desktopTrapFocus, {
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Transition2, _extends$1({}, TransitionProps, slotProps == null ? void 0 : slotProps.desktopTransition, {
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(PickersPopperPaperWrapper, {
              PaperComponent: Paper2,
              ownerState,
              popperPlacement,
              ref: handlePaperRef,
              onPaperClick,
              onPaperTouchStart,
              paperClasses: classes.paper,
              paperSlotProps: slotProps == null ? void 0 : slotProps.desktopPaper,
              children
            })
          }))
        }))
      }));
    }
    function getPickersToolbarUtilityClass(slot) {
      return generateUtilityClass$1("MuiPickersToolbar", slot);
    }
    generateUtilityClasses$1("MuiPickersToolbar", ["root", "content"]);
    const useUtilityClasses$g = (ownerState) => {
      const {
        classes,
        isLandscape
      } = ownerState;
      const slots = {
        root: ["root"],
        content: ["content"],
        penIconButton: ["penIconButton", isLandscape && "penIconButtonLandscape"]
      };
      return composeClasses(slots, getPickersToolbarUtilityClass, classes);
    };
    const PickersToolbarRoot = styled("div", {
      name: "MuiPickersToolbar",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })(({
      theme,
      ownerState
    }) => _extends$1({
      display: "flex",
      flexDirection: "column",
      alignItems: "flex-start",
      justifyContent: "space-between",
      padding: theme.spacing(2, 3)
    }, ownerState.isLandscape && {
      height: "auto",
      maxWidth: 160,
      padding: 16,
      justifyContent: "flex-start",
      flexWrap: "wrap"
    }));
    const PickersToolbarContent = styled("div", {
      name: "MuiPickersToolbar",
      slot: "Content",
      overridesResolver: (props, styles2) => styles2.content
    })(({
      ownerState
    }) => {
      var _ownerState$landscape;
      return {
        display: "flex",
        flexWrap: "wrap",
        width: "100%",
        justifyContent: ownerState.isLandscape ? "flex-start" : "space-between",
        flexDirection: ownerState.isLandscape ? (_ownerState$landscape = ownerState.landscapeDirection) != null ? _ownerState$landscape : "column" : "row",
        flex: 1,
        alignItems: ownerState.isLandscape ? "flex-start" : "center"
      };
    });
    const PickersToolbar = /* @__PURE__ */ reactExports.forwardRef(function PickersToolbar2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiPickersToolbar"
      });
      const {
        children,
        className,
        toolbarTitle,
        hidden,
        titleId
      } = props;
      const ownerState = props;
      const classes = useUtilityClasses$g(ownerState);
      if (hidden) {
        return null;
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersToolbarRoot, {
        ref,
        className: clsx(classes.root, className),
        ownerState,
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, {
          color: "text.secondary",
          variant: "overline",
          id: titleId,
          children: toolbarTitle
        }), /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarContent, {
          className: classes.content,
          ownerState,
          children
        })]
      });
    });
    function getPickersToolbarTextUtilityClass(slot) {
      return generateUtilityClass$1("MuiPickersToolbarText", slot);
    }
    const pickersToolbarTextClasses = generateUtilityClasses$1("MuiPickersToolbarText", ["root", "selected"]);
    const _excluded$k = ["className", "selected", "value"];
    const useUtilityClasses$f = (ownerState) => {
      const {
        classes,
        selected
      } = ownerState;
      const slots = {
        root: ["root", selected && "selected"]
      };
      return composeClasses(slots, getPickersToolbarTextUtilityClass, classes);
    };
    const PickersToolbarTextRoot = styled(Typography$1, {
      name: "MuiPickersToolbarText",
      slot: "Root",
      overridesResolver: (_2, styles2) => [styles2.root, {
        [`&.${pickersToolbarTextClasses.selected}`]: styles2.selected
      }]
    })(({
      theme
    }) => ({
      transition: theme.transitions.create("color"),
      color: (theme.vars || theme).palette.text.secondary,
      [`&.${pickersToolbarTextClasses.selected}`]: {
        color: (theme.vars || theme).palette.text.primary
      }
    }));
    const PickersToolbarText = /* @__PURE__ */ reactExports.forwardRef(function PickersToolbarText2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiPickersToolbarText"
      });
      const {
        className,
        value
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$k);
      const classes = useUtilityClasses$f(props);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarTextRoot, _extends$1({
        ref,
        className: clsx(className, classes.root),
        component: "span"
      }, other, {
        children: value
      }));
    });
    const _excluded$j = ["align", "className", "selected", "typographyClassName", "value", "variant", "width"];
    const useUtilityClasses$e = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"]
      };
      return composeClasses(slots, getPickersToolbarUtilityClass, classes);
    };
    const PickersToolbarButtonRoot = styled(Button$1, {
      name: "MuiPickersToolbarButton",
      slot: "Root",
      overridesResolver: (_2, styles2) => styles2.root
    })({
      padding: 0,
      minWidth: 16,
      textTransform: "none"
    });
    const PickersToolbarButton = /* @__PURE__ */ reactExports.forwardRef(function PickersToolbarButton2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiPickersToolbarButton"
      });
      const {
        align,
        className,
        selected,
        typographyClassName,
        value,
        variant,
        width: width2
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$j);
      const classes = useUtilityClasses$e(props);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButtonRoot, _extends$1({
        variant: "text",
        ref,
        className: clsx(className, classes.root)
      }, width2 ? {
        sx: {
          width: width2
        }
      } : {}, other, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarText, {
          align,
          className: typographyClassName,
          variant,
          value,
          selected
        })
      }));
    });
    const useOpenState = ({
      open,
      onOpen,
      onClose
    }) => {
      const isControllingOpenProp = reactExports.useRef(typeof open === "boolean").current;
      const [openState, setIsOpenState] = reactExports.useState(false);
      reactExports.useEffect(() => {
        if (isControllingOpenProp) {
          if (typeof open !== "boolean") {
            throw new Error("You must not mix controlling and uncontrolled mode for `open` prop");
          }
          setIsOpenState(open);
        }
      }, [isControllingOpenProp, open]);
      const setIsOpen = reactExports.useCallback((newIsOpen) => {
        if (!isControllingOpenProp) {
          setIsOpenState(newIsOpen);
        }
        if (newIsOpen && onOpen) {
          onOpen();
        }
        if (!newIsOpen && onClose) {
          onClose();
        }
      }, [isControllingOpenProp, onOpen, onClose]);
      return {
        isOpen: openState,
        setIsOpen
      };
    };
    const shouldPublishValue = (params) => {
      const {
        action,
        hasChanged,
        dateState,
        isControlled
      } = params;
      const isCurrentValueTheDefaultValue = !isControlled && !dateState.hasBeenModifiedSinceMount;
      if (action.name === "setValueFromField") {
        return true;
      }
      if (action.name === "setValueFromAction") {
        if (isCurrentValueTheDefaultValue && ["accept", "today", "clear"].includes(action.pickerAction)) {
          return true;
        }
        return hasChanged(dateState.lastPublishedValue);
      }
      if (action.name === "setValueFromView" && action.selectionState !== "shallow") {
        if (isCurrentValueTheDefaultValue) {
          return true;
        }
        return hasChanged(dateState.lastPublishedValue);
      }
      if (action.name === "setValueFromShortcut") {
        if (isCurrentValueTheDefaultValue) {
          return true;
        }
        return hasChanged(dateState.lastPublishedValue);
      }
      return false;
    };
    const shouldCommitValue = (params) => {
      const {
        action,
        hasChanged,
        dateState,
        isControlled,
        closeOnSelect
      } = params;
      const isCurrentValueTheDefaultValue = !isControlled && !dateState.hasBeenModifiedSinceMount;
      if (action.name === "setValueFromAction") {
        if (isCurrentValueTheDefaultValue && ["accept", "today", "clear"].includes(action.pickerAction)) {
          return true;
        }
        return hasChanged(dateState.lastCommittedValue);
      }
      if (action.name === "setValueFromView" && action.selectionState === "finish" && closeOnSelect) {
        if (isCurrentValueTheDefaultValue) {
          return true;
        }
        return hasChanged(dateState.lastCommittedValue);
      }
      if (action.name === "setValueFromShortcut") {
        return action.changeImportance === "accept" && hasChanged(dateState.lastCommittedValue);
      }
      return false;
    };
    const shouldClosePicker = (params) => {
      const {
        action,
        closeOnSelect
      } = params;
      if (action.name === "setValueFromAction") {
        return true;
      }
      if (action.name === "setValueFromView") {
        return action.selectionState === "finish" && closeOnSelect;
      }
      if (action.name === "setValueFromShortcut") {
        return action.changeImportance === "accept";
      }
      return false;
    };
    const usePickerValue = ({
      props,
      valueManager,
      valueType,
      wrapperVariant,
      validator: validator2
    }) => {
      const {
        onAccept,
        onChange,
        value: inValue,
        defaultValue: inDefaultValue,
        closeOnSelect = wrapperVariant === "desktop",
        selectedSections: selectedSectionsProp,
        onSelectedSectionsChange,
        timezone: timezoneProp
      } = props;
      const {
        current: defaultValue
      } = reactExports.useRef(inDefaultValue);
      const {
        current: isControlled
      } = reactExports.useRef(inValue !== void 0);
      const utils2 = useUtils();
      const adapter = useLocalizationContext();
      const [selectedSections, setSelectedSections] = useControlled({
        controlled: selectedSectionsProp,
        default: null,
        name: "usePickerValue",
        state: "selectedSections"
      });
      const {
        isOpen,
        setIsOpen
      } = useOpenState(props);
      const [dateState, setDateState] = reactExports.useState(() => {
        let initialValue;
        if (inValue !== void 0) {
          initialValue = inValue;
        } else if (defaultValue !== void 0) {
          initialValue = defaultValue;
        } else {
          initialValue = valueManager.emptyValue;
        }
        return {
          draft: initialValue,
          lastPublishedValue: initialValue,
          lastCommittedValue: initialValue,
          lastControlledValue: inValue,
          hasBeenModifiedSinceMount: false
        };
      });
      const {
        timezone,
        handleValueChange
      } = useValueWithTimezone({
        timezone: timezoneProp,
        value: inValue,
        defaultValue,
        onChange,
        valueManager
      });
      useValidation(_extends$1({}, props, {
        value: dateState.draft,
        timezone
      }), validator2, valueManager.isSameError, valueManager.defaultErrorState);
      const updateDate = useEventCallback((action) => {
        const updaterParams = {
          action,
          dateState,
          hasChanged: (comparison) => !valueManager.areValuesEqual(utils2, action.value, comparison),
          isControlled,
          closeOnSelect
        };
        const shouldPublish = shouldPublishValue(updaterParams);
        const shouldCommit = shouldCommitValue(updaterParams);
        const shouldClose = shouldClosePicker(updaterParams);
        setDateState((prev2) => _extends$1({}, prev2, {
          draft: action.value,
          lastPublishedValue: shouldPublish ? action.value : prev2.lastPublishedValue,
          lastCommittedValue: shouldCommit ? action.value : prev2.lastCommittedValue,
          hasBeenModifiedSinceMount: true
        }));
        if (shouldPublish) {
          const validationError = action.name === "setValueFromField" ? action.context.validationError : validator2({
            adapter,
            value: action.value,
            props: _extends$1({}, props, {
              value: action.value,
              timezone
            })
          });
          const context = {
            validationError
          };
          if (action.name === "setValueFromShortcut" && action.shortcut != null) {
            context.shortcut = action.shortcut;
          }
          handleValueChange(action.value, context);
        }
        if (shouldCommit && onAccept) {
          onAccept(action.value);
        }
        if (shouldClose) {
          setIsOpen(false);
        }
      });
      if (inValue !== void 0 && (dateState.lastControlledValue === void 0 || !valueManager.areValuesEqual(utils2, dateState.lastControlledValue, inValue))) {
        const isUpdateComingFromPicker = valueManager.areValuesEqual(utils2, dateState.draft, inValue);
        setDateState((prev2) => _extends$1({}, prev2, {
          lastControlledValue: inValue
        }, isUpdateComingFromPicker ? {} : {
          lastCommittedValue: inValue,
          lastPublishedValue: inValue,
          draft: inValue,
          hasBeenModifiedSinceMount: true
        }));
      }
      const handleClear = useEventCallback(() => {
        updateDate({
          value: valueManager.emptyValue,
          name: "setValueFromAction",
          pickerAction: "clear"
        });
      });
      const handleAccept = useEventCallback(() => {
        updateDate({
          value: dateState.lastPublishedValue,
          name: "setValueFromAction",
          pickerAction: "accept"
        });
      });
      const handleDismiss = useEventCallback(() => {
        updateDate({
          value: dateState.lastPublishedValue,
          name: "setValueFromAction",
          pickerAction: "dismiss"
        });
      });
      const handleCancel = useEventCallback(() => {
        updateDate({
          value: dateState.lastCommittedValue,
          name: "setValueFromAction",
          pickerAction: "cancel"
        });
      });
      const handleSetToday = useEventCallback(() => {
        updateDate({
          value: valueManager.getTodayValue(utils2, timezone, valueType),
          name: "setValueFromAction",
          pickerAction: "today"
        });
      });
      const handleOpen = useEventCallback(() => setIsOpen(true));
      const handleClose = useEventCallback(() => setIsOpen(false));
      const handleChange = useEventCallback((newValue, selectionState = "partial") => updateDate({
        name: "setValueFromView",
        value: newValue,
        selectionState
      }));
      const handleSelectShortcut = useEventCallback((newValue, changeImportance, shortcut) => updateDate({
        name: "setValueFromShortcut",
        value: newValue,
        changeImportance: changeImportance != null ? changeImportance : "accept",
        shortcut
      }));
      const handleChangeFromField = useEventCallback((newValue, context) => updateDate({
        name: "setValueFromField",
        value: newValue,
        context
      }));
      const handleFieldSelectedSectionsChange = useEventCallback((newSelectedSections) => {
        setSelectedSections(newSelectedSections);
        onSelectedSectionsChange == null || onSelectedSectionsChange(newSelectedSections);
      });
      const actions = {
        onClear: handleClear,
        onAccept: handleAccept,
        onDismiss: handleDismiss,
        onCancel: handleCancel,
        onSetToday: handleSetToday,
        onOpen: handleOpen,
        onClose: handleClose
      };
      const fieldResponse = {
        value: dateState.draft,
        onChange: handleChangeFromField,
        selectedSections,
        onSelectedSectionsChange: handleFieldSelectedSectionsChange
      };
      const viewValue = reactExports.useMemo(() => valueManager.cleanValue(utils2, dateState.draft), [utils2, valueManager, dateState.draft]);
      const viewResponse = {
        value: viewValue,
        onChange: handleChange,
        onClose: handleClose,
        open: isOpen,
        onSelectedSectionsChange: handleFieldSelectedSectionsChange
      };
      const isValid = (testedValue) => {
        const error = validator2({
          adapter,
          value: testedValue,
          props: _extends$1({}, props, {
            value: testedValue,
            timezone
          })
        });
        return !valueManager.hasError(error);
      };
      const layoutResponse = _extends$1({}, actions, {
        value: viewValue,
        onChange: handleChange,
        onSelectShortcut: handleSelectShortcut,
        isValid
      });
      return {
        open: isOpen,
        fieldProps: fieldResponse,
        viewProps: viewResponse,
        layoutProps: layoutResponse,
        actions
      };
    };
    function useViews({
      onChange,
      onViewChange,
      openTo,
      view: inView,
      views,
      autoFocus,
      focusedView: inFocusedView,
      onFocusedViewChange
    }) {
      var _views, _views2;
      const previousOpenTo = reactExports.useRef(openTo);
      const previousViews = reactExports.useRef(views);
      const defaultView = reactExports.useRef(views.includes(openTo) ? openTo : views[0]);
      const [view, setView] = useControlled({
        name: "useViews",
        state: "view",
        controlled: inView,
        default: defaultView.current
      });
      const defaultFocusedView = reactExports.useRef(autoFocus ? view : null);
      const [focusedView, setFocusedView] = useControlled({
        name: "useViews",
        state: "focusedView",
        controlled: inFocusedView,
        default: defaultFocusedView.current
      });
      reactExports.useEffect(() => {
        if (previousOpenTo.current && previousOpenTo.current !== openTo || previousViews.current && previousViews.current.some((previousView2) => !views.includes(previousView2))) {
          setView(views.includes(openTo) ? openTo : views[0]);
          previousViews.current = views;
          previousOpenTo.current = openTo;
        }
      }, [openTo, setView, view, views]);
      const viewIndex = views.indexOf(view);
      const previousView = (_views = views[viewIndex - 1]) != null ? _views : null;
      const nextView = (_views2 = views[viewIndex + 1]) != null ? _views2 : null;
      const handleFocusedViewChange = useEventCallback((viewToFocus, hasFocus) => {
        if (hasFocus) {
          setFocusedView(viewToFocus);
        } else {
          setFocusedView(
            (prevFocusedView) => viewToFocus === prevFocusedView ? null : prevFocusedView
            // If false the blur is due to view switching
          );
        }
        onFocusedViewChange == null || onFocusedViewChange(viewToFocus, hasFocus);
      });
      const handleChangeView = useEventCallback((newView) => {
        handleFocusedViewChange(newView, true);
        if (newView === view) {
          return;
        }
        setView(newView);
        if (onViewChange) {
          onViewChange(newView);
        }
      });
      const goToNextView = useEventCallback(() => {
        if (nextView) {
          handleChangeView(nextView);
        }
      });
      const setValueAndGoToNextView = useEventCallback((value, currentViewSelectionState, selectedView) => {
        const isSelectionFinishedOnCurrentView = currentViewSelectionState === "finish";
        const hasMoreViews = selectedView ? (
          // handles case like `DateTimePicker`, where a view might return a `finish` selection state
          // but we it's not the final view given all `views` -> overall selection state should be `partial`.
          views.indexOf(selectedView) < views.length - 1
        ) : Boolean(nextView);
        const globalSelectionState = isSelectionFinishedOnCurrentView && hasMoreViews ? "partial" : currentViewSelectionState;
        onChange(value, globalSelectionState, selectedView);
        if (selectedView && selectedView !== view) {
          const nextViewAfterSelected = views[views.indexOf(selectedView) + 1];
          if (nextViewAfterSelected) {
            handleChangeView(nextViewAfterSelected);
          }
        } else if (isSelectionFinishedOnCurrentView) {
          goToNextView();
        }
      });
      return {
        view,
        setView: handleChangeView,
        focusedView,
        setFocusedView: handleFocusedViewChange,
        nextView,
        previousView,
        // Always return up to date default view instead of the initial one (i.e. defaultView.current)
        defaultView: views.includes(openTo) ? openTo : views[0],
        goToNextView,
        setValueAndGoToNextView
      };
    }
    const _excluded$i = ["className", "sx"];
    const usePickerViews = ({
      props,
      propsFromPickerValue,
      additionalViewProps,
      inputRef,
      autoFocusView
    }) => {
      const {
        onChange,
        open,
        onSelectedSectionsChange,
        onClose
      } = propsFromPickerValue;
      const {
        views,
        openTo,
        onViewChange,
        disableOpenPicker,
        viewRenderers,
        timezone
      } = props;
      const propsToForwardToView = _objectWithoutPropertiesLoose$1(props, _excluded$i);
      const {
        view,
        setView,
        defaultView,
        focusedView,
        setFocusedView,
        setValueAndGoToNextView
      } = useViews({
        view: void 0,
        views,
        openTo,
        onChange,
        onViewChange,
        autoFocus: autoFocusView
      });
      const {
        hasUIView,
        viewModeLookup
      } = reactExports.useMemo(() => views.reduce((acc, viewForReduce) => {
        let viewMode;
        if (disableOpenPicker) {
          viewMode = "field";
        } else if (viewRenderers[viewForReduce] != null) {
          viewMode = "UI";
        } else {
          viewMode = "field";
        }
        acc.viewModeLookup[viewForReduce] = viewMode;
        if (viewMode === "UI") {
          acc.hasUIView = true;
        }
        return acc;
      }, {
        hasUIView: false,
        viewModeLookup: {}
      }), [disableOpenPicker, viewRenderers, views]);
      const timeViewsCount = reactExports.useMemo(() => views.reduce((acc, viewForReduce) => {
        if (viewRenderers[viewForReduce] != null && isTimeView(viewForReduce)) {
          return acc + 1;
        }
        return acc;
      }, 0), [viewRenderers, views]);
      const currentViewMode = viewModeLookup[view];
      const shouldRestoreFocus = useEventCallback(() => currentViewMode === "UI");
      const [popperView, setPopperView] = reactExports.useState(currentViewMode === "UI" ? view : null);
      if (popperView !== view && viewModeLookup[view] === "UI") {
        setPopperView(view);
      }
      useEnhancedEffect(() => {
        if (currentViewMode === "field" && open) {
          onClose();
          setTimeout(() => {
            inputRef == null || inputRef.current.focus();
            onSelectedSectionsChange(view);
          });
        }
      }, [view]);
      useEnhancedEffect(() => {
        if (!open) {
          return;
        }
        let newView = view;
        if (currentViewMode === "field" && popperView != null) {
          newView = popperView;
        }
        if (newView !== defaultView && viewModeLookup[newView] === "UI" && viewModeLookup[defaultView] === "UI") {
          newView = defaultView;
        }
        if (newView !== view) {
          setView(newView);
        }
        setFocusedView(newView, true);
      }, [open]);
      const layoutProps = {
        views,
        view: popperView,
        onViewChange: setView
      };
      return {
        hasUIView,
        shouldRestoreFocus,
        layoutProps,
        renderCurrentView: () => {
          if (popperView == null) {
            return null;
          }
          const renderer = viewRenderers[popperView];
          if (renderer == null) {
            return null;
          }
          return renderer(_extends$1({}, propsToForwardToView, additionalViewProps, propsFromPickerValue, {
            views,
            timezone,
            onChange: setValueAndGoToNextView,
            view: popperView,
            onViewChange: setView,
            focusedView,
            onFocusedViewChange: setFocusedView,
            showViewSwitcher: timeViewsCount > 1,
            timeViewsCount
          }));
        }
      };
    };
    function getOrientation() {
      if (typeof window === "undefined") {
        return "portrait";
      }
      if (window.screen && window.screen.orientation && window.screen.orientation.angle) {
        return Math.abs(window.screen.orientation.angle) === 90 ? "landscape" : "portrait";
      }
      if (window.orientation) {
        return Math.abs(Number(window.orientation)) === 90 ? "landscape" : "portrait";
      }
      return "portrait";
    }
    const useIsLandscape = (views, customOrientation) => {
      const [orientation, setOrientation] = reactExports.useState(getOrientation);
      useEnhancedEffect(() => {
        const eventHandler = () => {
          setOrientation(getOrientation());
        };
        window.addEventListener("orientationchange", eventHandler);
        return () => {
          window.removeEventListener("orientationchange", eventHandler);
        };
      }, []);
      if (arrayIncludes(views, ["hours", "minutes", "seconds"])) {
        return false;
      }
      const orientationToUse = customOrientation || orientation;
      return orientationToUse === "landscape";
    };
    const usePickerLayoutProps = ({
      props,
      propsFromPickerValue,
      propsFromPickerViews,
      wrapperVariant
    }) => {
      const {
        orientation
      } = props;
      const isLandscape = useIsLandscape(propsFromPickerViews.views, orientation);
      const layoutProps = _extends$1({}, propsFromPickerViews, propsFromPickerValue, {
        isLandscape,
        wrapperVariant,
        disabled: props.disabled,
        readOnly: props.readOnly
      });
      return {
        layoutProps
      };
    };
    const buildWarning = (message, gravity = "warning") => {
      let alreadyWarned2 = false;
      const cleanMessage = Array.isArray(message) ? message.join("\n") : message;
      return () => {
        if (!alreadyWarned2) {
          alreadyWarned2 = true;
          if (gravity === "error") {
            console.error(cleanMessage);
          } else {
            console.warn(cleanMessage);
          }
        }
      };
    };
    buildWarning(["The `renderInput` prop has been removed in version 6.0 of the Date and Time Pickers.", "You can replace it with the `textField` component slot in most cases.", "For more information, please have a look at the migration guide (https://mui.com/x/migration/migration-pickers-v5/#input-renderer-required-in-v5)."]);
    const usePicker = ({
      props,
      valueManager,
      valueType,
      wrapperVariant,
      inputRef,
      additionalViewProps,
      validator: validator2,
      autoFocusView
    }) => {
      const pickerValueResponse = usePickerValue({
        props,
        valueManager,
        valueType,
        wrapperVariant,
        validator: validator2
      });
      const pickerViewsResponse = usePickerViews({
        props,
        inputRef,
        additionalViewProps,
        autoFocusView,
        propsFromPickerValue: pickerValueResponse.viewProps
      });
      const pickerLayoutResponse = usePickerLayoutProps({
        props,
        wrapperVariant,
        propsFromPickerValue: pickerValueResponse.layoutProps,
        propsFromPickerViews: pickerViewsResponse.layoutProps
      });
      return {
        // Picker value
        open: pickerValueResponse.open,
        actions: pickerValueResponse.actions,
        fieldProps: pickerValueResponse.fieldProps,
        // Picker views
        renderCurrentView: pickerViewsResponse.renderCurrentView,
        hasUIView: pickerViewsResponse.hasUIView,
        shouldRestoreFocus: pickerViewsResponse.shouldRestoreFocus,
        // Picker layout
        layoutProps: pickerLayoutResponse.layoutProps
      };
    };
    function getPickersLayoutUtilityClass(slot) {
      return generateUtilityClass$1("MuiPickersLayout", slot);
    }
    const pickersLayoutClasses = generateUtilityClasses$1("MuiPickersLayout", ["root", "landscape", "contentWrapper", "toolbar", "actionBar", "tabs", "shortcuts"]);
    const _excluded$h = ["onAccept", "onClear", "onCancel", "onSetToday", "actions"];
    function PickersActionBar(props) {
      const {
        onAccept,
        onClear,
        onCancel,
        onSetToday,
        actions
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$h);
      const localeText = useLocaleText();
      if (actions == null || actions.length === 0) {
        return null;
      }
      const buttons = actions == null ? void 0 : actions.map((actionType) => {
        switch (actionType) {
          case "clear":
            return /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, {
              onClick: onClear,
              children: localeText.clearButtonLabel
            }, actionType);
          case "cancel":
            return /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, {
              onClick: onCancel,
              children: localeText.cancelButtonLabel
            }, actionType);
          case "accept":
            return /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, {
              onClick: onAccept,
              children: localeText.okButtonLabel
            }, actionType);
          case "today":
            return /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, {
              onClick: onSetToday,
              children: localeText.todayButtonLabel
            }, actionType);
          default:
            return null;
        }
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogActions$1, _extends$1({}, other, {
        children: buttons
      }));
    }
    function getListItemUtilityClass(slot) {
      return generateUtilityClass$1("MuiListItem", slot);
    }
    const listItemClasses = generateUtilityClasses$1("MuiListItem", ["root", "container", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "padding", "button", "secondaryAction", "selected"]);
    const listItemClasses$1 = listItemClasses;
    const listItemButtonClasses = generateUtilityClasses$1("MuiListItemButton", ["root", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "selected"]);
    const listItemButtonClasses$1 = listItemButtonClasses;
    function getListItemSecondaryActionClassesUtilityClass(slot) {
      return generateUtilityClass$1("MuiListItemSecondaryAction", slot);
    }
    generateUtilityClasses$1("MuiListItemSecondaryAction", ["root", "disableGutters"]);
    const _excluded$g = ["className"];
    const useUtilityClasses$d = (ownerState) => {
      const {
        disableGutters,
        classes
      } = ownerState;
      const slots = {
        root: ["root", disableGutters && "disableGutters"]
      };
      return composeClasses(slots, getListItemSecondaryActionClassesUtilityClass, classes);
    };
    const ListItemSecondaryActionRoot = styled("div", {
      name: "MuiListItemSecondaryAction",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, ownerState.disableGutters && styles2.disableGutters];
      }
    })(({
      ownerState
    }) => _extends$1({
      position: "absolute",
      right: 16,
      top: "50%",
      transform: "translateY(-50%)"
    }, ownerState.disableGutters && {
      right: 0
    }));
    const ListItemSecondaryAction = /* @__PURE__ */ reactExports.forwardRef(function ListItemSecondaryAction2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiListItemSecondaryAction"
      });
      const {
        className
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$g);
      const context = reactExports.useContext(ListContext$1);
      const ownerState = _extends$1({}, props, {
        disableGutters: context.disableGutters
      });
      const classes = useUtilityClasses$d(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemSecondaryActionRoot, _extends$1({
        className: clsx(classes.root, className),
        ownerState,
        ref
      }, other));
    });
    ListItemSecondaryAction.muiName = "ListItemSecondaryAction";
    const ListItemSecondaryAction$1 = ListItemSecondaryAction;
    const _excluded$f = ["className"], _excluded2$3 = ["alignItems", "autoFocus", "button", "children", "className", "component", "components", "componentsProps", "ContainerComponent", "ContainerProps", "dense", "disabled", "disableGutters", "disablePadding", "divider", "focusVisibleClassName", "secondaryAction", "selected", "slotProps", "slots"];
    const overridesResolver$1 = (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.dense && styles2.dense, ownerState.alignItems === "flex-start" && styles2.alignItemsFlexStart, ownerState.divider && styles2.divider, !ownerState.disableGutters && styles2.gutters, !ownerState.disablePadding && styles2.padding, ownerState.button && styles2.button, ownerState.hasSecondaryAction && styles2.secondaryAction];
    };
    const useUtilityClasses$c = (ownerState) => {
      const {
        alignItems,
        button,
        classes,
        dense,
        disabled,
        disableGutters,
        disablePadding,
        divider,
        hasSecondaryAction,
        selected
      } = ownerState;
      const slots = {
        root: ["root", dense && "dense", !disableGutters && "gutters", !disablePadding && "padding", divider && "divider", disabled && "disabled", button && "button", alignItems === "flex-start" && "alignItemsFlexStart", hasSecondaryAction && "secondaryAction", selected && "selected"],
        container: ["container"]
      };
      return composeClasses(slots, getListItemUtilityClass, classes);
    };
    const ListItemRoot = styled("div", {
      name: "MuiListItem",
      slot: "Root",
      overridesResolver: overridesResolver$1
    })(({
      theme,
      ownerState
    }) => _extends$1({
      display: "flex",
      justifyContent: "flex-start",
      alignItems: "center",
      position: "relative",
      textDecoration: "none",
      width: "100%",
      boxSizing: "border-box",
      textAlign: "left"
    }, !ownerState.disablePadding && _extends$1({
      paddingTop: 8,
      paddingBottom: 8
    }, ownerState.dense && {
      paddingTop: 4,
      paddingBottom: 4
    }, !ownerState.disableGutters && {
      paddingLeft: 16,
      paddingRight: 16
    }, !!ownerState.secondaryAction && {
      // Add some space to avoid collision as `ListItemSecondaryAction`
      // is absolutely positioned.
      paddingRight: 48
    }), !!ownerState.secondaryAction && {
      [`& > .${listItemButtonClasses$1.root}`]: {
        paddingRight: 48
      }
    }, {
      [`&.${listItemClasses$1.focusVisible}`]: {
        backgroundColor: (theme.vars || theme).palette.action.focus
      },
      [`&.${listItemClasses$1.selected}`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha$1(theme.palette.primary.main, theme.palette.action.selectedOpacity),
        [`&.${listItemClasses$1.focusVisible}`]: {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha$1(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
        }
      },
      [`&.${listItemClasses$1.disabled}`]: {
        opacity: (theme.vars || theme).palette.action.disabledOpacity
      }
    }, ownerState.alignItems === "flex-start" && {
      alignItems: "flex-start"
    }, ownerState.divider && {
      borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`,
      backgroundClip: "padding-box"
    }, ownerState.button && {
      transition: theme.transitions.create("background-color", {
        duration: theme.transitions.duration.shortest
      }),
      "&:hover": {
        textDecoration: "none",
        backgroundColor: (theme.vars || theme).palette.action.hover,
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      },
      [`&.${listItemClasses$1.selected}:hover`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha$1(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha$1(theme.palette.primary.main, theme.palette.action.selectedOpacity)
        }
      }
    }, ownerState.hasSecondaryAction && {
      // Add some space to avoid collision as `ListItemSecondaryAction`
      // is absolutely positioned.
      paddingRight: 48
    }));
    const ListItemContainer = styled("li", {
      name: "MuiListItem",
      slot: "Container",
      overridesResolver: (props, styles2) => styles2.container
    })({
      position: "relative"
    });
    const ListItem = /* @__PURE__ */ reactExports.forwardRef(function ListItem2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiListItem"
      });
      const {
        alignItems = "center",
        autoFocus = false,
        button = false,
        children: childrenProp,
        className,
        component: componentProp,
        components = {},
        componentsProps = {},
        ContainerComponent = "li",
        ContainerProps: {
          className: ContainerClassName
        } = {},
        dense = false,
        disabled = false,
        disableGutters = false,
        disablePadding = false,
        divider = false,
        focusVisibleClassName,
        secondaryAction,
        selected = false,
        slotProps = {},
        slots = {}
      } = props, ContainerProps = _objectWithoutPropertiesLoose$1(props.ContainerProps, _excluded$f), other = _objectWithoutPropertiesLoose$1(props, _excluded2$3);
      const context = reactExports.useContext(ListContext$1);
      const childContext = reactExports.useMemo(() => ({
        dense: dense || context.dense || false,
        alignItems,
        disableGutters
      }), [alignItems, context.dense, dense, disableGutters]);
      const listItemRef = reactExports.useRef(null);
      useEnhancedEffect(() => {
        if (autoFocus) {
          if (listItemRef.current) {
            listItemRef.current.focus();
          }
        }
      }, [autoFocus]);
      const children = reactExports.Children.toArray(childrenProp);
      const hasSecondaryAction = children.length && isMuiElement(children[children.length - 1], ["ListItemSecondaryAction"]);
      const ownerState = _extends$1({}, props, {
        alignItems,
        autoFocus,
        button,
        dense: childContext.dense,
        disabled,
        disableGutters,
        disablePadding,
        divider,
        hasSecondaryAction,
        selected
      });
      const classes = useUtilityClasses$c(ownerState);
      const handleRef = useForkRef(listItemRef, ref);
      const Root = slots.root || components.Root || ListItemRoot;
      const rootProps = slotProps.root || componentsProps.root || {};
      const componentProps = _extends$1({
        className: clsx(classes.root, rootProps.className, className),
        disabled
      }, other);
      let Component = componentProp || "li";
      if (button) {
        componentProps.component = componentProp || "div";
        componentProps.focusVisibleClassName = clsx(listItemClasses$1.focusVisible, focusVisibleClassName);
        Component = ButtonBase$1;
      }
      if (hasSecondaryAction) {
        Component = !componentProps.component && !componentProp ? "div" : Component;
        if (ContainerComponent === "li") {
          if (Component === "li") {
            Component = "div";
          } else if (componentProps.component === "li") {
            componentProps.component = "div";
          }
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext$1.Provider, {
          value: childContext,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItemContainer, _extends$1({
            as: ContainerComponent,
            className: clsx(classes.container, ContainerClassName),
            ref: handleRef,
            ownerState
          }, ContainerProps, {
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Root, _extends$1({}, rootProps, !isHostComponent(Root) && {
              as: Component,
              ownerState: _extends$1({}, ownerState, rootProps.ownerState)
            }, componentProps, {
              children
            })), children.pop()]
          }))
        });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext$1.Provider, {
        value: childContext,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Root, _extends$1({}, rootProps, {
          as: Component,
          ref: handleRef
        }, !isHostComponent(Root) && {
          ownerState: _extends$1({}, ownerState, rootProps.ownerState)
        }, componentProps, {
          children: [children, secondaryAction && /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemSecondaryAction$1, {
            children: secondaryAction
          })]
        }))
      });
    });
    const ListItem$1 = ListItem;
    const CancelIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"
    }), "Cancel");
    function getChipUtilityClass(slot) {
      return generateUtilityClass$1("MuiChip", slot);
    }
    const chipClasses = generateUtilityClasses$1("MuiChip", ["root", "sizeSmall", "sizeMedium", "colorError", "colorInfo", "colorPrimary", "colorSecondary", "colorSuccess", "colorWarning", "disabled", "clickable", "clickableColorPrimary", "clickableColorSecondary", "deletable", "deletableColorPrimary", "deletableColorSecondary", "outlined", "filled", "outlinedPrimary", "outlinedSecondary", "filledPrimary", "filledSecondary", "avatar", "avatarSmall", "avatarMedium", "avatarColorPrimary", "avatarColorSecondary", "icon", "iconSmall", "iconMedium", "iconColorPrimary", "iconColorSecondary", "label", "labelSmall", "labelMedium", "deleteIcon", "deleteIconSmall", "deleteIconMedium", "deleteIconColorPrimary", "deleteIconColorSecondary", "deleteIconOutlinedColorPrimary", "deleteIconOutlinedColorSecondary", "deleteIconFilledColorPrimary", "deleteIconFilledColorSecondary", "focusVisible"]);
    const chipClasses$1 = chipClasses;
    const _excluded$e = ["avatar", "className", "clickable", "color", "component", "deleteIcon", "disabled", "icon", "label", "onClick", "onDelete", "onKeyDown", "onKeyUp", "size", "variant", "tabIndex", "skipFocusWhenDisabled"];
    const useUtilityClasses$b = (ownerState) => {
      const {
        classes,
        disabled,
        size,
        color: color2,
        iconColor,
        onDelete,
        clickable,
        variant
      } = ownerState;
      const slots = {
        root: ["root", variant, disabled && "disabled", `size${capitalize(size)}`, `color${capitalize(color2)}`, clickable && "clickable", clickable && `clickableColor${capitalize(color2)}`, onDelete && "deletable", onDelete && `deletableColor${capitalize(color2)}`, `${variant}${capitalize(color2)}`],
        label: ["label", `label${capitalize(size)}`],
        avatar: ["avatar", `avatar${capitalize(size)}`, `avatarColor${capitalize(color2)}`],
        icon: ["icon", `icon${capitalize(size)}`, `iconColor${capitalize(iconColor)}`],
        deleteIcon: ["deleteIcon", `deleteIcon${capitalize(size)}`, `deleteIconColor${capitalize(color2)}`, `deleteIcon${capitalize(variant)}Color${capitalize(color2)}`]
      };
      return composeClasses(slots, getChipUtilityClass, classes);
    };
    const ChipRoot = styled("div", {
      name: "MuiChip",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        const {
          color: color2,
          iconColor,
          clickable,
          onDelete,
          size,
          variant
        } = ownerState;
        return [{
          [`& .${chipClasses$1.avatar}`]: styles2.avatar
        }, {
          [`& .${chipClasses$1.avatar}`]: styles2[`avatar${capitalize(size)}`]
        }, {
          [`& .${chipClasses$1.avatar}`]: styles2[`avatarColor${capitalize(color2)}`]
        }, {
          [`& .${chipClasses$1.icon}`]: styles2.icon
        }, {
          [`& .${chipClasses$1.icon}`]: styles2[`icon${capitalize(size)}`]
        }, {
          [`& .${chipClasses$1.icon}`]: styles2[`iconColor${capitalize(iconColor)}`]
        }, {
          [`& .${chipClasses$1.deleteIcon}`]: styles2.deleteIcon
        }, {
          [`& .${chipClasses$1.deleteIcon}`]: styles2[`deleteIcon${capitalize(size)}`]
        }, {
          [`& .${chipClasses$1.deleteIcon}`]: styles2[`deleteIconColor${capitalize(color2)}`]
        }, {
          [`& .${chipClasses$1.deleteIcon}`]: styles2[`deleteIcon${capitalize(variant)}Color${capitalize(color2)}`]
        }, styles2.root, styles2[`size${capitalize(size)}`], styles2[`color${capitalize(color2)}`], clickable && styles2.clickable, clickable && color2 !== "default" && styles2[`clickableColor${capitalize(color2)})`], onDelete && styles2.deletable, onDelete && color2 !== "default" && styles2[`deletableColor${capitalize(color2)}`], styles2[variant], styles2[`${variant}${capitalize(color2)}`]];
      }
    })(({
      theme,
      ownerState
    }) => {
      const textColor = theme.palette.mode === "light" ? theme.palette.grey[700] : theme.palette.grey[300];
      return _extends$1({
        maxWidth: "100%",
        fontFamily: theme.typography.fontFamily,
        fontSize: theme.typography.pxToRem(13),
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        height: 32,
        color: (theme.vars || theme).palette.text.primary,
        backgroundColor: (theme.vars || theme).palette.action.selected,
        borderRadius: 32 / 2,
        whiteSpace: "nowrap",
        transition: theme.transitions.create(["background-color", "box-shadow"]),
        // reset cursor explicitly in case ButtonBase is used
        cursor: "unset",
        // We disable the focus ring for mouse, touch and keyboard users.
        outline: 0,
        textDecoration: "none",
        border: 0,
        // Remove `button` border
        padding: 0,
        // Remove `button` padding
        verticalAlign: "middle",
        boxSizing: "border-box",
        [`&.${chipClasses$1.disabled}`]: {
          opacity: (theme.vars || theme).palette.action.disabledOpacity,
          pointerEvents: "none"
        },
        [`& .${chipClasses$1.avatar}`]: {
          marginLeft: 5,
          marginRight: -6,
          width: 24,
          height: 24,
          color: theme.vars ? theme.vars.palette.Chip.defaultAvatarColor : textColor,
          fontSize: theme.typography.pxToRem(12)
        },
        [`& .${chipClasses$1.avatarColorPrimary}`]: {
          color: (theme.vars || theme).palette.primary.contrastText,
          backgroundColor: (theme.vars || theme).palette.primary.dark
        },
        [`& .${chipClasses$1.avatarColorSecondary}`]: {
          color: (theme.vars || theme).palette.secondary.contrastText,
          backgroundColor: (theme.vars || theme).palette.secondary.dark
        },
        [`& .${chipClasses$1.avatarSmall}`]: {
          marginLeft: 4,
          marginRight: -4,
          width: 18,
          height: 18,
          fontSize: theme.typography.pxToRem(10)
        },
        [`& .${chipClasses$1.icon}`]: _extends$1({
          marginLeft: 5,
          marginRight: -6
        }, ownerState.size === "small" && {
          fontSize: 18,
          marginLeft: 4,
          marginRight: -4
        }, ownerState.iconColor === ownerState.color && _extends$1({
          color: theme.vars ? theme.vars.palette.Chip.defaultIconColor : textColor
        }, ownerState.color !== "default" && {
          color: "inherit"
        })),
        [`& .${chipClasses$1.deleteIcon}`]: _extends$1({
          WebkitTapHighlightColor: "transparent",
          color: theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / 0.26)` : alpha$1(theme.palette.text.primary, 0.26),
          fontSize: 22,
          cursor: "pointer",
          margin: "0 5px 0 -6px",
          "&:hover": {
            color: theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / 0.4)` : alpha$1(theme.palette.text.primary, 0.4)
          }
        }, ownerState.size === "small" && {
          fontSize: 16,
          marginRight: 4,
          marginLeft: -4
        }, ownerState.color !== "default" && {
          color: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].contrastTextChannel} / 0.7)` : alpha$1(theme.palette[ownerState.color].contrastText, 0.7),
          "&:hover, &:active": {
            color: (theme.vars || theme).palette[ownerState.color].contrastText
          }
        })
      }, ownerState.size === "small" && {
        height: 24
      }, ownerState.color !== "default" && {
        backgroundColor: (theme.vars || theme).palette[ownerState.color].main,
        color: (theme.vars || theme).palette[ownerState.color].contrastText
      }, ownerState.onDelete && {
        [`&.${chipClasses$1.focusVisible}`]: {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.selectedChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha$1(theme.palette.action.selected, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
        }
      }, ownerState.onDelete && ownerState.color !== "default" && {
        [`&.${chipClasses$1.focusVisible}`]: {
          backgroundColor: (theme.vars || theme).palette[ownerState.color].dark
        }
      });
    }, ({
      theme,
      ownerState
    }) => _extends$1({}, ownerState.clickable && {
      userSelect: "none",
      WebkitTapHighlightColor: "transparent",
      cursor: "pointer",
      "&:hover": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.selectedChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha$1(theme.palette.action.selected, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity)
      },
      [`&.${chipClasses$1.focusVisible}`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.selectedChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha$1(theme.palette.action.selected, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
      },
      "&:active": {
        boxShadow: (theme.vars || theme).shadows[1]
      }
    }, ownerState.clickable && ownerState.color !== "default" && {
      [`&:hover, &.${chipClasses$1.focusVisible}`]: {
        backgroundColor: (theme.vars || theme).palette[ownerState.color].dark
      }
    }), ({
      theme,
      ownerState
    }) => _extends$1({}, ownerState.variant === "outlined" && {
      backgroundColor: "transparent",
      border: theme.vars ? `1px solid ${theme.vars.palette.Chip.defaultBorder}` : `1px solid ${theme.palette.mode === "light" ? theme.palette.grey[400] : theme.palette.grey[700]}`,
      [`&.${chipClasses$1.clickable}:hover`]: {
        backgroundColor: (theme.vars || theme).palette.action.hover
      },
      [`&.${chipClasses$1.focusVisible}`]: {
        backgroundColor: (theme.vars || theme).palette.action.focus
      },
      [`& .${chipClasses$1.avatar}`]: {
        marginLeft: 4
      },
      [`& .${chipClasses$1.avatarSmall}`]: {
        marginLeft: 2
      },
      [`& .${chipClasses$1.icon}`]: {
        marginLeft: 4
      },
      [`& .${chipClasses$1.iconSmall}`]: {
        marginLeft: 2
      },
      [`& .${chipClasses$1.deleteIcon}`]: {
        marginRight: 5
      },
      [`& .${chipClasses$1.deleteIconSmall}`]: {
        marginRight: 3
      }
    }, ownerState.variant === "outlined" && ownerState.color !== "default" && {
      color: (theme.vars || theme).palette[ownerState.color].main,
      border: `1px solid ${theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.7)` : alpha$1(theme.palette[ownerState.color].main, 0.7)}`,
      [`&.${chipClasses$1.clickable}:hover`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha$1(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity)
      },
      [`&.${chipClasses$1.focusVisible}`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.focusOpacity})` : alpha$1(theme.palette[ownerState.color].main, theme.palette.action.focusOpacity)
      },
      [`& .${chipClasses$1.deleteIcon}`]: {
        color: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.7)` : alpha$1(theme.palette[ownerState.color].main, 0.7),
        "&:hover, &:active": {
          color: (theme.vars || theme).palette[ownerState.color].main
        }
      }
    }));
    const ChipLabel = styled("span", {
      name: "MuiChip",
      slot: "Label",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        const {
          size
        } = ownerState;
        return [styles2.label, styles2[`label${capitalize(size)}`]];
      }
    })(({
      ownerState
    }) => _extends$1({
      overflow: "hidden",
      textOverflow: "ellipsis",
      paddingLeft: 12,
      paddingRight: 12,
      whiteSpace: "nowrap"
    }, ownerState.variant === "outlined" && {
      paddingLeft: 11,
      paddingRight: 11
    }, ownerState.size === "small" && {
      paddingLeft: 8,
      paddingRight: 8
    }, ownerState.size === "small" && ownerState.variant === "outlined" && {
      paddingLeft: 7,
      paddingRight: 7
    }));
    function isDeleteKeyboardEvent(keyboardEvent) {
      return keyboardEvent.key === "Backspace" || keyboardEvent.key === "Delete";
    }
    const Chip = /* @__PURE__ */ reactExports.forwardRef(function Chip2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiChip"
      });
      const {
        avatar: avatarProp,
        className,
        clickable: clickableProp,
        color: color2 = "default",
        component: ComponentProp,
        deleteIcon: deleteIconProp,
        disabled = false,
        icon: iconProp,
        label,
        onClick,
        onDelete,
        onKeyDown,
        onKeyUp,
        size = "medium",
        variant = "filled",
        tabIndex,
        skipFocusWhenDisabled = false
        // TODO v6: Rename to `focusableWhenDisabled`.
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$e);
      const chipRef = reactExports.useRef(null);
      const handleRef = useForkRef(chipRef, ref);
      const handleDeleteIconClick = (event) => {
        event.stopPropagation();
        if (onDelete) {
          onDelete(event);
        }
      };
      const handleKeyDown2 = (event) => {
        if (event.currentTarget === event.target && isDeleteKeyboardEvent(event)) {
          event.preventDefault();
        }
        if (onKeyDown) {
          onKeyDown(event);
        }
      };
      const handleKeyUp = (event) => {
        if (event.currentTarget === event.target) {
          if (onDelete && isDeleteKeyboardEvent(event)) {
            onDelete(event);
          } else if (event.key === "Escape" && chipRef.current) {
            chipRef.current.blur();
          }
        }
        if (onKeyUp) {
          onKeyUp(event);
        }
      };
      const clickable = clickableProp !== false && onClick ? true : clickableProp;
      const component = clickable || onDelete ? ButtonBase$1 : ComponentProp || "div";
      const ownerState = _extends$1({}, props, {
        component,
        disabled,
        size,
        color: color2,
        iconColor: /* @__PURE__ */ reactExports.isValidElement(iconProp) ? iconProp.props.color || color2 : color2,
        onDelete: !!onDelete,
        clickable,
        variant
      });
      const classes = useUtilityClasses$b(ownerState);
      const moreProps = component === ButtonBase$1 ? _extends$1({
        component: ComponentProp || "div",
        focusVisibleClassName: classes.focusVisible
      }, onDelete && {
        disableRipple: true
      }) : {};
      let deleteIcon = null;
      if (onDelete) {
        deleteIcon = deleteIconProp && /* @__PURE__ */ reactExports.isValidElement(deleteIconProp) ? /* @__PURE__ */ reactExports.cloneElement(deleteIconProp, {
          className: clsx(deleteIconProp.props.className, classes.deleteIcon),
          onClick: handleDeleteIconClick
        }) : /* @__PURE__ */ jsxRuntimeExports.jsx(CancelIcon, {
          className: clsx(classes.deleteIcon),
          onClick: handleDeleteIconClick
        });
      }
      let avatar = null;
      if (avatarProp && /* @__PURE__ */ reactExports.isValidElement(avatarProp)) {
        avatar = /* @__PURE__ */ reactExports.cloneElement(avatarProp, {
          className: clsx(classes.avatar, avatarProp.props.className)
        });
      }
      let icon = null;
      if (iconProp && /* @__PURE__ */ reactExports.isValidElement(iconProp)) {
        icon = /* @__PURE__ */ reactExports.cloneElement(iconProp, {
          className: clsx(classes.icon, iconProp.props.className)
        });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(ChipRoot, _extends$1({
        as: component,
        className: clsx(classes.root, className),
        disabled: clickable && disabled ? true : void 0,
        onClick,
        onKeyDown: handleKeyDown2,
        onKeyUp: handleKeyUp,
        ref: handleRef,
        tabIndex: skipFocusWhenDisabled && disabled ? -1 : tabIndex,
        ownerState
      }, moreProps, other, {
        children: [avatar || icon, /* @__PURE__ */ jsxRuntimeExports.jsx(ChipLabel, {
          className: clsx(classes.label),
          ownerState,
          children: label
        }), deleteIcon]
      }));
    });
    const Chip$1 = Chip;
    const _excluded$d = ["items", "changeImportance", "isLandscape", "onChange", "isValid"], _excluded2$2 = ["getValue"];
    function PickersShortcuts(props) {
      const {
        items,
        changeImportance,
        onChange,
        isValid
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$d);
      if (items == null || items.length === 0) {
        return null;
      }
      const resolvedItems = items.map((_ref) => {
        let {
          getValue: getValue2
        } = _ref, item = _objectWithoutPropertiesLoose$1(_ref, _excluded2$2);
        const newValue = getValue2({
          isValid
        });
        return {
          label: item.label,
          onClick: () => {
            onChange(newValue, changeImportance, item);
          },
          disabled: !isValid(newValue)
        };
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(List$1, _extends$1({
        dense: true,
        sx: [{
          maxHeight: VIEW_HEIGHT,
          maxWidth: 200,
          overflow: "auto"
        }, ...Array.isArray(other.sx) ? other.sx : [other.sx]]
      }, other, {
        children: resolvedItems.map((item) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem$1, {
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Chip$1, _extends$1({}, item))
          }, item.label);
        })
      }));
    }
    const uncapitalizeObjectKeys = (capitalizedObject) => {
      if (capitalizedObject === void 0) {
        return void 0;
      }
      return Object.keys(capitalizedObject).reduce((acc, key) => _extends$1({}, acc, {
        [`${key.slice(0, 1).toLowerCase()}${key.slice(1)}`]: capitalizedObject[key]
      }), {});
    };
    function toolbarHasView(toolbarProps) {
      return toolbarProps.view !== null;
    }
    const useUtilityClasses$a = (ownerState) => {
      const {
        classes,
        isLandscape
      } = ownerState;
      const slots = {
        root: ["root", isLandscape && "landscape"],
        contentWrapper: ["contentWrapper"],
        toolbar: ["toolbar"],
        actionBar: ["actionBar"],
        tabs: ["tabs"],
        landscape: ["landscape"],
        shortcuts: ["shortcuts"]
      };
      return composeClasses(slots, getPickersLayoutUtilityClass, classes);
    };
    const usePickerLayout = (props) => {
      var _slots$actionBar, _slots$shortcuts;
      const {
        wrapperVariant,
        onAccept,
        onClear,
        onCancel,
        onSetToday,
        view,
        views,
        onViewChange,
        value,
        onChange,
        onSelectShortcut,
        isValid,
        isLandscape,
        disabled,
        readOnly,
        children,
        components,
        componentsProps,
        slots: innerSlots,
        slotProps: innerSlotProps
        // TODO: Remove this "as" hack. It get introduced to mark `value` prop in PickersLayoutProps as not required.
        // The true type should be
        // - For pickers value: TDate | null
        // - For range pickers value: [TDate | null, TDate | null]
      } = props;
      const slots = innerSlots != null ? innerSlots : uncapitalizeObjectKeys(components);
      const slotProps = innerSlotProps != null ? innerSlotProps : componentsProps;
      const classes = useUtilityClasses$a(props);
      const ActionBar = (_slots$actionBar = slots == null ? void 0 : slots.actionBar) != null ? _slots$actionBar : PickersActionBar;
      const actionBarProps = useSlotProps({
        elementType: ActionBar,
        externalSlotProps: slotProps == null ? void 0 : slotProps.actionBar,
        additionalProps: {
          onAccept,
          onClear,
          onCancel,
          onSetToday,
          actions: wrapperVariant === "desktop" ? [] : ["cancel", "accept"],
          className: classes.actionBar
        },
        ownerState: _extends$1({}, props, {
          wrapperVariant
        })
      });
      const actionBar = /* @__PURE__ */ jsxRuntimeExports.jsx(ActionBar, _extends$1({}, actionBarProps));
      const Toolbar = slots == null ? void 0 : slots.toolbar;
      const toolbarProps = useSlotProps({
        elementType: Toolbar,
        externalSlotProps: slotProps == null ? void 0 : slotProps.toolbar,
        additionalProps: {
          isLandscape,
          onChange,
          value,
          view,
          onViewChange,
          views,
          disabled,
          readOnly,
          className: classes.toolbar
        },
        ownerState: _extends$1({}, props, {
          wrapperVariant
        })
      });
      const toolbar = toolbarHasView(toolbarProps) && !!Toolbar ? /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar, _extends$1({}, toolbarProps)) : null;
      const content = children;
      const Tabs = slots == null ? void 0 : slots.tabs;
      const tabs = view && Tabs ? /* @__PURE__ */ jsxRuntimeExports.jsx(Tabs, _extends$1({
        view,
        onViewChange,
        className: classes.tabs
      }, slotProps == null ? void 0 : slotProps.tabs)) : null;
      const Shortcuts = (_slots$shortcuts = slots == null ? void 0 : slots.shortcuts) != null ? _slots$shortcuts : PickersShortcuts;
      const shortcutsProps = useSlotProps({
        elementType: Shortcuts,
        externalSlotProps: slotProps == null ? void 0 : slotProps.shortcuts,
        additionalProps: {
          isValid,
          isLandscape,
          onChange: onSelectShortcut,
          className: classes.shortcuts
        },
        ownerState: {
          isValid,
          isLandscape,
          onChange: onSelectShortcut,
          className: classes.shortcuts,
          wrapperVariant
        }
      });
      const shortcuts = view && !!Shortcuts ? /* @__PURE__ */ jsxRuntimeExports.jsx(Shortcuts, _extends$1({}, shortcutsProps)) : null;
      return {
        toolbar,
        content,
        tabs,
        actionBar,
        shortcuts
      };
    };
    const useUtilityClasses$9 = (ownerState) => {
      const {
        isLandscape,
        classes
      } = ownerState;
      const slots = {
        root: ["root", isLandscape && "landscape"],
        contentWrapper: ["contentWrapper"]
      };
      return composeClasses(slots, getPickersLayoutUtilityClass, classes);
    };
    const PickersLayoutRoot = styled("div", {
      name: "MuiPickersLayout",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })(({
      theme,
      ownerState
    }) => ({
      display: "grid",
      gridAutoColumns: "max-content auto max-content",
      gridAutoRows: "max-content auto max-content",
      [`& .${pickersLayoutClasses.toolbar}`]: ownerState.isLandscape ? {
        gridColumn: theme.direction === "rtl" ? 3 : 1,
        gridRow: "2 / 3"
      } : {
        gridColumn: "2 / 4",
        gridRow: 1
      },
      [`.${pickersLayoutClasses.shortcuts}`]: ownerState.isLandscape ? {
        gridColumn: "2 / 4",
        gridRow: 1
      } : {
        gridColumn: theme.direction === "rtl" ? 3 : 1,
        gridRow: "2 / 3"
      },
      [`& .${pickersLayoutClasses.actionBar}`]: {
        gridColumn: "1 / 4",
        gridRow: 3
      }
    }));
    PickersLayoutRoot.propTypes = {
      // ----------------------------- Warning --------------------------------
      // | These PropTypes are generated from the TypeScript type definitions |
      // | To update them edit the TypeScript types and run "yarn proptypes"  |
      // ----------------------------------------------------------------------
      as: PropTypes.elementType,
      ownerState: PropTypes.shape({
        isLandscape: PropTypes.bool.isRequired
      }).isRequired,
      sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object])
    };
    const PickersLayoutContentWrapper = styled("div", {
      name: "MuiPickersLayout",
      slot: "ContentWrapper",
      overridesResolver: (props, styles2) => styles2.contentWrapper
    })({
      gridColumn: 2,
      gridRow: 2,
      display: "flex",
      flexDirection: "column"
    });
    const PickersLayout = function PickersLayout2(inProps) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiPickersLayout"
      });
      const {
        toolbar,
        content,
        tabs,
        actionBar,
        shortcuts
      } = usePickerLayout(props);
      const {
        sx,
        className,
        isLandscape,
        ref,
        wrapperVariant
      } = props;
      const ownerState = props;
      const classes = useUtilityClasses$9(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersLayoutRoot, {
        ref,
        sx,
        className: clsx(className, classes.root),
        ownerState,
        children: [isLandscape ? shortcuts : toolbar, isLandscape ? toolbar : shortcuts, /* @__PURE__ */ jsxRuntimeExports.jsx(PickersLayoutContentWrapper, {
          className: classes.contentWrapper,
          children: wrapperVariant === "desktop" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
            children: [content, tabs]
          }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
            children: [tabs, content]
          })
        }), actionBar]
      });
    };
    function useMeridiemMode(date2, ampm, onChange, selectionState) {
      const utils2 = useUtils();
      const meridiemMode = getMeridiem(date2, utils2);
      const handleMeridiemChange = reactExports.useCallback((mode) => {
        const timeWithMeridiem = date2 == null ? null : convertToMeridiem(date2, mode, Boolean(ampm), utils2);
        onChange(timeWithMeridiem, selectionState != null ? selectionState : "partial");
      }, [ampm, date2, onChange, selectionState, utils2]);
      return {
        meridiemMode,
        handleMeridiemChange
      };
    }
    const _excluded$c = ["ownerState"];
    const useClearableField = ({
      clearable,
      fieldProps: forwardedFieldProps,
      InputProps: ForwardedInputProps,
      onClear,
      slots,
      slotProps,
      components,
      componentsProps
    }) => {
      var _ref, _slots$clearButton, _slotProps$clearButto, _ref2, _slots$clearIcon, _slotProps$clearIcon;
      const localeText = useLocaleText();
      const IconButton2 = (_ref = (_slots$clearButton = slots == null ? void 0 : slots.clearButton) != null ? _slots$clearButton : components == null ? void 0 : components.ClearButton) != null ? _ref : IconButton$1;
      const _useSlotProps = useSlotProps({
        elementType: IconButton2,
        externalSlotProps: (_slotProps$clearButto = slotProps == null ? void 0 : slotProps.clearButton) != null ? _slotProps$clearButto : componentsProps == null ? void 0 : componentsProps.clearButton,
        ownerState: {},
        className: "clearButton",
        additionalProps: {
          title: localeText.fieldClearLabel
        }
      }), iconButtonProps = _objectWithoutPropertiesLoose$1(_useSlotProps, _excluded$c);
      const EndClearIcon = (_ref2 = (_slots$clearIcon = slots == null ? void 0 : slots.clearIcon) != null ? _slots$clearIcon : components == null ? void 0 : components.ClearIcon) != null ? _ref2 : ClearIcon;
      const endClearIconProps = useSlotProps({
        elementType: EndClearIcon,
        externalSlotProps: (_slotProps$clearIcon = slotProps == null ? void 0 : slotProps.clearIcon) != null ? _slotProps$clearIcon : componentsProps == null ? void 0 : componentsProps.clearIcon,
        ownerState: {}
      });
      const InputProps = _extends$1({}, ForwardedInputProps, {
        endAdornment: /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
          children: [clearable && /* @__PURE__ */ jsxRuntimeExports.jsx(MuiInputAdornment, {
            position: "end",
            sx: {
              marginRight: ForwardedInputProps != null && ForwardedInputProps.endAdornment ? -1 : -1.5
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton2, _extends$1({}, iconButtonProps, {
              onClick: onClear,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(EndClearIcon, _extends$1({
                fontSize: "small"
              }, endClearIconProps))
            }))
          }), ForwardedInputProps == null ? void 0 : ForwardedInputProps.endAdornment]
        })
      });
      const fieldProps = _extends$1({}, forwardedFieldProps, {
        sx: [{
          "& .clearButton": {
            opacity: 1
          },
          "@media (pointer: fine)": {
            "& .clearButton": {
              opacity: 0
            },
            "&:hover, &:focus-within": {
              ".clearButton": {
                opacity: 1
              }
            }
          }
        }, ...Array.isArray(forwardedFieldProps.sx) ? forwardedFieldProps.sx : [forwardedFieldProps.sx]]
      });
      return {
        InputProps,
        fieldProps
      };
    };
    const _excluded$b = ["slots", "slotProps", "components", "componentsProps", "InputProps", "inputProps"], _excluded2$1 = ["inputRef"], _excluded3$1 = ["ref", "onPaste", "onKeyDown", "inputMode", "readOnly", "clearable", "onClear"];
    const TimeField = /* @__PURE__ */ reactExports.forwardRef(function TimeField2(inProps, ref) {
      var _ref, _slots$textField, _slotProps$textField;
      const themeProps = useThemeProps({
        props: inProps,
        name: "MuiTimeField"
      });
      const {
        slots,
        slotProps,
        components,
        componentsProps,
        InputProps,
        inputProps
      } = themeProps, other = _objectWithoutPropertiesLoose$1(themeProps, _excluded$b);
      const ownerState = themeProps;
      const TextField2 = (_ref = (_slots$textField = slots == null ? void 0 : slots.textField) != null ? _slots$textField : components == null ? void 0 : components.TextField) != null ? _ref : MuiTextField;
      const _useSlotProps = useSlotProps({
        elementType: TextField2,
        externalSlotProps: (_slotProps$textField = slotProps == null ? void 0 : slotProps.textField) != null ? _slotProps$textField : componentsProps == null ? void 0 : componentsProps.textField,
        externalForwardedProps: other,
        ownerState
      }), {
        inputRef: externalInputRef
      } = _useSlotProps, textFieldProps = _objectWithoutPropertiesLoose$1(_useSlotProps, _excluded2$1);
      textFieldProps.inputProps = _extends$1({}, inputProps, textFieldProps.inputProps);
      textFieldProps.InputProps = _extends$1({}, InputProps, textFieldProps.InputProps);
      const _useTimeField = useTimeField({
        props: textFieldProps,
        inputRef: externalInputRef
      }), {
        ref: inputRef,
        onPaste,
        onKeyDown,
        inputMode,
        readOnly,
        clearable,
        onClear
      } = _useTimeField, fieldProps = _objectWithoutPropertiesLoose$1(_useTimeField, _excluded3$1);
      const {
        InputProps: ProcessedInputProps,
        fieldProps: processedFieldProps
      } = useClearableField({
        onClear,
        clearable,
        fieldProps,
        InputProps: fieldProps.InputProps,
        slots,
        slotProps,
        components,
        componentsProps
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(TextField2, _extends$1({
        ref
      }, processedFieldProps, {
        InputProps: _extends$1({}, ProcessedInputProps, {
          readOnly
        }),
        inputProps: _extends$1({}, fieldProps.inputProps, {
          inputMode,
          onPaste,
          onKeyDown,
          ref: inputRef
        })
      }));
    });
    function getTimePickerToolbarUtilityClass(slot) {
      return generateUtilityClass$1("MuiTimePickerToolbar", slot);
    }
    const timePickerToolbarClasses = generateUtilityClasses$1("MuiTimePickerToolbar", ["root", "separator", "hourMinuteLabel", "hourMinuteLabelLandscape", "hourMinuteLabelReverse", "ampmSelection", "ampmLandscape", "ampmLabel"]);
    const _excluded$a = ["ampm", "ampmInClock", "value", "isLandscape", "onChange", "view", "onViewChange", "views", "disabled", "readOnly"];
    const useUtilityClasses$8 = (ownerState) => {
      const {
        theme,
        isLandscape,
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        separator: ["separator"],
        hourMinuteLabel: ["hourMinuteLabel", isLandscape && "hourMinuteLabelLandscape", theme.direction === "rtl" && "hourMinuteLabelReverse"],
        ampmSelection: ["ampmSelection", isLandscape && "ampmLandscape"],
        ampmLabel: ["ampmLabel"]
      };
      return composeClasses(slots, getTimePickerToolbarUtilityClass, classes);
    };
    const TimePickerToolbarRoot = styled(PickersToolbar, {
      name: "MuiTimePickerToolbar",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })({});
    const TimePickerToolbarSeparator = styled(PickersToolbarText, {
      name: "MuiTimePickerToolbar",
      slot: "Separator",
      overridesResolver: (props, styles2) => styles2.separator
    })({
      outline: 0,
      margin: "0 4px 0 2px",
      cursor: "default"
    });
    const TimePickerToolbarHourMinuteLabel = styled("div", {
      name: "MuiTimePickerToolbar",
      slot: "HourMinuteLabel",
      overridesResolver: (props, styles2) => [{
        [`&.${timePickerToolbarClasses.hourMinuteLabelLandscape}`]: styles2.hourMinuteLabelLandscape,
        [`&.${timePickerToolbarClasses.hourMinuteLabelReverse}`]: styles2.hourMinuteLabelReverse
      }, styles2.hourMinuteLabel]
    })(({
      theme,
      ownerState
    }) => _extends$1({
      display: "flex",
      justifyContent: "flex-end",
      alignItems: "flex-end"
    }, ownerState.isLandscape && {
      marginTop: "auto"
    }, theme.direction === "rtl" && {
      flexDirection: "row-reverse"
    }));
    TimePickerToolbarHourMinuteLabel.propTypes = {
      // ----------------------------- Warning --------------------------------
      // | These PropTypes are generated from the TypeScript type definitions |
      // | To update them edit the TypeScript types and run "yarn proptypes"  |
      // ----------------------------------------------------------------------
      as: PropTypes.elementType,
      ownerState: PropTypes.object.isRequired,
      sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object])
    };
    const TimePickerToolbarAmPmSelection = styled("div", {
      name: "MuiTimePickerToolbar",
      slot: "AmPmSelection",
      overridesResolver: (props, styles2) => [{
        [`.${timePickerToolbarClasses.ampmLabel}`]: styles2.ampmLabel
      }, {
        [`&.${timePickerToolbarClasses.ampmLandscape}`]: styles2.ampmLandscape
      }, styles2.ampmSelection]
    })(({
      ownerState
    }) => _extends$1({
      display: "flex",
      flexDirection: "column",
      marginRight: "auto",
      marginLeft: 12
    }, ownerState.isLandscape && {
      margin: "4px 0 auto",
      flexDirection: "row",
      justifyContent: "space-around",
      flexBasis: "100%"
    }, {
      [`& .${timePickerToolbarClasses.ampmLabel}`]: {
        fontSize: 17
      }
    }));
    TimePickerToolbarAmPmSelection.propTypes = {
      // ----------------------------- Warning --------------------------------
      // | These PropTypes are generated from the TypeScript type definitions |
      // | To update them edit the TypeScript types and run "yarn proptypes"  |
      // ----------------------------------------------------------------------
      as: PropTypes.elementType,
      ownerState: PropTypes.object.isRequired,
      sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object])
    };
    function TimePickerToolbar(inProps) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiTimePickerToolbar"
      });
      const {
        ampm,
        ampmInClock,
        value,
        isLandscape,
        onChange,
        view,
        onViewChange,
        views,
        disabled,
        readOnly
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$a);
      const utils2 = useUtils();
      const localeText = useLocaleText();
      const theme = useTheme();
      const showAmPmControl = Boolean(ampm && !ampmInClock && views.includes("hours"));
      const {
        meridiemMode,
        handleMeridiemChange
      } = useMeridiemMode(value, ampm, onChange);
      const formatHours = (time2) => ampm ? utils2.format(time2, "hours12h") : utils2.format(time2, "hours24h");
      const ownerState = props;
      const classes = useUtilityClasses$8(_extends$1({}, ownerState, {
        theme
      }));
      const separator = /* @__PURE__ */ jsxRuntimeExports.jsx(TimePickerToolbarSeparator, {
        tabIndex: -1,
        value: ":",
        variant: "h3",
        selected: false,
        className: classes.separator
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(TimePickerToolbarRoot, _extends$1({
        landscapeDirection: "row",
        toolbarTitle: localeText.timePickerToolbarTitle,
        isLandscape,
        ownerState,
        className: classes.root
      }, other, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(TimePickerToolbarHourMinuteLabel, {
          className: classes.hourMinuteLabel,
          ownerState,
          children: [arrayIncludes(views, "hours") && /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
            tabIndex: -1,
            variant: "h3",
            onClick: () => onViewChange("hours"),
            selected: view === "hours",
            value: value ? formatHours(value) : "--"
          }), arrayIncludes(views, ["hours", "minutes"]) && separator, arrayIncludes(views, "minutes") && /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
            tabIndex: -1,
            variant: "h3",
            onClick: () => onViewChange("minutes"),
            selected: view === "minutes",
            value: value ? utils2.format(value, "minutes") : "--"
          }), arrayIncludes(views, ["minutes", "seconds"]) && separator, arrayIncludes(views, "seconds") && /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
            variant: "h3",
            onClick: () => onViewChange("seconds"),
            selected: view === "seconds",
            value: value ? utils2.format(value, "seconds") : "--"
          })]
        }), showAmPmControl && /* @__PURE__ */ jsxRuntimeExports.jsxs(TimePickerToolbarAmPmSelection, {
          className: classes.ampmSelection,
          ownerState,
          children: [/* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
            disableRipple: true,
            variant: "subtitle2",
            selected: meridiemMode === "am",
            typographyClassName: classes.ampmLabel,
            value: formatMeridiem(utils2, "am"),
            onClick: readOnly ? void 0 : () => handleMeridiemChange("am"),
            disabled
          }), /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
            disableRipple: true,
            variant: "subtitle2",
            selected: meridiemMode === "pm",
            typographyClassName: classes.ampmLabel,
            value: formatMeridiem(utils2, "pm"),
            onClick: readOnly ? void 0 : () => handleMeridiemChange("pm"),
            disabled
          })]
        })]
      }));
    }
    function useTimePickerDefaultizedProps(props, name) {
      var _themeProps$ampm, _themeProps$slots, _themeProps$slotProps, _themeProps$disableFu, _themeProps$disablePa;
      const utils2 = useUtils();
      const themeProps = useThemeProps({
        props,
        name
      });
      const ampm = (_themeProps$ampm = themeProps.ampm) != null ? _themeProps$ampm : utils2.is12HourCycleInCurrentLocale();
      const localeText = reactExports.useMemo(() => {
        var _themeProps$localeTex;
        if (((_themeProps$localeTex = themeProps.localeText) == null ? void 0 : _themeProps$localeTex.toolbarTitle) == null) {
          return themeProps.localeText;
        }
        return _extends$1({}, themeProps.localeText, {
          timePickerToolbarTitle: themeProps.localeText.toolbarTitle
        });
      }, [themeProps.localeText]);
      const slots = (_themeProps$slots = themeProps.slots) != null ? _themeProps$slots : uncapitalizeObjectKeys(themeProps.components);
      const slotProps = (_themeProps$slotProps = themeProps.slotProps) != null ? _themeProps$slotProps : themeProps.componentsProps;
      return _extends$1({}, themeProps, {
        ampm,
        localeText
      }, applyDefaultViewProps({
        views: themeProps.views,
        openTo: themeProps.openTo,
        defaultViews: ["hours", "minutes"],
        defaultOpenTo: "hours"
      }), {
        disableFuture: (_themeProps$disableFu = themeProps.disableFuture) != null ? _themeProps$disableFu : false,
        disablePast: (_themeProps$disablePa = themeProps.disablePast) != null ? _themeProps$disablePa : false,
        slots: _extends$1({
          toolbar: TimePickerToolbar
        }, slots),
        slotProps: _extends$1({}, slotProps, {
          toolbar: _extends$1({
            ampm,
            ampmInClock: themeProps.ampmInClock
          }, slotProps == null ? void 0 : slotProps.toolbar)
        })
      });
    }
    const _excluded$9 = ["props", "getOpenDialogAriaText"], _excluded2 = ["ownerState"], _excluded3 = ["ownerState"];
    const useDesktopPicker = (_ref) => {
      var _innerSlotProps$toolb, _innerSlotProps$toolb2, _slots$inputAdornment, _slots$openPickerButt, _slots$layout;
      let {
        props,
        getOpenDialogAriaText
      } = _ref, pickerParams = _objectWithoutPropertiesLoose$1(_ref, _excluded$9);
      const {
        slots,
        slotProps: innerSlotProps,
        className,
        sx,
        format,
        formatDensity,
        timezone,
        name,
        label,
        inputRef,
        readOnly,
        disabled,
        autoFocus,
        localeText,
        reduceAnimations
      } = props;
      const utils2 = useUtils();
      const internalInputRef = reactExports.useRef(null);
      const containerRef = reactExports.useRef(null);
      const labelId = useId();
      const isToolbarHidden = (_innerSlotProps$toolb = innerSlotProps == null || (_innerSlotProps$toolb2 = innerSlotProps.toolbar) == null ? void 0 : _innerSlotProps$toolb2.hidden) != null ? _innerSlotProps$toolb : false;
      const {
        open,
        actions,
        hasUIView,
        layoutProps,
        renderCurrentView,
        shouldRestoreFocus,
        fieldProps: pickerFieldProps
      } = usePicker(_extends$1({}, pickerParams, {
        props,
        inputRef: internalInputRef,
        autoFocusView: true,
        additionalViewProps: {},
        wrapperVariant: "desktop"
      }));
      const InputAdornment2 = (_slots$inputAdornment = slots.inputAdornment) != null ? _slots$inputAdornment : MuiInputAdornment;
      const _useSlotProps = useSlotProps({
        elementType: InputAdornment2,
        externalSlotProps: innerSlotProps == null ? void 0 : innerSlotProps.inputAdornment,
        additionalProps: {
          position: "end"
        },
        ownerState: props
      }), inputAdornmentProps = _objectWithoutPropertiesLoose$1(_useSlotProps, _excluded2);
      const OpenPickerButton = (_slots$openPickerButt = slots.openPickerButton) != null ? _slots$openPickerButt : IconButton$1;
      const _useSlotProps2 = useSlotProps({
        elementType: OpenPickerButton,
        externalSlotProps: innerSlotProps == null ? void 0 : innerSlotProps.openPickerButton,
        additionalProps: {
          disabled: disabled || readOnly,
          onClick: open ? actions.onClose : actions.onOpen,
          "aria-label": getOpenDialogAriaText(pickerFieldProps.value, utils2),
          edge: inputAdornmentProps.position
        },
        ownerState: props
      }), openPickerButtonProps = _objectWithoutPropertiesLoose$1(_useSlotProps2, _excluded3);
      const OpenPickerIcon = slots.openPickerIcon;
      const Field = slots.field;
      const fieldProps = useSlotProps({
        elementType: Field,
        externalSlotProps: innerSlotProps == null ? void 0 : innerSlotProps.field,
        additionalProps: _extends$1({}, pickerFieldProps, isToolbarHidden && {
          id: labelId
        }, {
          readOnly,
          disabled,
          className,
          sx,
          format,
          formatDensity,
          timezone,
          label,
          name,
          autoFocus: autoFocus && !props.open,
          focused: open ? true : void 0
        }),
        ownerState: props
      });
      if (hasUIView) {
        fieldProps.InputProps = _extends$1({}, fieldProps.InputProps, {
          ref: containerRef,
          [`${inputAdornmentProps.position}Adornment`]: /* @__PURE__ */ jsxRuntimeExports.jsx(InputAdornment2, _extends$1({}, inputAdornmentProps, {
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(OpenPickerButton, _extends$1({}, openPickerButtonProps, {
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(OpenPickerIcon, _extends$1({}, innerSlotProps == null ? void 0 : innerSlotProps.openPickerIcon))
            }))
          }))
        });
      }
      const slotsForField = _extends$1({
        textField: slots.textField,
        clearIcon: slots.clearIcon,
        clearButton: slots.clearButton
      }, fieldProps.slots);
      const Layout = (_slots$layout = slots.layout) != null ? _slots$layout : PickersLayout;
      const handleInputRef = useForkRef(internalInputRef, fieldProps.inputRef, inputRef);
      let labelledById = labelId;
      if (isToolbarHidden) {
        if (label) {
          labelledById = `${labelId}-label`;
        } else {
          labelledById = void 0;
        }
      }
      const slotProps = _extends$1({}, innerSlotProps, {
        toolbar: _extends$1({}, innerSlotProps == null ? void 0 : innerSlotProps.toolbar, {
          titleId: labelId
        }),
        popper: _extends$1({
          "aria-labelledby": labelledById
        }, innerSlotProps == null ? void 0 : innerSlotProps.popper)
      });
      const renderPicker = () => /* @__PURE__ */ jsxRuntimeExports.jsxs(LocalizationProvider, {
        localeText,
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Field, _extends$1({}, fieldProps, {
          slots: slotsForField,
          slotProps,
          inputRef: handleInputRef
        })), /* @__PURE__ */ jsxRuntimeExports.jsx(PickersPopper, _extends$1({
          role: "dialog",
          placement: "bottom-start",
          anchorEl: containerRef.current
        }, actions, {
          open,
          slots,
          slotProps,
          shouldRestoreFocus,
          reduceAnimations,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Layout, _extends$1({}, layoutProps, slotProps == null ? void 0 : slotProps.layout, {
            slots,
            slotProps,
            children: renderCurrentView()
          }))
        }))]
      });
      return {
        renderPicker
      };
    };
    const PickerViewRoot = styled("div")({
      overflow: "hidden",
      width: DIALOG_WIDTH,
      maxHeight: VIEW_HEIGHT,
      display: "flex",
      flexDirection: "column",
      margin: "0 auto"
    });
    function getTimeClockUtilityClass(slot) {
      return generateUtilityClass$1("MuiTimeClock", slot);
    }
    generateUtilityClasses$1("MuiTimeClock", ["root", "arrowSwitcher"]);
    const CLOCK_WIDTH = 220;
    const CLOCK_HOUR_WIDTH = 36;
    const clockCenter = {
      x: CLOCK_WIDTH / 2,
      y: CLOCK_WIDTH / 2
    };
    const baseClockPoint = {
      x: clockCenter.x,
      y: 0
    };
    const cx = baseClockPoint.x - clockCenter.x;
    const cy = baseClockPoint.y - clockCenter.y;
    const rad2deg = (rad) => rad * (180 / Math.PI);
    const getAngleValue = (step, offsetX, offsetY) => {
      const x2 = offsetX - clockCenter.x;
      const y2 = offsetY - clockCenter.y;
      const atan = Math.atan2(cx, cy) - Math.atan2(x2, y2);
      let deg = rad2deg(atan);
      deg = Math.round(deg / step) * step;
      deg %= 360;
      const value = Math.floor(deg / step) || 0;
      const delta = x2 ** 2 + y2 ** 2;
      const distance2 = Math.sqrt(delta);
      return {
        value,
        distance: distance2
      };
    };
    const getMinutes = (offsetX, offsetY, step = 1) => {
      const angleStep = step * 6;
      let {
        value
      } = getAngleValue(angleStep, offsetX, offsetY);
      value = value * step % 60;
      return value;
    };
    const getHours = (offsetX, offsetY, ampm) => {
      const {
        value,
        distance: distance2
      } = getAngleValue(30, offsetX, offsetY);
      let hour = value || 12;
      if (!ampm) {
        if (distance2 < CLOCK_WIDTH / 2 - CLOCK_HOUR_WIDTH) {
          hour += 12;
          hour %= 24;
        }
      } else {
        hour %= 12;
      }
      return hour;
    };
    function getClockPointerUtilityClass(slot) {
      return generateUtilityClass$1("MuiClockPointer", slot);
    }
    generateUtilityClasses$1("MuiClockPointer", ["root", "thumb"]);
    const _excluded$8 = ["className", "hasSelected", "isInner", "type", "viewValue"];
    const useUtilityClasses$7 = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        thumb: ["thumb"]
      };
      return composeClasses(slots, getClockPointerUtilityClass, classes);
    };
    const ClockPointerRoot = styled("div", {
      name: "MuiClockPointer",
      slot: "Root",
      overridesResolver: (_2, styles2) => styles2.root
    })(({
      theme,
      ownerState
    }) => _extends$1({
      width: 2,
      backgroundColor: (theme.vars || theme).palette.primary.main,
      position: "absolute",
      left: "calc(50% - 1px)",
      bottom: "50%",
      transformOrigin: "center bottom 0px"
    }, ownerState.shouldAnimate && {
      transition: theme.transitions.create(["transform", "height"])
    }));
    const ClockPointerThumb = styled("div", {
      name: "MuiClockPointer",
      slot: "Thumb",
      overridesResolver: (_2, styles2) => styles2.thumb
    })(({
      theme,
      ownerState
    }) => _extends$1({
      width: 4,
      height: 4,
      backgroundColor: (theme.vars || theme).palette.primary.contrastText,
      borderRadius: "50%",
      position: "absolute",
      top: -21,
      left: `calc(50% - ${CLOCK_HOUR_WIDTH / 2}px)`,
      border: `${(CLOCK_HOUR_WIDTH - 4) / 2}px solid ${(theme.vars || theme).palette.primary.main}`,
      boxSizing: "content-box"
    }, ownerState.hasSelected && {
      backgroundColor: (theme.vars || theme).palette.primary.main
    }));
    function ClockPointer(inProps) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiClockPointer"
      });
      const {
        className,
        isInner,
        type,
        viewValue
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$8);
      const previousType = reactExports.useRef(type);
      reactExports.useEffect(() => {
        previousType.current = type;
      }, [type]);
      const ownerState = _extends$1({}, props, {
        shouldAnimate: previousType.current !== type
      });
      const classes = useUtilityClasses$7(ownerState);
      const getAngleStyle = () => {
        const max2 = type === "hours" ? 12 : 60;
        let angle = 360 / max2 * viewValue;
        if (type === "hours" && viewValue > 12) {
          angle -= 360;
        }
        return {
          height: Math.round((isInner ? 0.26 : 0.4) * CLOCK_WIDTH),
          transform: `rotateZ(${angle}deg)`
        };
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ClockPointerRoot, _extends$1({
        style: getAngleStyle(),
        className: clsx(className, classes.root),
        ownerState
      }, other, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ClockPointerThumb, {
          ownerState,
          className: classes.thumb
        })
      }));
    }
    function getClockUtilityClass(slot) {
      return generateUtilityClass$1("MuiClock", slot);
    }
    generateUtilityClasses$1("MuiClock", ["root", "clock", "wrapper", "squareMask", "pin", "amButton", "pmButton", "meridiemText"]);
    const useUtilityClasses$6 = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        clock: ["clock"],
        wrapper: ["wrapper"],
        squareMask: ["squareMask"],
        pin: ["pin"],
        amButton: ["amButton"],
        pmButton: ["pmButton"],
        meridiemText: ["meridiemText"]
      };
      return composeClasses(slots, getClockUtilityClass, classes);
    };
    const ClockRoot = styled("div", {
      name: "MuiClock",
      slot: "Root",
      overridesResolver: (_2, styles2) => styles2.root
    })(({
      theme
    }) => ({
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      margin: theme.spacing(2)
    }));
    const ClockClock = styled("div", {
      name: "MuiClock",
      slot: "Clock",
      overridesResolver: (_2, styles2) => styles2.clock
    })({
      backgroundColor: "rgba(0,0,0,.07)",
      borderRadius: "50%",
      height: 220,
      width: 220,
      flexShrink: 0,
      position: "relative",
      pointerEvents: "none"
    });
    const ClockWrapper = styled("div", {
      name: "MuiClock",
      slot: "Wrapper",
      overridesResolver: (_2, styles2) => styles2.wrapper
    })({
      "&:focus": {
        outline: "none"
      }
    });
    const ClockSquareMask = styled("div", {
      name: "MuiClock",
      slot: "SquareMask",
      overridesResolver: (_2, styles2) => styles2.squareMask
    })(({
      ownerState
    }) => _extends$1({
      width: "100%",
      height: "100%",
      position: "absolute",
      pointerEvents: "auto",
      outline: 0,
      // Disable scroll capabilities.
      touchAction: "none",
      userSelect: "none"
    }, ownerState.disabled ? {} : {
      "@media (pointer: fine)": {
        cursor: "pointer",
        borderRadius: "50%"
      },
      "&:active": {
        cursor: "move"
      }
    }));
    const ClockPin = styled("div", {
      name: "MuiClock",
      slot: "Pin",
      overridesResolver: (_2, styles2) => styles2.pin
    })(({
      theme
    }) => ({
      width: 6,
      height: 6,
      borderRadius: "50%",
      backgroundColor: (theme.vars || theme).palette.primary.main,
      position: "absolute",
      top: "50%",
      left: "50%",
      transform: "translate(-50%, -50%)"
    }));
    const ClockAmButton = styled(IconButton$1, {
      name: "MuiClock",
      slot: "AmButton",
      overridesResolver: (_2, styles2) => styles2.amButton
    })(({
      theme,
      ownerState
    }) => _extends$1({
      zIndex: 1,
      position: "absolute",
      bottom: 8,
      left: 8,
      paddingLeft: 4,
      paddingRight: 4,
      width: CLOCK_HOUR_WIDTH
    }, ownerState.meridiemMode === "am" && {
      backgroundColor: (theme.vars || theme).palette.primary.main,
      color: (theme.vars || theme).palette.primary.contrastText,
      "&:hover": {
        backgroundColor: (theme.vars || theme).palette.primary.light
      }
    }));
    const ClockPmButton = styled(IconButton$1, {
      name: "MuiClock",
      slot: "PmButton",
      overridesResolver: (_2, styles2) => styles2.pmButton
    })(({
      theme,
      ownerState
    }) => _extends$1({
      zIndex: 1,
      position: "absolute",
      bottom: 8,
      right: 8,
      paddingLeft: 4,
      paddingRight: 4,
      width: CLOCK_HOUR_WIDTH
    }, ownerState.meridiemMode === "pm" && {
      backgroundColor: (theme.vars || theme).palette.primary.main,
      color: (theme.vars || theme).palette.primary.contrastText,
      "&:hover": {
        backgroundColor: (theme.vars || theme).palette.primary.light
      }
    }));
    const ClockMeridiemText = styled(Typography$1, {
      name: "MuiClock",
      slot: "meridiemText",
      overridesResolver: (_2, styles2) => styles2.meridiemText
    })({
      overflow: "hidden",
      whiteSpace: "nowrap",
      textOverflow: "ellipsis"
    });
    function Clock(inProps) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiClock"
      });
      const {
        ampm,
        ampmInClock,
        autoFocus,
        children,
        value,
        handleMeridiemChange,
        isTimeDisabled,
        meridiemMode,
        minutesStep = 1,
        onChange,
        selectedId,
        type,
        viewValue,
        disabled,
        readOnly,
        className
      } = props;
      const ownerState = props;
      const utils2 = useUtils();
      const localeText = useLocaleText();
      const isMoving = reactExports.useRef(false);
      const classes = useUtilityClasses$6(ownerState);
      const isSelectedTimeDisabled = isTimeDisabled(viewValue, type);
      const isPointerInner = !ampm && type === "hours" && (viewValue < 1 || viewValue > 12);
      const handleValueChange = (newValue, isFinish) => {
        if (disabled || readOnly) {
          return;
        }
        if (isTimeDisabled(newValue, type)) {
          return;
        }
        onChange(newValue, isFinish);
      };
      const setTime = (event, isFinish) => {
        let {
          offsetX,
          offsetY
        } = event;
        if (offsetX === void 0) {
          const rect = event.target.getBoundingClientRect();
          offsetX = event.changedTouches[0].clientX - rect.left;
          offsetY = event.changedTouches[0].clientY - rect.top;
        }
        const newSelectedValue = type === "seconds" || type === "minutes" ? getMinutes(offsetX, offsetY, minutesStep) : getHours(offsetX, offsetY, Boolean(ampm));
        handleValueChange(newSelectedValue, isFinish);
      };
      const handleTouchMove = (event) => {
        isMoving.current = true;
        setTime(event, "shallow");
      };
      const handleTouchEnd = (event) => {
        if (isMoving.current) {
          setTime(event, "finish");
          isMoving.current = false;
        }
      };
      const handleMouseMove = (event) => {
        if (event.buttons > 0) {
          setTime(event.nativeEvent, "shallow");
        }
      };
      const handleMouseUp = (event) => {
        if (isMoving.current) {
          isMoving.current = false;
        }
        setTime(event.nativeEvent, "finish");
      };
      const hasSelected = reactExports.useMemo(() => {
        if (type === "hours") {
          return true;
        }
        return viewValue % 5 === 0;
      }, [type, viewValue]);
      const keyboardControlStep = type === "minutes" ? minutesStep : 1;
      const listboxRef = reactExports.useRef(null);
      useEnhancedEffect(() => {
        if (autoFocus) {
          listboxRef.current.focus();
        }
      }, [autoFocus]);
      const handleKeyDown2 = (event) => {
        if (isMoving.current) {
          return;
        }
        switch (event.key) {
          case "Home":
            handleValueChange(0, "partial");
            event.preventDefault();
            break;
          case "End":
            handleValueChange(type === "minutes" ? 59 : 23, "partial");
            event.preventDefault();
            break;
          case "ArrowUp":
            handleValueChange(viewValue + keyboardControlStep, "partial");
            event.preventDefault();
            break;
          case "ArrowDown":
            handleValueChange(viewValue - keyboardControlStep, "partial");
            event.preventDefault();
            break;
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(ClockRoot, {
        className: clsx(className, classes.root),
        children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(ClockClock, {
          className: classes.clock,
          children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ClockSquareMask, {
            onTouchMove: handleTouchMove,
            onTouchEnd: handleTouchEnd,
            onMouseUp: handleMouseUp,
            onMouseMove: handleMouseMove,
            ownerState: {
              disabled
            },
            className: classes.squareMask
          }), !isSelectedTimeDisabled && /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ClockPin, {
              className: classes.pin
            }), value != null && /* @__PURE__ */ jsxRuntimeExports.jsx(ClockPointer, {
              type,
              viewValue,
              isInner: isPointerInner,
              hasSelected
            })]
          }), /* @__PURE__ */ jsxRuntimeExports.jsx(ClockWrapper, {
            "aria-activedescendant": selectedId,
            "aria-label": localeText.clockLabelText(type, value, utils2),
            ref: listboxRef,
            role: "listbox",
            onKeyDown: handleKeyDown2,
            tabIndex: 0,
            className: classes.wrapper,
            children
          })]
        }), ampm && ampmInClock && /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
          children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ClockAmButton, {
            onClick: readOnly ? void 0 : () => handleMeridiemChange("am"),
            disabled: disabled || meridiemMode === null,
            ownerState,
            className: classes.amButton,
            title: formatMeridiem(utils2, "am"),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(ClockMeridiemText, {
              variant: "caption",
              className: classes.meridiemText,
              children: formatMeridiem(utils2, "am")
            })
          }), /* @__PURE__ */ jsxRuntimeExports.jsx(ClockPmButton, {
            disabled: disabled || meridiemMode === null,
            onClick: readOnly ? void 0 : () => handleMeridiemChange("pm"),
            ownerState,
            className: classes.pmButton,
            title: formatMeridiem(utils2, "pm"),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(ClockMeridiemText, {
              variant: "caption",
              className: classes.meridiemText,
              children: formatMeridiem(utils2, "pm")
            })
          })]
        })]
      });
    }
    function getClockNumberUtilityClass(slot) {
      return generateUtilityClass$1("MuiClockNumber", slot);
    }
    const clockNumberClasses = generateUtilityClasses$1("MuiClockNumber", ["root", "selected", "disabled"]);
    const _excluded$7 = ["className", "disabled", "index", "inner", "label", "selected"];
    const useUtilityClasses$5 = (ownerState) => {
      const {
        classes,
        selected,
        disabled
      } = ownerState;
      const slots = {
        root: ["root", selected && "selected", disabled && "disabled"]
      };
      return composeClasses(slots, getClockNumberUtilityClass, classes);
    };
    const ClockNumberRoot = styled("span", {
      name: "MuiClockNumber",
      slot: "Root",
      overridesResolver: (_2, styles2) => [styles2.root, {
        [`&.${clockNumberClasses.disabled}`]: styles2.disabled
      }, {
        [`&.${clockNumberClasses.selected}`]: styles2.selected
      }]
    })(({
      theme,
      ownerState
    }) => _extends$1({
      height: CLOCK_HOUR_WIDTH,
      width: CLOCK_HOUR_WIDTH,
      position: "absolute",
      left: `calc((100% - ${CLOCK_HOUR_WIDTH}px) / 2)`,
      display: "inline-flex",
      justifyContent: "center",
      alignItems: "center",
      borderRadius: "50%",
      color: (theme.vars || theme).palette.text.primary,
      fontFamily: theme.typography.fontFamily,
      "&:focused": {
        backgroundColor: (theme.vars || theme).palette.background.paper
      },
      [`&.${clockNumberClasses.selected}`]: {
        color: (theme.vars || theme).palette.primary.contrastText
      },
      [`&.${clockNumberClasses.disabled}`]: {
        pointerEvents: "none",
        color: (theme.vars || theme).palette.text.disabled
      }
    }, ownerState.inner && _extends$1({}, theme.typography.body2, {
      color: (theme.vars || theme).palette.text.secondary
    })));
    function ClockNumber(inProps) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiClockNumber"
      });
      const {
        className,
        disabled,
        index,
        inner,
        label,
        selected
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$7);
      const ownerState = props;
      const classes = useUtilityClasses$5(ownerState);
      const angle = index % 12 / 12 * Math.PI * 2 - Math.PI / 2;
      const length2 = (CLOCK_WIDTH - CLOCK_HOUR_WIDTH - 2) / 2 * (inner ? 0.65 : 1);
      const x2 = Math.round(Math.cos(angle) * length2);
      const y2 = Math.round(Math.sin(angle) * length2);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ClockNumberRoot, _extends$1({
        className: clsx(className, classes.root),
        "aria-disabled": disabled ? true : void 0,
        "aria-selected": selected ? true : void 0,
        role: "option",
        style: {
          transform: `translate(${x2}px, ${y2 + (CLOCK_WIDTH - CLOCK_HOUR_WIDTH) / 2}px`
        },
        ownerState
      }, other, {
        children: label
      }));
    }
    const getHourNumbers = ({
      ampm,
      value,
      getClockNumberText,
      isDisabled,
      selectedId,
      utils: utils2
    }) => {
      const currentHours = value ? utils2.getHours(value) : null;
      const hourNumbers = [];
      const startHour = ampm ? 1 : 0;
      const endHour = ampm ? 12 : 23;
      const isSelected = (hour) => {
        if (currentHours === null) {
          return false;
        }
        if (ampm) {
          if (hour === 12) {
            return currentHours === 12 || currentHours === 0;
          }
          return currentHours === hour || currentHours - 12 === hour;
        }
        return currentHours === hour;
      };
      for (let hour = startHour; hour <= endHour; hour += 1) {
        let label = hour.toString();
        if (hour === 0) {
          label = "00";
        }
        const inner = !ampm && (hour === 0 || hour > 12);
        label = utils2.formatNumber(label);
        const selected = isSelected(hour);
        hourNumbers.push(/* @__PURE__ */ jsxRuntimeExports.jsx(ClockNumber, {
          id: selected ? selectedId : void 0,
          index: hour,
          inner,
          selected,
          disabled: isDisabled(hour),
          label,
          "aria-label": getClockNumberText(label)
        }, hour));
      }
      return hourNumbers;
    };
    const getMinutesNumbers = ({
      utils: utils2,
      value,
      isDisabled,
      getClockNumberText,
      selectedId
    }) => {
      const f2 = utils2.formatNumber;
      return [[5, f2("05")], [10, f2("10")], [15, f2("15")], [20, f2("20")], [25, f2("25")], [30, f2("30")], [35, f2("35")], [40, f2("40")], [45, f2("45")], [50, f2("50")], [55, f2("55")], [0, f2("00")]].map(([numberValue, label], index) => {
        const selected = numberValue === value;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(ClockNumber, {
          label,
          id: selected ? selectedId : void 0,
          index: index + 1,
          inner: false,
          disabled: isDisabled(numberValue),
          selected,
          "aria-label": getClockNumberText(label)
        }, numberValue);
      });
    };
    const useClockReferenceDate = ({
      value,
      referenceDate: referenceDateProp,
      utils: utils2,
      props,
      timezone
    }) => {
      const referenceDate = reactExports.useMemo(
        () => singleItemValueManager.getInitialReferenceValue({
          value,
          utils: utils2,
          props,
          referenceDate: referenceDateProp,
          granularity: SECTION_TYPE_GRANULARITY.day,
          timezone,
          getTodayDate: () => getTodayDate(utils2, timezone, "date")
        }),
        // We only want to compute the reference date on mount.
        []
        // eslint-disable-line react-hooks/exhaustive-deps
      );
      return value != null ? value : referenceDate;
    };
    const _excluded$6 = ["ampm", "ampmInClock", "autoFocus", "components", "componentsProps", "slots", "slotProps", "value", "defaultValue", "referenceDate", "disableIgnoringDatePartForTimeValidation", "maxTime", "minTime", "disableFuture", "disablePast", "minutesStep", "shouldDisableClock", "shouldDisableTime", "showViewSwitcher", "onChange", "view", "views", "openTo", "onViewChange", "focusedView", "onFocusedViewChange", "className", "disabled", "readOnly", "timezone"];
    const useUtilityClasses$4 = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        arrowSwitcher: ["arrowSwitcher"]
      };
      return composeClasses(slots, getTimeClockUtilityClass, classes);
    };
    const TimeClockRoot = styled(PickerViewRoot, {
      name: "MuiTimeClock",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })({
      display: "flex",
      flexDirection: "column",
      position: "relative"
    });
    const TimeClockArrowSwitcher = styled(PickersArrowSwitcher, {
      name: "MuiTimeClock",
      slot: "ArrowSwitcher",
      overridesResolver: (props, styles2) => styles2.arrowSwitcher
    })({
      position: "absolute",
      right: 12,
      top: 15
    });
    const TIME_CLOCK_DEFAULT_VIEWS = ["hours", "minutes"];
    const TimeClock = /* @__PURE__ */ reactExports.forwardRef(function TimeClock2(inProps, ref) {
      const utils2 = useUtils();
      const props = useThemeProps({
        props: inProps,
        name: "MuiTimeClock"
      });
      const {
        ampm = utils2.is12HourCycleInCurrentLocale(),
        ampmInClock = false,
        autoFocus,
        components,
        componentsProps,
        slots: innerSlots,
        slotProps: innerSlotProps,
        value: valueProp,
        defaultValue,
        referenceDate: referenceDateProp,
        disableIgnoringDatePartForTimeValidation = false,
        maxTime,
        minTime,
        disableFuture,
        disablePast,
        minutesStep = 1,
        shouldDisableClock,
        shouldDisableTime,
        showViewSwitcher,
        onChange,
        view: inView,
        views = TIME_CLOCK_DEFAULT_VIEWS,
        openTo,
        onViewChange,
        focusedView,
        onFocusedViewChange,
        className,
        disabled,
        readOnly,
        timezone: timezoneProp
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$6);
      const slots = innerSlots != null ? innerSlots : uncapitalizeObjectKeys(components);
      const slotProps = innerSlotProps != null ? innerSlotProps : componentsProps;
      const {
        value,
        handleValueChange,
        timezone
      } = useControlledValueWithTimezone({
        name: "TimeClock",
        timezone: timezoneProp,
        value: valueProp,
        defaultValue,
        onChange,
        valueManager: singleItemValueManager
      });
      const valueOrReferenceDate = useClockReferenceDate({
        value,
        referenceDate: referenceDateProp,
        utils: utils2,
        props,
        timezone
      });
      const localeText = useLocaleText();
      const now2 = useNow(timezone);
      const {
        view,
        setView,
        previousView,
        nextView,
        setValueAndGoToNextView
      } = useViews({
        view: inView,
        views,
        openTo,
        onViewChange,
        onChange: handleValueChange,
        focusedView,
        onFocusedViewChange
      });
      const {
        meridiemMode,
        handleMeridiemChange
      } = useMeridiemMode(valueOrReferenceDate, ampm, setValueAndGoToNextView);
      const isTimeDisabled = reactExports.useCallback((rawValue, viewType) => {
        const isAfter = createIsAfterIgnoreDatePart(disableIgnoringDatePartForTimeValidation, utils2);
        const shouldCheckPastEnd = viewType === "hours" || viewType === "minutes" && views.includes("seconds");
        const containsValidTime = ({
          start: start2,
          end: end2
        }) => {
          if (minTime && isAfter(minTime, end2)) {
            return false;
          }
          if (maxTime && isAfter(start2, maxTime)) {
            return false;
          }
          if (disableFuture && isAfter(start2, now2)) {
            return false;
          }
          if (disablePast && isAfter(now2, shouldCheckPastEnd ? end2 : start2)) {
            return false;
          }
          return true;
        };
        const isValidValue = (timeValue, step = 1) => {
          if (timeValue % step !== 0) {
            return false;
          }
          if (shouldDisableClock != null && shouldDisableClock(timeValue, viewType)) {
            return false;
          }
          if (shouldDisableTime) {
            switch (viewType) {
              case "hours":
                return !shouldDisableTime(utils2.setHours(valueOrReferenceDate, timeValue), "hours");
              case "minutes":
                return !shouldDisableTime(utils2.setMinutes(valueOrReferenceDate, timeValue), "minutes");
              case "seconds":
                return !shouldDisableTime(utils2.setSeconds(valueOrReferenceDate, timeValue), "seconds");
              default:
                return false;
            }
          }
          return true;
        };
        switch (viewType) {
          case "hours": {
            const valueWithMeridiem = convertValueToMeridiem(rawValue, meridiemMode, ampm);
            const dateWithNewHours = utils2.setHours(valueOrReferenceDate, valueWithMeridiem);
            const start2 = utils2.setSeconds(utils2.setMinutes(dateWithNewHours, 0), 0);
            const end2 = utils2.setSeconds(utils2.setMinutes(dateWithNewHours, 59), 59);
            return !containsValidTime({
              start: start2,
              end: end2
            }) || !isValidValue(valueWithMeridiem);
          }
          case "minutes": {
            const dateWithNewMinutes = utils2.setMinutes(valueOrReferenceDate, rawValue);
            const start2 = utils2.setSeconds(dateWithNewMinutes, 0);
            const end2 = utils2.setSeconds(dateWithNewMinutes, 59);
            return !containsValidTime({
              start: start2,
              end: end2
            }) || !isValidValue(rawValue, minutesStep);
          }
          case "seconds": {
            const dateWithNewSeconds = utils2.setSeconds(valueOrReferenceDate, rawValue);
            const start2 = dateWithNewSeconds;
            const end2 = dateWithNewSeconds;
            return !containsValidTime({
              start: start2,
              end: end2
            }) || !isValidValue(rawValue);
          }
          default:
            throw new Error("not supported");
        }
      }, [ampm, valueOrReferenceDate, disableIgnoringDatePartForTimeValidation, maxTime, meridiemMode, minTime, minutesStep, shouldDisableClock, shouldDisableTime, utils2, disableFuture, disablePast, now2, views]);
      const selectedId = useId();
      const viewProps = reactExports.useMemo(() => {
        switch (view) {
          case "hours": {
            const handleHoursChange = (hourValue, isFinish) => {
              const valueWithMeridiem = convertValueToMeridiem(hourValue, meridiemMode, ampm);
              setValueAndGoToNextView(utils2.setHours(valueOrReferenceDate, valueWithMeridiem), isFinish);
            };
            return {
              onChange: handleHoursChange,
              viewValue: utils2.getHours(valueOrReferenceDate),
              children: getHourNumbers({
                value,
                utils: utils2,
                ampm,
                onChange: handleHoursChange,
                getClockNumberText: localeText.hoursClockNumberText,
                isDisabled: (hourValue) => disabled || isTimeDisabled(hourValue, "hours"),
                selectedId
              })
            };
          }
          case "minutes": {
            const minutesValue = utils2.getMinutes(valueOrReferenceDate);
            const handleMinutesChange = (minuteValue, isFinish) => {
              setValueAndGoToNextView(utils2.setMinutes(valueOrReferenceDate, minuteValue), isFinish);
            };
            return {
              viewValue: minutesValue,
              onChange: handleMinutesChange,
              children: getMinutesNumbers({
                utils: utils2,
                value: minutesValue,
                onChange: handleMinutesChange,
                getClockNumberText: localeText.minutesClockNumberText,
                isDisabled: (minuteValue) => disabled || isTimeDisabled(minuteValue, "minutes"),
                selectedId
              })
            };
          }
          case "seconds": {
            const secondsValue = utils2.getSeconds(valueOrReferenceDate);
            const handleSecondsChange = (secondValue, isFinish) => {
              setValueAndGoToNextView(utils2.setSeconds(valueOrReferenceDate, secondValue), isFinish);
            };
            return {
              viewValue: secondsValue,
              onChange: handleSecondsChange,
              children: getMinutesNumbers({
                utils: utils2,
                value: secondsValue,
                onChange: handleSecondsChange,
                getClockNumberText: localeText.secondsClockNumberText,
                isDisabled: (secondValue) => disabled || isTimeDisabled(secondValue, "seconds"),
                selectedId
              })
            };
          }
          default:
            throw new Error("You must provide the type for ClockView");
        }
      }, [view, utils2, value, ampm, localeText.hoursClockNumberText, localeText.minutesClockNumberText, localeText.secondsClockNumberText, meridiemMode, setValueAndGoToNextView, valueOrReferenceDate, isTimeDisabled, selectedId, disabled]);
      const ownerState = props;
      const classes = useUtilityClasses$4(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(TimeClockRoot, _extends$1({
        ref,
        className: clsx(classes.root, className),
        ownerState
      }, other, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Clock, _extends$1({
          autoFocus: autoFocus != null ? autoFocus : !!focusedView,
          ampmInClock: ampmInClock && views.includes("hours"),
          value,
          type: view,
          ampm,
          minutesStep,
          isTimeDisabled,
          meridiemMode,
          handleMeridiemChange,
          selectedId,
          disabled,
          readOnly
        }, viewProps)), showViewSwitcher && /* @__PURE__ */ jsxRuntimeExports.jsx(TimeClockArrowSwitcher, {
          className: classes.arrowSwitcher,
          slots,
          slotProps,
          onGoToPrevious: () => setView(previousView),
          isPreviousDisabled: !previousView,
          previousLabel: localeText.openPreviousView,
          onGoToNext: () => setView(nextView),
          isNextDisabled: !nextView,
          nextLabel: localeText.openNextView,
          ownerState
        })]
      }));
    });
    const dividerClasses = generateUtilityClasses$1("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]);
    const dividerClasses$1 = dividerClasses;
    const listItemIconClasses = generateUtilityClasses$1("MuiListItemIcon", ["root", "alignItemsFlexStart"]);
    const listItemIconClasses$1 = listItemIconClasses;
    const listItemTextClasses = generateUtilityClasses$1("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]);
    const listItemTextClasses$1 = listItemTextClasses;
    function getMenuItemUtilityClass(slot) {
      return generateUtilityClass$1("MuiMenuItem", slot);
    }
    const menuItemClasses = generateUtilityClasses$1("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]);
    const menuItemClasses$1 = menuItemClasses;
    const _excluded$5 = ["autoFocus", "component", "dense", "divider", "disableGutters", "focusVisibleClassName", "role", "tabIndex", "className"];
    const overridesResolver = (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.dense && styles2.dense, ownerState.divider && styles2.divider, !ownerState.disableGutters && styles2.gutters];
    };
    const useUtilityClasses$3 = (ownerState) => {
      const {
        disabled,
        dense,
        divider,
        disableGutters,
        selected,
        classes
      } = ownerState;
      const slots = {
        root: ["root", dense && "dense", disabled && "disabled", !disableGutters && "gutters", divider && "divider", selected && "selected"]
      };
      const composedClasses = composeClasses(slots, getMenuItemUtilityClass, classes);
      return _extends$1({}, classes, composedClasses);
    };
    const MenuItemRoot = styled(ButtonBase$1, {
      shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
      name: "MuiMenuItem",
      slot: "Root",
      overridesResolver
    })(({
      theme,
      ownerState
    }) => _extends$1({}, theme.typography.body1, {
      display: "flex",
      justifyContent: "flex-start",
      alignItems: "center",
      position: "relative",
      textDecoration: "none",
      minHeight: 48,
      paddingTop: 6,
      paddingBottom: 6,
      boxSizing: "border-box",
      whiteSpace: "nowrap"
    }, !ownerState.disableGutters && {
      paddingLeft: 16,
      paddingRight: 16
    }, ownerState.divider && {
      borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`,
      backgroundClip: "padding-box"
    }, {
      "&:hover": {
        textDecoration: "none",
        backgroundColor: (theme.vars || theme).palette.action.hover,
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      },
      [`&.${menuItemClasses$1.selected}`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha$1(theme.palette.primary.main, theme.palette.action.selectedOpacity),
        [`&.${menuItemClasses$1.focusVisible}`]: {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha$1(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
        }
      },
      [`&.${menuItemClasses$1.selected}:hover`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha$1(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha$1(theme.palette.primary.main, theme.palette.action.selectedOpacity)
        }
      },
      [`&.${menuItemClasses$1.focusVisible}`]: {
        backgroundColor: (theme.vars || theme).palette.action.focus
      },
      [`&.${menuItemClasses$1.disabled}`]: {
        opacity: (theme.vars || theme).palette.action.disabledOpacity
      },
      [`& + .${dividerClasses$1.root}`]: {
        marginTop: theme.spacing(1),
        marginBottom: theme.spacing(1)
      },
      [`& + .${dividerClasses$1.inset}`]: {
        marginLeft: 52
      },
      [`& .${listItemTextClasses$1.root}`]: {
        marginTop: 0,
        marginBottom: 0
      },
      [`& .${listItemTextClasses$1.inset}`]: {
        paddingLeft: 36
      },
      [`& .${listItemIconClasses$1.root}`]: {
        minWidth: 36
      }
    }, !ownerState.dense && {
      [theme.breakpoints.up("sm")]: {
        minHeight: "auto"
      }
    }, ownerState.dense && _extends$1({
      minHeight: 32,
      // https://m2.material.io/components/menus#specs > Dense
      paddingTop: 4,
      paddingBottom: 4
    }, theme.typography.body2, {
      [`& .${listItemIconClasses$1.root} svg`]: {
        fontSize: "1.25rem"
      }
    })));
    const MenuItem = /* @__PURE__ */ reactExports.forwardRef(function MenuItem2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiMenuItem"
      });
      const {
        autoFocus = false,
        component = "li",
        dense = false,
        divider = false,
        disableGutters = false,
        focusVisibleClassName,
        role = "menuitem",
        tabIndex: tabIndexProp,
        className
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$5);
      const context = reactExports.useContext(ListContext$1);
      const childContext = reactExports.useMemo(() => ({
        dense: dense || context.dense || false,
        disableGutters
      }), [context.dense, dense, disableGutters]);
      const menuItemRef = reactExports.useRef(null);
      useEnhancedEffect(() => {
        if (autoFocus) {
          if (menuItemRef.current) {
            menuItemRef.current.focus();
          }
        }
      }, [autoFocus]);
      const ownerState = _extends$1({}, props, {
        dense: childContext.dense,
        divider,
        disableGutters
      });
      const classes = useUtilityClasses$3(props);
      const handleRef = useForkRef(menuItemRef, ref);
      let tabIndex;
      if (!props.disabled) {
        tabIndex = tabIndexProp !== void 0 ? tabIndexProp : -1;
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext$1.Provider, {
        value: childContext,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItemRoot, _extends$1({
          ref: handleRef,
          role,
          tabIndex,
          component,
          focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
          className: clsx(classes.root, className)
        }, other, {
          ownerState,
          classes
        }))
      });
    });
    const MenuItem$1 = MenuItem;
    function getDigitalClockUtilityClass(slot) {
      return generateUtilityClass$1("MuiDigitalClock", slot);
    }
    generateUtilityClasses$1("MuiDigitalClock", ["root", "list", "item"]);
    const _excluded$4 = ["ampm", "timeStep", "autoFocus", "components", "componentsProps", "slots", "slotProps", "value", "defaultValue", "referenceDate", "disableIgnoringDatePartForTimeValidation", "maxTime", "minTime", "disableFuture", "disablePast", "minutesStep", "shouldDisableClock", "shouldDisableTime", "onChange", "view", "openTo", "onViewChange", "focusedView", "onFocusedViewChange", "className", "disabled", "readOnly", "views", "skipDisabled", "timezone"];
    const useUtilityClasses$2 = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        list: ["list"],
        item: ["item"]
      };
      return composeClasses(slots, getDigitalClockUtilityClass, classes);
    };
    const DigitalClockRoot = styled(PickerViewRoot, {
      name: "MuiDigitalClock",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })(({
      ownerState
    }) => ({
      overflowY: "auto",
      width: "100%",
      "@media (prefers-reduced-motion: no-preference)": {
        scrollBehavior: ownerState.alreadyRendered ? "smooth" : "auto"
      },
      maxHeight: DIGITAL_CLOCK_VIEW_HEIGHT
    }));
    const DigitalClockList = styled(MenuList$1, {
      name: "MuiDigitalClock",
      slot: "List",
      overridesResolver: (props, styles2) => styles2.list
    })({
      padding: 0
    });
    const DigitalClockItem = styled(MenuItem$1, {
      name: "MuiDigitalClock",
      slot: "Item",
      overridesResolver: (props, styles2) => styles2.item
    })(({
      theme
    }) => ({
      padding: "8px 16px",
      margin: "2px 4px",
      "&:first-of-type": {
        marginTop: 4
      },
      "&:hover": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha$1(theme.palette.primary.main, theme.palette.action.hoverOpacity)
      },
      "&.Mui-selected": {
        backgroundColor: (theme.vars || theme).palette.primary.main,
        color: (theme.vars || theme).palette.primary.contrastText,
        "&:focus-visible, &:hover": {
          backgroundColor: (theme.vars || theme).palette.primary.dark
        }
      },
      "&.Mui-focusVisible": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.focusOpacity})` : alpha$1(theme.palette.primary.main, theme.palette.action.focusOpacity)
      }
    }));
    const DigitalClock = /* @__PURE__ */ reactExports.forwardRef(function DigitalClock2(inProps, ref) {
      var _ref, _slots$digitalClockIt, _slotProps$digitalClo;
      const utils2 = useUtils();
      const containerRef = reactExports.useRef(null);
      const handleRef = useForkRef(ref, containerRef);
      const props = useThemeProps({
        props: inProps,
        name: "MuiDigitalClock"
      });
      const {
        ampm = utils2.is12HourCycleInCurrentLocale(),
        timeStep = 30,
        autoFocus,
        components,
        componentsProps,
        slots,
        slotProps,
        value: valueProp,
        defaultValue,
        referenceDate: referenceDateProp,
        disableIgnoringDatePartForTimeValidation = false,
        maxTime,
        minTime,
        disableFuture,
        disablePast,
        minutesStep = 1,
        shouldDisableClock,
        shouldDisableTime,
        onChange,
        view: inView,
        openTo,
        onViewChange,
        focusedView,
        onFocusedViewChange,
        className,
        disabled,
        readOnly,
        views = ["hours"],
        skipDisabled = false,
        timezone: timezoneProp
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$4);
      const {
        value,
        handleValueChange: handleRawValueChange,
        timezone
      } = useControlledValueWithTimezone({
        name: "DigitalClock",
        timezone: timezoneProp,
        value: valueProp,
        defaultValue,
        onChange,
        valueManager: singleItemValueManager
      });
      const localeText = useLocaleText();
      const now2 = useNow(timezone);
      const ownerState = reactExports.useMemo(() => _extends$1({}, props, {
        alreadyRendered: !!containerRef.current
      }), [props]);
      const classes = useUtilityClasses$2(ownerState);
      const ClockItem = (_ref = (_slots$digitalClockIt = slots == null ? void 0 : slots.digitalClockItem) != null ? _slots$digitalClockIt : components == null ? void 0 : components.DigitalClockItem) != null ? _ref : DigitalClockItem;
      const clockItemProps = useSlotProps({
        elementType: ClockItem,
        externalSlotProps: (_slotProps$digitalClo = slotProps == null ? void 0 : slotProps.digitalClockItem) != null ? _slotProps$digitalClo : componentsProps == null ? void 0 : componentsProps.digitalClockItem,
        ownerState: {},
        className: classes.item
      });
      const valueOrReferenceDate = useClockReferenceDate({
        value,
        referenceDate: referenceDateProp,
        utils: utils2,
        props,
        timezone
      });
      const handleValueChange = useEventCallback((newValue) => handleRawValueChange(newValue, "finish", "hours"));
      const {
        setValueAndGoToNextView
      } = useViews({
        view: inView,
        views,
        openTo,
        onViewChange,
        onChange: handleValueChange,
        focusedView,
        onFocusedViewChange
      });
      const handleItemSelect = useEventCallback((newValue) => {
        setValueAndGoToNextView(newValue, "finish");
      });
      reactExports.useEffect(() => {
        if (containerRef.current === null) {
          return;
        }
        const selectedItem = containerRef.current.querySelector('[role="listbox"] [role="option"][aria-selected="true"]');
        if (!selectedItem) {
          return;
        }
        const offsetTop = selectedItem.offsetTop;
        containerRef.current.scrollTop = offsetTop - 4;
      });
      const isTimeDisabled = reactExports.useCallback((valueToCheck) => {
        const isAfter = createIsAfterIgnoreDatePart(disableIgnoringDatePartForTimeValidation, utils2);
        const containsValidTime = () => {
          if (minTime && isAfter(minTime, valueToCheck)) {
            return false;
          }
          if (maxTime && isAfter(valueToCheck, maxTime)) {
            return false;
          }
          if (disableFuture && isAfter(valueToCheck, now2)) {
            return false;
          }
          if (disablePast && isAfter(now2, valueToCheck)) {
            return false;
          }
          return true;
        };
        const isValidValue = () => {
          if (utils2.getMinutes(valueToCheck) % minutesStep !== 0) {
            return false;
          }
          if (shouldDisableClock != null && shouldDisableClock(utils2.toJsDate(valueToCheck).getTime(), "hours")) {
            return false;
          }
          if (shouldDisableTime) {
            return !shouldDisableTime(valueToCheck, "hours");
          }
          return true;
        };
        return !containsValidTime() || !isValidValue();
      }, [disableIgnoringDatePartForTimeValidation, utils2, minTime, maxTime, disableFuture, now2, disablePast, minutesStep, shouldDisableClock, shouldDisableTime]);
      const timeOptions = reactExports.useMemo(() => {
        const startOfDay = utils2.startOfDay(valueOrReferenceDate);
        return [startOfDay, ...Array.from({
          length: Math.ceil(24 * 60 / timeStep) - 1
        }, (_2, index) => utils2.addMinutes(startOfDay, timeStep * (index + 1)))];
      }, [valueOrReferenceDate, timeStep, utils2]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(DigitalClockRoot, _extends$1({
        ref: handleRef,
        className: clsx(classes.root, className),
        ownerState
      }, other, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(DigitalClockList, {
          autoFocusItem: autoFocus || !!focusedView,
          role: "listbox",
          "aria-label": localeText.timePickerToolbarTitle,
          className: classes.list,
          children: timeOptions.map((option) => {
            if (skipDisabled && isTimeDisabled(option)) {
              return null;
            }
            const isSelected = utils2.isEqual(option, value);
            return /* @__PURE__ */ jsxRuntimeExports.jsx(ClockItem, _extends$1({
              onClick: () => !readOnly && handleItemSelect(option),
              selected: isSelected,
              disabled: disabled || isTimeDisabled(option),
              disableRipple: readOnly,
              role: "option",
              "aria-disabled": readOnly,
              "aria-selected": isSelected
            }, clockItemProps, {
              children: utils2.format(option, ampm ? "fullTime12h" : "fullTime24h")
            }), utils2.toISO(option));
          })
        })
      }));
    });
    function getMultiSectionDigitalClockUtilityClass(slot) {
      return generateUtilityClass$1("MuiMultiSectionDigitalClock", slot);
    }
    generateUtilityClasses$1("MuiMultiSectionDigitalClock", ["root"]);
    function getMultiSectionDigitalClockSectionUtilityClass(slot) {
      return generateUtilityClass$1("MuiMultiSectionDigitalClockSection", slot);
    }
    generateUtilityClasses$1("MuiMultiSectionDigitalClockSection", ["root", "item"]);
    const _excluded$3 = ["autoFocus", "onChange", "className", "disabled", "readOnly", "items", "active", "slots", "slotProps", "skipDisabled"];
    const useUtilityClasses$1 = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        item: ["item"]
      };
      return composeClasses(slots, getMultiSectionDigitalClockSectionUtilityClass, classes);
    };
    const MultiSectionDigitalClockSectionRoot = styled(MenuList$1, {
      name: "MuiMultiSectionDigitalClockSection",
      slot: "Root",
      overridesResolver: (_2, styles2) => styles2.root
    })(({
      theme,
      ownerState
    }) => ({
      maxHeight: DIGITAL_CLOCK_VIEW_HEIGHT,
      width: 56,
      padding: 0,
      overflow: "hidden",
      "@media (prefers-reduced-motion: no-preference)": {
        scrollBehavior: ownerState.alreadyRendered ? "smooth" : "auto"
      },
      "@media (pointer: fine)": {
        "&:hover": {
          overflowY: "auto"
        }
      },
      "@media (pointer: none), (pointer: coarse)": {
        overflowY: "auto"
      },
      "&:not(:first-of-type)": {
        borderLeft: `1px solid ${(theme.vars || theme).palette.divider}`
      },
      "&:after": {
        display: "block",
        content: '""',
        // subtracting the height of one item, extra margin and borders to make sure the max height is correct
        height: "calc(100% - 40px - 6px)"
      }
    }));
    const MultiSectionDigitalClockSectionItem = styled(MenuItem$1, {
      name: "MuiMultiSectionDigitalClockSection",
      slot: "Item",
      overridesResolver: (_2, styles2) => styles2.item
    })(({
      theme
    }) => ({
      padding: 8,
      margin: "2px 4px",
      width: MULTI_SECTION_CLOCK_SECTION_WIDTH,
      justifyContent: "center",
      "&:first-of-type": {
        marginTop: 4
      },
      "&:hover": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha$1(theme.palette.primary.main, theme.palette.action.hoverOpacity)
      },
      "&.Mui-selected": {
        backgroundColor: (theme.vars || theme).palette.primary.main,
        color: (theme.vars || theme).palette.primary.contrastText,
        "&:focus-visible, &:hover": {
          backgroundColor: (theme.vars || theme).palette.primary.dark
        }
      },
      "&.Mui-focusVisible": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.focusOpacity})` : alpha$1(theme.palette.primary.main, theme.palette.action.focusOpacity)
      }
    }));
    const MultiSectionDigitalClockSection = /* @__PURE__ */ reactExports.forwardRef(function MultiSectionDigitalClockSection2(inProps, ref) {
      var _slots$digitalClockSe;
      const containerRef = reactExports.useRef(null);
      const handleRef = useForkRef(ref, containerRef);
      const previousActive = reactExports.useRef(null);
      const props = useThemeProps({
        props: inProps,
        name: "MuiMultiSectionDigitalClockSection"
      });
      const {
        autoFocus,
        onChange,
        className,
        disabled,
        readOnly,
        items,
        active,
        slots,
        slotProps,
        skipDisabled
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$3);
      const ownerState = reactExports.useMemo(() => _extends$1({}, props, {
        alreadyRendered: !!containerRef.current
      }), [props]);
      const classes = useUtilityClasses$1(ownerState);
      const DigitalClockSectionItem = (_slots$digitalClockSe = slots == null ? void 0 : slots.digitalClockSectionItem) != null ? _slots$digitalClockSe : MultiSectionDigitalClockSectionItem;
      reactExports.useEffect(() => {
        if (containerRef.current === null) {
          return;
        }
        const activeItem = containerRef.current.querySelector('[role="option"][aria-selected="true"]');
        if (active && autoFocus && activeItem) {
          activeItem.focus();
        }
        if (!activeItem || previousActive.current === activeItem) {
          return;
        }
        previousActive.current = activeItem;
        const offsetTop = activeItem.offsetTop;
        containerRef.current.scrollTop = offsetTop - 4;
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(MultiSectionDigitalClockSectionRoot, _extends$1({
        ref: handleRef,
        className: clsx(classes.root, className),
        ownerState,
        autoFocusItem: autoFocus && active,
        role: "listbox"
      }, other, {
        children: items.map((option) => {
          var _option$isDisabled, _option$isDisabled2;
          if (skipDisabled && (_option$isDisabled = option.isDisabled) != null && _option$isDisabled.call(option, option.value)) {
            return null;
          }
          const isSelected = option.isSelected(option.value);
          return /* @__PURE__ */ jsxRuntimeExports.jsx(DigitalClockSectionItem, _extends$1({
            onClick: () => !readOnly && onChange(option.value),
            selected: isSelected,
            disabled: disabled || ((_option$isDisabled2 = option.isDisabled) == null ? void 0 : _option$isDisabled2.call(option, option.value)),
            disableRipple: readOnly,
            role: "option",
            "aria-disabled": readOnly,
            "aria-label": option.ariaLabel,
            "aria-selected": isSelected,
            className: classes.item
          }, slotProps == null ? void 0 : slotProps.digitalClockSectionItem, {
            children: option.label
          }), option.label);
        })
      }));
    });
    const getHourSectionOptions = ({
      now: now2,
      value,
      utils: utils2,
      ampm,
      isDisabled,
      resolveAriaLabel,
      timeStep
    }) => {
      const currentHours = value ? utils2.getHours(value) : null;
      const result = [];
      const isSelected = (hour) => {
        if (currentHours === null) {
          return false;
        }
        if (ampm) {
          if (hour === 12) {
            return currentHours === 12 || currentHours === 0;
          }
          return currentHours === hour || currentHours - 12 === hour;
        }
        return currentHours === hour;
      };
      const endHour = ampm ? 11 : 23;
      for (let hour = 0; hour <= endHour; hour += timeStep) {
        let label = utils2.format(utils2.setHours(now2, hour), ampm ? "hours12h" : "hours24h");
        const ariaLabel = resolveAriaLabel(parseInt(label, 10).toString());
        label = utils2.formatNumber(label);
        result.push({
          value: hour,
          label,
          isSelected,
          isDisabled,
          ariaLabel
        });
      }
      return result;
    };
    const getTimeSectionOptions = ({
      value,
      utils: utils2,
      isDisabled,
      timeStep,
      resolveLabel,
      resolveAriaLabel,
      hasValue: hasValue2 = true
    }) => {
      const isSelected = (timeValue) => {
        if (value === null) {
          return false;
        }
        return hasValue2 && value === timeValue;
      };
      return [...Array.from({
        length: Math.ceil(60 / timeStep)
      }, (_2, index) => {
        const timeValue = timeStep * index;
        return {
          value: timeValue,
          label: utils2.formatNumber(resolveLabel(timeValue)),
          isDisabled,
          isSelected,
          ariaLabel: resolveAriaLabel(timeValue.toString())
        };
      })];
    };
    const _excluded$2 = ["ampm", "timeSteps", "autoFocus", "components", "componentsProps", "slots", "slotProps", "value", "defaultValue", "referenceDate", "disableIgnoringDatePartForTimeValidation", "maxTime", "minTime", "disableFuture", "disablePast", "minutesStep", "shouldDisableClock", "shouldDisableTime", "onChange", "view", "views", "openTo", "onViewChange", "focusedView", "onFocusedViewChange", "className", "disabled", "readOnly", "skipDisabled", "timezone"];
    const useUtilityClasses = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"]
      };
      return composeClasses(slots, getMultiSectionDigitalClockUtilityClass, classes);
    };
    const MultiSectionDigitalClockRoot = styled(PickerViewRoot, {
      name: "MuiMultiSectionDigitalClock",
      slot: "Root",
      overridesResolver: (_2, styles2) => styles2.root
    })(({
      theme
    }) => ({
      display: "flex",
      flexDirection: "row",
      width: "100%",
      borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`
    }));
    const MultiSectionDigitalClock = /* @__PURE__ */ reactExports.forwardRef(function MultiSectionDigitalClock2(inProps, ref) {
      const utils2 = useUtils();
      const props = useThemeProps({
        props: inProps,
        name: "MuiMultiSectionDigitalClock"
      });
      const {
        ampm = utils2.is12HourCycleInCurrentLocale(),
        timeSteps: inTimeSteps,
        autoFocus,
        components,
        componentsProps,
        slots,
        slotProps,
        value: valueProp,
        defaultValue,
        referenceDate: referenceDateProp,
        disableIgnoringDatePartForTimeValidation = false,
        maxTime,
        minTime,
        disableFuture,
        disablePast,
        minutesStep = 1,
        shouldDisableClock,
        shouldDisableTime,
        onChange,
        view: inView,
        views: inViews = ["hours", "minutes"],
        openTo,
        onViewChange,
        focusedView: inFocusedView,
        onFocusedViewChange,
        className,
        disabled,
        readOnly,
        skipDisabled = false,
        timezone: timezoneProp
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$2);
      const {
        value,
        handleValueChange: handleRawValueChange,
        timezone
      } = useControlledValueWithTimezone({
        name: "MultiSectionDigitalClock",
        timezone: timezoneProp,
        value: valueProp,
        defaultValue,
        onChange,
        valueManager: singleItemValueManager
      });
      const localeText = useLocaleText();
      const now2 = useNow(timezone);
      const timeSteps = reactExports.useMemo(() => _extends$1({
        hours: 1,
        minutes: 5,
        seconds: 5
      }, inTimeSteps), [inTimeSteps]);
      const valueOrReferenceDate = useClockReferenceDate({
        value,
        referenceDate: referenceDateProp,
        utils: utils2,
        props,
        timezone
      });
      const handleValueChange = useEventCallback((newValue, selectionState, selectedView) => handleRawValueChange(newValue, selectionState, selectedView));
      const views = reactExports.useMemo(() => {
        if (!ampm || !inViews.includes("hours")) {
          return inViews;
        }
        return inViews.includes("meridiem") ? inViews : [...inViews, "meridiem"];
      }, [ampm, inViews]);
      const {
        view,
        setValueAndGoToNextView,
        focusedView
      } = useViews({
        view: inView,
        views,
        openTo,
        onViewChange,
        onChange: handleValueChange,
        focusedView: inFocusedView,
        onFocusedViewChange
      });
      const handleMeridiemValueChange = useEventCallback((newValue) => {
        setValueAndGoToNextView(newValue, "finish", "meridiem");
      });
      const {
        meridiemMode,
        handleMeridiemChange
      } = useMeridiemMode(valueOrReferenceDate, ampm, handleMeridiemValueChange, "finish");
      const isTimeDisabled = reactExports.useCallback((rawValue, viewType) => {
        const isAfter = createIsAfterIgnoreDatePart(disableIgnoringDatePartForTimeValidation, utils2);
        const shouldCheckPastEnd = viewType === "hours" || viewType === "minutes" && views.includes("seconds");
        const containsValidTime = ({
          start: start2,
          end: end2
        }) => {
          if (minTime && isAfter(minTime, end2)) {
            return false;
          }
          if (maxTime && isAfter(start2, maxTime)) {
            return false;
          }
          if (disableFuture && isAfter(start2, now2)) {
            return false;
          }
          if (disablePast && isAfter(now2, shouldCheckPastEnd ? end2 : start2)) {
            return false;
          }
          return true;
        };
        const isValidValue = (timeValue, step = 1) => {
          if (timeValue % step !== 0) {
            return false;
          }
          if (shouldDisableClock != null && shouldDisableClock(timeValue, viewType)) {
            return false;
          }
          if (shouldDisableTime) {
            switch (viewType) {
              case "hours":
                return !shouldDisableTime(utils2.setHours(valueOrReferenceDate, timeValue), "hours");
              case "minutes":
                return !shouldDisableTime(utils2.setMinutes(valueOrReferenceDate, timeValue), "minutes");
              case "seconds":
                return !shouldDisableTime(utils2.setSeconds(valueOrReferenceDate, timeValue), "seconds");
              default:
                return false;
            }
          }
          return true;
        };
        switch (viewType) {
          case "hours": {
            const valueWithMeridiem = convertValueToMeridiem(rawValue, meridiemMode, ampm);
            const dateWithNewHours = utils2.setHours(valueOrReferenceDate, valueWithMeridiem);
            const start2 = utils2.setSeconds(utils2.setMinutes(dateWithNewHours, 0), 0);
            const end2 = utils2.setSeconds(utils2.setMinutes(dateWithNewHours, 59), 59);
            return !containsValidTime({
              start: start2,
              end: end2
            }) || !isValidValue(valueWithMeridiem);
          }
          case "minutes": {
            const dateWithNewMinutes = utils2.setMinutes(valueOrReferenceDate, rawValue);
            const start2 = utils2.setSeconds(dateWithNewMinutes, 0);
            const end2 = utils2.setSeconds(dateWithNewMinutes, 59);
            return !containsValidTime({
              start: start2,
              end: end2
            }) || !isValidValue(rawValue, minutesStep);
          }
          case "seconds": {
            const dateWithNewSeconds = utils2.setSeconds(valueOrReferenceDate, rawValue);
            const start2 = dateWithNewSeconds;
            const end2 = dateWithNewSeconds;
            return !containsValidTime({
              start: start2,
              end: end2
            }) || !isValidValue(rawValue);
          }
          default:
            throw new Error("not supported");
        }
      }, [ampm, valueOrReferenceDate, disableIgnoringDatePartForTimeValidation, maxTime, meridiemMode, minTime, minutesStep, shouldDisableClock, shouldDisableTime, utils2, disableFuture, disablePast, now2, views]);
      const buildViewProps = reactExports.useCallback((viewToBuild) => {
        switch (viewToBuild) {
          case "hours": {
            return {
              onChange: (hours) => {
                const valueWithMeridiem = convertValueToMeridiem(hours, meridiemMode, ampm);
                setValueAndGoToNextView(utils2.setHours(valueOrReferenceDate, valueWithMeridiem), "finish", "hours");
              },
              items: getHourSectionOptions({
                now: now2,
                value,
                ampm,
                utils: utils2,
                isDisabled: (hours) => disabled || isTimeDisabled(hours, "hours"),
                timeStep: timeSteps.hours,
                resolveAriaLabel: localeText.hoursClockNumberText
              })
            };
          }
          case "minutes": {
            return {
              onChange: (minutes) => {
                setValueAndGoToNextView(utils2.setMinutes(valueOrReferenceDate, minutes), "finish", "minutes");
              },
              items: getTimeSectionOptions({
                value: utils2.getMinutes(valueOrReferenceDate),
                utils: utils2,
                isDisabled: (minutes) => disabled || isTimeDisabled(minutes, "minutes"),
                resolveLabel: (minutes) => utils2.format(utils2.setMinutes(now2, minutes), "minutes"),
                timeStep: timeSteps.minutes,
                hasValue: !!value,
                resolveAriaLabel: localeText.minutesClockNumberText
              })
            };
          }
          case "seconds": {
            return {
              onChange: (seconds) => {
                setValueAndGoToNextView(utils2.setSeconds(valueOrReferenceDate, seconds), "finish", "seconds");
              },
              items: getTimeSectionOptions({
                value: utils2.getSeconds(valueOrReferenceDate),
                utils: utils2,
                isDisabled: (seconds) => disabled || isTimeDisabled(seconds, "seconds"),
                resolveLabel: (seconds) => utils2.format(utils2.setSeconds(now2, seconds), "seconds"),
                timeStep: timeSteps.seconds,
                hasValue: !!value,
                resolveAriaLabel: localeText.secondsClockNumberText
              })
            };
          }
          case "meridiem": {
            const amLabel = formatMeridiem(utils2, "am");
            const pmLabel = formatMeridiem(utils2, "pm");
            return {
              onChange: handleMeridiemChange,
              items: [{
                value: "am",
                label: amLabel,
                isSelected: () => !!value && meridiemMode === "am",
                ariaLabel: amLabel
              }, {
                value: "pm",
                label: pmLabel,
                isSelected: () => !!value && meridiemMode === "pm",
                ariaLabel: pmLabel
              }]
            };
          }
          default:
            throw new Error(`Unknown view: ${viewToBuild} found.`);
        }
      }, [now2, value, ampm, utils2, timeSteps.hours, timeSteps.minutes, timeSteps.seconds, localeText.hoursClockNumberText, localeText.minutesClockNumberText, localeText.secondsClockNumberText, meridiemMode, setValueAndGoToNextView, valueOrReferenceDate, disabled, isTimeDisabled, handleMeridiemChange]);
      const viewTimeOptions = reactExports.useMemo(() => {
        return views.reduce((result, currentView) => {
          return _extends$1({}, result, {
            [currentView]: buildViewProps(currentView)
          });
        }, {});
      }, [views, buildViewProps]);
      const ownerState = props;
      const classes = useUtilityClasses(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(MultiSectionDigitalClockRoot, _extends$1({
        ref,
        className: clsx(classes.root, className),
        ownerState,
        role: "group"
      }, other, {
        children: Object.entries(viewTimeOptions).map(([timeView, viewOptions]) => /* @__PURE__ */ jsxRuntimeExports.jsx(MultiSectionDigitalClockSection, {
          items: viewOptions.items,
          onChange: viewOptions.onChange,
          active: view === timeView,
          autoFocus: autoFocus != null ? autoFocus : focusedView === timeView,
          disabled,
          readOnly,
          slots: slots != null ? slots : components,
          slotProps: slotProps != null ? slotProps : componentsProps,
          skipDisabled,
          "aria-label": localeText.selectViewText(timeView)
        }, timeView))
      }));
    });
    const renderTimeViewClock = ({
      view,
      onViewChange,
      focusedView,
      onFocusedViewChange,
      views,
      value,
      defaultValue,
      referenceDate,
      onChange,
      className,
      classes,
      disableFuture,
      disablePast,
      minTime,
      maxTime,
      shouldDisableTime,
      shouldDisableClock,
      minutesStep,
      ampm,
      ampmInClock,
      components,
      componentsProps,
      slots,
      slotProps,
      readOnly,
      disabled,
      sx,
      autoFocus,
      showViewSwitcher,
      disableIgnoringDatePartForTimeValidation,
      timezone
    }) => /* @__PURE__ */ jsxRuntimeExports.jsx(TimeClock, {
      view,
      onViewChange,
      focusedView: focusedView && isTimeView(focusedView) ? focusedView : null,
      onFocusedViewChange,
      views: views.filter(isTimeView),
      value,
      defaultValue,
      referenceDate,
      onChange,
      className,
      classes,
      disableFuture,
      disablePast,
      minTime,
      maxTime,
      shouldDisableTime,
      shouldDisableClock,
      minutesStep,
      ampm,
      ampmInClock,
      components,
      componentsProps,
      slots,
      slotProps,
      readOnly,
      disabled,
      sx,
      autoFocus,
      showViewSwitcher,
      disableIgnoringDatePartForTimeValidation,
      timezone
    });
    const renderDigitalClockTimeView = ({
      view,
      onViewChange,
      focusedView,
      onFocusedViewChange,
      views,
      value,
      defaultValue,
      referenceDate,
      onChange,
      className,
      classes,
      disableFuture,
      disablePast,
      minTime,
      maxTime,
      shouldDisableTime,
      shouldDisableClock,
      minutesStep,
      ampm,
      components,
      componentsProps,
      slots,
      slotProps,
      readOnly,
      disabled,
      sx,
      autoFocus,
      disableIgnoringDatePartForTimeValidation,
      timeSteps,
      skipDisabled,
      timezone
    }) => /* @__PURE__ */ jsxRuntimeExports.jsx(DigitalClock, {
      view,
      onViewChange,
      focusedView,
      onFocusedViewChange,
      views: views.filter(isTimeView),
      value,
      defaultValue,
      referenceDate,
      onChange,
      className,
      classes,
      disableFuture,
      disablePast,
      minTime,
      maxTime,
      shouldDisableTime,
      shouldDisableClock,
      minutesStep,
      ampm,
      components,
      componentsProps,
      slots,
      slotProps,
      readOnly,
      disabled,
      sx,
      autoFocus,
      disableIgnoringDatePartForTimeValidation,
      timeStep: timeSteps == null ? void 0 : timeSteps.minutes,
      skipDisabled,
      timezone
    });
    const renderMultiSectionDigitalClockTimeView = ({
      view,
      onViewChange,
      focusedView,
      onFocusedViewChange,
      views,
      value,
      defaultValue,
      referenceDate,
      onChange,
      className,
      classes,
      disableFuture,
      disablePast,
      minTime,
      maxTime,
      shouldDisableTime,
      shouldDisableClock,
      minutesStep,
      ampm,
      components,
      componentsProps,
      slots,
      slotProps,
      readOnly,
      disabled,
      sx,
      autoFocus,
      disableIgnoringDatePartForTimeValidation,
      timeSteps,
      skipDisabled,
      timezone
    }) => /* @__PURE__ */ jsxRuntimeExports.jsx(MultiSectionDigitalClock, {
      view,
      onViewChange,
      focusedView,
      onFocusedViewChange,
      views: views.filter(isTimeView),
      value,
      defaultValue,
      referenceDate,
      onChange,
      className,
      classes,
      disableFuture,
      disablePast,
      minTime,
      maxTime,
      shouldDisableTime,
      shouldDisableClock,
      minutesStep,
      ampm,
      components,
      componentsProps,
      slots,
      slotProps,
      readOnly,
      disabled,
      sx,
      autoFocus,
      disableIgnoringDatePartForTimeValidation,
      timeSteps,
      skipDisabled,
      timezone
    });
    const resolveViews = (ampm, views, shouldUseSingleColumn) => {
      if (shouldUseSingleColumn) {
        return views.filter((view) => !isInternalTimeView(view) || view === "hours");
      }
      return ampm ? [...views, "meridiem"] : views;
    };
    const resolveShouldRenderTimeInASingleColumn = (timeSteps, threshold) => {
      var _timeSteps$hours, _timeSteps$minutes;
      return 24 * 60 / (((_timeSteps$hours = timeSteps.hours) != null ? _timeSteps$hours : 1) * ((_timeSteps$minutes = timeSteps.minutes) != null ? _timeSteps$minutes : 5)) <= threshold;
    };
    function resolveTimeViewsResponse({
      thresholdToRenderTimeInASingleColumn: inThreshold,
      ampm,
      timeSteps: inTimeSteps,
      views
    }) {
      const thresholdToRenderTimeInASingleColumn = inThreshold != null ? inThreshold : 24;
      const timeSteps = _extends$1({
        hours: 1,
        minutes: 5,
        seconds: 5
      }, inTimeSteps);
      const shouldRenderTimeInASingleColumn = resolveShouldRenderTimeInASingleColumn(timeSteps, thresholdToRenderTimeInASingleColumn);
      return {
        thresholdToRenderTimeInASingleColumn,
        timeSteps,
        shouldRenderTimeInASingleColumn,
        views: resolveViews(ampm, views, shouldRenderTimeInASingleColumn)
      };
    }
    const DesktopTimePicker = /* @__PURE__ */ reactExports.forwardRef(function DesktopTimePicker2(inProps, ref) {
      var _defaultizedProps$amp, _viewRenderers$hours, _defaultizedProps$slo2, _defaultizedProps$slo3, _props$localeText$ope, _props$localeText;
      const localeText = useLocaleText();
      const utils2 = useUtils();
      const defaultizedProps = useTimePickerDefaultizedProps(inProps, "MuiDesktopTimePicker");
      const {
        shouldRenderTimeInASingleColumn,
        views: resolvedViews,
        timeSteps
      } = resolveTimeViewsResponse(defaultizedProps);
      const renderTimeView = shouldRenderTimeInASingleColumn ? renderDigitalClockTimeView : renderMultiSectionDigitalClockTimeView;
      const viewRenderers = _extends$1({
        hours: renderTimeView,
        minutes: renderTimeView,
        seconds: renderTimeView,
        meridiem: renderTimeView
      }, defaultizedProps.viewRenderers);
      const ampmInClock = (_defaultizedProps$amp = defaultizedProps.ampmInClock) != null ? _defaultizedProps$amp : true;
      const actionBarActions = shouldRenderTimeInASingleColumn ? [] : ["accept"];
      const shouldHoursRendererContainMeridiemView = ((_viewRenderers$hours = viewRenderers.hours) == null ? void 0 : _viewRenderers$hours.name) === renderMultiSectionDigitalClockTimeView.name;
      const views = !shouldHoursRendererContainMeridiemView ? resolvedViews.filter((view) => view !== "meridiem") : resolvedViews;
      const props = _extends$1({}, defaultizedProps, {
        ampmInClock,
        timeSteps,
        viewRenderers,
        format: resolveTimeFormat(utils2, defaultizedProps),
        // Setting only `hours` time view in case of single column time picker
        // Allows for easy view lifecycle management
        views: shouldRenderTimeInASingleColumn ? ["hours"] : views,
        slots: _extends$1({
          field: TimeField,
          openPickerIcon: ClockIcon
        }, defaultizedProps.slots),
        slotProps: _extends$1({}, defaultizedProps.slotProps, {
          field: (ownerState) => {
            var _defaultizedProps$slo;
            return _extends$1({}, resolveComponentProps((_defaultizedProps$slo = defaultizedProps.slotProps) == null ? void 0 : _defaultizedProps$slo.field, ownerState), extractValidationProps(defaultizedProps), {
              ref
            });
          },
          toolbar: _extends$1({
            hidden: true,
            ampmInClock
          }, (_defaultizedProps$slo2 = defaultizedProps.slotProps) == null ? void 0 : _defaultizedProps$slo2.toolbar),
          actionBar: _extends$1({
            actions: actionBarActions
          }, (_defaultizedProps$slo3 = defaultizedProps.slotProps) == null ? void 0 : _defaultizedProps$slo3.actionBar)
        })
      });
      const {
        renderPicker
      } = useDesktopPicker({
        props,
        valueManager: singleItemValueManager,
        valueType: "time",
        getOpenDialogAriaText: (_props$localeText$ope = (_props$localeText = props.localeText) == null ? void 0 : _props$localeText.openTimePickerDialogue) != null ? _props$localeText$ope : localeText.openTimePickerDialogue,
        validator: validateTime
      });
      return renderPicker();
    });
    DesktopTimePicker.propTypes = {
      // ----------------------------- Warning --------------------------------
      // | These PropTypes are generated from the TypeScript type definitions |
      // | To update them edit the TypeScript types and run "yarn proptypes"  |
      // ----------------------------------------------------------------------
      /**
       * 12h/24h view for hour selection clock.
       * @default `utils.is12HourCycleInCurrentLocale()`
       */
      ampm: PropTypes.bool,
      /**
       * Display ampm controls under the clock (instead of in the toolbar).
       * @default true on desktop, false on mobile
       */
      ampmInClock: PropTypes.bool,
      /**
       * If `true`, the main element is focused during the first mount.
       * This main element is:
       * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
       * - the `input` element if there is a field rendered.
       */
      autoFocus: PropTypes.bool,
      /**
       * Class name applied to the root element.
       */
      className: PropTypes.string,
      /**
       * If `true`, the popover or modal will close after submitting the full date.
       * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
       */
      closeOnSelect: PropTypes.bool,
      /**
       * Overridable components.
       * @default {}
       * @deprecated Please use `slots`.
       */
      components: PropTypes.object,
      /**
       * The props used for each component slot.
       * @default {}
       * @deprecated Please use `slotProps`.
       */
      componentsProps: PropTypes.object,
      /**
       * The default value.
       * Used when the component is not controlled.
       */
      defaultValue: PropTypes.any,
      /**
       * If `true`, the picker and text field are disabled.
       * @default false
       */
      disabled: PropTypes.bool,
      /**
       * If `true`, disable values after the current date for date components, time for time components and both for date time components.
       * @default false
       */
      disableFuture: PropTypes.bool,
      /**
       * Do not ignore date part when validating min/max time.
       * @default false
       */
      disableIgnoringDatePartForTimeValidation: PropTypes.bool,
      /**
       * If `true`, the open picker button will not be rendered (renders only the field).
       * @default false
       */
      disableOpenPicker: PropTypes.bool,
      /**
       * If `true`, disable values before the current date for date components, time for time components and both for date time components.
       * @default false
       */
      disablePast: PropTypes.bool,
      /**
       * Format of the date when rendered in the input(s).
       * Defaults to localized format based on the used `views`.
       */
      format: PropTypes.string,
      /**
       * Density of the format when rendered in the input.
       * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
       * @default "dense"
       */
      formatDensity: PropTypes.oneOf(["dense", "spacious"]),
      /**
       * Pass a ref to the `input` element.
       */
      inputRef: refType$1,
      /**
       * The label content.
       */
      label: PropTypes.node,
      /**
       * Locale for components texts.
       * Allows overriding texts coming from `LocalizationProvider` and `theme`.
       */
      localeText: PropTypes.object,
      /**
       * Maximal selectable time.
       * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
       */
      maxTime: PropTypes.any,
      /**
       * Minimal selectable time.
       * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
       */
      minTime: PropTypes.any,
      /**
       * Step over minutes.
       * @default 1
       */
      minutesStep: PropTypes.number,
      /**
       * Name attribute used by the `input` element in the Field.
       */
      name: PropTypes.string,
      /**
       * Callback fired when the value is accepted.
       * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
       * @param {TValue} value The value that was just accepted.
       */
      onAccept: PropTypes.func,
      /**
       * Callback fired when the value changes.
       * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
       * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
       * @param {TValue} value The new value.
       * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
       */
      onChange: PropTypes.func,
      /**
       * Callback fired when the popup requests to be closed.
       * Use in controlled mode (see `open`).
       */
      onClose: PropTypes.func,
      /**
       * Callback fired when the error associated to the current value changes.
       * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
       *
       * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
       * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
       * @param {TError} error The new error describing why the current value is not valid.
       * @param {TValue} value The value associated to the error.
       */
      onError: PropTypes.func,
      /**
       * Callback fired when the popup requests to be opened.
       * Use in controlled mode (see `open`).
       */
      onOpen: PropTypes.func,
      /**
       * Callback fired when the selected sections change.
       * @param {FieldSelectedSections} newValue The new selected sections.
       */
      onSelectedSectionsChange: PropTypes.func,
      /**
       * Callback fired on view change.
       * @template TView
       * @param {TView} view The new view.
       */
      onViewChange: PropTypes.func,
      /**
       * Control the popup or dialog open state.
       * @default false
       */
      open: PropTypes.bool,
      /**
       * The default visible view.
       * Used when the component view is not controlled.
       * Must be a valid option from `views` list.
       */
      openTo: PropTypes.oneOf(["hours", "meridiem", "minutes", "seconds"]),
      /**
       * Force rendering in particular orientation.
       */
      orientation: PropTypes.oneOf(["landscape", "portrait"]),
      readOnly: PropTypes.bool,
      /**
       * If `true`, disable heavy animations.
       * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
       */
      reduceAnimations: PropTypes.bool,
      /**
       * The date used to generate the new value when both `value` and `defaultValue` are empty.
       * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
       */
      referenceDate: PropTypes.any,
      /**
       * The currently selected sections.
       * This prop accept four formats:
       * 1. If a number is provided, the section at this index will be selected.
       * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
       * 3. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
       * 4. If `null` is provided, no section will be selected
       * If not provided, the selected sections will be handled internally.
       */
      selectedSections: PropTypes.oneOfType([PropTypes.oneOf(["all", "day", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), PropTypes.number, PropTypes.shape({
        endIndex: PropTypes.number.isRequired,
        startIndex: PropTypes.number.isRequired
      })]),
      /**
       * Disable specific clock time.
       * @param {number} clockValue The value to check.
       * @param {TimeView} view The clock type of the timeValue.
       * @returns {boolean} If `true` the time will be disabled.
       * @deprecated Consider using `shouldDisableTime`.
       */
      shouldDisableClock: PropTypes.func,
      /**
       * Disable specific time.
       * @template TDate
       * @param {TDate} value The value to check.
       * @param {TimeView} view The clock type of the timeValue.
       * @returns {boolean} If `true` the time will be disabled.
       */
      shouldDisableTime: PropTypes.func,
      /**
       * If `true`, disabled digital clock items will not be rendered.
       * @default false
       */
      skipDisabled: PropTypes.bool,
      /**
       * The props used for each component slot.
       * @default {}
       */
      slotProps: PropTypes.object,
      /**
       * Overridable component slots.
       * @default {}
       */
      slots: PropTypes.object,
      /**
       * The system prop that allows defining system overrides as well as additional CSS styles.
       */
      sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
      /**
       * Amount of time options below or at which the single column time renderer is used.
       * @default 24
       */
      thresholdToRenderTimeInASingleColumn: PropTypes.number,
      /**
       * The time steps between two time unit options.
       * For example, if `timeStep.minutes = 8`, then the available minute options will be `[0, 8, 16, 24, 32, 40, 48, 56]`.
       * When single column time renderer is used, only `timeStep.minutes` will be used.
       * @default{ hours: 1, minutes: 5, seconds: 5 }
       */
      timeSteps: PropTypes.shape({
        hours: PropTypes.number,
        minutes: PropTypes.number,
        seconds: PropTypes.number
      }),
      /**
       * Choose which timezone to use for the value.
       * Example: "default", "system", "UTC", "America/New_York".
       * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
       * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documention} for more details.
       * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
       */
      timezone: PropTypes.string,
      /**
       * The selected value.
       * Used when the component is controlled.
       */
      value: PropTypes.any,
      /**
       * The visible view.
       * Used when the component view is controlled.
       * Must be a valid option from `views` list.
       */
      view: PropTypes.oneOf(["hours", "meridiem", "minutes", "seconds"]),
      /**
       * Define custom view renderers for each section.
       * If `null`, the section will only have field editing.
       * If `undefined`, internally defined view will be the used.
       */
      viewRenderers: PropTypes.shape({
        hours: PropTypes.func,
        meridiem: PropTypes.func,
        minutes: PropTypes.func,
        seconds: PropTypes.func
      }),
      /**
       * Available views.
       */
      views: PropTypes.arrayOf(PropTypes.oneOf(["hours", "minutes", "seconds"]).isRequired)
    };
    const _excluded$1 = ["props", "getOpenDialogAriaText"];
    const useMobilePicker = (_ref) => {
      var _innerSlotProps$toolb, _innerSlotProps$toolb2, _slots$layout;
      let {
        props,
        getOpenDialogAriaText
      } = _ref, pickerParams = _objectWithoutPropertiesLoose$1(_ref, _excluded$1);
      const {
        slots,
        slotProps: innerSlotProps,
        className,
        sx,
        format,
        formatDensity,
        timezone,
        name,
        label,
        inputRef,
        readOnly,
        disabled,
        localeText
      } = props;
      const utils2 = useUtils();
      const internalInputRef = reactExports.useRef(null);
      const labelId = useId();
      const isToolbarHidden = (_innerSlotProps$toolb = innerSlotProps == null || (_innerSlotProps$toolb2 = innerSlotProps.toolbar) == null ? void 0 : _innerSlotProps$toolb2.hidden) != null ? _innerSlotProps$toolb : false;
      const {
        open,
        actions,
        layoutProps,
        renderCurrentView,
        fieldProps: pickerFieldProps
      } = usePicker(_extends$1({}, pickerParams, {
        props,
        inputRef: internalInputRef,
        autoFocusView: true,
        additionalViewProps: {},
        wrapperVariant: "mobile"
      }));
      const Field = slots.field;
      const fieldProps = useSlotProps({
        elementType: Field,
        externalSlotProps: innerSlotProps == null ? void 0 : innerSlotProps.field,
        additionalProps: _extends$1({}, pickerFieldProps, isToolbarHidden && {
          id: labelId
        }, !(disabled || readOnly) && {
          onClick: actions.onOpen,
          onKeyDown: onSpaceOrEnter(actions.onOpen)
        }, {
          readOnly: readOnly != null ? readOnly : true,
          disabled,
          className,
          sx,
          format,
          formatDensity,
          timezone,
          label,
          name
        }),
        ownerState: props
      });
      fieldProps.inputProps = _extends$1({}, fieldProps.inputProps, {
        "aria-label": getOpenDialogAriaText(pickerFieldProps.value, utils2)
      });
      const slotsForField = _extends$1({
        textField: slots.textField
      }, fieldProps.slots);
      const Layout = (_slots$layout = slots.layout) != null ? _slots$layout : PickersLayout;
      const handleInputRef = useForkRef(internalInputRef, fieldProps.inputRef, inputRef);
      let labelledById = labelId;
      if (isToolbarHidden) {
        if (label) {
          labelledById = `${labelId}-label`;
        } else {
          labelledById = void 0;
        }
      }
      const slotProps = _extends$1({}, innerSlotProps, {
        toolbar: _extends$1({}, innerSlotProps == null ? void 0 : innerSlotProps.toolbar, {
          titleId: labelId
        }),
        mobilePaper: _extends$1({
          "aria-labelledby": labelledById
        }, innerSlotProps == null ? void 0 : innerSlotProps.mobilePaper)
      });
      const renderPicker = () => /* @__PURE__ */ jsxRuntimeExports.jsxs(LocalizationProvider, {
        localeText,
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Field, _extends$1({}, fieldProps, {
          slots: slotsForField,
          slotProps,
          inputRef: handleInputRef
        })), /* @__PURE__ */ jsxRuntimeExports.jsx(PickersModalDialog, _extends$1({}, actions, {
          open,
          slots,
          slotProps,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Layout, _extends$1({}, layoutProps, slotProps == null ? void 0 : slotProps.layout, {
            slots,
            slotProps,
            children: renderCurrentView()
          }))
        }))]
      });
      return {
        renderPicker
      };
    };
    const MobileTimePicker = /* @__PURE__ */ reactExports.forwardRef(function MobileTimePicker2(inProps, ref) {
      var _defaultizedProps$amp, _defaultizedProps$slo2, _props$localeText$ope, _props$localeText;
      const localeText = useLocaleText();
      const utils2 = useUtils();
      const defaultizedProps = useTimePickerDefaultizedProps(inProps, "MuiMobileTimePicker");
      const viewRenderers = _extends$1({
        hours: renderTimeViewClock,
        minutes: renderTimeViewClock,
        seconds: renderTimeViewClock
      }, defaultizedProps.viewRenderers);
      const ampmInClock = (_defaultizedProps$amp = defaultizedProps.ampmInClock) != null ? _defaultizedProps$amp : false;
      const props = _extends$1({}, defaultizedProps, {
        ampmInClock,
        viewRenderers,
        format: resolveTimeFormat(utils2, defaultizedProps),
        slots: _extends$1({
          field: TimeField
        }, defaultizedProps.slots),
        slotProps: _extends$1({}, defaultizedProps.slotProps, {
          field: (ownerState) => {
            var _defaultizedProps$slo;
            return _extends$1({}, resolveComponentProps((_defaultizedProps$slo = defaultizedProps.slotProps) == null ? void 0 : _defaultizedProps$slo.field, ownerState), extractValidationProps(defaultizedProps), {
              ref
            });
          },
          toolbar: _extends$1({
            hidden: false,
            ampmInClock
          }, (_defaultizedProps$slo2 = defaultizedProps.slotProps) == null ? void 0 : _defaultizedProps$slo2.toolbar)
        })
      });
      const {
        renderPicker
      } = useMobilePicker({
        props,
        valueManager: singleItemValueManager,
        valueType: "time",
        getOpenDialogAriaText: (_props$localeText$ope = (_props$localeText = props.localeText) == null ? void 0 : _props$localeText.openTimePickerDialogue) != null ? _props$localeText$ope : localeText.openTimePickerDialogue,
        validator: validateTime
      });
      return renderPicker();
    });
    MobileTimePicker.propTypes = {
      // ----------------------------- Warning --------------------------------
      // | These PropTypes are generated from the TypeScript type definitions |
      // | To update them edit the TypeScript types and run "yarn proptypes"  |
      // ----------------------------------------------------------------------
      /**
       * 12h/24h view for hour selection clock.
       * @default `utils.is12HourCycleInCurrentLocale()`
       */
      ampm: PropTypes.bool,
      /**
       * Display ampm controls under the clock (instead of in the toolbar).
       * @default true on desktop, false on mobile
       */
      ampmInClock: PropTypes.bool,
      /**
       * If `true`, the main element is focused during the first mount.
       * This main element is:
       * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
       * - the `input` element if there is a field rendered.
       */
      autoFocus: PropTypes.bool,
      /**
       * Class name applied to the root element.
       */
      className: PropTypes.string,
      /**
       * If `true`, the popover or modal will close after submitting the full date.
       * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
       */
      closeOnSelect: PropTypes.bool,
      /**
       * Overridable components.
       * @default {}
       * @deprecated Please use `slots`.
       */
      components: PropTypes.object,
      /**
       * The props used for each component slot.
       * @default {}
       * @deprecated Please use `slotProps`.
       */
      componentsProps: PropTypes.object,
      /**
       * The default value.
       * Used when the component is not controlled.
       */
      defaultValue: PropTypes.any,
      /**
       * If `true`, the picker and text field are disabled.
       * @default false
       */
      disabled: PropTypes.bool,
      /**
       * If `true`, disable values after the current date for date components, time for time components and both for date time components.
       * @default false
       */
      disableFuture: PropTypes.bool,
      /**
       * Do not ignore date part when validating min/max time.
       * @default false
       */
      disableIgnoringDatePartForTimeValidation: PropTypes.bool,
      /**
       * If `true`, the open picker button will not be rendered (renders only the field).
       * @default false
       */
      disableOpenPicker: PropTypes.bool,
      /**
       * If `true`, disable values before the current date for date components, time for time components and both for date time components.
       * @default false
       */
      disablePast: PropTypes.bool,
      /**
       * Format of the date when rendered in the input(s).
       * Defaults to localized format based on the used `views`.
       */
      format: PropTypes.string,
      /**
       * Density of the format when rendered in the input.
       * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
       * @default "dense"
       */
      formatDensity: PropTypes.oneOf(["dense", "spacious"]),
      /**
       * Pass a ref to the `input` element.
       */
      inputRef: refType$1,
      /**
       * The label content.
       */
      label: PropTypes.node,
      /**
       * Locale for components texts.
       * Allows overriding texts coming from `LocalizationProvider` and `theme`.
       */
      localeText: PropTypes.object,
      /**
       * Maximal selectable time.
       * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
       */
      maxTime: PropTypes.any,
      /**
       * Minimal selectable time.
       * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
       */
      minTime: PropTypes.any,
      /**
       * Step over minutes.
       * @default 1
       */
      minutesStep: PropTypes.number,
      /**
       * Name attribute used by the `input` element in the Field.
       */
      name: PropTypes.string,
      /**
       * Callback fired when the value is accepted.
       * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
       * @param {TValue} value The value that was just accepted.
       */
      onAccept: PropTypes.func,
      /**
       * Callback fired when the value changes.
       * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
       * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
       * @param {TValue} value The new value.
       * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
       */
      onChange: PropTypes.func,
      /**
       * Callback fired when the popup requests to be closed.
       * Use in controlled mode (see `open`).
       */
      onClose: PropTypes.func,
      /**
       * Callback fired when the error associated to the current value changes.
       * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
       *
       * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
       * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
       * @param {TError} error The new error describing why the current value is not valid.
       * @param {TValue} value The value associated to the error.
       */
      onError: PropTypes.func,
      /**
       * Callback fired when the popup requests to be opened.
       * Use in controlled mode (see `open`).
       */
      onOpen: PropTypes.func,
      /**
       * Callback fired when the selected sections change.
       * @param {FieldSelectedSections} newValue The new selected sections.
       */
      onSelectedSectionsChange: PropTypes.func,
      /**
       * Callback fired on view change.
       * @template TView
       * @param {TView} view The new view.
       */
      onViewChange: PropTypes.func,
      /**
       * Control the popup or dialog open state.
       * @default false
       */
      open: PropTypes.bool,
      /**
       * The default visible view.
       * Used when the component view is not controlled.
       * Must be a valid option from `views` list.
       */
      openTo: PropTypes.oneOf(["hours", "minutes", "seconds"]),
      /**
       * Force rendering in particular orientation.
       */
      orientation: PropTypes.oneOf(["landscape", "portrait"]),
      readOnly: PropTypes.bool,
      /**
       * If `true`, disable heavy animations.
       * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
       */
      reduceAnimations: PropTypes.bool,
      /**
       * The date used to generate the new value when both `value` and `defaultValue` are empty.
       * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
       */
      referenceDate: PropTypes.any,
      /**
       * The currently selected sections.
       * This prop accept four formats:
       * 1. If a number is provided, the section at this index will be selected.
       * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
       * 3. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
       * 4. If `null` is provided, no section will be selected
       * If not provided, the selected sections will be handled internally.
       */
      selectedSections: PropTypes.oneOfType([PropTypes.oneOf(["all", "day", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), PropTypes.number, PropTypes.shape({
        endIndex: PropTypes.number.isRequired,
        startIndex: PropTypes.number.isRequired
      })]),
      /**
       * Disable specific clock time.
       * @param {number} clockValue The value to check.
       * @param {TimeView} view The clock type of the timeValue.
       * @returns {boolean} If `true` the time will be disabled.
       * @deprecated Consider using `shouldDisableTime`.
       */
      shouldDisableClock: PropTypes.func,
      /**
       * Disable specific time.
       * @template TDate
       * @param {TDate} value The value to check.
       * @param {TimeView} view The clock type of the timeValue.
       * @returns {boolean} If `true` the time will be disabled.
       */
      shouldDisableTime: PropTypes.func,
      /**
       * The props used for each component slot.
       * @default {}
       */
      slotProps: PropTypes.object,
      /**
       * Overridable component slots.
       * @default {}
       */
      slots: PropTypes.object,
      /**
       * The system prop that allows defining system overrides as well as additional CSS styles.
       */
      sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
      /**
       * Choose which timezone to use for the value.
       * Example: "default", "system", "UTC", "America/New_York".
       * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
       * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documention} for more details.
       * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
       */
      timezone: PropTypes.string,
      /**
       * The selected value.
       * Used when the component is controlled.
       */
      value: PropTypes.any,
      /**
       * The visible view.
       * Used when the component view is controlled.
       * Must be a valid option from `views` list.
       */
      view: PropTypes.oneOf(["hours", "minutes", "seconds"]),
      /**
       * Define custom view renderers for each section.
       * If `null`, the section will only have field editing.
       * If `undefined`, internally defined view will be the used.
       */
      viewRenderers: PropTypes.shape({
        hours: PropTypes.func,
        minutes: PropTypes.func,
        seconds: PropTypes.func
      }),
      /**
       * Available views.
       */
      views: PropTypes.arrayOf(PropTypes.oneOf(["hours", "minutes", "seconds"]).isRequired)
    };
    const _excluded = ["desktopModeMediaQuery"];
    const TimePicker = /* @__PURE__ */ reactExports.forwardRef(function TimePicker2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiTimePicker"
      });
      const {
        desktopModeMediaQuery = DEFAULT_DESKTOP_MODE_MEDIA_QUERY
      } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded);
      const isDesktop = useMediaQuery(desktopModeMediaQuery, {
        defaultMatches: true
      });
      if (isDesktop) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(DesktopTimePicker, _extends$1({
          ref
        }, other));
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(MobileTimePicker, _extends$1({
        ref
      }, other));
    });
    var dayjs_min = { exports: {} };
    (function(module2, exports2) {
      !function(t2, e2) {
        module2.exports = e2();
      }(commonjsGlobal, function() {
        var t2 = 1e3, e2 = 6e4, n2 = 36e5, r2 = "millisecond", i = "second", s = "minute", u2 = "hour", a = "day", o = "week", c2 = "month", f2 = "quarter", h2 = "year", d2 = "date", l2 = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
          var e3 = ["th", "st", "nd", "rd"], n3 = t3 % 100;
          return "[" + t3 + (e3[(n3 - 20) % 10] || e3[n3] || e3[0]) + "]";
        } }, m2 = function(t3, e3, n3) {
          var r3 = String(t3);
          return !r3 || r3.length >= e3 ? t3 : "" + Array(e3 + 1 - r3.length).join(n3) + t3;
        }, v2 = { s: m2, z: function(t3) {
          var e3 = -t3.utcOffset(), n3 = Math.abs(e3), r3 = Math.floor(n3 / 60), i2 = n3 % 60;
          return (e3 <= 0 ? "+" : "-") + m2(r3, 2, "0") + ":" + m2(i2, 2, "0");
        }, m: function t3(e3, n3) {
          if (e3.date() < n3.date())
            return -t3(n3, e3);
          var r3 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i2 = e3.clone().add(r3, c2), s2 = n3 - i2 < 0, u3 = e3.clone().add(r3 + (s2 ? -1 : 1), c2);
          return +(-(r3 + (n3 - i2) / (s2 ? i2 - u3 : u3 - i2)) || 0);
        }, a: function(t3) {
          return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
        }, p: function(t3) {
          return { M: c2, y: h2, w: o, d: a, D: d2, h: u2, m: s, s: i, ms: r2, Q: f2 }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
        }, u: function(t3) {
          return void 0 === t3;
        } }, g2 = "en", D2 = {};
        D2[g2] = M2;
        var p2 = "$isDayjsObject", S2 = function(t3) {
          return t3 instanceof _2 || !(!t3 || !t3[p2]);
        }, w2 = function t3(e3, n3, r3) {
          var i2;
          if (!e3)
            return g2;
          if ("string" == typeof e3) {
            var s2 = e3.toLowerCase();
            D2[s2] && (i2 = s2), n3 && (D2[s2] = n3, i2 = s2);
            var u3 = e3.split("-");
            if (!i2 && u3.length > 1)
              return t3(u3[0]);
          } else {
            var a2 = e3.name;
            D2[a2] = e3, i2 = a2;
          }
          return !r3 && i2 && (g2 = i2), i2 || !r3 && g2;
        }, O2 = function(t3, e3) {
          if (S2(t3))
            return t3.clone();
          var n3 = "object" == typeof e3 ? e3 : {};
          return n3.date = t3, n3.args = arguments, new _2(n3);
        }, b2 = v2;
        b2.l = w2, b2.i = S2, b2.w = function(t3, e3) {
          return O2(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
        };
        var _2 = function() {
          function M3(t3) {
            this.$L = w2(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p2] = true;
          }
          var m3 = M3.prototype;
          return m3.parse = function(t3) {
            this.$d = function(t4) {
              var e3 = t4.date, n3 = t4.utc;
              if (null === e3)
                return /* @__PURE__ */ new Date(NaN);
              if (b2.u(e3))
                return /* @__PURE__ */ new Date();
              if (e3 instanceof Date)
                return new Date(e3);
              if ("string" == typeof e3 && !/Z$/i.test(e3)) {
                var r3 = e3.match($);
                if (r3) {
                  var i2 = r3[2] - 1 || 0, s2 = (r3[7] || "0").substring(0, 3);
                  return n3 ? new Date(Date.UTC(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2)) : new Date(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2);
                }
              }
              return new Date(e3);
            }(t3), this.init();
          }, m3.init = function() {
            var t3 = this.$d;
            this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
          }, m3.$utils = function() {
            return b2;
          }, m3.isValid = function() {
            return !(this.$d.toString() === l2);
          }, m3.isSame = function(t3, e3) {
            var n3 = O2(t3);
            return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
          }, m3.isAfter = function(t3, e3) {
            return O2(t3) < this.startOf(e3);
          }, m3.isBefore = function(t3, e3) {
            return this.endOf(e3) < O2(t3);
          }, m3.$g = function(t3, e3, n3) {
            return b2.u(t3) ? this[e3] : this.set(n3, t3);
          }, m3.unix = function() {
            return Math.floor(this.valueOf() / 1e3);
          }, m3.valueOf = function() {
            return this.$d.getTime();
          }, m3.startOf = function(t3, e3) {
            var n3 = this, r3 = !!b2.u(e3) || e3, f3 = b2.p(t3), l3 = function(t4, e4) {
              var i2 = b2.w(n3.$u ? Date.UTC(n3.$y, e4, t4) : new Date(n3.$y, e4, t4), n3);
              return r3 ? i2 : i2.endOf(a);
            }, $2 = function(t4, e4) {
              return b2.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
            }, y3 = this.$W, M4 = this.$M, m4 = this.$D, v3 = "set" + (this.$u ? "UTC" : "");
            switch (f3) {
              case h2:
                return r3 ? l3(1, 0) : l3(31, 11);
              case c2:
                return r3 ? l3(1, M4) : l3(0, M4 + 1);
              case o:
                var g3 = this.$locale().weekStart || 0, D3 = (y3 < g3 ? y3 + 7 : y3) - g3;
                return l3(r3 ? m4 - D3 : m4 + (6 - D3), M4);
              case a:
              case d2:
                return $2(v3 + "Hours", 0);
              case u2:
                return $2(v3 + "Minutes", 1);
              case s:
                return $2(v3 + "Seconds", 2);
              case i:
                return $2(v3 + "Milliseconds", 3);
              default:
                return this.clone();
            }
          }, m3.endOf = function(t3) {
            return this.startOf(t3, false);
          }, m3.$set = function(t3, e3) {
            var n3, o2 = b2.p(t3), f3 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a] = f3 + "Date", n3[d2] = f3 + "Date", n3[c2] = f3 + "Month", n3[h2] = f3 + "FullYear", n3[u2] = f3 + "Hours", n3[s] = f3 + "Minutes", n3[i] = f3 + "Seconds", n3[r2] = f3 + "Milliseconds", n3)[o2], $2 = o2 === a ? this.$D + (e3 - this.$W) : e3;
            if (o2 === c2 || o2 === h2) {
              var y3 = this.clone().set(d2, 1);
              y3.$d[l3]($2), y3.init(), this.$d = y3.set(d2, Math.min(this.$D, y3.daysInMonth())).$d;
            } else
              l3 && this.$d[l3]($2);
            return this.init(), this;
          }, m3.set = function(t3, e3) {
            return this.clone().$set(t3, e3);
          }, m3.get = function(t3) {
            return this[b2.p(t3)]();
          }, m3.add = function(r3, f3) {
            var d3, l3 = this;
            r3 = Number(r3);
            var $2 = b2.p(f3), y3 = function(t3) {
              var e3 = O2(l3);
              return b2.w(e3.date(e3.date() + Math.round(t3 * r3)), l3);
            };
            if ($2 === c2)
              return this.set(c2, this.$M + r3);
            if ($2 === h2)
              return this.set(h2, this.$y + r3);
            if ($2 === a)
              return y3(1);
            if ($2 === o)
              return y3(7);
            var M4 = (d3 = {}, d3[s] = e2, d3[u2] = n2, d3[i] = t2, d3)[$2] || 1, m4 = this.$d.getTime() + r3 * M4;
            return b2.w(m4, this);
          }, m3.subtract = function(t3, e3) {
            return this.add(-1 * t3, e3);
          }, m3.format = function(t3) {
            var e3 = this, n3 = this.$locale();
            if (!this.isValid())
              return n3.invalidDate || l2;
            var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b2.z(this), s2 = this.$H, u3 = this.$m, a2 = this.$M, o2 = n3.weekdays, c3 = n3.months, f3 = n3.meridiem, h3 = function(t4, n4, i3, s3) {
              return t4 && (t4[n4] || t4(e3, r3)) || i3[n4].slice(0, s3);
            }, d3 = function(t4) {
              return b2.s(s2 % 12 || 12, t4, "0");
            }, $2 = f3 || function(t4, e4, n4) {
              var r4 = t4 < 12 ? "AM" : "PM";
              return n4 ? r4.toLowerCase() : r4;
            };
            return r3.replace(y2, function(t4, r4) {
              return r4 || function(t5) {
                switch (t5) {
                  case "YY":
                    return String(e3.$y).slice(-2);
                  case "YYYY":
                    return b2.s(e3.$y, 4, "0");
                  case "M":
                    return a2 + 1;
                  case "MM":
                    return b2.s(a2 + 1, 2, "0");
                  case "MMM":
                    return h3(n3.monthsShort, a2, c3, 3);
                  case "MMMM":
                    return h3(c3, a2);
                  case "D":
                    return e3.$D;
                  case "DD":
                    return b2.s(e3.$D, 2, "0");
                  case "d":
                    return String(e3.$W);
                  case "dd":
                    return h3(n3.weekdaysMin, e3.$W, o2, 2);
                  case "ddd":
                    return h3(n3.weekdaysShort, e3.$W, o2, 3);
                  case "dddd":
                    return o2[e3.$W];
                  case "H":
                    return String(s2);
                  case "HH":
                    return b2.s(s2, 2, "0");
                  case "h":
                    return d3(1);
                  case "hh":
                    return d3(2);
                  case "a":
                    return $2(s2, u3, true);
                  case "A":
                    return $2(s2, u3, false);
                  case "m":
                    return String(u3);
                  case "mm":
                    return b2.s(u3, 2, "0");
                  case "s":
                    return String(e3.$s);
                  case "ss":
                    return b2.s(e3.$s, 2, "0");
                  case "SSS":
                    return b2.s(e3.$ms, 3, "0");
                  case "Z":
                    return i2;
                }
                return null;
              }(t4) || i2.replace(":", "");
            });
          }, m3.utcOffset = function() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }, m3.diff = function(r3, d3, l3) {
            var $2, y3 = this, M4 = b2.p(d3), m4 = O2(r3), v3 = (m4.utcOffset() - this.utcOffset()) * e2, g3 = this - m4, D3 = function() {
              return b2.m(y3, m4);
            };
            switch (M4) {
              case h2:
                $2 = D3() / 12;
                break;
              case c2:
                $2 = D3();
                break;
              case f2:
                $2 = D3() / 3;
                break;
              case o:
                $2 = (g3 - v3) / 6048e5;
                break;
              case a:
                $2 = (g3 - v3) / 864e5;
                break;
              case u2:
                $2 = g3 / n2;
                break;
              case s:
                $2 = g3 / e2;
                break;
              case i:
                $2 = g3 / t2;
                break;
              default:
                $2 = g3;
            }
            return l3 ? $2 : b2.a($2);
          }, m3.daysInMonth = function() {
            return this.endOf(c2).$D;
          }, m3.$locale = function() {
            return D2[this.$L];
          }, m3.locale = function(t3, e3) {
            if (!t3)
              return this.$L;
            var n3 = this.clone(), r3 = w2(t3, e3, true);
            return r3 && (n3.$L = r3), n3;
          }, m3.clone = function() {
            return b2.w(this.$d, this);
          }, m3.toDate = function() {
            return new Date(this.valueOf());
          }, m3.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
          }, m3.toISOString = function() {
            return this.$d.toISOString();
          }, m3.toString = function() {
            return this.$d.toUTCString();
          }, M3;
        }(), k2 = _2.prototype;
        return O2.prototype = k2, [["$ms", r2], ["$s", i], ["$m", s], ["$H", u2], ["$W", a], ["$M", c2], ["$y", h2], ["$D", d2]].forEach(function(t3) {
          k2[t3[1]] = function(e3) {
            return this.$g(e3, t3[0], t3[1]);
          };
        }), O2.extend = function(t3, e3) {
          return t3.$i || (t3(e3, _2, O2), t3.$i = true), O2;
        }, O2.locale = w2, O2.isDayjs = S2, O2.unix = function(t3) {
          return O2(1e3 * t3);
        }, O2.en = D2[g2], O2.Ls = D2, O2.p = {}, O2;
      });
    })(dayjs_min);
    var dayjs_minExports = dayjs_min.exports;
    const defaultDayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
    var weekOfYear$1 = { exports: {} };
    (function(module2, exports2) {
      !function(e2, t2) {
        module2.exports = t2();
      }(commonjsGlobal, function() {
        var e2 = "week", t2 = "year";
        return function(i, n2, r2) {
          var f2 = n2.prototype;
          f2.week = function(i2) {
            if (void 0 === i2 && (i2 = null), null !== i2)
              return this.add(7 * (i2 - this.week()), "day");
            var n3 = this.$locale().yearStart || 1;
            if (11 === this.month() && this.date() > 25) {
              var f3 = r2(this).startOf(t2).add(1, t2).date(n3), s = r2(this).endOf(e2);
              if (f3.isBefore(s))
                return 1;
            }
            var a = r2(this).startOf(t2).date(n3).startOf(e2).subtract(1, "millisecond"), o = this.diff(a, e2, true);
            return o < 0 ? r2(this).startOf("week").week() : Math.ceil(o);
          }, f2.weeks = function(e3) {
            return void 0 === e3 && (e3 = null), this.week(e3);
          };
        };
      });
    })(weekOfYear$1);
    var weekOfYearExports = weekOfYear$1.exports;
    const weekOfYear = /* @__PURE__ */ getDefaultExportFromCjs(weekOfYearExports);
    var customParseFormat = { exports: {} };
    (function(module2, exports2) {
      !function(e2, t2) {
        module2.exports = t2();
      }(commonjsGlobal, function() {
        var e2 = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t2 = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n2 = /\d\d/, r2 = /\d\d?/, i = /\d*[^-_:/,()\s\d]+/, o = {}, s = function(e3) {
          return (e3 = +e3) + (e3 > 68 ? 1900 : 2e3);
        };
        var a = function(e3) {
          return function(t3) {
            this[e3] = +t3;
          };
        }, f2 = [/[+-]\d\d:?(\d\d)?|Z/, function(e3) {
          (this.zone || (this.zone = {})).offset = function(e4) {
            if (!e4)
              return 0;
            if ("Z" === e4)
              return 0;
            var t3 = e4.match(/([+-]|\d\d)/g), n3 = 60 * t3[1] + (+t3[2] || 0);
            return 0 === n3 ? 0 : "+" === t3[0] ? -n3 : n3;
          }(e3);
        }], h2 = function(e3) {
          var t3 = o[e3];
          return t3 && (t3.indexOf ? t3 : t3.s.concat(t3.f));
        }, u2 = function(e3, t3) {
          var n3, r3 = o.meridiem;
          if (r3) {
            for (var i2 = 1; i2 <= 24; i2 += 1)
              if (e3.indexOf(r3(i2, 0, t3)) > -1) {
                n3 = i2 > 12;
                break;
              }
          } else
            n3 = e3 === (t3 ? "pm" : "PM");
          return n3;
        }, d2 = { A: [i, function(e3) {
          this.afternoon = u2(e3, false);
        }], a: [i, function(e3) {
          this.afternoon = u2(e3, true);
        }], S: [/\d/, function(e3) {
          this.milliseconds = 100 * +e3;
        }], SS: [n2, function(e3) {
          this.milliseconds = 10 * +e3;
        }], SSS: [/\d{3}/, function(e3) {
          this.milliseconds = +e3;
        }], s: [r2, a("seconds")], ss: [r2, a("seconds")], m: [r2, a("minutes")], mm: [r2, a("minutes")], H: [r2, a("hours")], h: [r2, a("hours")], HH: [r2, a("hours")], hh: [r2, a("hours")], D: [r2, a("day")], DD: [n2, a("day")], Do: [i, function(e3) {
          var t3 = o.ordinal, n3 = e3.match(/\d+/);
          if (this.day = n3[0], t3)
            for (var r3 = 1; r3 <= 31; r3 += 1)
              t3(r3).replace(/\[|\]/g, "") === e3 && (this.day = r3);
        }], M: [r2, a("month")], MM: [n2, a("month")], MMM: [i, function(e3) {
          var t3 = h2("months"), n3 = (h2("monthsShort") || t3.map(function(e4) {
            return e4.slice(0, 3);
          })).indexOf(e3) + 1;
          if (n3 < 1)
            throw new Error();
          this.month = n3 % 12 || n3;
        }], MMMM: [i, function(e3) {
          var t3 = h2("months").indexOf(e3) + 1;
          if (t3 < 1)
            throw new Error();
          this.month = t3 % 12 || t3;
        }], Y: [/[+-]?\d+/, a("year")], YY: [n2, function(e3) {
          this.year = s(e3);
        }], YYYY: [/\d{4}/, a("year")], Z: f2, ZZ: f2 };
        function c2(n3) {
          var r3, i2;
          r3 = n3, i2 = o && o.formats;
          for (var s2 = (n3 = r3.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t3, n4, r4) {
            var o2 = r4 && r4.toUpperCase();
            return n4 || i2[r4] || e2[r4] || i2[o2].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e3, t4, n5) {
              return t4 || n5.slice(1);
            });
          })).match(t2), a2 = s2.length, f3 = 0; f3 < a2; f3 += 1) {
            var h3 = s2[f3], u3 = d2[h3], c3 = u3 && u3[0], l2 = u3 && u3[1];
            s2[f3] = l2 ? { regex: c3, parser: l2 } : h3.replace(/^\[|\]$/g, "");
          }
          return function(e3) {
            for (var t3 = {}, n4 = 0, r4 = 0; n4 < a2; n4 += 1) {
              var i3 = s2[n4];
              if ("string" == typeof i3)
                r4 += i3.length;
              else {
                var o2 = i3.regex, f4 = i3.parser, h4 = e3.slice(r4), u4 = o2.exec(h4)[0];
                f4.call(t3, u4), e3 = e3.replace(u4, "");
              }
            }
            return function(e4) {
              var t4 = e4.afternoon;
              if (void 0 !== t4) {
                var n5 = e4.hours;
                t4 ? n5 < 12 && (e4.hours += 12) : 12 === n5 && (e4.hours = 0), delete e4.afternoon;
              }
            }(t3), t3;
          };
        }
        return function(e3, t3, n3) {
          n3.p.customParseFormat = true, e3 && e3.parseTwoDigitYear && (s = e3.parseTwoDigitYear);
          var r3 = t3.prototype, i2 = r3.parse;
          r3.parse = function(e4) {
            var t4 = e4.date, r4 = e4.utc, s2 = e4.args;
            this.$u = r4;
            var a2 = s2[1];
            if ("string" == typeof a2) {
              var f3 = true === s2[2], h3 = true === s2[3], u3 = f3 || h3, d3 = s2[2];
              h3 && (d3 = s2[2]), o = this.$locale(), !f3 && d3 && (o = n3.Ls[d3]), this.$d = function(e5, t5, n4) {
                try {
                  if (["x", "X"].indexOf(t5) > -1)
                    return new Date(("X" === t5 ? 1e3 : 1) * e5);
                  var r5 = c2(t5)(e5), i3 = r5.year, o2 = r5.month, s3 = r5.day, a3 = r5.hours, f4 = r5.minutes, h4 = r5.seconds, u4 = r5.milliseconds, d4 = r5.zone, l3 = /* @__PURE__ */ new Date(), m3 = s3 || (i3 || o2 ? 1 : l3.getDate()), M3 = i3 || l3.getFullYear(), Y2 = 0;
                  i3 && !o2 || (Y2 = o2 > 0 ? o2 - 1 : l3.getMonth());
                  var p2 = a3 || 0, v2 = f4 || 0, D2 = h4 || 0, g2 = u4 || 0;
                  return d4 ? new Date(Date.UTC(M3, Y2, m3, p2, v2, D2, g2 + 60 * d4.offset * 1e3)) : n4 ? new Date(Date.UTC(M3, Y2, m3, p2, v2, D2, g2)) : new Date(M3, Y2, m3, p2, v2, D2, g2);
                } catch (e6) {
                  return /* @__PURE__ */ new Date("");
                }
              }(t4, a2, r4), this.init(), d3 && true !== d3 && (this.$L = this.locale(d3).$L), u3 && t4 != this.format(a2) && (this.$d = /* @__PURE__ */ new Date("")), o = {};
            } else if (a2 instanceof Array)
              for (var l2 = a2.length, m2 = 1; m2 <= l2; m2 += 1) {
                s2[1] = a2[m2 - 1];
                var M2 = n3.apply(this, s2);
                if (M2.isValid()) {
                  this.$d = M2.$d, this.$L = M2.$L, this.init();
                  break;
                }
                m2 === l2 && (this.$d = /* @__PURE__ */ new Date(""));
              }
            else
              i2.call(this, e4);
          };
        };
      });
    })(customParseFormat);
    var customParseFormatExports = customParseFormat.exports;
    const customParseFormatPlugin = /* @__PURE__ */ getDefaultExportFromCjs(customParseFormatExports);
    var localizedFormat = { exports: {} };
    (function(module2, exports2) {
      !function(e2, t2) {
        module2.exports = t2();
      }(commonjsGlobal, function() {
        var e2 = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" };
        return function(t2, o, n2) {
          var r2 = o.prototype, i = r2.format;
          n2.en.formats = e2, r2.format = function(t3) {
            void 0 === t3 && (t3 = "YYYY-MM-DDTHH:mm:ssZ");
            var o2 = this.$locale().formats, n3 = function(t4, o3) {
              return t4.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t5, n4, r3) {
                var i2 = r3 && r3.toUpperCase();
                return n4 || o3[r3] || e2[r3] || o3[i2].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e3, t6, o4) {
                  return t6 || o4.slice(1);
                });
              });
            }(t3, void 0 === o2 ? {} : o2);
            return i.call(this, n3);
          };
        };
      });
    })(localizedFormat);
    var localizedFormatExports = localizedFormat.exports;
    const localizedFormatPlugin = /* @__PURE__ */ getDefaultExportFromCjs(localizedFormatExports);
    var isBetween = { exports: {} };
    (function(module2, exports2) {
      !function(e2, i) {
        module2.exports = i();
      }(commonjsGlobal, function() {
        return function(e2, i, t2) {
          i.prototype.isBetween = function(e3, i2, s, f2) {
            var n2 = t2(e3), o = t2(i2), r2 = "(" === (f2 = f2 || "()")[0], u2 = ")" === f2[1];
            return (r2 ? this.isAfter(n2, s) : !this.isBefore(n2, s)) && (u2 ? this.isBefore(o, s) : !this.isAfter(o, s)) || (r2 ? this.isBefore(n2, s) : !this.isAfter(n2, s)) && (u2 ? this.isAfter(o, s) : !this.isBefore(o, s));
          };
        };
      });
    })(isBetween);
    var isBetweenExports = isBetween.exports;
    const isBetweenPlugin = /* @__PURE__ */ getDefaultExportFromCjs(isBetweenExports);
    defaultDayjs.extend(customParseFormatPlugin);
    defaultDayjs.extend(localizedFormatPlugin);
    defaultDayjs.extend(isBetweenPlugin);
    const localeNotFoundWarning = buildWarning(["Your locale has not been found.", "Either the locale key is not a supported one. Locales supported by dayjs are available here: https://github.com/iamkun/dayjs/tree/dev/src/locale", "Or you forget to import the locale from 'dayjs/locale/{localeUsed}'", "fallback on English locale"]);
    const formatTokenMap = {
      // Year
      YY: "year",
      YYYY: {
        sectionType: "year",
        contentType: "digit",
        maxLength: 4
      },
      // Month
      M: {
        sectionType: "month",
        contentType: "digit",
        maxLength: 2
      },
      MM: "month",
      MMM: {
        sectionType: "month",
        contentType: "letter"
      },
      MMMM: {
        sectionType: "month",
        contentType: "letter"
      },
      // Day of the month
      D: {
        sectionType: "day",
        contentType: "digit",
        maxLength: 2
      },
      DD: "day",
      Do: {
        sectionType: "day",
        contentType: "digit-with-letter"
      },
      // Day of the week
      d: {
        sectionType: "weekDay",
        contentType: "digit",
        maxLength: 2
      },
      dd: {
        sectionType: "weekDay",
        contentType: "letter"
      },
      ddd: {
        sectionType: "weekDay",
        contentType: "letter"
      },
      dddd: {
        sectionType: "weekDay",
        contentType: "letter"
      },
      // Meridiem
      A: "meridiem",
      a: "meridiem",
      // Hours
      H: {
        sectionType: "hours",
        contentType: "digit",
        maxLength: 2
      },
      HH: "hours",
      h: {
        sectionType: "hours",
        contentType: "digit",
        maxLength: 2
      },
      hh: "hours",
      // Minutes
      m: {
        sectionType: "minutes",
        contentType: "digit",
        maxLength: 2
      },
      mm: "minutes",
      // Seconds
      s: {
        sectionType: "seconds",
        contentType: "digit",
        maxLength: 2
      },
      ss: "seconds"
    };
    const defaultFormats = {
      year: "YYYY",
      month: "MMMM",
      monthShort: "MMM",
      dayOfMonth: "D",
      weekday: "dddd",
      weekdayShort: "dd",
      hours24h: "HH",
      hours12h: "hh",
      meridiem: "A",
      minutes: "mm",
      seconds: "ss",
      fullDate: "ll",
      fullDateWithWeekday: "dddd, LL",
      keyboardDate: "L",
      shortDate: "MMM D",
      normalDate: "D MMMM",
      normalDateWithWeekday: "ddd, MMM D",
      monthAndYear: "MMMM YYYY",
      monthAndDate: "MMMM D",
      fullTime: "LT",
      fullTime12h: "hh:mm A",
      fullTime24h: "HH:mm",
      fullDateTime: "lll",
      fullDateTime12h: "ll hh:mm A",
      fullDateTime24h: "ll HH:mm",
      keyboardDateTime: "L LT",
      keyboardDateTime12h: "L hh:mm A",
      keyboardDateTime24h: "L HH:mm"
    };
    const MISSING_UTC_PLUGIN = ["Missing UTC plugin", "To be able to use UTC or timezones, you have to enable the `utc` plugin", "Find more information on https://mui.com/x/react-date-pickers/timezone/#day-js-and-utc"].join("\n");
    const MISSING_TIMEZONE_PLUGIN = ["Missing timezone plugin", "To be able to use timezones, you have to enable both the `utc` and the `timezone` plugin", "Find more information on https://mui.com/x/react-date-pickers/timezone/#day-js-and-timezone"].join("\n");
    const withLocale = (dayjs, locale) => !locale ? dayjs : (...args) => dayjs(...args).locale(locale);
    class AdapterDayjs {
      constructor({
        locale: _locale,
        formats,
        instance: instance2
      } = {}) {
        var _this$rawDayJsInstanc;
        this.isMUIAdapter = true;
        this.isTimezoneCompatible = true;
        this.lib = "dayjs";
        this.rawDayJsInstance = void 0;
        this.dayjs = void 0;
        this.locale = void 0;
        this.formats = void 0;
        this.escapedCharacters = {
          start: "[",
          end: "]"
        };
        this.formatTokenMap = formatTokenMap;
        this.setLocaleToValue = (value) => {
          const expectedLocale = this.getCurrentLocaleCode();
          if (expectedLocale === value.locale()) {
            return value;
          }
          return value.locale(expectedLocale);
        };
        this.hasUTCPlugin = () => typeof defaultDayjs.utc !== "undefined";
        this.hasTimezonePlugin = () => typeof defaultDayjs.tz !== "undefined";
        this.isSame = (value, comparing, comparisonTemplate) => {
          const comparingInValueTimezone = this.setTimezone(comparing, this.getTimezone(value));
          return value.format(comparisonTemplate) === comparingInValueTimezone.format(comparisonTemplate);
        };
        this.cleanTimezone = (timezone) => {
          switch (timezone) {
            case "default": {
              return void 0;
            }
            case "system": {
              return defaultDayjs.tz.guess();
            }
            default: {
              return timezone;
            }
          }
        };
        this.createSystemDate = (value) => {
          if (this.rawDayJsInstance) {
            return this.rawDayJsInstance(value);
          }
          if (this.hasUTCPlugin() && this.hasTimezonePlugin()) {
            const timezone = defaultDayjs.tz.guess();
            if (timezone !== "UTC") {
              return defaultDayjs.tz(value, timezone);
            }
            return defaultDayjs(value);
          }
          return defaultDayjs(value);
        };
        this.createUTCDate = (value) => {
          if (!this.hasUTCPlugin()) {
            throw new Error(MISSING_UTC_PLUGIN);
          }
          return defaultDayjs.utc(value);
        };
        this.createTZDate = (value, timezone) => {
          if (!this.hasUTCPlugin()) {
            throw new Error(MISSING_UTC_PLUGIN);
          }
          if (!this.hasTimezonePlugin()) {
            throw new Error(MISSING_TIMEZONE_PLUGIN);
          }
          const keepLocalTime = value !== void 0 && !value.endsWith("Z");
          return defaultDayjs(value).tz(this.cleanTimezone(timezone), keepLocalTime);
        };
        this.getLocaleFormats = () => {
          const locales = defaultDayjs.Ls;
          const locale = this.locale || "en";
          let localeObject = locales[locale];
          if (localeObject === void 0) {
            localeNotFoundWarning();
            localeObject = locales.en;
          }
          return localeObject.formats;
        };
        this.adjustOffset = (value) => {
          if (!this.hasTimezonePlugin()) {
            return value;
          }
          const timezone = this.getTimezone(value);
          if (timezone !== "UTC") {
            var _fixedValue$$offset, _value$$offset;
            const fixedValue = value.tz(this.cleanTimezone(timezone), true);
            if (((_fixedValue$$offset = fixedValue.$offset) != null ? _fixedValue$$offset : 0) === ((_value$$offset = value.$offset) != null ? _value$$offset : 0)) {
              return value;
            }
            return fixedValue;
          }
          return value;
        };
        this.date = (value) => {
          if (value === null) {
            return null;
          }
          return this.dayjs(value);
        };
        this.dateWithTimezone = (value, timezone) => {
          if (value === null) {
            return null;
          }
          let parsedValue;
          if (timezone === "UTC") {
            parsedValue = this.createUTCDate(value);
          } else if (timezone === "system" || timezone === "default" && !this.hasTimezonePlugin()) {
            parsedValue = this.createSystemDate(value);
          } else {
            parsedValue = this.createTZDate(value, timezone);
          }
          if (this.locale === void 0) {
            return parsedValue;
          }
          return parsedValue.locale(this.locale);
        };
        this.getTimezone = (value) => {
          if (this.hasTimezonePlugin()) {
            var _value$$x;
            const zone = (_value$$x = value.$x) == null ? void 0 : _value$$x.$timezone;
            if (zone) {
              return zone;
            }
          }
          if (this.hasUTCPlugin() && value.isUTC()) {
            return "UTC";
          }
          return "system";
        };
        this.setTimezone = (value, timezone) => {
          if (this.getTimezone(value) === timezone) {
            return value;
          }
          if (timezone === "UTC") {
            if (!this.hasUTCPlugin()) {
              throw new Error(MISSING_UTC_PLUGIN);
            }
            return value.utc();
          }
          if (timezone === "system") {
            return value.local();
          }
          if (!this.hasTimezonePlugin()) {
            if (timezone === "default") {
              return value;
            }
            throw new Error(MISSING_TIMEZONE_PLUGIN);
          }
          return defaultDayjs.tz(value, this.cleanTimezone(timezone));
        };
        this.toJsDate = (value) => {
          return value.toDate();
        };
        this.parseISO = (isoString) => {
          return this.dayjs(isoString);
        };
        this.toISO = (value) => {
          return value.toISOString();
        };
        this.parse = (value, format) => {
          if (value === "") {
            return null;
          }
          return this.dayjs(value, format, this.locale, true);
        };
        this.getCurrentLocaleCode = () => {
          return this.locale || "en";
        };
        this.is12HourCycleInCurrentLocale = () => {
          return /A|a/.test(this.getLocaleFormats().LT || "");
        };
        this.expandFormat = (format) => {
          const localeFormats = this.getLocaleFormats();
          const t2 = (formatBis) => formatBis.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, (_2, a, b2) => a || b2.slice(1));
          return format.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, (_2, a, b2) => {
            const B2 = b2 && b2.toUpperCase();
            return a || localeFormats[b2] || t2(localeFormats[B2]);
          });
        };
        this.getFormatHelperText = (format) => {
          return this.expandFormat(format).replace(/a/gi, "(a|p)m").toLocaleLowerCase();
        };
        this.isNull = (value) => {
          return value === null;
        };
        this.isValid = (value) => {
          return this.dayjs(value).isValid();
        };
        this.format = (value, formatKey) => {
          return this.formatByString(value, this.formats[formatKey]);
        };
        this.formatByString = (value, formatString) => {
          return this.dayjs(value).format(formatString);
        };
        this.formatNumber = (numberToFormat) => {
          return numberToFormat;
        };
        this.getDiff = (value, comparing, unit) => {
          return value.diff(comparing, unit);
        };
        this.isEqual = (value, comparing) => {
          if (value === null && comparing === null) {
            return true;
          }
          return this.dayjs(value).toDate().getTime() === this.dayjs(comparing).toDate().getTime();
        };
        this.isSameYear = (value, comparing) => {
          return this.isSame(value, comparing, "YYYY");
        };
        this.isSameMonth = (value, comparing) => {
          return this.isSame(value, comparing, "YYYY-MM");
        };
        this.isSameDay = (value, comparing) => {
          return this.isSame(value, comparing, "YYYY-MM-DD");
        };
        this.isSameHour = (value, comparing) => {
          return value.isSame(comparing, "hour");
        };
        this.isAfter = (value, comparing) => {
          return value > comparing;
        };
        this.isAfterYear = (value, comparing) => {
          if (!this.hasUTCPlugin()) {
            return value.isAfter(comparing, "year");
          }
          return !this.isSameYear(value, comparing) && value.utc() > comparing.utc();
        };
        this.isAfterDay = (value, comparing) => {
          if (!this.hasUTCPlugin()) {
            return value.isAfter(comparing, "day");
          }
          return !this.isSameDay(value, comparing) && value.utc() > comparing.utc();
        };
        this.isBefore = (value, comparing) => {
          return value < comparing;
        };
        this.isBeforeYear = (value, comparing) => {
          if (!this.hasUTCPlugin()) {
            return value.isBefore(comparing, "year");
          }
          return !this.isSameYear(value, comparing) && value.utc() < comparing.utc();
        };
        this.isBeforeDay = (value, comparing) => {
          if (!this.hasUTCPlugin()) {
            return value.isBefore(comparing, "day");
          }
          return !this.isSameDay(value, comparing) && value.utc() < comparing.utc();
        };
        this.isWithinRange = (value, [start2, end2]) => {
          return value >= start2 && value <= end2;
        };
        this.startOfYear = (value) => {
          return this.adjustOffset(value.startOf("year"));
        };
        this.startOfMonth = (value) => {
          return this.adjustOffset(value.startOf("month"));
        };
        this.startOfWeek = (value) => {
          return this.adjustOffset(value.startOf("week"));
        };
        this.startOfDay = (value) => {
          return this.adjustOffset(value.startOf("day"));
        };
        this.endOfYear = (value) => {
          return this.adjustOffset(value.endOf("year"));
        };
        this.endOfMonth = (value) => {
          return this.adjustOffset(value.endOf("month"));
        };
        this.endOfWeek = (value) => {
          return this.adjustOffset(value.endOf("week"));
        };
        this.endOfDay = (value) => {
          return this.adjustOffset(value.endOf("day"));
        };
        this.addYears = (value, amount) => {
          return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "year") : value.add(amount, "year"));
        };
        this.addMonths = (value, amount) => {
          return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "month") : value.add(amount, "month"));
        };
        this.addWeeks = (value, amount) => {
          return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "week") : value.add(amount, "week"));
        };
        this.addDays = (value, amount) => {
          return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "day") : value.add(amount, "day"));
        };
        this.addHours = (value, amount) => {
          return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "hour") : value.add(amount, "hour"));
        };
        this.addMinutes = (value, amount) => {
          return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "minute") : value.add(amount, "minute"));
        };
        this.addSeconds = (value, amount) => {
          return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "second") : value.add(amount, "second"));
        };
        this.getYear = (value) => {
          return value.year();
        };
        this.getMonth = (value) => {
          return value.month();
        };
        this.getDate = (value) => {
          return value.date();
        };
        this.getHours = (value) => {
          return value.hour();
        };
        this.getMinutes = (value) => {
          return value.minute();
        };
        this.getSeconds = (value) => {
          return value.second();
        };
        this.getMilliseconds = (value) => {
          return value.millisecond();
        };
        this.setYear = (value, year) => {
          return this.adjustOffset(value.set("year", year));
        };
        this.setMonth = (value, month) => {
          return this.adjustOffset(value.set("month", month));
        };
        this.setDate = (value, date2) => {
          return this.adjustOffset(value.set("date", date2));
        };
        this.setHours = (value, hours) => {
          return this.adjustOffset(value.set("hour", hours));
        };
        this.setMinutes = (value, minutes) => {
          return this.adjustOffset(value.set("minute", minutes));
        };
        this.setSeconds = (value, seconds) => {
          return this.adjustOffset(value.set("second", seconds));
        };
        this.setMilliseconds = (value, milliseconds) => {
          return this.adjustOffset(value.set("millisecond", milliseconds));
        };
        this.getDaysInMonth = (value) => {
          return value.daysInMonth();
        };
        this.getNextMonth = (value) => {
          return this.addMonths(value, 1);
        };
        this.getPreviousMonth = (value) => {
          return this.addMonths(value, -1);
        };
        this.getMonthArray = (value) => {
          const firstMonth = value.startOf("year");
          const monthArray = [firstMonth];
          while (monthArray.length < 12) {
            const prevMonth = monthArray[monthArray.length - 1];
            monthArray.push(this.addMonths(prevMonth, 1));
          }
          return monthArray;
        };
        this.mergeDateAndTime = (dateParam, timeParam) => {
          return dateParam.hour(timeParam.hour()).minute(timeParam.minute()).second(timeParam.second());
        };
        this.getWeekdays = () => {
          const start2 = this.dayjs().startOf("week");
          return [0, 1, 2, 3, 4, 5, 6].map((diff) => this.formatByString(this.addDays(start2, diff), "dd"));
        };
        this.getWeekArray = (value) => {
          const cleanValue = this.setLocaleToValue(value);
          const start2 = cleanValue.startOf("month").startOf("week");
          const end2 = cleanValue.endOf("month").endOf("week");
          let count = 0;
          let current = start2;
          const nestedWeeks = [];
          while (current < end2) {
            const weekNumber = Math.floor(count / 7);
            nestedWeeks[weekNumber] = nestedWeeks[weekNumber] || [];
            nestedWeeks[weekNumber].push(current);
            current = this.addDays(current, 1);
            count += 1;
          }
          return nestedWeeks;
        };
        this.getWeekNumber = (value) => {
          return value.week();
        };
        this.getYearRange = (start2, end2) => {
          const startDate = start2.startOf("year");
          const endDate = end2.endOf("year");
          const years = [];
          let current = startDate;
          while (current < endDate) {
            years.push(current);
            current = this.addYears(current, 1);
          }
          return years;
        };
        this.getMeridiemText = (ampm) => {
          return ampm === "am" ? "AM" : "PM";
        };
        this.rawDayJsInstance = instance2;
        this.dayjs = withLocale((_this$rawDayJsInstanc = this.rawDayJsInstance) != null ? _this$rawDayJsInstanc : defaultDayjs, _locale);
        this.locale = _locale;
        this.formats = _extends$1({}, defaultFormats, formats);
        defaultDayjs.extend(weekOfYear);
      }
    }
    const boxClasses = generateUtilityClasses$1("MuiBox", ["root"]);
    const boxClasses$1 = boxClasses;
    const defaultTheme = createTheme();
    const Box = createBox$1({
      themeId: THEME_ID,
      defaultTheme,
      defaultClassName: boxClasses$1.root,
      generateClassName: ClassNameGenerator.generate
    });
    const Box$1 = Box;
    const ExpandTable = (props) => {
      const {
        options,
        addons,
        basic,
        date: date2,
        blocked_slots,
        prevBooking,
        addOption,
        removeOption,
        addAddon,
        removeAddon,
        changeAddonQuantity
      } = props;
      const [expand, setExpand] = reactExports.useState(false);
      const active_date = GetDateCategory(date2);
      const [time2, setTime] = reactExports.useState({
        start: null,
        end: null
      });
      reactExports.useState({
        start: true,
        end: false
      });
      const bookedSlots = blocked_slots || [];
      const toggle_option = (msg) => {
        return () => {
          if (msg === "open") {
            if (time2.start === null || time2.end === null) {
              return alert("Please select start and end time");
            }
            const selectedStartTime = new Date(time2.start);
            const selectedEndTime = new Date(time2.end);
            selectedStartTime.getHours() + ":" + selectedStartTime.getMinutes();
            selectedEndTime.getHours() + ":" + selectedEndTime.getMinutes();
            for (const booking of bookedSlots) {
              const bookingDate = new Date(booking.date);
              if (bookingDate.toISOString().split("T")[0] === date2.toISOString().split("T")[0]) {
                console.log("booking", booking);
                for (const slot of booking.blocked_slots) {
                  const slotStartTime = new Date(slot.start);
                  const slotEndTime = new Date(slot.end);
                  if (selectedStartTime >= slotStartTime && selectedStartTime < slotEndTime || selectedEndTime > slotStartTime && selectedEndTime <= slotEndTime || selectedStartTime <= slotStartTime && selectedEndTime >= slotEndTime) {
                    alert("This time slot is already booked!");
                    return;
                  }
                }
              }
            }
            for (const option of prevBooking.options) {
              const bookedStartTime = new Date(option.time.start);
              const bookedEndTime = new Date(option.time.end);
              if (selectedStartTime >= bookedStartTime && selectedStartTime < bookedEndTime || selectedEndTime > bookedStartTime && selectedEndTime <= bookedEndTime || selectedStartTime <= bookedStartTime && selectedEndTime >= bookedEndTime) {
                alert("You booked this time slot already!");
                return;
              }
            }
            setExpand(true);
            addOption(date2, { ...options, time: { ...time2 }, active_date });
          } else {
            setExpand(false);
            removeOption(date2, options.option_id);
          }
        };
      };
      reactExports.useEffect(() => {
        setExpand(false);
        setTime({ start: null, end: null });
      }, [date2]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(LocalizationProvider, { dateAdapter: AdapterDayjs, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { style: { border: "1px solid #fff", width: "30%" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { style: { border: "1px solid #fff", width: "40%" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: options.title }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { style: { border: "1px solid #fff", width: "20%" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("b", { children: [
            "LKR",
            " ",
            parseFloat(options[active_date]).toLocaleString("en-US", {
              minimumFractionDigits: 2,
              maximumFractionDigits: 2
            })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { style: { border: "1px solid #fff", width: "20%" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "d-flex flex-row bd-highlight",
              style: { maxWidth: "150px" },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                TimePicker,
                {
                  value: time2.start,
                  label: "Start Time",
                  style: { height: "50px", borderColor: "red" },
                  onChange: (e2) => setTime({ ...time2, start: e2.toLocaleString() })
                }
              )
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { style: { border: "1px solid #fff", width: "20%" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "d-flex flex-row bd-highlight",
              style: { maxWidth: "150px" },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                TimePicker,
                {
                  label: "End Time",
                  style: { width: "100%" },
                  onChange: (e2) => setTime({ ...time2, end: e2.toLocaleString() }),
                  value: time2.end
                }
              )
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { style: { border: "1px solid #fff", width: "20%" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              style: { display: "flex", alignItems: "center", height: "100%" },
              children: expand ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button$1,
                {
                  variant: "contained",
                  sx: {
                    width: "120px",
                    background: "#C17603",
                    color: "#fff",
                    "&:hover": { background: "red" }
                  },
                  onClick: toggle_option("close"),
                  children: "Remove"
                }
              ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button$1,
                {
                  variant: "contained",
                  sx: { width: "120px", background: "#C17603", color: "#fff" },
                  onClick: toggle_option("open"),
                  children: "Book Now"
                }
              )
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("tr", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "td",
          {
            colSpan: "5",
            style: { border: "none", backgroundColor: "#fff", padding: "0" },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("form", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "table",
              {
                className: "table",
                style: {
                  borderCollapse: "collapse",
                  borderColor: "#fff",
                  maxWidth: "700px",
                  marginTop: 10
                },
                children: expand && /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: addons == null ? void 0 : addons.map((addon, index) => {
                  return /* @__PURE__ */ jsxRuntimeExports.jsx(
                    AddOnsRow,
                    {
                      addon,
                      addAddon,
                      removeAddon,
                      date: date2,
                      options,
                      changeAddonQuantity
                    },
                    index
                  );
                }) })
              }
            ) })
          }
        ) })
      ] });
    };
    const AddOnsRow = ({
      addon,
      addAddon,
      removeAddon,
      date: date2,
      options,
      changeAddonQuantity
    }) => {
      const [checked, setChecked] = reactExports.useState(false);
      const [error, setError] = reactExports.useState("");
      const handleChange = (e2) => {
        if (e2.target.value === "") {
          return setError("Please enter a valid number");
        }
        if (e2.target.value > addon.max_qty) {
          return setError("Maximum quantity exceeded");
        }
        if (e2.target.value < 0) {
          return setError("Please enter a valid number");
        }
        if (isNaN(e2.target.value)) {
          return setError("Please enter a valid number");
        }
        setError("");
        changeAddonQuantity(
          date2,
          options.option_id,
          addon.add_ons_id,
          parseInt(e2.target.value)
        );
      };
      const change_addon_checkbox = (e2, addon2) => {
        if (e2.target.checked) {
          addAddon(date2, options.option_id, { ...addon2, quantity: 1 });
          setChecked(true);
        } else {
          removeAddon(date2, options.option_id, addon2.add_ons_id);
          setChecked(false);
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: addon.add_ons_name }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: addon.cost == 0 ? "FOC" : `LKR ${parseFloat(addon.cost).toLocaleString("en-US", {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2
        })}` }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", {}),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "checkbox",
              onClick: (e2) => change_addon_checkbox(e2, addon)
            }
          ),
          addon.max_qty > 1 && checked && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              style: {
                width: 60,
                height: 30,
                padding: 5,
                marginLeft: 40,
                borderWidth: "1px",
                borderStyle: "solid",
                borderColor: "#000",
                borderRadius: 5,
                outline: "none"
              },
              placeholder: "Qty",
              onChange: handleChange,
              defaultValue: 1
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "p",
            {
              style: {
                color: "red",
                fontSize: 12,
                marginTop: 5,
                position: "absolute",
                marginLeft: "40px"
              },
              children: error
            }
          )
        ] })
      ] });
    };
    const Venue = () => {
      const navigation = useNavigate();
      const { id: id2 } = useParams();
      const currentUrl = window.location.href;
      const urlParams = new URLSearchParams(currentUrl);
      reactExports.useState(false);
      const [param, setParam] = reactExports.useState({
        start_date: urlParams.get("start_date"),
        venue_type: urlParams.get("venue_type"),
        end_date: urlParams.get("end_date")
      });
      const [venue, setVenue] = reactExports.useState(null);
      const [date2, setDate] = reactExports.useState(null);
      const [activeDate, setActiveDate] = reactExports.useState(null);
      const [booking, setBooking] = reactExports.useState([]);
      const addOption = (date22, option) => {
        setBooking(
          (prv) => prv.map((data) => {
            if (data.date === date22) {
              const exist = data.options.find(
                (opt) => opt.option_id === option.option_id
              );
              if (!exist) {
                return {
                  ...data,
                  options: [...data.options, option]
                };
              }
            }
            return data;
          })
        );
      };
      const removeOption = (date22, option_id) => {
        setBooking(
          (prv) => prv.map((data) => {
            if (data.date === date22) {
              return {
                ...data,
                options: data.options.filter((opt) => opt.option_id !== option_id)
              };
            }
            return data;
          })
        );
      };
      const addAddon = (date22, option_id, addon) => {
        setBooking(
          (prv) => prv.map((data) => {
            if (data.date === date22) {
              return {
                ...data,
                options: data.options.map((opt) => {
                  if (opt.option_id === option_id) {
                    return {
                      ...opt,
                      addons: opt.addons ? [...opt.addons, addon] : [addon]
                    };
                  }
                  return opt;
                })
              };
            }
            return data;
          })
        );
      };
      const removeAddon = (date22, option_id, addon_id) => {
        setBooking(
          (prv) => prv.map((data) => {
            if (data.date === date22) {
              return {
                ...data,
                options: data.options.map((opt) => {
                  console.log(opt.option_id === option_id);
                  if (opt.option_id === option_id) {
                    return {
                      ...opt,
                      addons: opt.addons.filter(
                        (addon) => addon.add_ons_id !== addon_id
                      )
                    };
                  } else {
                    return opt;
                  }
                })
              };
            }
            return data;
          })
        );
      };
      const changeAddonQuantity = (date22, option_id, addon_id, quantity) => {
        setBooking(
          (prv) => prv.map((data) => {
            if (data.date === date22) {
              return {
                ...data,
                options: data.options.map((opt) => {
                  if (opt.option_id === option_id) {
                    return {
                      ...opt,
                      addons: opt.addons.map((addon) => {
                        if (addon.add_ons_id === addon_id) {
                          return {
                            ...addon,
                            quantity
                          };
                        }
                      })
                    };
                  }
                  return opt;
                })
              };
            }
            return data;
          })
        );
      };
      const changeDate = (date22) => {
        setActiveDate(date22);
      };
      reactExports.useEffect(() => {
        console.log("Current Booking are :", booking);
      }, [booking]);
      reactExports.useEffect(() => {
        const getData = async () => {
          try {
            const res = await instance.get(`/customer/venue/${id2}`);
            if (res.status === 200) {
              console.log(res.data);
              setVenue(res.data);
            }
          } catch (err) {
            console.log(err);
          }
        };
        getData();
      }, []);
      const getDates = (start2, end2) => {
        let date_range = [];
        const start_date = new Date(start2);
        const end_date = new Date(end2);
        for (let date22 = start_date; date22 <= end_date; date22.setDate(date22.getDate() + 1)) {
          date_range.push(new Date(date22));
        }
        setActiveDate(date_range[0]);
        return date_range;
      };
      const goReceptPage = () => {
        navigation("/booking-form", { state: { booking, venue } });
      };
      reactExports.useEffect(() => {
        const start2 = new Date(param.start_date);
        const end2 = new Date(param.end_date);
        const date_range = getDates(start2, end2);
        setDate(date_range);
        changeDate(date_range[0]);
        const _date = date_range.map((date22) => {
          return { date: date22, options: [] };
        });
        setBooking(_date);
      }, [param]);
      if (venue === null || date2 === null) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Loading..." });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { id: "venue", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "event-search", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SearchEventCard,
          {
            setParam,
            useSearch: {
              venue_type: param.venue_type,
              start_date: param.start_date,
              end_date: param.end_date
            }
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "venue-details", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "title", children: venue.basic.name }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "venue-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "img", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: `${base_url}/public/venue-image/${venue.basic.thumbnail}`,
                alt: "venue"
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "details", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "top", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "description", children: venue.basic.description }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
              /* @__PURE__ */ jsxRuntimeExports.jsx("table", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tbody", { children: [
                venue.basic.capacity !== 1 && venue.basic.capacity !== "1" && /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: "Capacity (No. of pax)" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { children: [
                    ": ",
                    venue.basic.capacity
                  ] })
                ] }),
                venue.basic.stage !== 1 && venue.basic.stage !== "1" && /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: "Stage size" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { children: [
                    ": ",
                    venue.basic.stage
                  ] })
                ] }),
                venue.basic.ceiling_height !== 1 && venue.basic.ceiling_height !== "1" && /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: "Ceiling height (ft)" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { children: [
                    ": ",
                    venue.basic.ceiling_height
                  ] })
                ] }),
                venue.basic.floor_area !== 1 && venue.basic.floor_area !== "1" && /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: "Floor size (Sq ft)" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { children: [
                    ": ",
                    venue.basic.floor_area
                  ] })
                ] })
              ] }) })
            ] }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "select-dates", children: date2.map((date22, index) => {
            const format = new Date(date22);
            const month = format.toLocaleString("en-US", { month: "short" });
            const day = format.getDate();
            return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "btn pe-none", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                style: activeDate === date22 ? { backgroundColor: "#be6900", color: "white" } : {},
                children: `${month} ${day}`
              }
            ) }, index) });
          }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "my-4", children: [
            venue.options.map((option, index) => {
              return /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: {
                    border: "1px solid #ccc",
                    padding: 20,
                    marginBottom: 15,
                    paddingBottom: 0,
                    borderRadius: 5
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "table",
                    {
                      style: {
                        width: "100%",
                        maxWidth: "1500px",
                        borderCollapse: "collapse"
                      },
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        ExpandTable,
                        {
                          options: option,
                          blocked_slots: venue.blocked_slots,
                          addons: venue.add_ons,
                          basic: venue.basic,
                          date: activeDate,
                          addOption,
                          removeOption,
                          addAddon,
                          removeAddon,
                          changeAddonQuantity,
                          prevBooking: booking.find((b2) => b2.date === activeDate)
                        }
                      ) })
                    }
                  )
                },
                index
              );
            }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                style: {
                  backgroundColor: "#be6900",
                  color: "white",
                  padding: "5px 10px",
                  borderRadius: 5,
                  border: "none",
                  float: "right"
                },
                onClick: () => {
                  const index = date2.findIndex((d2) => d2 === activeDate);
                  if (index !== date2.length - 1) {
                    if (booking[index].options.length === 0) {
                      alert("Please select at least one option");
                      return;
                    }
                    changeDate(date2[index + 1]);
                  } else {
                    if (booking[index].options.length > 0) {
                      console.log(booking[index]);
                      goReceptPage();
                    } else {
                      alert("Please select at least one option");
                    }
                  }
                },
                children: date2.findIndex((d2) => d2 === activeDate) === date2.length - 1 ? "Submit" : "Next"
              }
            )
          ] })
        ] })
      ] });
    };
    const TextInput = ({ parentClasses, label, labelClass, type, value, inputClass, touched, error, handleBlur, name, onChange, _id, required, placeholder }) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: parentClasses, style: { width: "100%", minHeight: "60px" }, children: [
        label && /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { htmlFor: _id, className: labelClass, children: [
          label,
          " ",
          required && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "require", children: "*" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { width: "100%" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type,
              name,
              className: inputClass + " form-control",
              onChange,
              value,
              style: { width: "100%" },
              onBlur: handleBlur,
              id: _id,
              placeholder
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: touched && error ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "red" }, children: error }) : null })
        ] })
      ] });
    };
    const Checkbox = ({ parentClasses, label, labelClass, type, value, handleBlur, name, onChange, _id, required }) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: parentClasses, style: { width: "100%", minHeight: "60px", display: "inline", alignItems: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { width: "100%" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type,
            name,
            className: "form-check-input",
            onChange,
            value,
            style: { marginRight: 9 },
            onBlur: handleBlur,
            id: _id
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { htmlFor: _id, className: labelClass, children: [
          label,
          " ",
          required && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "require", children: "*" })
        ] })
      ] }) });
    };
    const Radio = ({ parentClasses, label, labelClass, type, value, handleBlur, name, onChange, _id, required }) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: parentClasses, style: { width: "100%", minHeight: "60px", display: "inline", alignItems: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { width: "100%" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "radio",
            name,
            className: "form-check-input",
            onChange,
            value,
            style: { marginRight: 9 },
            onBlur: handleBlur,
            id: _id
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { htmlFor: _id, className: labelClass, children: [
          label,
          " ",
          required && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "require", children: "*" })
        ] })
      ] }) });
    };
    const FileInput = ({ parentClasses, label, labelClass, type, value, handleBlur, name, onChange, _id, required, touched, error, setVatImage }) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: parentClasses, style: { width: "100%", minHeight: "60px" }, children: [
        label && /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { htmlFor: _id, className: labelClass, children: [
          label,
          " ",
          required && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "require", children: "*" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { width: "100%" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type,
              name,
              className: "form-control",
              onChange: (e2) => {
                onChange(e2);
                setVatImage(e2.target.files[0]);
              },
              value,
              style: { width: "100%" },
              onBlur: handleBlur,
              id: _id,
              accept: "image/*,.pdf",
              maxfilesize: 2e6
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: touched && error ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "red" }, children: error }) : null })
        ] })
      ] });
    };
    const AddonsSection = ({ addon }) => {
      const { quantity, cost } = addon;
      let totalCost = quantity * parseFloat(cost);
      const formatCost = totalCost.toLocaleString("en-US", { minimumFractionDigits: 2, maximumFractionDigits: 2 });
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "addons", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "title-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
          addon.add_ons_name,
          " ",
          parseInt(quantity) > 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
            "x",
            quantity
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "price", children: [
          "LKR ",
          formatCost
        ] })
      ] }) });
    };
    const OptionSection = (props) => {
      var _a;
      let totalCost = 0;
      const { title, time: time2, initial_booking_hours, active_date, price_per_additional_hour } = props.option;
      const initial_hours = parseFloat(initial_booking_hours);
      const start2 = new Date(time2.start).getTime();
      const end2 = new Date(time2.end).getTime();
      const timeDiff = end2 - start2;
      const hours = timeDiff / (1e3 * 60 * 60);
      if (initial_hours >= hours) {
        totalCost = totalCost + parseFloat(props.option[active_date]);
      } else {
        const additional_hours = hours - initial_hours;
        totalCost = totalCost + (parseFloat(props.option[active_date]) + parseFloat(price_per_additional_hour) * Math.ceil(additional_hours));
      }
      const formatCost = totalCost.toLocaleString("en-US", { minimumFractionDigits: 2, maximumFractionDigits: 2 });
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "option", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "option_title", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h6", { children: title }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            "LKR ",
            formatCost
          ] })
        ] }),
        (_a = props.option.addons) == null ? void 0 : _a.map((addon, index) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(AddonsSection, { addon }, index + 1e3);
        })
      ] });
    };
    const PricingMoreDetails = (props) => {
      const { bookingData, setPopup } = props;
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: "PricingMoreDetails", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card", children: bookingData == null ? void 0 : bookingData.map((data, index) => {
        var _a;
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "date", children: new Date(data.date).toLocaleDateString("en-IN", { day: "numeric", month: "long", year: "numeric" }) }),
          (_a = data.options) == null ? void 0 : _a.map((option, index2) => {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(OptionSection, { option }, index2);
          })
        ] }, index);
      }) }) });
    };
    const MainBookingForm = (props) => {
      const style2 = {
        position: "absolute",
        top: "50%",
        left: "50%",
        transform: "translate(-50%, -50%)",
        width: 400,
        textAlign: "center",
        bgcolor: "background.paper",
        borderRadius: 3,
        boxShadow: 24,
        p: 4
      };
      const [open, setOpen] = React.useState(false);
      const handleClose = () => setOpen(false);
      const [reservationCount, setReservationCount] = reactExports.useState(950);
      const navigate = useNavigate();
      const [vat_image, setVatImage] = reactExports.useState(null);
      const {
        values: values2,
        errors,
        handleChange,
        touched,
        handleBlur,
        handleSubmit,
        setFieldValue,
        resetForm,
        setFieldError
      } = useFormik({
        initialValues: {
          name_of_organization_individual: "",
          account_name: "",
          account_number: "",
          bank_name: "",
          bank_code: "",
          branch_name: "",
          branch_code: "",
          swift_code: "",
          contact_person: "",
          address: "",
          telephone_no: "",
          mobile_no: "",
          email: "",
          name_of_the_event: "",
          venue_name: "",
          date: "",
          time: "",
          event_type: [],
          setup: [],
          public_performance_approval: "",
          chief_guest: "",
          expected: "",
          guaranteed: "",
          VAT_registration_no: "",
          VAT_copy: "",
          other: ""
        },
        onSubmit: (values22) => submit(),
        validationSchema: BookingFormValidation
      });
      const submit = async () => {
        console.log("This function Clicked");
        console.log(values2);
        let error = 0;
        Object.keys(meal).forEach((key) => {
          if (meal[key].check && meal[key].time === "") {
            error += 1;
            return document.getElementById(key + "_time").focus();
          }
        });
        if (error === 0) {
          const refund_drawn = {
            account_name: values2.account_name,
            account_number: values2.account_number,
            bank_name: values2.bank_name,
            bank_code: values2.bank_code,
            branch_name: values2.branch_name,
            branch_code: values2.branch_code
          };
          if (values2.swift_code !== void 0 && values2.swift_code !== null && values2.swift_code !== "") {
            refund_drawn.swift_code = values2.swift_code;
          }
          const contact_person = {
            name: values2.contact_person,
            address: values2.address,
            email: values2.email
          };
          if (values2.telephone_no !== void 0 && values2.telephone_no !== null && values2.telephone_no !== "") {
            contact_person.telephone_no = values2.telephone_no;
          }
          if (values2.mobile_no !== void 0 && values2.mobile_no !== null && values2.mobile_no !== "") {
            contact_person.mobile_no = values2.mobile_no;
          }
          const video_wall = {};
          const fields2 = ["name_of_the_event", "venue_name", "date", "time"];
          fields2.forEach((field) => {
            if (values2[field] !== void 0 && values2[field] !== null && values2[field] !== "") {
              video_wall[field] = values2[field];
            }
          });
          let meal_plan = [];
          Object.keys(meal).forEach((key) => {
            if (meal[key].check) {
              meal_plan.push({ [key]: meal[key].time });
            }
          });
          const number_of_guests = {
            expected: values2.expected,
            guaranteed: values2.guaranteed
          };
          const formData = new FormData();
          formData.append("name", values2.name_of_organization_individual);
          formData.append("refund_drawn", JSON.stringify(refund_drawn));
          formData.append("contact_person", JSON.stringify(contact_person));
          formData.append("video_wall", JSON.stringify(video_wall));
          formData.append(
            "event_type",
            JSON.stringify({ ...values2.event_type, other: values2.other })
          );
          formData.append("setup", JSON.stringify(values2.setup));
          formData.append("meal_plan", JSON.stringify(meal_plan));
          formData.append(
            "public_performance_approval",
            values2.public_performance_approval
          );
          formData.append("chief_guest", values2.chief_guest);
          formData.append("number_of_guests", JSON.stringify(number_of_guests));
          if (values2.VAT_registration_no !== void 0 && values2.VAT_registration_no !== null && values2.VAT_registration_no !== "") {
            formData.append("VAT_registration_no", values2.VAT_registration_no);
          }
          if (vat_image !== void 0 && vat_image !== null) {
            formData.append("VAT_copy", vat_image);
          }
          formData.append("venue_id", props.venue.id);
          formData.append("BOOKING_DATA", JSON.stringify(props.bookingData));
          const newCount = reservationCount + 1;
          setReservationCount(newCount);
          localStorage.setItem("reservation_Count", newCount.toString());
          formData.append("reservation_count", reservationCount);
          try {
            const config2 = {
              headers: {
                "Content-Type": "multipart/form-data"
              }
            };
            const res = await instance.post(
              "/customer/venue-booking",
              formData,
              config2
            );
            navigate("/booking-success", { state: { fromBookingPage: true } });
          } catch (err) {
            console.log("This is the error why this booking failed", err);
            alert("Booking Failed");
          }
        }
      };
      const margin_bottom = "mb-3";
      const fields = {
        name_of_organization_individual: {
          label: "Name of Organization/Individual",
          _id: "name_of_organization_individual",
          type: "text",
          parentClasses: margin_bottom,
          inputClass: "",
          labelClass: "",
          name: "name_of_organization_individual",
          handleBlur,
          touched: touched["name_of_organization_individual"],
          error: errors["name_of_organization_individual"],
          onChange: handleChange,
          value: values2["name_of_organization_individual"],
          required: true
        },
        account_name: {
          label: "Account Name",
          _id: "account_name",
          type: "text",
          parentClasses: margin_bottom,
          inputClass: "",
          labelClass: "",
          name: "account_name",
          handleBlur,
          touched: touched["account_name"],
          error: errors["account_name"],
          onChange: handleChange,
          value: values2["account_name"],
          required: true
        },
        account_number: {
          label: "Account Number",
          _id: "account_number",
          type: "text",
          parentClasses: margin_bottom,
          inputClass: "",
          labelClass: "",
          name: "account_number",
          handleBlur,
          touched: touched["account_number"],
          error: errors["account_number"],
          onChange: handleChange,
          value: values2["account_number"],
          required: true
        },
        bank_name: {
          label: "Bank Name",
          _id: "bank_name",
          type: "text",
          parentClasses: margin_bottom,
          inputClass: "",
          labelClass: "",
          name: "bank_name",
          handleBlur,
          touched: touched["bank_name"],
          error: errors["bank_name"],
          onChange: handleChange,
          value: values2["bank_name"],
          required: true
        },
        bank_code: {
          label: "Bank Code",
          _id: "bank_code",
          type: "text",
          parentClasses: margin_bottom,
          inputClass: "",
          labelClass: "",
          name: "bank_code",
          handleBlur,
          touched: touched["bank_code"],
          error: errors["bank_code"],
          onChange: handleChange,
          value: values2["bank_code"],
          required: true
        },
        branch_name: {
          label: "Branch Name",
          _id: "branch_name",
          type: "text",
          parentClasses: margin_bottom,
          inputClass: "",
          labelClass: "",
          name: "branch_name",
          handleBlur,
          touched: touched["branch_name"],
          error: errors["branch_name"],
          onChange: handleChange,
          value: values2["branch_name"],
          required: true
        },
        branch_code: {
          label: "Branch Code",
          _id: "branch_code",
          type: "text",
          parentClasses: margin_bottom,
          inputClass: "",
          labelClass: "",
          name: "branch_code",
          handleBlur,
          touched: touched["branch_code"],
          error: errors["branch_code"],
          onChange: handleChange,
          value: values2["branch_code"],
          required: true
        },
        swift_code: {
          label: "Swift Code (if any)",
          _id: "swift_code",
          type: "text",
          parentClasses: margin_bottom,
          inputClass: "",
          labelClass: "",
          name: "swift_code",
          handleBlur,
          touched: touched["swift_code"],
          error: errors["swift_code"],
          onChange: handleChange,
          value: values2["swift_code"]
          // required: true,  // Not Compulsory
        },
        contact_person: {
          label: "Contact Person",
          _id: "contact_person",
          type: "text",
          parentClasses: margin_bottom,
          inputClass: "",
          labelClass: "",
          name: "contact_person",
          handleBlur,
          touched: touched["contact_person"],
          error: errors["contact_person"],
          onChange: handleChange,
          value: values2["contact_person"],
          required: true
        },
        address: {
          label: "Address",
          _id: "address",
          type: "text",
          parentClasses: margin_bottom,
          inputClass: "",
          labelClass: "",
          name: "address",
          handleBlur,
          touched: touched["address"],
          error: errors["address"],
          onChange: handleChange,
          value: values2["address"],
          required: true
        },
        telephone_no: {
          label: "Telephone No.",
          _id: "telephone_no",
          type: "text",
          parentClasses: margin_bottom,
          inputClass: "",
          labelClass: "",
          name: "telephone_no",
          handleBlur,
          touched: touched["telephone_no"],
          error: errors["telephone_no"],
          onChange: handleChange,
          value: values2["telephone_no"]
          // required: true, // Not Compulsory
        },
        mobile_no: {
          label: "Mobile No.",
          _id: "mobile_no",
          type: "text",
          parentClasses: margin_bottom,
          inputClass: "",
          labelClass: "",
          name: "mobile_no",
          handleBlur,
          touched: touched["mobile_no"],
          error: errors["mobile_no"],
          onChange: handleChange,
          value: values2["mobile_no"]
          // required: true, // Not Compulsory
        },
        email: {
          label: "Email",
          _id: "email",
          type: "email",
          parentClasses: margin_bottom,
          inputClass: "",
          labelClass: "",
          name: "email",
          handleBlur,
          touched: touched["email"],
          error: errors["email"],
          onChange: handleChange,
          value: values2["email"],
          required: true
        },
        name_of_the_event: {
          label: "Name of the Event",
          _id: "name_of_the_event",
          type: "text",
          parentClasses: margin_bottom,
          inputClass: "",
          labelClass: "",
          name: "name_of_the_event",
          handleBlur,
          touched: touched["name_of_the_event"],
          error: errors["name_of_the_event"],
          onChange: handleChange,
          value: values2["name_of_the_event"]
          // required: true, // Not Compulsory
        },
        venue_name: {
          label: "Venue Name",
          _id: "venue_name",
          type: "text",
          parentClasses: margin_bottom,
          inputClass: "",
          labelClass: "",
          name: "venue_name",
          handleBlur,
          touched: touched["venue_name"],
          error: errors["venue_name"],
          onChange: handleChange,
          value: values2["venue_name"]
          // required: true, // Not Compulsory
        },
        date: {
          label: "Date",
          _id: "date",
          type: "date",
          parentClasses: margin_bottom,
          inputClass: "",
          labelClass: "",
          name: "date",
          handleBlur,
          touched: touched["date"],
          error: errors["date"],
          onChange: handleChange,
          value: values2["date"]
          // required: true,
        },
        time: {
          label: "Time",
          _id: "time",
          type: "time",
          parentClasses: margin_bottom,
          inputClass: "",
          labelClass: "",
          name: "time",
          handleBlur,
          touched: touched["time"],
          error: errors["time"],
          onChange: handleChange,
          value: values2["time"]
          // required: true,
        },
        event_type: {
          exhibition: {
            label: "Exhibition",
            _id: "exhibition",
            type: "checkbox",
            parentClasses: margin_bottom,
            inputClass: "form-check-input",
            labelClass: "",
            name: "event_type",
            handleBlur,
            touched: touched["event_type"],
            error: errors["event_type"],
            onChange: handleChange,
            value: "exhibition"
          },
          conference: {
            label: "Conference",
            _id: "conference",
            type: "checkbox",
            parentClasses: margin_bottom,
            inputClass: "form-check-input",
            labelClass: "",
            name: "event_type",
            handleBlur,
            touched: touched["event_type"],
            error: errors["event_type"],
            onChange: handleChange,
            value: "conference"
          },
          convocation: {
            label: "Convocation",
            _id: "convocation",
            type: "checkbox",
            parentClasses: margin_bottom,
            inputClass: "form-check-input",
            labelClass: "",
            name: "event_type",
            handleBlur,
            touched: touched["event_type"],
            error: errors["event_type"],
            onChange: handleChange,
            value: "convocation"
          },
          seminar: {
            label: "Seminar",
            _id: "seminar",
            type: "checkbox",
            parentClasses: margin_bottom,
            inputClass: "form-check-input",
            labelClass: "",
            name: "event_type",
            handleBlur,
            touched: touched["event_type"],
            error: errors["event_type"],
            onChange: handleChange,
            value: "seminar"
          },
          ceremony: {
            label: "Ceremony",
            _id: "ceremony",
            type: "checkbox",
            parentClasses: margin_bottom,
            inputClass: "form-check-input",
            labelClass: "",
            name: "event_type",
            handleBlur,
            touched: touched["event_type"],
            error: errors["event_type"],
            onChange: handleChange,
            value: "ceremony"
          },
          other: {
            label: "Other",
            _id: "other",
            type: "checkbox",
            parentClasses: margin_bottom,
            inputClass: "form-check-input",
            labelClass: "",
            name: "event_type",
            handleBlur,
            touched: touched["event_type"],
            error: errors["event_type"],
            onChange: handleChange,
            value: "other",
            other: {
              label: "",
              _id: "other",
              type: "text",
              parentClasses: margin_bottom,
              inputClass: "",
              labelClass: "",
              name: "other",
              handleBlur,
              touched: touched["other"],
              error: errors["other"],
              onChange: handleChange,
              value: values2["other"],
              placeholder: "Please specify"
            }
          }
        },
        setup: {
          theatre: {
            label: "Theatre",
            _id: "theatre",
            type: "checkbox",
            parentClasses: margin_bottom,
            inputClass: "form-check-input",
            labelClass: "",
            name: "setup",
            handleBlur,
            touched: touched["setup"],
            error: errors["setup"],
            onChange: handleChange,
            value: "theatre"
          },
          classroom: {
            label: "Classroom",
            _id: "classroom",
            type: "checkbox",
            parentClasses: margin_bottom,
            inputClass: "form-check-input",
            labelClass: "",
            name: "setup",
            handleBlur,
            touched: touched["setup"],
            error: errors["setup"],
            onChange: handleChange,
            value: "classroom"
          },
          boardroom: {
            label: "Boardroom",
            _id: "boardroom",
            type: "checkbox",
            parentClasses: margin_bottom,
            inputClass: "form-check-input",
            labelClass: "",
            name: "setup",
            handleBlur,
            touched: touched["setup"],
            error: errors["setup"],
            onChange: handleChange,
            value: "boardroom"
          },
          cluster: {
            label: "Cluster",
            _id: "cluster",
            type: "checkbox",
            parentClasses: margin_bottom,
            inputClass: "form-check-input",
            labelClass: "",
            name: "setup",
            handleBlur,
            touched: touched["setup"],
            error: errors["setup"],
            onChange: handleChange,
            value: "cluster"
          },
          U_shape: {
            label: "U-Shape",
            _id: "U_shape",
            type: "checkbox",
            parentClasses: margin_bottom,
            inputClass: "form-check-input",
            labelClass: "",
            name: "setup",
            handleBlur,
            touched: touched["setup"],
            error: errors["setup"],
            onChange: handleChange,
            value: "U_shape"
          },
          hollow: {
            label: "Hollow",
            _id: "hollow",
            type: "checkbox",
            parentClasses: margin_bottom,
            inputClass: "form-check-input",
            labelClass: "",
            name: "setup",
            handleBlur,
            touched: touched["setup"],
            error: errors["setup"],
            onChange: handleChange,
            value: "hollow"
          },
          banquet: {
            label: "Banquet",
            _id: "banquet",
            type: "checkbox",
            parentClasses: margin_bottom,
            inputClass: "form-check-input",
            labelClass: "",
            name: "setup",
            handleBlur,
            touched: touched["setup"],
            error: errors["setup"],
            onChange: handleChange,
            value: "banquet"
          },
          cocktail: {
            label: "Cocktail",
            _id: "cocktail",
            type: "checkbox",
            parentClasses: margin_bottom,
            inputClass: "form-check-input",
            labelClass: "",
            name: "setup",
            handleBlur,
            touched: touched["setup"],
            error: errors["setup"],
            onChange: handleChange,
            value: "cocktail"
          }
        },
        public_performance_approval: {
          yes: {
            label: "Yes",
            _id: "public_performance_approval_yes",
            parentClasses: margin_bottom,
            inputClass: "form-check-input",
            labelClass: "",
            name: "public_performance_approval",
            handleBlur,
            touched: touched["public_performance_approval"],
            error: errors["public_performance_approval"],
            onChange: handleChange,
            value: true
          },
          no: {
            label: "No",
            _id: "public_performance_approval_no",
            parentClasses: margin_bottom,
            inputClass: "form-check-input",
            labelClass: "",
            name: "public_performance_approval",
            handleBlur,
            touched: touched["public_performance_approval"],
            error: errors["public_performance_approval"],
            onChange: handleChange,
            value: false
          }
        },
        chief_guest: {
          label: "Chief Guest",
          _id: "chief_guest",
          type: "text",
          parentClasses: margin_bottom,
          inputClass: "",
          labelClass: "",
          name: "chief_guest",
          handleBlur,
          touched: touched["chief_guest"],
          error: errors["chief_guest"],
          onChange: handleChange,
          value: values2["chief_guest"]
        },
        number_of_guests: {
          expected: {
            label: "Expected",
            _id: "expected",
            type: "number",
            parentClasses: margin_bottom,
            inputClass: "",
            labelClass: "",
            name: "expected",
            handleBlur,
            touched: touched["expected"],
            error: errors["expected"],
            onChange: handleChange,
            value: values2["expected"],
            required: true
          },
          guaranteed: {
            label: "Guaranteed",
            _id: "guaranteed",
            type: "number",
            parentClasses: margin_bottom,
            inputClass: "",
            labelClass: "",
            name: "guaranteed",
            handleBlur,
            touched: touched["guaranteed"],
            error: errors["guaranteed"],
            onChange: handleChange,
            value: values2["guaranteed"],
            required: true
          }
        },
        VAT_registration_no: {
          label: "VAT Registration No.",
          _id: "VAT_registration_no",
          type: "text",
          parentClasses: margin_bottom,
          inputClass: "",
          labelClass: "",
          name: "VAT_registration_no",
          handleBlur,
          touched: touched["VAT_registration_no"],
          error: errors["VAT_registration_no"],
          onChange: handleChange,
          value: values2["VAT_registration_no"]
          // required: true,
        },
        VAT_copy: {
          label: "VAT Registration Copy",
          _id: "VAT_copy",
          type: "file",
          parentClasses: margin_bottom,
          inputClass: "",
          labelClass: "",
          name: "VAT_copy",
          handleBlur,
          touched: touched["VAT_copy"],
          error: errors["VAT_copy"],
          onChange: handleChange,
          value: values2["VAT_copy"]
          // required: true,
        }
      };
      const [meal, setMeal] = reactExports.useState({
        breakfast: {
          check: false,
          time: ""
        },
        morning_snack: {
          check: false,
          time: ""
        },
        morning_snack_and_lunch: {
          check: false,
          time: ""
        },
        morning_snack_lunch_and_evening_snack: {
          check: false,
          time: ""
        },
        lunch_and_Evening_snack: {
          check: false,
          time: ""
        },
        evening_snack: {
          check: false,
          time: ""
        },
        lunch: {
          check: false,
          time: ""
        },
        dinner: {
          check: false,
          time: ""
        },
        cocktail: {
          check: false,
          time: ""
        }
      });
      reactExports.useEffect(() => {
        const previousCount = localStorage.getItem("reservation_Count");
        if (previousCount) {
          setReservationCount(parseInt(previousCount));
        }
      }, []);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-md-8 order-md-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Modal$1,
          {
            open,
            onClose: handleClose,
            "aria-labelledby": "modal-modal-title",
            "aria-describedby": "modal-modal-description",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, { sx: style2, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { id: "modal-modal-title", variant: "h6", component: "h2", children: "Reservation Request" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { id: "modal-modal-description", sx: { mt: 2 }, children: "Are you sure you want to submit this request?" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-4 d-flex justify-content-around", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button$1,
                  {
                    style: {
                      backgroundColor: "#fff",
                      color: "#c17603",
                      border: "1px solid #c17603"
                    },
                    onClick: handleClose,
                    children: "Cancel"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button$1,
                  {
                    onClick: () => {
                      handleClose();
                      submit();
                    },
                    style: { backgroundColor: "#c17603", color: "white" },
                    children: "Confirm"
                  }
                )
              ] })
            ] })
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { className: "needs-validation", onSubmit: handleSubmit, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "row", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextInput, { ...fields.name_of_organization_individual }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "fw-bold", children: "Refund cheque to be drawn in favour of :" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "row", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextInput, { ...fields.account_name }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextInput, { ...fields.account_number }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "row", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextInput, { ...fields.bank_name }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextInput, { ...fields.bank_code }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "row", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextInput, { ...fields.branch_name }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextInput, { ...fields.branch_code }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "row", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextInput, { ...fields.swift_code }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "fw-bold", children: "Contact Details :" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "row", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextInput, { ...fields.contact_person }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "row", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextInput, { ...fields.address }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "row", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextInput, { ...fields.telephone_no }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextInput, { ...fields.mobile_no }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "row", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextInput, { ...fields.email }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("hr", { className: "mb-4" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "fw-bold", children: "Name to be on VIDEO WALL & LED SCREEN: FORMAT as follows (Once given, cannot be changed)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "row", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextInput, { ...fields.name_of_the_event }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextInput, { ...fields.venue_name }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "row", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextInput, { ...fields.date }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextInput, { ...fields.time }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("hr", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "fw-bold", children: [
            "Event Type ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "require", children: "*" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "row", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-4 mb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox, { ...fields.event_type.exhibition }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-4 mb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox, { ...fields.event_type.conference }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-4 mb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox, { ...fields.event_type.convocation }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-4 mb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox, { ...fields.event_type.seminar }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-4 mb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox, { ...fields.event_type.ceremony }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox, { ...fields.event_type.other }),
          values2.event_type.includes("other") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "row mt-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextInput, { ...fields.event_type.other.other }) }),
          errors && errors.event_type && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "red" }, children: errors.event_type }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("hr", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "fw-bold", children: "Set-Up" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "row", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-4 mb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox, { ...fields.setup.theatre }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-4 mb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox, { ...fields.setup.classroom }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-4 mb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox, { ...fields.setup.boardroom }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-4 mb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox, { ...fields.setup.cluster }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-4 mb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox, { ...fields.setup.U_shape }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-4 mb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox, { ...fields.setup.hollow }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-4 mb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox, { ...fields.setup.banquet }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-4 mb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox, { ...fields.setup.cocktail }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("hr", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "fw-bold", children: "Meal Plan" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("table", { className: "table", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tbody", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: "Breakfast" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "checkbox",
                  name: "breakfast_check_box",
                  onChange: (e2) => setMeal((prv) => ({
                    ...prv,
                    breakfast: {
                      ...prv.breakfast,
                      check: e2.target.checked
                    }
                  }))
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: meal.breakfast.check && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "time",
                  required: true,
                  id: "breakfast_time",
                  onChange: (e2) => setMeal((prv) => ({
                    ...prv,
                    breakfast: { ...prv.breakfast, time: e2.target.value }
                  }))
                }
              ) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: "Morning Snack" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "checkbox",
                  name: "morning_snack_check_box",
                  onChange: (e2) => setMeal((prv) => ({
                    ...prv,
                    morning_snack: {
                      ...prv.morning_snack,
                      check: e2.target.checked
                    }
                  }))
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: meal.morning_snack.check && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "time",
                  id: "morning_snack_time",
                  onChange: (e2) => setMeal((prv) => ({
                    ...prv,
                    morning_snack: {
                      ...prv.morning_snack,
                      time: e2.target.value
                    }
                  }))
                }
              ) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: "Morning Snack & Lunch" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "checkbox",
                  name: "morning_snack_and_lunch_check_box",
                  onChange: (e2) => setMeal((prv) => ({
                    ...prv,
                    morning_snack_and_lunch: {
                      ...prv.morning_snack_and_lunch,
                      check: e2.target.checked
                    }
                  }))
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: meal.morning_snack_and_lunch.check && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "time",
                  id: "morning_snack_and_lunch_time",
                  onChange: (e2) => setMeal((prv) => ({
                    ...prv,
                    morning_snack_and_lunch: {
                      ...prv.morning_snack_and_lunch,
                      time: e2.target.value
                    }
                  }))
                }
              ) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: "Morning Snack, Lunch & Evening Snack" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "checkbox",
                  name: "morning_snack_lunch_and_evening_snack_check_box",
                  onChange: (e2) => setMeal((prv) => ({
                    ...prv,
                    morning_snack_lunch_and_evening_snack: {
                      ...prv.morning_snack_lunch_and_evening_snack,
                      check: e2.target.checked
                    }
                  }))
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: meal.morning_snack_lunch_and_evening_snack.check && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "time",
                  id: "morning_snack_lunch_and_evening_snack_time",
                  onChange: (e2) => setMeal((prv) => ({
                    ...prv,
                    morning_snack_lunch_and_evening_snack: {
                      ...prv.morning_snack_lunch_and_evening_snack,
                      time: e2.target.value
                    }
                  }))
                }
              ) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: "Lunch & Evening Snack" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "checkbox",
                  name: "lunch_and_Evening_snack_check_box",
                  onChange: (e2) => setMeal((prv) => ({
                    ...prv,
                    lunch_and_Evening_snack: {
                      ...prv.lunch_and_Evening_snack,
                      check: e2.target.checked
                    }
                  }))
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: meal.lunch_and_Evening_snack.check && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "time",
                  id: "lunch_and_Evening_snack_time",
                  onChange: (e2) => setMeal((prv) => ({
                    ...prv,
                    lunch_and_Evening_snack: {
                      ...prv.lunch_and_Evening_snack,
                      time: e2.target.value
                    }
                  }))
                }
              ) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: "Evening Snack" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "checkbox",
                  name: "evening_snack_check_box",
                  onChange: (e2) => setMeal((prv) => ({
                    ...prv,
                    evening_snack: {
                      ...prv.evening_snack,
                      check: e2.target.checked
                    }
                  }))
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: meal.evening_snack.check && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "time",
                  id: "evening_snack_time",
                  onChange: (e2) => setMeal((prv) => ({
                    ...prv,
                    evening_snack: {
                      ...prv.evening_snack,
                      time: e2.target.value
                    }
                  }))
                }
              ) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: "Lunch" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "checkbox",
                  name: "lunch_check_box",
                  onChange: (e2) => setMeal((prv) => ({
                    ...prv,
                    lunch: {
                      ...prv.lunch,
                      check: e2.target.checked
                    }
                  }))
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: meal.lunch.check && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "time",
                  id: "lunch_time",
                  onChange: (e2) => setMeal((prv) => ({
                    ...prv,
                    lunch: { ...prv.lunch, time: e2.target.value }
                  }))
                }
              ) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: "Dinner" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "checkbox",
                  name: "dinner_check_box",
                  onChange: (e2) => setMeal((prv) => ({
                    ...prv,
                    dinner: {
                      ...prv.dinner,
                      check: e2.target.checked
                    }
                  }))
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: meal.dinner.check && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "time",
                  id: "dinner_time",
                  onChange: (e2) => setMeal((prv) => ({
                    ...prv,
                    dinner: { ...prv.dinner, time: e2.target.value }
                  }))
                }
              ) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: "Cocktail" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "checkbox",
                  name: "cocktail_check_box",
                  onChange: (e2) => setMeal((prv) => ({
                    ...prv,
                    cocktail: {
                      ...prv.cocktail,
                      check: e2.target.checked
                    }
                  }))
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: meal.cocktail.check && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "time",
                  id: "cocktail_time",
                  onChange: (e2) => setMeal((prv) => ({
                    ...prv,
                    cocktail: { ...prv.cocktail, time: e2.target.value }
                  }))
                }
              ) })
            ] })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "fw-bold mb-2", children: [
            "Public Performance approval ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "require", children: "*" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "row", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-2 mb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Radio, { ...fields.public_performance_approval.yes }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-2 mb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Radio, { ...fields.public_performance_approval.no }) })
          ] }),
          errors && errors.public_performance_approval && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "red" }, children: errors.public_performance_approval }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("hr", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "fw-bold", children: "Chief Guest" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "row", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextInput, { ...fields.chief_guest }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("hr", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "fw-bold", children: "Number of Guests " }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "row", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextInput, { ...fields.number_of_guests.expected }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextInput, { ...fields.number_of_guests.guaranteed }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("hr", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "fw-bold", children: "VAT Registration" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "row", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextInput, { ...fields.VAT_registration_no }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FileInput, { ...fields.VAT_copy, setVatImage }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            PricingMoreDetails,
            {
              bookingData: props.bookingData,
              setPopup: props.setPopup
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "reg-btn", type: "submit", children: "Submit Request" })
        ] })
      ] });
    };
    const Pricing = (props) => {
      const { bookingData } = props;
      const [totalCost, setTotalCost] = reactExports.useState(null);
      const getTotalCostForOption = (option) => {
        var _a;
        let totalCost2 = 0;
        console.log(option);
        const { time: time2, initial_booking_hours, price_per_additional_hour } = option;
        const initial_hours = parseFloat(initial_booking_hours);
        const start2 = new Date(time2.start).getTime();
        const end2 = new Date(time2.end).getTime();
        const timeDiff = end2 - start2;
        const hours = timeDiff / (1e3 * 60 * 60);
        if (initial_hours >= hours) {
          totalCost2 = totalCost2 + parseFloat(option[option.active_date]);
        } else {
          const additional_hours = hours - initial_hours;
          console.log(additional_hours);
          totalCost2 = totalCost2 + (parseFloat(option[option.active_date]) + parseFloat(price_per_additional_hour) * Math.ceil(additional_hours));
        }
        (_a = option.addons) == null ? void 0 : _a.forEach((addon) => {
          totalCost2 = totalCost2 + parseFloat(addon.cost) * addon.quantity;
        });
        return totalCost2;
      };
      reactExports.useEffect(() => {
        let totalCost2 = 0;
        bookingData == null ? void 0 : bookingData.forEach((data) => {
          var _a;
          (_a = data.options) == null ? void 0 : _a.forEach((option) => {
            totalCost2 = totalCost2 + getTotalCostForOption(option);
          });
        });
        setTotalCost(totalCost2);
      }, [bookingData]);
      if (totalCost === null) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Loading" });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-md-4 order-md-2 mb-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "d-flex justify-content-between align-items-center mb-4" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "list-group mb-3 ", children: [
          bookingData == null ? void 0 : bookingData.map((data, index) => {
            var _a;
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "list-group-item pt-3", style: { minWidth: "300px" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { children: new Date(data.date).toLocaleDateString("en-IN", { day: "numeric", month: "long", year: "numeric" }) }),
              (_a = data.options) == null ? void 0 : _a.map((option, index2) => {
                const cost = getTotalCostForOption(option).toLocaleString("en-US", { minimumFractionDigits: 2, maximumFractionDigits: 2 });
                return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "d-flex justify-content-between lh-sm", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("h6", { className: "my-0 text-muted", children: option.title }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-muted", children: [
                    "LKR ",
                    cost
                  ] })
                ] }, index2);
              })
            ] }, index);
          }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "list-group-item d-flex justify-content-between", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Total" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
              "LKR ",
              totalCost.toLocaleString("en-US", { minimumFractionDigits: 2, maximumFractionDigits: 2 })
            ] })
          ] })
        ] })
      ] });
    };
    const FormAndPricing = () => {
      const location = useLocation();
      const [bookingData, setBookingData] = reactExports.useState(null);
      const [venue, setVenue] = reactExports.useState(null);
      reactExports.useEffect(() => {
        var _a, _b;
        const bookingData2 = (_a = location.state) == null ? void 0 : _a.booking;
        const venue2 = (_b = location.state) == null ? void 0 : _b.venue;
        setBookingData(bookingData2);
        setVenue(venue2);
      }, [location]);
      if (!bookingData || !venue) {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: "margin" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Loading..." })
        ] });
      }
      const firstDay = new Date(bookingData[0].date).toLocaleDateString("en-IN", { day: "numeric", month: "long", year: "numeric" });
      const lastDay = new Date(bookingData[bookingData.length - 1].date).toLocaleDateString("en-IN", { day: "numeric", month: "long", year: "numeric" });
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: "margin" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: "form-and-pricing", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { children: [
            venue.basic.name,
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: {
              fontSize: "25px",
              color: "grey",
              marginLeft: "10px"
            }, children: [
              "(",
              firstDay,
              " - ",
              lastDay,
              ")"
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "row", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Pricing, { bookingData }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MainBookingForm, { bookingData, venue: venue.basic })
          ] })
        ] }) })
      ] });
    };
    var CheckCircleOutline = {};
    var interopRequireDefault = { exports: {} };
    (function(module2) {
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }
      module2.exports = _interopRequireDefault2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    })(interopRequireDefault);
    var interopRequireDefaultExports = interopRequireDefault.exports;
    var createSvgIcon = {};
    const require$$0 = /* @__PURE__ */ getAugmentedNamespace(utils);
    var hasRequiredCreateSvgIcon;
    function requireCreateSvgIcon() {
      if (hasRequiredCreateSvgIcon)
        return createSvgIcon;
      hasRequiredCreateSvgIcon = 1;
      (function(exports2) {
        "use client";
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        Object.defineProperty(exports2, "default", {
          enumerable: true,
          get: function() {
            return _utils.createSvgIcon;
          }
        });
        var _utils = require$$0;
      })(createSvgIcon);
      return createSvgIcon;
    }
    var _interopRequireDefault = interopRequireDefaultExports;
    Object.defineProperty(CheckCircleOutline, "__esModule", {
      value: true
    });
    var default_1 = CheckCircleOutline.default = void 0;
    var _createSvgIcon = _interopRequireDefault(requireCreateSvgIcon());
    var _jsxRuntime = jsxRuntimeExports;
    default_1 = CheckCircleOutline.default = (0, _createSvgIcon.default)(/* @__PURE__ */ (0, _jsxRuntime.jsx)("path", {
      d: "M16.59 7.58 10 14.17l-3.59-3.58L5 12l5 5 8-8zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8"
    }), "CheckCircleOutline");
    const Success = () => {
      const location = useLocation();
      location.state && location.state.fromBookingPage;
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container d-flex justify-content-center align-items-center vh-100", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card text-center shadow p-3 mb-5 bg-body rounded-3", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card-body", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("h5", { className: "card-title ", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(default_1, {}),
          " Booking Success!",
          " "
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "card-text", children: "Thank you, Your reservation has been successfully booked." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/", className: "btn text-light ", style: { backgroundColor: "#c17603" }, children: "Home" })
      ] }) }) });
    };
    const App = () => {
      const auth = useAuthStore((state) => state.authState);
      const AuthRoute = ({ children }) => {
        return auth === true ? /* @__PURE__ */ jsxRuntimeExports.jsx(Navigate, { to: "/" }) : children;
      };
      const router = createBrowserRouter([
        {
          path: "/",
          element: /* @__PURE__ */ jsxRuntimeExports.jsx(PublicLayout, {}),
          children: [
            {
              path: "",
              element: /* @__PURE__ */ jsxRuntimeExports.jsx(Welcome, {})
            },
            {
              path: "venues",
              element: /* @__PURE__ */ jsxRuntimeExports.jsx(Venues, {})
            },
            {
              path: "venue/:id",
              element: /* @__PURE__ */ jsxRuntimeExports.jsx(Venue, {})
            },
            {
              path: "booking-form",
              element: /* @__PURE__ */ jsxRuntimeExports.jsx(FormAndPricing, {})
            },
            {
              path: "booking-success",
              element: /* @__PURE__ */ jsxRuntimeExports.jsx(Success, {})
            }
          ]
        },
        {
          path: "/login",
          element: /* @__PURE__ */ jsxRuntimeExports.jsx(AuthRoute, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Login, {}) })
        },
        {
          path: "/register",
          element: /* @__PURE__ */ jsxRuntimeExports.jsx(AuthRoute, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Register, {}) })
        },
        {
          path: "/forgot-password",
          element: /* @__PURE__ */ jsxRuntimeExports.jsx(AuthRoute, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ForgotPassword, {}) })
        },
        {
          path: "/reset-password/*",
          element: /* @__PURE__ */ jsxRuntimeExports.jsx(AuthRoute, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ResetPassword, {}) })
        },
        {
          path: "/acc-activate/*",
          element: /* @__PURE__ */ jsxRuntimeExports.jsx(AuthRoute, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ActivateAcc, {}) })
        }
      ]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(RouterProvider, { router });
    };
    client.createRoot(document.getElementById("root")).render(
      /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) })
    );
  }
});
export default require_index_001();
//# sourceMappingURL=index-O_vAoj7k.js.map
